<div class='rc-contact-picker'>
    <input  class='rc-input --clean' 
            data-info='input' 
            data-event='input:autoComplete'
            placeholder=''>
    </input>
    <div class='rc-contact-picker__contacts rc-list' data-info='contacts'>
        <contact-picker-item dynamic></contact-picker-item>
    </div>
</div>
<script>
w.register(function() {
    var enlarge = w.transition('enlarge')
    this.props = {
        limit: 10,
        show: false,
        whiteList: null,
        contacts: []
    }
    this.actions = {
        init:{
            method: function(finish) {
                this.data.whiteList && (this.props.whiteList = this.data.whiteList)
                return finish();
            }
        },
        mount: {
            method: function(finish) {
                finish();
            },
            after: function() {
                enlarge.init(this.dom.contacts)
                document.addEventListener('click', e => {
                    var currentNode = e.target
                    while(currentNode.parentNode) {
                        currentNode = currentNode.parentNode
                        if (currentNode.isEqualNode(this.root) ||
                            (this.props.whiteList && currentNode.isEqualNode(this.props.whiteList)))
                            return
                    }
                    this.hide()
                })
                if (this.data.contact)
                    this.dom.input.value = this.data.contact
            }
        },
        hide: {
            after: function() {
                if (this.props.show) {
                    // delay the hidden process, make options clickable, then hide the panel
                    setTimeout(() => {
                        this.props.show = false;
                        enlarge.out(this.dom.contacts)
                    }, 50)
                }
            }
        },
        show: {
            after: function() {
                if (!this.props.show) {
                    this.props.show = true;
                    enlarge.in(this.dom.contacts)
                }
            }
        },
        getInput: {
            method: function() {
                return this.dom.input.value;
            }
        },
        appendInput: {
            before: function(value) {
                this.dom.input.value += value;
                this.dom.input.focus();
            }
        },
        setInput: {
            before: function(value) {
                this.dom.input.value = value;
                this.dom.input.focus();
            }
        },
        disable: {
            method: function() {
                this.dom.input.readOnly = true
            }
        },
        focus: {
            method: function() {
                this.dom.input.focus();
            }
        },
        autoComplete: {
            method: function(finish) {
                this.props.inputValue = this.dom.input.value;
                return finish()
            },
            after: function(contacts) {
                if (!contacts) return
                while (this.dom.contacts.firstChild)
                    this.dom.contacts.removeChild(this.dom.contacts.firstChild);
                if (contacts.length > 0) this.show()
                else this.hide()
                this.props.contacts.length = 0
                var parent = this
                var count = this.props.limit
                contacts.forEach(contact => {
                    var contact = w('contact-picker-item', {
                        actions: {
                            init: {
                                method: function() {
                                    return contact;
                                }
                            },
                            select: {
                                method: function() {
                                    parent.setInput(this.props.contact.value);
                                    parent.hide();
                                }
                            },
                            hover: {
                                before: function(bool) {
                                    // avoid circular calling
                                    if (!bool)
                                        return
                                    parent.props.contacts.forEach(contact => {
                                        if (contact.props.focused) contact.focus(false)
                                        if (contact.props.hovered) contact.hover(false)
                                    })
                                }
                            },
                            focus: {
                                before: function(bool) {
                                    // avoid circular calling
                                    if (!bool)
                                        return
                                    parent.props.contacts.forEach(contact => {
                                        if (contact.props.focused) contact.focus(false)
                                        if (contact.props.hovered) contact.hover(false)
                                    })
                                }
                            }
                        }
                    })
                    contact.mount(this.dom.contacts)
                    this.props.contacts.push(contact)
                })
            }
        }
    }
    this.on('input', 'input', function(e) {
        if (this.dom.input.value === '')
            this.hide()
        else
            this.autoComplete()
    })
    this.on('keydown', 'input', function(e) {
        if (e.keyCode === 38) { // up
            e.preventDefault()
            var index = this.props.contacts.findIndex(contact => contact.props.hovered)
            if (index === -1) 
                index = this.props.contacts.findIndex(contact => contact.props.focused)
            if (index === -1)
                index = 0
            var hoverObj = this.props.contacts[index]
            if (index === 0)
                index = this.props.contacts.length
            this.props.contacts[index - 1].focus(true)
        } else if (e.keyCode === 40) { // down
            e.preventDefault()
            var index = this.props.contacts.findIndex(contact => contact.props.hovered)
            if (index === -1) 
                index = this.props.contacts.findIndex(contact => contact.props.focused)
            if (index === -1)
                index = 0
            var hoverObj = this.props.contacts[index]
            if (index === this.props.contacts.length - 1)
                index = -1
            this.props.contacts[index + 1].focus(true)
        } else if (e.keyCode === 13) { // enter
            e.preventDefault()
            var index = this.props.contacts.findIndex(contact => contact.props.hovered)
            if (index === -1) 
                index = this.props.contacts.findIndex(contact => contact.props.focused)
            if (index === -1)
                index = 0
            var hoverObj = this.props.contacts[index]
            this.setInput(hoverObj.props.contact.value);
            this.hide();
        }

    })
})

//# sourceURL=contact-picker.html
</script>
