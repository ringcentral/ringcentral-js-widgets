{"version":3,"sources":["modules/AvailabilityMonitor/availabilityMonitorHelper.ts"],"names":["TMP_HA_ERROR_CODE","HA_ERROR_CODE","HA_ERROR_STATUS","extractUrl","url","filteredUrl","match","splitUrl","split","isHAError","error","status","errors","errorCodeIn","e","validHAError","resErrorCode","generateRandomNumber","max","min","Math","random","getAvailabilityLevel","path","method","highAvailabilityAPI","api","reg","isHAEnabledAPI","condition","console","availability","HIGH"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;AAEA;;AACA;;;;;;;;;;AAEO,IAAMA,iBAAiB,GAAG,iBAA1B;;AACA,IAAMC,aAAa,GAAG,SAAtB;;AACA,IAAMC,eAAe,GAAG,GAAxB;;;AAEA,SAASC,UAAT,OAA6B;AAAA,MAAPC,GAAO,QAAPA,GAAO;;AAClC,MAAIA,GAAG,KAAK,EAAZ,EAAgB;AACd,WAAO,EAAP;AACD;;AAED,MAAMC,WAAW,GACdD,GAAG,CAACE,KAAJ,CAAU,iBAAV,KAAgCF,GAAG,CAACE,KAAJ,CAAU,iBAAV,EAA6B,CAA7B,CAAjC,IAAqE,EADvE;AAEA,MAAMC,QAAQ,GAAGF,WAAW,CAACG,KAAZ,CAAkB,GAAlB,EAAuB,CAAvB,KAA6B,EAA9C;AACA,SAAOD,QAAP;AACD;AAED;;;AACO,SAASE,SAAT,CAAmBC,KAAnB,EAA0B;AAC/B,MAAMC,MAAM,GAAG,mBAAO,CAAC,CAAR,EAAW,CAAC,UAAD,EAAa,QAAb,CAAX,EAAmCD,KAAnC,CAAf;AACA,MAAME,MAAM,GAAG,mBAAO,EAAP,EAAW,CAAC,UAAD,EAAa,OAAb,EAAsB,QAAtB,CAAX,EAA4CF,KAA5C,CAAf;AAEA,MAAIG,WAAW,GAAG,KAAlB;;AAJ+B,6CAKfD,MALe;AAAA;;AAAA;AAK/B,wDAAwB;AAAA,UAAbE,CAAa;;AACtB,UAAI,mBAAO,EAAP,EAAW,CAAC,WAAD,CAAX,EAA0BA,CAA1B,MAAiCb,aAArC,EAAoD;AAClDY,QAAAA,WAAW,GAAG,IAAd;AACA;AACD;AACF,KAV8B,CAY/B;;AAZ+B;AAAA;AAAA;AAAA;AAAA;;AAa/B,MAAIE,YAAY,GAAGJ,MAAM,KAAKT,eAAX,IAA8BW,WAAjD;;AACA,MAAI,CAACE,YAAL,EAAmB;AACjB;AACA,QAAMC,YAAY,GAAG,mBACnB,IADmB,EAEnB,CAAC,UAAD,EAAa,OAAb,EAAsB,WAAtB,CAFmB,EAGnBN,KAHmB,CAArB;AAKAK,IAAAA,YAAY,GAAGC,YAAY,KAAKhB,iBAAhC;AACD;;AAED,SAAOe,YAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASE,oBAAT,GAAkD;AAAA,MAApBC,GAAoB,uEAAd,GAAc;AAAA,MAATC,GAAS,uEAAH,CAAG;AACvD,SAAOC,IAAI,CAACC,MAAL,MAAiBH,GAAG,GAAGC,GAAvB,IAA8BA,GAArC;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASG,oBAAT,CAA8BC,IAA9B,EAAoCC,MAApC,EAA4C;AAAA,8CACxBC,+BADwB;AAAA;;AAAA;AAC1C,2DAAuC;AAAA,UAA5BC,GAA4B;;AACrC,UAAIH,IAAI,CAACjB,KAAL,CAAWoB,GAAG,CAACC,GAAf,KAAuBH,MAAM,IAAIE,GAArC,EAA0C;AACxC,eAAOA,GAAG,CAACF,MAAD,CAAV;AACD;AACF;AALyC;AAAA;AAAA;AAAA;AAAA;AAM3C;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASI,cAAT,QAAyC;AAAA,MAAfxB,GAAe,SAAfA,GAAe;AAAA,MAAVoB,MAAU,SAAVA,MAAU;AAC9C,MAAMnB,WAAW,GAAGF,UAAU,CAAC;AAAEC,IAAAA,GAAG,EAAHA;AAAF,GAAD,CAA9B;;AACA,MAAI,CAACC,WAAL,EAAkB;AAChB,WAAO,KAAP;AACD;;AAED,MAAMwB,SAAS,GAAGP,oBAAoB,CAACjB,WAAD,EAAcmB,MAAd,CAAtC;;AACA,MAAI,CAACK,SAAL,EAAgB;AACdC,IAAAA,OAAO,CAACpB,KAAR,gBACUN,GADV,sBACyBoB,MADzB,mDADc,CAId;;AACA,WAAO,IAAP;AACD;;AAED,SAAOK,SAAS,KAAKE,+BAAaC,IAAlC;AACD","sourcesContent":["/**\n * Created by Sophie, edited by Bruce\n */\nimport { pathOr } from 'ramda';\n\nimport availability from './availabilityStatus';\nimport highAvailabilityAPI from './highAvailabilityAPI';\n\nexport const TMP_HA_ERROR_CODE = 'MaintenanceMode';\nexport const HA_ERROR_CODE = 'CMN-211';\nexport const HA_ERROR_STATUS = 503;\n\nexport function extractUrl({ url }) {\n  if (url === '') {\n    return '';\n  }\n\n  const filteredUrl =\n    (url.match(/\\/restapi(.*)/gi) && url.match(/\\/restapi(.*)/gi)[0]) || '';\n  const splitUrl = filteredUrl.split('?')[0] || '';\n  return splitUrl;\n}\n\n/** Check if this damn error is HA error. */\nexport function isHAError(error) {\n  const status = pathOr(-1, ['response', 'status'], error);\n  const errors = pathOr([], ['response', '_json', 'errors'], error);\n\n  let errorCodeIn = false;\n  for (const e of errors) {\n    if (pathOr('', ['errorCode'], e) === HA_ERROR_CODE) {\n      errorCodeIn = true;\n      break;\n    }\n  }\n\n  // Result from `status` and `errorCode`.\n  let validHAError = status === HA_ERROR_STATUS && errorCodeIn;\n  if (!validHAError) {\n    // Result from temp error code, expecially for `presence`.\n    const resErrorCode = pathOr(\n      null,\n      ['response', '_json', 'errorCode'],\n      error,\n    );\n    validHAError = resErrorCode === TMP_HA_ERROR_CODE;\n  }\n\n  return validHAError;\n}\n\n/**\n * Generate 1 ~ 120 seconds\n *\n * @export\n * @returns 1 ~ 120 seconds\n */\nexport function generateRandomNumber(max = 120, min = 1) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Get availability level by path of url\n * TODO: Use lru cache to improve performance?\n */\nfunction getAvailabilityLevel(path, method) {\n  for (const api of highAvailabilityAPI) {\n    if (path.match(api.reg) && method in api) {\n      return api[method];\n    }\n  }\n}\n\n/**\n * Check if an api is *High* or *Limited*\n *\n * @export\n * @param {*} { url, method }\n * @returns boolean\n */\nexport function isHAEnabledAPI({ url, method }) {\n  const filteredUrl = extractUrl({ url });\n  if (!filteredUrl) {\n    return false;\n  }\n\n  const condition = getAvailabilityLevel(filteredUrl, method);\n  if (!condition) {\n    console.error(\n      `url: ${url} method: ${method} is not set in high or limited available API`,\n    );\n    // If a core API is not in the list, the request should be launched.\n    return true;\n  }\n\n  return condition === availability.HIGH;\n}\n"],"file":"availabilityMonitorHelper.js"}