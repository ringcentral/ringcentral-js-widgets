{"version":3,"sources":["modules/AvailabilityMonitorV2/AvailabilityMonitor.ts"],"names":["HEALTH_CHECK_INTERVAL","STATUS_END_POINT","DEFAULT_TIME","AvailabilityMonitor","name","deps","dep","optional","_enabled","_deps","availabilityMonitorOptions","enabled","_randomTime","_limitedTimeout","_normalTimeout","_promise","_healthRetryTime","_unbindHandlers","_beforeRequestHandler","params","isLimitedAvailabilityMode","requestUrl","requestMethod","url","method","Error","errorMessages","serviceLimited","_requestErrorHandler","error","response","_json","clone","json","extractedUrl","hasLimitedStatusError","setLimitedModeStatusError","headers","retryAfter","_retrieveRetryAfter","_switchToLimitedMode","_retry","_refreshErrorHandler","isOffline","message","platform","client","service","RES_STATUS","status","auth","refreshTokenValid","_switchToVoIPOnlyMode","_refreshSuccessHandler","isVoIPOnlyMode","setVoIPOnlyReset","_clearLimitedTimeout","setVoIPOnlyMode","_switchToNormalMode","setNormalMode","_clearNormalTimeout","healthCheck","fn","_healthCheck","manual","isLimitedMode","_bindHandlers","environment","changeCounter","ready","on","events","beforeRequest","requestError","addListener","loginSuccess","logoutSuccess","logoutError","refreshError","refreshSuccess","removeListener","parseFloat","get","Number","isNaN","setLimitedMode","clearTimeout","skipAuthCheck","Authorization","accessToken","res","setTimeout","_getStatus","console","errMessage","RcModuleV2","state","action"],"mappings":"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","sourcesContent":["import { pathOr } from 'ramda';\n\nimport {\n  action,\n  RcModuleV2,\n  state,\n  watch,\n} from '@ringcentral-integration/core';\nimport { ApiError } from '@ringcentral/sdk';\n\nimport { promisedThrottle } from '../../lib/debounce-throttle';\nimport { Module } from '../../lib/di';\nimport validateIsOffline from '../../lib/validateIsOffline';\nimport { Deps, ErrorMessages } from './AvailabilityMonitor.interface';\nimport {\n  extractUrl,\n  generateRandomNumber,\n  isHAEnabledAPI,\n  isHAError,\n} from './availabilityMonitorHelper';\nimport { errorMessages } from './errorMessages';\n\nexport const HEALTH_CHECK_INTERVAL = 60 * 1000;\nexport const STATUS_END_POINT = '/restapi/v1.0/status';\nconst DEFAULT_TIME = 0;\n\n@Module({\n  name: 'AvailabilityMonitor',\n  deps: [\n    'Auth',\n    'Client',\n    { dep: 'Environment', optional: true },\n    { dep: 'AvailabilityMonitorOptions', optional: true },\n  ],\n})\nexport class AvailabilityMonitor extends RcModuleV2<Deps> {\n  protected _enabled = this._deps.availabilityMonitorOptions?.enabled ?? false;\n\n  protected _randomTime = DEFAULT_TIME;\n\n  protected _limitedTimeout: NodeJS.Timeout = null;\n\n  protected _normalTimeout: NodeJS.Timeout = null;\n\n  protected _promise: Promise<Response> = null;\n\n  protected _healthRetryTime = HEALTH_CHECK_INTERVAL;\n\n  protected _unbindHandlers: () => void = null;\n\n  constructor(deps: Deps) {\n    super({\n      deps,\n    });\n  }\n\n  /**\n   * When App is in Limited Mode and Status check met a non-503 error\n   */\n  @state\n  hasLimitedStatusError = false;\n\n  @state\n  isLimitedMode = false;\n\n  @state\n  isVoIPOnlyMode = false;\n\n  @action\n  setLimitedModeStatusError() {\n    this.hasLimitedStatusError = true;\n  }\n\n  @action\n  setNormalMode() {\n    this.hasLimitedStatusError = false;\n    this.isLimitedMode = false;\n    this.isVoIPOnlyMode = false;\n  }\n\n  @action\n  setLimitedMode() {\n    this.isLimitedMode = true;\n  }\n\n  @action\n  setVoIPOnlyMode() {\n    this.isVoIPOnlyMode = true;\n  }\n\n  @action\n  setVoIPOnlyReset() {\n    this.isVoIPOnlyMode = false;\n  }\n\n  onInit() {\n    this._bindHandlers();\n  }\n\n  onInitOnce() {\n    watch(\n      this,\n      () => this._deps.environment.changeCounter,\n      () => {\n        if (this.ready && this._deps.environment?.ready) {\n          this._bindHandlers();\n        }\n      },\n    );\n  }\n\n  _bindHandlers() {\n    if (this._unbindHandlers) {\n      this._unbindHandlers();\n    }\n\n    const client = this._deps.client.service.client();\n    const platform = this._deps.client.service.platform();\n\n    // TODO: in other modules, when they catch error first check if app is in HA mode.\n    client.on(client.events.beforeRequest, this._beforeRequestHandler);\n    client.on(client.events.requestError, this._requestErrorHandler);\n    platform.addListener(\n      platform.events.loginSuccess,\n      this._switchToNormalMode,\n    );\n    platform.addListener(\n      platform.events.logoutSuccess,\n      this._switchToNormalMode,\n    );\n    platform.addListener(platform.events.logoutError, this._switchToNormalMode);\n    platform.addListener(\n      platform.events.refreshError,\n      this._refreshErrorHandler,\n    );\n    platform.addListener(\n      platform.events.refreshSuccess,\n      this._refreshSuccessHandler,\n    );\n\n    this._unbindHandlers = () => {\n      client.removeListener(\n        client.events.beforeRequest,\n        this._beforeRequestHandler,\n      );\n      client.removeListener(\n        client.events.requestError,\n        this._requestErrorHandler,\n      );\n      platform.removeListener(\n        platform.events.loginSuccess,\n        this._switchToNormalMode,\n      );\n      platform.removeListener(\n        platform.events.logoutSuccess,\n        this._switchToNormalMode,\n      );\n      platform.removeListener(\n        platform.events.logoutError,\n        this._switchToNormalMode,\n      );\n      platform.removeListener(\n        platform.events.refreshError,\n        this._refreshErrorHandler,\n      );\n      platform.removeListener(\n        platform.events.refreshSuccess,\n        this._refreshSuccessHandler,\n      );\n      this._unbindHandlers = null;\n    };\n  }\n\n  _beforeRequestHandler = (params: Request) => {\n    if (!this.isLimitedAvailabilityMode || !this._enabled) {\n      return;\n    }\n\n    const requestUrl = pathOr<string>(null, ['_request', 'url'], params);\n    const requestMethod = pathOr<string>(null, ['_request', 'method'], params);\n\n    if (!requestUrl || !requestMethod) {\n      return;\n    }\n\n    // In the limited availability mode, should not block status check api\n    // or highly availability api.\n    if (\n      extractUrl({ url: requestUrl }) === STATUS_END_POINT ||\n      isHAEnabledAPI({ url: requestUrl, method: requestMethod })\n    ) {\n      return;\n    }\n\n    throw new Error(errorMessages.serviceLimited);\n  };\n\n  /**\n   * Retrieve retry after value from response headers\n   */\n  _retrieveRetryAfter(headers: ApiError['response']['headers']) {\n    try {\n      const retryAfter = parseFloat(`${headers.get('Retry-After') || -1}`);\n      return Number.isNaN(retryAfter) ? -1 : retryAfter;\n    } catch (error) {\n      return -1;\n    }\n  }\n\n  /**\n   * Check if app can enter LA mode.\n   * If this module is not enabled, just return.\n   *\n   */\n  _requestErrorHandler = async (error: ApiError) => {\n    if (\n      error.response &&\n      !(error.response as ApiError['response'] & ErrorMessages)._json\n    ) {\n      (error.response as ApiError['response'] & ErrorMessages)._json =\n        await error.response.clone().json();\n    }\n    const requestUrl = pathOr<ApiError['request']['url']>(\n      '',\n      ['request', 'url'],\n      error,\n    );\n    const extractedUrl = extractUrl({\n      url: requestUrl,\n    });\n\n    // If app is in Limited Mode and staus API met a status which is not 200 nor 503\n    if (\n      this.isLimitedAvailabilityMode &&\n      extractedUrl === STATUS_END_POINT &&\n      !isHAError(error)\n    ) {\n      if (!this.hasLimitedStatusError) {\n        this.setLimitedModeStatusError();\n      }\n      return;\n    }\n\n    if (!isHAError(error) || !this._enabled) {\n      return;\n    }\n\n    const headers = pathOr(\n      {},\n      ['response', 'headers'],\n      error,\n    ) as ApiError['response']['headers'];\n    const retryAfter = this._retrieveRetryAfter(headers);\n\n    if (retryAfter > 0) {\n      // Retry-After unit is secons, make it mili-secons\n      this._healthRetryTime = retryAfter * 1000;\n    } else {\n      this._healthRetryTime = HEALTH_CHECK_INTERVAL;\n    }\n\n    this._switchToLimitedMode();\n    this._retry();\n  };\n\n  _refreshErrorHandler = async (error: ApiError) => {\n    const isOffline = validateIsOffline(error.message);\n\n    const platform = this._deps.client.service.platform();\n    const RES_STATUS = (error.response && error.response.status) || null;\n    const refreshTokenValid =\n      (isOffline || RES_STATUS >= 500) &&\n      (await platform.auth().refreshTokenValid());\n    if (refreshTokenValid) {\n      this._switchToVoIPOnlyMode();\n    }\n  };\n\n  _refreshSuccessHandler = () => {\n    if (this.isVoIPOnlyMode) {\n      this.setVoIPOnlyReset();\n    }\n    this._clearLimitedTimeout();\n  };\n\n  _switchToVoIPOnlyMode = () => {\n    if (this.isVoIPOnlyMode) {\n      return;\n    }\n\n    this._healthRetryTime = HEALTH_CHECK_INTERVAL;\n    this.setVoIPOnlyMode();\n    this._retry();\n  };\n\n  _switchToLimitedMode() {\n    if (this.isLimitedMode) {\n      return;\n    }\n\n    this.setLimitedMode();\n  }\n\n  _switchToNormalMode = () => {\n    if (!this.isLimitedAvailabilityMode) {\n      return;\n    }\n\n    this.setNormalMode();\n\n    this._clearLimitedTimeout();\n    this._clearNormalTimeout();\n  };\n\n  _clearLimitedTimeout() {\n    if (this._limitedTimeout) {\n      clearTimeout(this._limitedTimeout);\n      this._limitedTimeout = null;\n    }\n  }\n\n  _clearNormalTimeout() {\n    if (this._normalTimeout) {\n      clearTimeout(this._normalTimeout);\n      this._normalTimeout = null;\n    }\n  }\n\n  async _getStatus() {\n    // !!This API must be always called with OAuth token in Authorization header\n    // !! (same as in case of regular API calls) in order to ensure the request is routed to proper POD/partition.\n    // Client app can even continue use expired access token with this API - backend will pass such requests through.\n    // The result of the API call is unpredictable when it is called without access token!\n    //\n    // Reference: https://wiki.ringcentral.com/display/PLAT/High+Availability+Guidelines+for+API+Clients\n\n    const res: Response = await this._deps.client.service\n      .platform()\n      .get('/restapi/v1.0/status', null, {\n        skipAuthCheck: true,\n        headers: {\n          Authorization: `Bearer ${this._deps.auth.accessToken}`,\n        },\n      });\n    return res;\n  }\n\n  _retry() {\n    if (!this._limitedTimeout) {\n      this._limitedTimeout = setTimeout(() => {\n        this._clearLimitedTimeout();\n        this._healthCheck();\n      }, this._healthRetryTime);\n    }\n  }\n\n  /**\n   * Inner method of health checking\n   */\n  async _healthCheck({ manual = false } = {}) {\n    if (this._promise) return;\n    try {\n      this._promise = this._getStatus();\n      const response = await this._promise;\n      if (!response || response.status !== 200) {\n        return;\n      }\n    } catch (err) {\n      console.error('error from request of /restapi/v1.0/status.');\n      return;\n    } finally {\n      this._promise = null;\n    }\n    if (manual) {\n      this._clearNormalTimeout();\n      this._switchToNormalMode();\n      return;\n    }\n    // In the described situation Client Application should follow an \"Exponential Backoff\" approach:\n    // The retries exponentially increase the waiting time up to a certain threshold.\n    // The idea is that if the server is down temporarily,\n    // it is not overwhelmed with requests hitting at the same time when it comes back up.\n    //\n    // Reference: https://wiki.ringcentral.com/display/PLAT/Error+Handling+Guidelines+for+API+Clients\n\n    this._randomTime = this._randomTime || generateRandomNumber(); // Generate random seconds (1 ~ 121)\n    this._normalTimeout = setTimeout(() => {\n      this._clearNormalTimeout();\n      this._switchToNormalMode();\n    }, this._randomTime * 1000);\n  }\n\n  /**\n   * Health check with status API\n   */\n  healthCheck = promisedThrottle({\n    async fn(this: AvailabilityMonitor) {\n      return this._healthCheck({ manual: true });\n    },\n  });\n\n  /**\n   * Check if the error is Survival Mode error,\n   * Or if app is already in Survival Mode and current request is blocked with an error.\n   */\n  async checkIfHAError(error: ApiError) {\n    const errMessage = pathOr<string>(null, ['message'], error);\n    if (error.response) {\n      (error.response as ApiError['response'] & ErrorMessages)._json =\n        await error.response.clone().json();\n    }\n    return isHAError(error) || errMessage === errorMessages.serviceLimited;\n  }\n\n  /**\n   * Is App in limited mode\n   */\n  get isLimitedAvailabilityMode() {\n    return this.isLimitedMode || this.isVoIPOnlyMode;\n  }\n}\n"],"file":"AvailabilityMonitor.js"}