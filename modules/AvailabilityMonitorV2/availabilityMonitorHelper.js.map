{"version":3,"sources":["modules/AvailabilityMonitorV2/availabilityMonitorHelper.ts"],"names":["TMP_HA_ERROR_CODE","HA_ERROR_CODE","HA_ERROR_STATUS","extractUrl","url","filteredUrl","match","splitUrl","split","isHAError","error","status","errors","errorCodeIn","e","validHAError","resErrorCode","generateRandomNumber","max","min","Math","random","getAvailabilityLevel","path","method","highAvailabilityAPI","api","reg","isHAEnabledAPI","condition","console","availability","HIGH"],"mappings":"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","sourcesContent":["import { pathOr } from 'ramda';\nimport { ApiError } from '@ringcentral/sdk';\nimport { highAvailabilityAPI } from './highAvailabilityAPI';\nimport { availability } from './availabilityStatus';\nimport { ErrorMessages } from './AvailabilityMonitor.interface';\n\nexport const TMP_HA_ERROR_CODE = 'MaintenanceMode';\nexport const HA_ERROR_CODE = 'CMN-211';\nexport const HA_ERROR_STATUS = 503;\n\nexport function extractUrl({ url }: { url: string }) {\n  if (url === '') {\n    return '';\n  }\n\n  const filteredUrl =\n    (url.match(/\\/restapi(.*)/gi) && url.match(/\\/restapi(.*)/gi)[0]) || '';\n  const splitUrl = filteredUrl.split('?')[0] || '';\n  return splitUrl;\n}\n\n/** Check if this damn error is HA error. */\nexport function isHAError(error: ApiError) {\n  const status = pathOr<number>(-1, ['response', 'status'], error);\n  const errors = pathOr<ErrorMessages['_json']>(\n    [],\n    ['response', '_json', 'errors'],\n    error,\n  );\n\n  let errorCodeIn = false;\n  for (const e of errors) {\n    if (pathOr<string>('', ['errorCode'], e) === HA_ERROR_CODE) {\n      errorCodeIn = true;\n      break;\n    }\n  }\n\n  // Result from `status` and `errorCode`.\n  let validHAError = status === HA_ERROR_STATUS && errorCodeIn;\n  if (!validHAError) {\n    // Result from temp error code, expecially for `presence`.\n    const resErrorCode = pathOr(\n      null,\n      ['response', '_json', 'errorCode'],\n      error,\n    );\n    validHAError = resErrorCode === TMP_HA_ERROR_CODE;\n  }\n\n  return validHAError;\n}\n\n/**\n * Generate 1 ~ 120 seconds\n */\nexport function generateRandomNumber(max = 120, min = 1) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Get availability level by path of url\n * TODO: Use lru cache to improve performance?\n */\nfunction getAvailabilityLevel(path: string, method: string) {\n  for (const api of highAvailabilityAPI) {\n    if (path.match(api.reg) && method in api) {\n      return (api as Record<string, any>)[method] as string;\n    }\n  }\n}\n\n/**\n * Check if an api is *High* or *Limited*\n *\n */\nexport function isHAEnabledAPI({\n  url,\n  method,\n}: {\n  url: string;\n  method: string;\n}) {\n  const filteredUrl = extractUrl({ url });\n  if (!filteredUrl) {\n    return false;\n  }\n\n  const condition = getAvailabilityLevel(filteredUrl, method);\n  if (!condition) {\n    console.error(\n      `url: ${url} method: ${method} is not set in high or limited available API`,\n    );\n    // If a core API is not in the list, the request should be launched.\n    return true;\n  }\n\n  return condition === availability.HIGH;\n}\n"],"file":"availabilityMonitorHelper.js"}