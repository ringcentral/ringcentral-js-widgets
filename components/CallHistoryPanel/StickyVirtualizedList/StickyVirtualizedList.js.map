{"version":3,"sources":["components/CallHistoryPanel/StickyVirtualizedList/StickyVirtualizedList.tsx"],"names":["StickyVirtualizedList","props","nodes","getChildrenCache","rowRenderCache","rowRenderRange","structureChanged","elem","pendingScrollTop","treeToRender","onScroll","bind","state","scrollTop","currNodePos","scrollTick","undefined","node","isFirstChild","isLastChild","parentIndex","context","totalHeight","index","length","height","defaultRowHeight","parentInfo","id","isSticky","stickyTop","zIndex","rest","nodeInfo","top","depth","push","children","getChildren","isModelImmutable","oldChildren","every","child","i","getBranchChildrenIds","forEach","Array","isArray","flattenTree","arr","refreshCachedMetadata","storeRenderTree","newProps","root","treeDataUpdated","scrollIndex","scrollIndexIntoView","newState","nodeId","findIndex","getNodeIndex","includeObscured","isIndexVisible","inView","getParentPath","includes","isIndexInViewport","path","ancestor","getIndexTop","isNaN","setScrollTopAndClosestNode","scrollReasons","requested","alignToTop","setScrollTop","prevProps","prevState","scrollReason","onRowsRendered","range","visibleStartInfo","visibleStart","visibleEndInfo","visibleEnd","overscanStartIndex","start","overscanStopIndex","end","startIndex","stopIndex","startNode","endNode","forceUpdate","renderParentTree","getRenderRowRange","indexesToRender","Set","add","renderRoot","width","position","renderChildWithChildren","renderParentContainer","parent","renderChildren","getChildContainerStyle","renderNode","getClientNodeStyle","style","has","wrapAllLeafNodes","getClientLeafNodeStyle","renderedRow","rowRenderer","overscanRowCount","nodeIndex","topDownOrder","currNode","reverse","searchPos","Math","min","max","scrollHeight","offsetHeight","pos","forwardSearch","backwardSearch","setState","e","target","scrollLeft","overflow","React","PureComponent","defaultProps"],"mappings":"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","sourcesContent":["/* eslint-disable*/\n// Original Library: react-virtualized-sticky-tree\n// Ref: https://github.com/marchaos/react-virtualized-sticky-tree\nimport React, { CSSProperties } from 'react';\n\nimport {\n  Node,\n  scrollReasons,\n  ScrollReasons,\n  StickyVirtualizedListProps,\n  StickyVirtualizedListState,\n} from './StickyVirtualizedList.interface';\n\nexport class StickyVirtualizedList extends React.PureComponent<\n  StickyVirtualizedListProps,\n  StickyVirtualizedListState\n> {\n  static defaultProps = {\n    overscanRowCount: 10,\n    renderRoot: false,\n    wrapAllLeafNodes: false,\n    isModelImmutable: false,\n  };\n\n  nodes: Node[];\n\n  getChildrenCache: {\n    [key: string]: Node[];\n  };\n\n  rowRenderCache: {\n    [key: string]: JSX.Element;\n  };\n\n  rowRenderRange: {\n    start: number;\n    end: number;\n    visibleStart: number;\n    visibleEnd: number;\n  };\n  structureChanged: boolean;\n  elem: HTMLElement;\n  pendingScrollTop: number;\n  treeToRender: JSX.Element;\n\n  constructor(props: StickyVirtualizedListProps) {\n    super(props);\n    this.onScroll = this.onScroll.bind(this);\n\n    this.state = {\n      scrollTop: 0,\n      currNodePos: 0,\n      scrollTick: false,\n    };\n\n    this.nodes = [];\n    this.getChildrenCache = {};\n    this.rowRenderCache = {};\n    this.rowRenderRange = undefined;\n  }\n\n  flattenTree(\n    node: Node,\n    props = this.props,\n    nodes: Node[] = [],\n    isFirstChild = false,\n    isLastChild = false,\n    parentIndex: number = undefined,\n    context = { totalHeight: 0 },\n  ) {\n    const index = nodes.length;\n    const height =\n      node.height !== undefined ? node.height : props.defaultRowHeight;\n\n    const parentInfo = nodes[parentIndex];\n\n    const { id, isSticky = false, stickyTop = 0, zIndex = 0, ...rest } = node;\n\n    const nodeInfo = {\n      id,\n      isSticky,\n      stickyTop,\n      zIndex,\n      ...rest,\n      top: context.totalHeight,\n      parentIndex,\n      parentInfo,\n      depth: parentIndex !== undefined ? parentInfo.depth + 1 : 0,\n      height,\n      index,\n      isFirstChild,\n      isLastChild,\n    };\n\n    nodes.push(nodeInfo);\n\n    if (parentIndex !== undefined) {\n      parentInfo.children.push(index);\n    }\n\n    context.totalHeight += height;\n\n    const children = props.getChildren(node.id, nodeInfo);\n\n    if (props.isModelImmutable) {\n      // If children is undefined, then it is probably a leaf node, so we will have to render this since we don't know if the node\n      // itself has changed.\n      const oldChildren = this.getChildrenCache[node.id];\n      if (children === undefined || oldChildren !== children) {\n        delete this.rowRenderCache[node.id];\n        this.getChildrenCache[node.id] = children;\n\n        // Check for structure changes...\n        if (\n          children &&\n          oldChildren &&\n          (children.length !== oldChildren.length ||\n            !children.every((child, i) => child.id === oldChildren[i].id))\n        ) {\n          this.structureChanged = true;\n          // We need to update the entire branch if the structure has changed.\n          this.getBranchChildrenIds(children).forEach(\n            (id) => delete this.rowRenderCache[id],\n          );\n        }\n      }\n    } else {\n      this.structureChanged = true;\n    }\n\n    if (Array.isArray(children)) {\n      nodeInfo.children = [];\n      for (let i = 0; i < children.length; i++) {\n        // Need to reset parentIndex here as we are recursive.\n        const child = children[i];\n        this.flattenTree(\n          child,\n          props,\n          nodes,\n          i === 0,\n          i === children.length - 1,\n          index,\n          context,\n        );\n      }\n    }\n\n    nodeInfo.totalHeight = context.totalHeight - nodeInfo.top;\n\n    return nodes;\n  }\n\n  getBranchChildrenIds(children: Node[], arr: string[] = []) {\n    if (!children) {\n      return arr;\n    }\n    children.forEach((child) => {\n      arr.push(child.id);\n      this.getBranchChildrenIds(this.getChildrenCache[child.id], arr);\n    });\n    return arr;\n  }\n\n  UNSAFE_componentWillMount() {\n    this.refreshCachedMetadata(this.props);\n    this.storeRenderTree(this.props, this.state);\n  }\n\n  treeDataUpdated(newProps: StickyVirtualizedListProps) {\n    return (\n      newProps.root !== this.props.root ||\n      newProps.getChildren !== this.props.getChildren ||\n      newProps.defaultRowHeight !== this.props.defaultRowHeight\n    );\n  }\n\n  UNSAFE_componentWillReceiveProps(newProps: StickyVirtualizedListProps) {\n    // These two properties will change when the structure changes, so we need to re-build the tree when this happens.\n    if (this.treeDataUpdated(newProps)) {\n      this.refreshCachedMetadata(newProps);\n    }\n\n    if (newProps.scrollIndex !== undefined && newProps.scrollIndex >= 0) {\n      this.scrollIndexIntoView(newProps.scrollIndex);\n    }\n  }\n\n  UNSAFE_componentWillUpdate(\n    newProps: StickyVirtualizedListProps,\n    newState: StickyVirtualizedListState,\n  ) {\n    if (\n      newState.scrollTick === this.state.scrollTick ||\n      newState.currNodePos !== this.state.currNodePos\n    ) {\n      this.storeRenderTree(newProps, newState);\n    }\n  }\n\n  /**\n   * Returns the index of the node in a flat list tree (post-order traversal).\n   *\n   * @param nodeId The node index to get the index for.\n   * @returns {number}\n   */\n  getNodeIndex(nodeId: string) {\n    return this.nodes.findIndex((node) => node.id === nodeId);\n  }\n\n  /**\n   * Returns the node that appears higher than this node (either a parent, sibling or child of the sibling above).\n   * @param nodeId The node to get the previous node of.\n   * @returns {*}\n   */\n  getPreviousNodeId(nodeId: string) {\n    const index = this.getNodeIndex(nodeId);\n    if (index !== -1) {\n      const node = this.nodes[index - 1];\n      if (node) {\n        return node.id;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the node that appears lower than this node (sibling or sibling of the node's parent).\n   * @param nodeId The node to get the next node of.\n   * @returns {*}\n   */\n  getNextNodeId(nodeId: string) {\n    const index = this.getNodeIndex(nodeId);\n    if (index !== -1) {\n      const node = this.nodes[index + 1];\n      if (node) {\n        return node.id;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns true if the node is completely visible and is not obscured.\n   * This will return false when the node is partially obscured.\n   *\n   * @param nodeId The id of the node to check\n   * @param includeObscured if true, this method will return true for partially visible nodes.\n   * @returns {boolean}\n   */\n  isNodeVisible(nodeId: string, includeObscured = false) {\n    return this.isIndexVisible(this.getNodeIndex(nodeId), includeObscured);\n  }\n\n  /**\n   * Returns true if the node is completely visible and is not obscured, unless includeObscured is specified.\n   * This will return false when the node is partially obscured, unless includeObscured is set to true.\n   *\n   * @param index The index of the node to check, generally retrieved via getNodeIndex()\n   * @param includeObscured if true, this method will return true for partially visible nodes.\n   * @returns {boolean}\n   */\n  isIndexVisible(index: number, includeObscured = false) {\n    let inView;\n    const node = this.nodes[index];\n\n    if (!node) {\n      return false;\n    }\n\n    if (\n      (node.isSticky && index === this.state.currNodePos) ||\n      this.getParentPath(this.state.currNodePos).includes(this.nodes[index])\n    ) {\n      return true;\n    }\n\n    if (!includeObscured) {\n      inView = this.isIndexInViewport(index);\n    } else {\n      inView =\n        this.elem.scrollTop <= node.top + node.height - node.stickyTop &&\n        this.elem.scrollTop + this.props.height >= node.top;\n    }\n    if (inView) {\n      const path = this.getParentPath(index, false);\n      // If this node is in view, new need to check to see if it is obscured by a sticky parent.\n      // Note that this does not handle weird scenarios where the node's parent has a sticky top which is less than other ancestors.\n      // Or any z-index weirdness.\n      for (let i = 0; i < path.length; i++) {\n        const ancestor = path[i];\n        // If the ancestor is sticky and the node is in view, then it must be stuck to the top\n        if (ancestor.isSticky) {\n          if (\n            !includeObscured &&\n            ancestor.stickyTop + ancestor.height >\n              node.top - this.elem.scrollTop\n          ) {\n            return false;\n          }\n          if (\n            includeObscured &&\n            ancestor.stickyTop + ancestor.height >\n              node.top + node.height - this.elem.scrollTop\n          ) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isNodeInViewport(nodeId: string) {\n    return this.isIndexInViewport(this.getNodeIndex(nodeId));\n  }\n\n  isIndexInViewport(index: number) {\n    let node = this.nodes[index];\n    if (!node || !this.elem) {\n      return false;\n    }\n    return (\n      this.elem.scrollTop <= node.top - node.stickyTop &&\n      this.elem.scrollTop + this.props.height >= node.top + node.height\n    );\n  }\n\n  getNodeTop(nodeId: string) {\n    return this.getIndexTop(this.getNodeIndex(nodeId));\n  }\n\n  getIndexTop(index: number) {\n    const node = this.nodes[index];\n    return node ? node.top : -1;\n  }\n\n  getScrollTop() {\n    return this.elem ? this.elem.scrollTop : -1;\n  }\n\n  setScrollTop(scrollTop: number) {\n    if (!isNaN(scrollTop)) {\n      this.setScrollTopAndClosestNode(\n        scrollTop,\n        this.state.currNodePos,\n        scrollReasons.requested,\n      );\n    }\n  }\n\n  scrollNodeIntoView(nodeId: string, alignToTop = true) {\n    this.scrollIndexIntoView(this.getNodeIndex(nodeId), alignToTop);\n  }\n\n  scrollIndexIntoView(index: number, alignToTop = true) {\n    let node = this.nodes[index];\n    if (node !== undefined) {\n      let scrollTop;\n      if (alignToTop) {\n        if (node.isSticky) {\n          scrollTop = node.top - node.stickyTop;\n        } else {\n          const path = this.getParentPath(index, false);\n          for (let i = 0; i < path.length; i++) {\n            const ancestor = path[i];\n            if (ancestor.isSticky) {\n              scrollTop = node.top - ancestor.stickyTop - ancestor.height;\n              break;\n            }\n          }\n          if (scrollTop === undefined) {\n            // Fallback if nothing is sticky.\n            scrollTop = node.top;\n          }\n        }\n      } else {\n        scrollTop = node.top - this.props.height + node.height;\n      }\n      this.setScrollTop(scrollTop);\n    }\n  }\n\n  componentDidUpdate(\n    prevProps: StickyVirtualizedListProps,\n    prevState: StickyVirtualizedListState,\n  ) {\n    if (this.state.scrollReason === scrollReasons.requested) {\n      if (\n        this.state.scrollTop >= 0 &&\n        this.state.scrollTop !== this.elem.scrollTop\n      ) {\n        this.elem.scrollTop = this.state.scrollTop;\n      }\n    }\n\n    if (\n      this.props.onRowsRendered !== undefined &&\n      (prevState.currNodePos !== this.state.currNodePos ||\n        this.treeDataUpdated(prevProps))\n    ) {\n      const range = this.rowRenderRange;\n      const visibleStartInfo = this.nodes[range.visibleStart];\n      const visibleEndInfo = this.nodes[range.visibleEnd];\n\n      this.props.onRowsRendered({\n        overscanStartIndex: range.start,\n        overscanStopIndex: range.end,\n        startIndex: range.visibleStart,\n        stopIndex: range.visibleEnd,\n        startNode: visibleStartInfo && visibleStartInfo.id,\n        endNode: visibleEndInfo && visibleEndInfo.id,\n        nodes: this.nodes,\n      });\n    }\n  }\n\n  refreshCachedMetadata(props: StickyVirtualizedListProps) {\n    this.structureChanged = false;\n    this.nodes = this.flattenTree(props.root, props);\n\n    if (this.structureChanged) {\n      // Need to re-render as the curr node may not be in view\n      if (this.elem) {\n        // We need to find the the closest node to where we are scrolled to since the structure of the\n        // the tree probably has changed.\n        this.setScrollTopAndClosestNode(\n          this.pendingScrollTop || this.elem.scrollTop,\n          0,\n          scrollReasons.requested,\n        );\n      }\n    }\n  }\n\n  recomputeTree() {\n    if (this.props.root !== undefined && this.props.getChildren !== undefined) {\n      this.refreshCachedMetadata(this.props);\n      this.forceUpdate();\n    }\n  }\n\n  storeRenderTree(\n    props: StickyVirtualizedListProps,\n    state: StickyVirtualizedListState,\n  ) {\n    this.treeToRender = this.renderParentTree(props, state);\n  }\n\n  forceUpdate() {\n    this.getChildrenCache = {};\n    this.rowRenderCache = {};\n    this.storeRenderTree(this.props, this.state);\n    super.forceUpdate();\n  }\n\n  renderParentTree(\n    props: StickyVirtualizedListProps,\n    state: StickyVirtualizedListState,\n  ) {\n    this.rowRenderRange = this.getRenderRowRange(props, state);\n    const path = this.getParentPath(this.rowRenderRange.start);\n\n    // Parent nodes to the current range.\n    const indexesToRender: Set<number> = new Set();\n    for (let i = 0; i < path.length; i++) {\n      indexesToRender.add(path[i].index);\n    }\n\n    // The rest of the nodes within the range.\n    for (let i = this.rowRenderRange.start; i <= this.rowRenderRange.end; i++) {\n      indexesToRender.add(this.nodes[i].index);\n    }\n\n    if (this.props.renderRoot) {\n      return (\n        <div\n          className=\"rv-sticky-node-list\"\n          style={{ width: '100%', position: 'absolute', top: 0 }}\n        >\n          {this.renderChildWithChildren(\n            props,\n            state,\n            this.nodes[0],\n            0,\n            indexesToRender,\n          )}\n        </div>\n      );\n    }\n    return this.renderParentContainer(\n      props,\n      state,\n      this.nodes[0],\n      indexesToRender,\n    );\n  }\n\n  renderParentContainer(\n    props: StickyVirtualizedListProps,\n    state: StickyVirtualizedListState,\n    parent: Node,\n    indexesToRender: Set<number>,\n  ) {\n    return (\n      <div\n        className=\"rv-sticky-node-list\"\n        style={{\n          position: 'absolute',\n          width: '100%',\n          height: parent.totalHeight - parent.height,\n        }}\n      >\n        {this.renderChildren(props, state, parent, indexesToRender)}\n      </div>\n    );\n  }\n\n  getChildContainerStyle(child: Node, top: number) {\n    return {\n      position: 'absolute',\n      top,\n      height: child.totalHeight,\n      width: '100%',\n    } as CSSProperties;\n  }\n\n  renderChildWithChildren(\n    props: StickyVirtualizedListProps,\n    state: StickyVirtualizedListState,\n    child: Node,\n    top: number,\n    indexesToRender: Set<number>,\n  ) {\n    return (\n      <div\n        key={`rv-node-${child.id}`}\n        className=\"rv-sticky-parent-node\"\n        style={this.getChildContainerStyle(child, top)}\n      >\n        {this.renderNode(props, state, child, this.getClientNodeStyle(child))}\n        {this.renderParentContainer(props, state, child, indexesToRender)}\n      </div>\n    );\n  }\n\n  getClientNodeStyle(node: Node) {\n    const style: CSSProperties = { height: node.height };\n    if (node.isSticky) {\n      style.position = 'sticky';\n      style.top = node.stickyTop;\n      style.zIndex = node.zIndex;\n    }\n\n    return style;\n  }\n\n  getClientLeafNodeStyle(node: Node, top: number) {\n    return {\n      position: 'absolute',\n      top,\n      height: node.height,\n      width: '100%',\n    } as CSSProperties;\n  }\n\n  renderChildren(\n    props: StickyVirtualizedListProps,\n    state: StickyVirtualizedListState,\n    parent: Node,\n    indexesToRender: Set<number>,\n  ) {\n    const nodes: JSX.Element[] = [];\n    let top = 0;\n    parent.children.forEach((index) => {\n      const child = this.nodes[index];\n\n      if (indexesToRender.has(index)) {\n        if (child.children && child.children.length > 0) {\n          nodes.push(\n            this.renderChildWithChildren(\n              props,\n              state,\n              child,\n              top,\n              indexesToRender,\n            ),\n          );\n        } else {\n          // Sticky nodes will need a container so that their top is correct. The sticky node itself will have a top\n          // of the offset where it should stick, which would conflict with the absolute position of the node.\n          if (child.isSticky || props.wrapAllLeafNodes) {\n            nodes.push(\n              <div\n                className=\"rv-sticky-leaf-node\"\n                key={`rv-node-${child.id}`}\n                style={this.getChildContainerStyle(child, top)}\n              >\n                {this.renderNode(\n                  props,\n                  state,\n                  child,\n                  this.getClientNodeStyle(child),\n                )}\n              </div>,\n            );\n          } else {\n            nodes.push(\n              this.renderNode(\n                props,\n                state,\n                child,\n                this.getClientLeafNodeStyle(child, top),\n              ),\n            );\n          }\n        }\n      }\n      // Needs to be on the outside so that we add the the top even if\n      // this node is not visible\n      top += child.totalHeight;\n    });\n    return nodes;\n  }\n\n  renderNode(\n    props: StickyVirtualizedListProps,\n    state: StickyVirtualizedListState,\n    nodeInfo: Node,\n    style?: CSSProperties,\n  ) {\n    // If they have not mutated their getChildren, then no need to call them again for the same structure.\n    if (props.isModelImmutable && this.rowRenderCache[nodeInfo.id]) {\n      return this.rowRenderCache[nodeInfo.id];\n    }\n\n    const renderedRow = props.rowRenderer({ id: nodeInfo.id, nodeInfo, style });\n\n    if (props.isModelImmutable) {\n      this.rowRenderCache[nodeInfo.id] = renderedRow;\n    }\n\n    return renderedRow;\n  }\n\n  /**\n   * Determines the start and end number of the range to be rendered.\n   * @returns {{start: number, end: number}} Indexes within nodes\n   */\n  getRenderRowRange(\n    props: StickyVirtualizedListProps,\n    state: StickyVirtualizedListState,\n  ) {\n    // Needs to be at least 1\n    const overscanRowCount =\n      props.overscanRowCount > 0 ? props.overscanRowCount : 1;\n    let start = state.currNodePos - overscanRowCount;\n    if (start < 0) {\n      start = 0;\n    }\n    let visibleEnd = state.currNodePos + 1;\n\n    while (\n      this.nodes[visibleEnd] &&\n      this.nodes[visibleEnd].top < state.scrollTop + props.height\n    ) {\n      visibleEnd++;\n    }\n\n    let end = visibleEnd + overscanRowCount;\n    if (end > this.nodes.length - 1) {\n      end = this.nodes.length - 1;\n    }\n\n    return { start, end, visibleStart: state.currNodePos, visibleEnd };\n  }\n\n  getParentPath(nodeIndex: number, topDownOrder = true) {\n    let currNode = this.nodes[nodeIndex];\n    const path = [];\n    while (currNode) {\n      currNode = this.nodes[currNode.parentIndex];\n      if (currNode) {\n        path.push(currNode);\n      }\n    }\n    return topDownOrder ? path.reverse() : path;\n  }\n\n  forwardSearch(scrollTop: number, searchPos: number) {\n    const nodes = this.nodes;\n    for (let i = searchPos; i < nodes.length; i++) {\n      if (nodes[i].top >= scrollTop) {\n        return i;\n      }\n    }\n    return nodes.length - 1;\n  }\n\n  backwardSearch(scrollTop: number, searchPos: number) {\n    const nodes = this.nodes;\n    for (\n      let i = Math.min(searchPos, Math.max(nodes.length - 1, 0));\n      i >= 0;\n      i--\n    ) {\n      if (nodes[i].top <= scrollTop) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  setScrollTopAndClosestNode(\n    scrollTop: number,\n    currNodePos: number,\n    scrollReason: ScrollReasons,\n  ) {\n    if (scrollTop === this.state.scrollTop) {\n      return;\n    }\n\n    if (scrollTop >= this.elem.scrollHeight - this.elem.offsetHeight) {\n      scrollTop = this.elem.scrollHeight - this.elem.offsetHeight;\n    }\n\n    let pos;\n    if (scrollTop > this.state.scrollTop || currNodePos === 0) {\n      pos = this.forwardSearch(scrollTop, currNodePos);\n    }\n    if (scrollTop < this.state.scrollTop && pos === undefined) {\n      pos = this.backwardSearch(scrollTop, currNodePos);\n    }\n\n    this.pendingScrollTop = scrollTop;\n    this.setState(\n      { currNodePos: pos ? pos : 0, scrollTop, scrollReason },\n      () => {\n        this.pendingScrollTop = undefined;\n      },\n    );\n  }\n\n  onScroll(e: React.UIEvent<HTMLElement>) {\n    const { scrollTop, scrollLeft } = e.target as HTMLElement;\n\n    const scrollReason = this.state.scrollReason || scrollReasons.requested;\n\n    this.setScrollTopAndClosestNode(\n      scrollTop,\n      this.state.currNodePos,\n      scrollReason,\n    );\n\n    if (this.props.onScroll !== undefined) {\n      this.props.onScroll({ scrollTop, scrollLeft, scrollReason });\n    }\n\n    this.setState({\n      scrollTick: !this.state.scrollTick,\n      scrollReason: undefined,\n    });\n  }\n\n  render() {\n    let style = { overflow: 'auto', position: 'relative' } as CSSProperties;\n    if (this.props.width) {\n      style.width = this.props.width;\n    }\n    if (this.props.height) {\n      style.height = this.props.height;\n    }\n\n    return (\n      <div\n        ref={(elem) => (this.elem = elem)}\n        className=\"rv-sticky-tree\"\n        style={style}\n        onScroll={this.onScroll}\n      >\n        {this.treeToRender}\n      </div>\n    );\n  }\n}\n"],"file":"StickyVirtualizedList.js"}