__w_widgets = {};__w_widgets['auth-panel'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  function t() {\n\t    this.dom[\"country-list\"].classList.toggle(\"display-none\");\n\t  }function o(t) {\n\t    this.dom[\"country-dropdown\"].textContent = t, this.dom[\"country-list\"].classList.add(\"display-none\"), this.props.country = t;\n\t  }var s = w.transition(\"fade\");this.props = { country: \"United States\", username: null, extension: null, password: null, oauth: !1 }, this.actions = { init: { before: function before() {\n\t        this.data.oauth && (this.props.oauth = this.data.oauth);\n\t      }, method: function method(t) {\n\t        t();\n\t      }, after: function after() {\n\t        var t = (w.t(this.data.lang), this.data),\n\t            o = (t.color, t.lang, t.logo);this.dom.logo.src = o || \"./ringcentral-logo.svg\", this.props.oauth && (this.dom[\"user-info\"].classList.add(\"display-none\"), this.dom[\"remember-wrapper\"].classList.add(\"display-none\"));\n\t      } }, mount: { before: function before() {}, after: function after() {\n\t        this.dom.username.value = localStorage.getItem(\"username\"), this.dom.extension.value = localStorage.getItem(\"extension\"), this.dom.password.value = localStorage.getItem(\"password\"), this.data.external ? (this.dom[\"login-button\"].classList.add(\"display-none\"), this.dom[\"user-info\"].classList.add(\"display-none\")) : this.dom[\"external-login-button\"].classList.add(\"display-none\"), s.in(this.root);\n\t      } }, login: { before: function before() {\n\t        this.dom[\"login-button\"].disabled = !0, this.dom.error.textContent = \"\", this.dom[\"disabled-mask\"].classList.remove(\"display-none\"), this.dom.container.classList.add(\"blur\");\n\t      }, method: function method(t) {\n\t        return this.props.username = this.dom.username.value, this.props.extension = this.dom.extension.value, this.props.password = this.dom.password.value, t();\n\t      }, after: function after() {\n\t        this.dom[\"login-button\"].disabled = !1, this.dom[\"disabled-mask\"].classList.add(\"display-none\"), this.dom.container.classList.remove(\"blur\"), this.dom.remember.checked && (localStorage.setItem(\"username\", this.dom.username.value || \"\"), localStorage.setItem(\"extension\", this.dom.extension.value || \"\"), localStorage.setItem(\"password\", this.dom.password.value || \"\"));\n\t      }, error: function error(t) {\n\t        this.dom[\"disabled-mask\"].classList.add(\"display-none\"), this.dom.container.classList.remove(\"blur\"), this.dom[\"login-button\"].disabled = !1;\n\t      } }, externalLogin: { before: function before() {\n\t        this.dom[\"login-button\"].disabled = !0, this.dom.error.textContent = \"\", this.dom[\"login-button\"].classList.add(\"rc-button-loading\");\n\t      }, method: function method(t) {\n\t        return t();\n\t      }, after: function after() {}, error: function error(t) {\n\t        console.error(t), this.dom.error.textContent = t.message, this.dom[\"login-button\"].disabled = !1;\n\t      } }, disable: { method: function method(t) {} }, warn: { method: function method(t, o) {} }, country: { method: function method(t, s) {\n\t        if (s) return o.call(this, s), s;\n\t      } } }, this.on(\"click\", function (o) {\n\t    o.target === this.dom[\"login-button\"] && this.login(), o.target === this.dom[\"external-login-button\"] && this.externalLogin(), o.target === this.dom[\"\"] && t.call(this, o.target.textContent);\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=\"rc-panel rc-auth-panel\">\n        <div class=rc-auth-panel__container data-info=container>\n            <div class=\"rc-panel__header rc-auth-panel__header rc-auth-panel__header--color\">\n                <img class=\"rc-img rc-auth-panel__img\" src=./ringcentral_logo.png data-info=logo>\n            </div>\n            <div class=\"rc-panel__content rc-auth-panel__content rc-auth-panel__content--color\">\n                <div data-info=user-info>\n                    <input class=\"rc-input rc-input--round\" data-info=username placeholder=username>\n                    \n                    <input class=\"rc-input rc-input--round\" data-info=extension placeholder=extension>\n                    <input class=\"rc-input rc-input--round\" data-info=password placeholder=password type=password>\n                    \n                </div>\n                <div class=\"rc-label rc-auth-panel__error\" data-info=error></div>\n                <div class=button-panel>\n                    <button class=\"rc-button rc-button--round rc-auth-panel__button rc-auth-panel__button--color\" data-info=external-login-button>Third party\n                    </button>\n                    <button class=\"rc-button rc-button--round rc-button--material rc-auth-panel__button rc-auth-panel__button--color\" data-info=login-button>Login\n                    </button>\n                </div>\n                <div class=rc-label data-info=remember-wrapper>\n                    <label for=remember>Remember me:</label>\n                    <input id=remember type=checkbox data-info=remember checked=checked>\n                </div>\n            </div>\n        </div>\n        <div class=\"rc-auth-panel__mask display-none\" data-info=disabled-mask>\n            <p data-info=disabled-mask-text>Login...</p>\n        </div>\n    </div>\n","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-auth-panel .input-panel {\n    border-radius: 2px;\n    border: 1px solid #bdc3c7;\n}\n.rc-auth-panel .input-panel > .rc-input {}\n.rc-auth-panel .input-panel__flag {\n    float: left;\n    width: 40px;\n    /* For test, the position is for country flag */\n    height: 30px;\n    background: #000;\n}\n.rc-auth-panel .input-panel__phone {\n    float: left;\n    width: calc(100% - 40px);\n}\n.rc-auth-panel .button-panel {\n    /* Move to the bottom of flex container */\n    margin-top: auto\n}\n.rc-auth-panel .button-panel > .rc-button {\n    margin-top: 10px;\n    width: 100%;\n}\n.rc-auth-panel .blur {\n    filter: blur(2px);\n    -webkit-filter: blur(2px);\n}\n.rc-auth-panel__content {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    padding: 10px;\n}\n.rc-auth-panel__content .rc-input {\n    margin: 5px 0;\n}\n.rc-auth-panel__container {\n    /* used as a positioned reference */\n    position: relative;\n    height: 100%;\n}\n.rc-auth-panel__header {\n    text-align: center;\n}\n.rc-auth-panel__img {\n    margin-top: 10px;\n    width: 60%;\n}\n.rc-auth-panel__button {}\n.rc-auth-panel__button--color {}\n.rc-auth-panel__mask {\n    position: absolute;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.rc-auth-panel__mask > p {\n    font-weight: bold;\n    text-align: center;\n}\n.rc-auth-panel__mask::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.rc-auth-panel__error {\n    color: #e74c3c;\n    font-size: .9em;\n}\n\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['auto-complete'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = { init: { before: function before() {}, after: function after() {} }, mount: { before: function before() {}, method: function method(t) {\n\t        t();\n\t      }, after: function after() {\n\t        var t = this;window.addEventListener(\"click\", function (i) {\n\t          i.target === t.dom.input || i.target.classList.contains(\"candidate\") || t.hide();\n\t        });\n\t      } }, hide: { after: function after() {\n\t        this.dom.candidates.classList.add(\"display-none\"), this.showingTimeout && (window.clearTimeout(this.showingTimeout), this.showingTimeout = null);\n\t      } }, show: { after: function after() {\n\t        var t = this;this.showingTimeout || (this.showingTimeout = window.setTimeout(function () {\n\t          t.dom.input === document.activeElement && t.dom.candidates.classList.remove(\"display-none\");\n\t        }, 300));\n\t      } }, appendInput: { before: function before(t) {\n\t        this.dom.input.value += t, this.dom.input.focus();\n\t      } }, autoComplete: { before: function before() {}, method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        var i = this;if (t) {\n\t          for (; this.dom.candidates.firstChild;) {\n\t            this.dom.candidates.removeChild(this.dom.candidates.firstChild);\n\t          }t.length > 0 ? this.show() : this.hide(), t.forEach(function (t) {\n\t            var n = i.dom[\"candidate-template\"].cloneNode(!0);n.addEventListener(\"click\", function (t) {\n\t              i.dom.input.value = n.textContent, i.hide();\n\t            }), n.textContent = t.from.phoneNumber, i.dom.candidates.appendChild(n);\n\t          });\n\t        }\n\t      } } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=auto-complete>\n    <input class=rc-input placeholder=\"To: Enter name or number\" data-info=input data-event=input:autoComplete>\n    <div data-info=candidates class=\"candidates display-none\">\n        <div data-info=candidate-template class=candidate></div>\n    </div>\n</div>","style":"\n.auto-complete .candidates {\n    position: absolute;\n    background-color: #fff;\n    width: 228px;\n    padding: 2px 0;\n    margin-top: 1px;\n    border: 1px solid #878787;\n    color: #878787;\n}\n\n.auto-complete .candidate {\n    font-size: 14px;\n    padding: 5px 10px;\n}\n\n.auto-complete .candidate:hover {\n    background-color: #3498db;\n    color: #fff;\n}\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['call-log-item'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = { init: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        this.props.item = t, \"Missed\" === t.result && this.dom.callResult.classList.add(\"--missed\"), \"Outbound\" === t.direction ? (this.dom.time.innerHTML = t.startTime, t.to.name ? this.dom.contact.innerHTML = t.to.name : this.dom.contact.innerHTML = t.to.phoneNumber, t.to.location && (this.dom.location.innerHTML = t.to.location), \"Missed\" !== t.result && this.dom.callResult.classList.add(\"--outbound\")) : (this.dom.time.innerHTML = t.startTime, t.from.name ? this.dom.contact.innerHTML = t.from.name : this.dom.contact.innerHTML = t.from.phoneNumber, \"Missed\" !== t.result && this.dom.callResult.classList.add(\"--inbound\"));\n\t      } } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=rc-call-log-item data-info=entry>\n    <i data-info=callResult class=rc-call-log-item__icon></i>\n    <span class=rc-call-log-item__time data-info=time></span>\n    <div class=rc-call-log-item__body>\n        <a class=__contact data-info=contact>\n            \n        </a>\n        <p class=__location data-info=location></p>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['call-log'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  function t(t, s) {\n\t    t && t.forEach(function (t) {\n\t      var i = w(\"call-log-item\", { actions: { init: { method: function method() {\n\t              return t;\n\t            } } } });i.mount(s.dom.logs), s.props.widgetItems.push(i);\n\t    });\n\t  }function s(t, s) {\n\t    t.forEach(function (t) {\n\t      s(t) ? t.show() : t.hide();\n\t    });\n\t  }function i(t, s) {\n\t    t.classList.contains(\"--active\") === !1 && (t.classList.add(\"--active\"), s.classList.remove(\"--active\"));\n\t  }this.actions = { init: { before: function before() {\n\t        this.props.widgetItems = [];\n\t      }, method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        this.props.logItems = t, this.refreshCallLogs();\n\t      } }, mount: { after: function after() {\n\t        this.refreshCallLogs();\n\t      } }, refreshCallLogs: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {\n\t        this.props.widgetItems.length > 0 || t(this.props.logItems, this);\n\t      } }, enableAllCallTab: { after: function after() {\n\t        i(this.dom.allCallTab, this.dom.missedCallTab), s(this.props.widgetItems, function () {\n\t          return !0;\n\t        });\n\t      } }, enableMissedCallTab: { after: function after() {\n\t        i(this.dom.missedCallTab, this.dom.allCallTab), s(this.props.widgetItems, function (t) {\n\t          return \"Missed\" === t.props.item.result;\n\t        });\n\t      } } }, this.on(\"click\", function (t) {\n\t    t.target === this.dom.allCallTab ? this.enableAllCallTab() : t.target === this.dom.missedCallTab && this.enableMissedCallTab();\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=rc-panel>\n    <div class=rc-panel__header>\n        <div class=rc-tabs>\n            <a class=\"rc-tabs__tab --active --color --width2\" data-info=allCallTab>\n                All\n            </a>\n            <a class=\"rc-tabs__tab --color --width2\" data-info=missedCallTab>\n                Missed\n            </a>\n        </div>\n    </div>\n    <div class=\"rc-panel__content rc-call-log__content\" data-info=logs>\n        <call-log-item dynamic></call-log-item>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['call-panel-incoming'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  var t = (w.transition(\"circle\"), w.transition(\"fade\")),\n\t      e = function e(t) {\n\t    var e = this;document.querySelector(\"#rc-advance-button\") && this.dom[\"advance-panel\"].removeChild(document.querySelector(\"#rc-advance-button\"));var n = document.createElement(\"div\");n.innerHTML = \"<button \\n            id='rc-advance-button'\\n            class='rc-button rc-button--circle rc-button--positive advance-panel__button'>\\n        </button>\", n.firstChild.addEventListener(\"click\", function (n) {\n\t      var i = e.refs[\"contact-picker\"].getInput();e[t](i);\n\t    }), this.dom[\"advance-panel\"].appendChild(n.firstChild);\n\t  };this.props = { name: null, target: null, remoteVideo: null, localVideo: null, session: null, width: 250, height: 400, simple: !1, actionNumber: \"\" }, this.actions = { init: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {\n\t        this.props.target = this.data.target, this.props.remoteVideo = this.data.remoteVideo, this.props.localVideo = this.data.localVideo, this.props.width = this.data.width, this.props.height = this.data.height, this.data.simple && (this.props.simple = this.data.simple), this.root.firstChild.style.width = this.props.width + \"px\", this.root.firstChild.style.height = this.props.height + \"px\", this.props.simple && this.dom[\"control-panel\"].classList.add(\"display-none\");var t = this;w.customize(this, \"contact-picker\", { actions: { autoComplete: { method: function method() {\n\t                return t.props.inputValue = this.props.inputValue, t.queryContacts();\n\t              } } } });\n\t      } }, mount: { after: function after() {\n\t        t.init(this.root), t.in(this.root);\n\t      } }, unmount: { after: function after() {\n\t        this.dom[\"advance-panel\"].classList.add(\"display-none\");\n\t      } }, setName: { method: function method(t, e) {\n\t        this.props.name = e, this.dom.name.textContent = e;\n\t      } }, ignore: { after: function after() {\n\t        console.log(\"unmount\"), this.unmount();\n\t      } }, reject: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {\n\t        this.unmount();\n\t      } }, accept: { method: function method(t) {\n\t        return t();\n\t      }, error: function error(t) {\n\t        console.log(t);\n\t      } }, readyForward: { after: function after() {\n\t        this.dom[\"advance-panel\"].classList.remove(\"display-none\"), e.call(this, \"forward\");\n\t      } }, forward: { method: function method(t, e) {\n\t        return this.props.actionNumber = e, t();\n\t      } }, simplify: { before: function before(t) {\n\t        t ? this.dom.panel.classList.add(\"rc-panel__content--min\") : this.dom.panel.classList.remove(\"rc-panel__content--min\");\n\t      } }, queryContacts: { method: function method(t) {\n\t        return t();\n\t      } } }, this.on(\"click\", function (t) {\n\t    var e = this;[\"accept\", \"ignore\", \"reject\", \"message\", \"readyForward\"].forEach(function (n) {\n\t      t.target !== e.dom[n] && t.target.parentNode !== e.dom[n] || e[n]();\n\t    });\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=\"rc-panel rc-call-panel\">\n    <div class=\"rc-panel__header rc-panel__header--center\">\n        <div class=name data-info=name></div>\n        <p>Call Incoming</p>\n    </div>\n    <div class=rc-panel__content data-info=panel>\n        <div class=control-panel data-info=control-panel>\n            <div class=control-panel__line>\n                <div class=control-panel__item>\n                    <button data-info=readyForward class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                        <span class=icon-uni27></span>\n                        <span class=icon-uni34></span>\n                    </button>\n                    <div class=text-center>Forward</div>\n                </div>\n                \n                <div class=control-panel__item>\n                    <button data-info=ignore class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                        <span class=icon-uni43></span>\n                        <span class=icon-uni43></span>\n                    </button>\n                    <div class=text-center>Ignore</div>\n                </div>\n            </div>\n        </div>\n        <div class=\"advance-panel display-none\" data-info=advance-panel>\n            <contact-picker data-info=contact-picker></contact-picker>\n        </div>\n        <div class=rc-call-panel__footer>\n            \n\n            <div class=\"action-panel text-center\">\n                <button data-info=accept class=\"rc-button rc-button--round action-panel__action action-panel__action--mr\">\n                        <span class=icon-uniAE></span>\n                    </button>\n                <button data-info=reject class=\"rc-button rc-button--round rc-button--negative action-panel__action\">\n                        <span class=icon-uni44></span>\n                    </button>\n            </div>\n        </div>\n    </div>\n</div>","style":"\n    call-panel-incoming .name {\n        font-size: 1.6em;\n        margin-top: 10px;\n        margin-bottom: 5px;\n    }\n    call-panel-incoming .rc-call-panel {\n    }\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":true}};
__w_widgets['call-panel'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  function t(t) {\n\t    return t < 10 ? \"0\" + t : t;\n\t  }var i,\n\t      e = w.transition(\"fade\"),\n\t      s = function s(t) {\n\t    var i = this;document.querySelector(\"#rc-advance-button\") && this.dom[\"advance-panel\"].removeChild(document.querySelector(\"#rc-advance-button\"));var e = document.createElement(\"div\");e.innerHTML = \"<button \\n            id='rc-advance-button'\\n            class='rc-button rc-button--circle rc-button--positive advance-panel__button'>\\n        </button>\", e.firstChild.addEventListener(\"click\", function (e) {\n\t      var s = \"flip\" === t ? i.refs.dropdown.getSelected() : i.refs[\"contact-picker\"].getInput();console.log(i.refs.dropdown.getSelected()), i[t](s);\n\t    }), this.dom[\"advance-panel\"].appendChild(e.firstChild);\n\t  };this.props = { name: null, advance: !0, time: 0, minimized: !1, width: 250, height: 400, target: null, remoteVideo: null, localVideo: null, isMute: !1, isHold: !1, isRecord: !1, isPark: !1, actionNumber: \"\", dtmfNumber: \"\" }, this.actions = { init: { after: function after() {\n\t        this.props.name = this.data.name, this.props.width = this.data.width, this.props.height = this.data.height, this.props.target = this.data.target, \"undefined\" != typeof this.data.advance && (this.props.advance = this.data.advance), this.props.remoteVideo = this.dom.remote, this.props.localVideo = this.dom.local, this.root.firstChild.style.width = this.props.width + \"px\", this.root.firstChild.style.height = this.props.height + \"px\", this.dom.content.style.transition = \"opacity .1s ease-in-out\", this.dom.content.style.opacity = 0, this.props.advance || this.dom[\"contral-panel\"].classList.add(\"display-none\");var t = this;w.customize(this, \"contact-picker\", { actions: { autoComplete: { method: function method() {\n\t                return t.props.inputValue = this.props.inputValue, t.queryContacts();\n\t              } } } }), w.customize(this, \"dropdown\", { data: { height: 35 }, actions: { getData: { method: function method() {\n\t                return t.getOutboundCallerID();\n\t              } }, switchTitle: { method: function method(i) {\n\t                t.props.actionNumber = i;\n\t              } } } });\n\t      } }, mount: { after: function after() {\n\t        var t = this;this.props.advance || this.dom[\"contral-panel\"].classList.add(\"display-none\"), e.init(this.root), e.in(this.root), this.props.name && this.setName(this.props.name), this.refs.dropdown.getData(), setTimeout(function () {\n\t          return t.dom.content.style.opacity = 1;\n\t        }, 17), this.getContact().then(function (i) {\n\t          i && i[0] && i[0].name && (console.log(i[0].name), t.setName(i[0].name));\n\t        });\n\t      } }, unmount: { after: function after() {\n\t        this.dom.time.textContent = \"Dialing\", this.dom.time.classList.add(\"blink\"), this.dom.content.style.opacity = 0, this.props.duration = 0, i && (i(), i = null), this.props.isMute = !1;var t = document.createElement(\"span\");for (t.classList.add(\"icon-uniCE\"); this.dom.mute.firstChild;) {\n\t          this.dom.mute.removeChild(this.dom.mute.firstChild);\n\t        }this.dom.mute.appendChild(t), this.enableFlip(), this.enableRecord(), this.enablePark(), this.props.isHold = !1;var t = document.createElement(\"span\"),\n\t            e = document.createElement(\"span\");for (t.classList.add(\"icon-uni28\"), e.classList.add(\"icon-uni35\"); this.dom.hold.firstChild;) {\n\t          this.dom.hold.removeChild(this.dom.hold.firstChild);\n\t        }this.dom.hold.appendChild(t), this.dom.hold.appendChild(e), this.props.isRecord = !1;var t = document.createElement(\"span\"),\n\t            e = document.createElement(\"span\");for (t.classList.add(\"icon-uni24\"), e.classList.add(\"icon-Active_Call-33\"); this.dom.record.firstChild;) {\n\t          this.dom.record.removeChild(this.dom.record.firstChild);\n\t        }this.dom.record.appendChild(t), this.dom.record.appendChild(e), this.dom[\"contral-panel\"].classList.remove(\"display-none\"), this.dom[\"dialing-panel\"].classList.add(\"display-none\"), this.dom.mask.classList.add(\"display-none\"), this.props.isPark = !1;var t = document.createElement(\"span\"),\n\t            e = document.createElement(\"span\");for (t.classList.add(\"icon-uni22\"), e.classList.add(\"icon-uni2E\"); this.dom.park.firstChild;) {\n\t          this.dom.park.removeChild(this.dom.park.firstChild);\n\t        }this.dom.park.appendChild(t), this.dom.park.appendChild(e), this.dom[\"advance-panel\"].classList.add(\"display-none\");\n\t      } }, getContact: { method: function method(t) {\n\t        return t();\n\t      } }, setName: { method: function method(t, i) {\n\t        this.props.name = i, this.dom.name.textContent = i, this.dom[\"bar-name\"].textContent = i;\n\t      } }, start: { after: function after(e) {\n\t        this.props.startTime = Date.now(), this.props.duration = 0;var s = Math.floor(this.props.duration / 60),\n\t            d = this.props.duration % 60;this.dom.time.classList.remove(\"blink\"), this.dom.time.textContent = t(s) + \":\" + t(d), i && (i(), i = null), i = function (t) {\n\t          console.log(\"set interval\");var i = setInterval(function () {\n\t            t.count();\n\t          }, 1e3);return function () {\n\t            clearInterval(i);\n\t          };\n\t        }(this);\n\t      } }, count: { after: function after() {\n\t        this.props.duration += 1;var i = Math.floor(this.props.duration / 60),\n\t            e = this.props.duration % 60;this.dom.time.textContent = t(i) + \":\" + t(e), this.dom[\"bar-time\"].textContent = t(i) + \":\" + t(e);\n\t      } }, ended: { after: function after() {\n\t        this.unmount();\n\t      } }, hangup: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {\n\t        this.ended();\n\t      } }, hold: { method: function method(t) {\n\t        return console.log(\"ui hold\"), t();\n\t      }, after: function after(t) {\n\t        if (t && (this.props.isHold = t.isOnHold().local), this.props.isHold) {\n\t          var i = document.createElement(\"span\"),\n\t              e = document.createElement(\"span\");for (i.classList.add(\"icon-uni37\"), e.classList.add(\"icon-uni3C\"); this.dom.hold.firstChild;) {\n\t            this.dom.hold.removeChild(this.dom.hold.firstChild);\n\t          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.disablePark(), this.disableFlip(), this.disableRecord();\n\t        } else {\n\t          var i = document.createElement(\"span\"),\n\t              e = document.createElement(\"span\");for (i.classList.add(\"icon-uni28\"), e.classList.add(\"icon-uni35\"); this.dom.hold.firstChild;) {\n\t            this.dom.hold.removeChild(this.dom.hold.firstChild);\n\t          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.enablePark(), this.enableFlip(), this.enableRecord();\n\t        }\n\t      }, error: function error(t) {\n\t        if (console.error(t), t && (this.props.isHold = t.isOnHold().local), this.props.isHold) {\n\t          var i = document.createElement(\"span\"),\n\t              e = document.createElement(\"span\");for (i.classList.add(\"icon-uni37\"), e.classList.add(\"icon-uni3C\"); this.dom.hold.firstChild;) {\n\t            this.dom.hold.removeChild(this.dom.hold.firstChild);\n\t          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.disablePark(), this.disableFlip(), this.disableRecord();\n\t        } else {\n\t          var i = document.createElement(\"span\"),\n\t              e = document.createElement(\"span\");for (i.classList.add(\"icon-uni28\"), e.classList.add(\"icon-uni35\"); this.dom.hold.firstChild;) {\n\t            this.dom.hold.removeChild(this.dom.hold.firstChild);\n\t          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.enablePark(), this.enableFlip(), this.enableRecord();\n\t        }\n\t      } }, mute: { method: function method(t) {\n\t        return console.log(\"ui mute\"), t();\n\t      }, after: function after() {\n\t        if (this.props.isMute = !this.props.isMute, this.props.isMute) {\n\t          var t = document.createElement(\"span\");for (t.classList.add(\"icon-uni7B\"); this.dom.mute.firstChild;) {\n\t            this.dom.mute.removeChild(this.dom.mute.firstChild);\n\t          }this.dom.mute.appendChild(t);\n\t        } else {\n\t          var t = document.createElement(\"span\");for (t.classList.add(\"icon-uniCE\"); this.dom.mute.firstChild;) {\n\t            this.dom.mute.removeChild(this.dom.mute.firstChild);\n\t          }this.dom.mute.appendChild(t);\n\t        }\n\t      } }, readyFlip: { method: function method(t, i) {\n\t        return this.dom[\"advance-panel\"].classList.remove(\"display-none\"), this.dom[\"contact-picker\"].classList.add(\"display-none\"), this.dom.dropdown.classList.remove(\"display-none\"), s.call(this, \"flip\"), t();\n\t      } }, flip: { method: function method(t, i) {\n\t        return console.log(\"flip: \" + i), this.props.actionNumber = i, t();\n\t      }, after: function after() {\n\t        this.dom[\"advance-panel\"].classList.add(\"display-none\");\n\t      }, error: function error(t) {\n\t        console.error(t), this.dom[\"advance-panel\"].classList.add(\"display-none\");\n\t      } }, readyTransfer: { method: function method(t, i) {\n\t        return this.dom[\"advance-panel\"].classList.remove(\"display-none\"), this.dom[\"contact-picker\"].classList.remove(\"display-none\"), this.dom.dropdown.classList.add(\"display-none\"), s.call(this, \"transfer\"), t();\n\t      } }, disableFlip: { after: function after() {\n\t        var t = document.createElement(\"span\"),\n\t            i = document.createElement(\"span\");for (t.classList.add(\"control-panel__icon--disabled\"), i.classList.add(\"control-panel__icon--disabled\"), t.classList.add(\"icon-uni34\"), i.classList.add(\"icon-uni34\"); this.dom.readyFlip.firstChild;) {\n\t          this.dom.readyFlip.removeChild(this.dom.readyFlip.firstChild);\n\t        }this.dom.readyFlip.appendChild(t), this.dom.readyFlip.appendChild(i), this.dom.readyFlip.disabled = !0;\n\t      } }, enableFlip: { after: function after() {\n\t        var t = document.createElement(\"span\"),\n\t            i = document.createElement(\"span\");for (t.classList.add(\"icon-uni27\"), i.classList.add(\"icon-uni34\"); this.dom.readyFlip.firstChild;) {\n\t          this.dom.readyFlip.removeChild(this.dom.readyFlip.firstChild);\n\t        }this.dom.readyFlip.appendChild(t), this.dom.readyFlip.appendChild(i), this.dom.readyFlip.disabled = !1;\n\t      } }, transfer: { method: function method(t, i) {\n\t        return console.log(\"transfer:\" + i), this.props.actionNumber = i, t();\n\t      }, after: function after() {\n\t        console.log(\"after transfer\"), this.dom[\"advance-panel\"].classList.add(\"display-none\");\n\t      }, error: function error(t) {\n\t        console.error(t), this.dom[\"advance-panel\"].classList.add(\"display-none\");\n\t      } }, record: { method: function method(t) {\n\t        return console.log(\"ui record\"), t();\n\t      }, after: function after() {\n\t        if (console.log(\"after record\"), this.props.isRecord = !this.props.isRecord, this.props.isRecord) {\n\t          var t = document.createElement(\"span\"),\n\t              i = document.createElement(\"span\");for (t.classList.add(\"icon-uni30\"), i.classList.add(\"icon-uni30\"); this.dom.record.firstChild;) {\n\t            this.dom.record.removeChild(this.dom.record.firstChild);\n\t          }this.dom.record.appendChild(t), this.dom.record.appendChild(i);\n\t        } else {\n\t          var t = document.createElement(\"span\"),\n\t              i = document.createElement(\"span\");for (t.classList.add(\"icon-uni24\"), i.classList.add(\"icon-Active_Call-33\"); this.dom.record.firstChild;) {\n\t            this.dom.record.removeChild(this.dom.record.firstChild);\n\t          }this.dom.record.appendChild(t), this.dom.record.appendChild(i);\n\t        }\n\t      }, error: function error(t) {\n\t        if (console.error(t), t.code === -200) {\n\t          this.props.isRecord = !0;var i = document.createElement(\"span\"),\n\t              e = document.createElement(\"span\");for (i.classList.add(\"icon-uni30\"), e.classList.add(\"icon-uni30\"); this.dom.record.firstChild;) {\n\t            this.dom.record.removeChild(this.dom.record.firstChild);\n\t          }this.dom.record.appendChild(i), this.dom.record.appendChild(e);\n\t        }\n\t      } }, disableRecord: { after: function after() {\n\t        var t = document.createElement(\"span\"),\n\t            i = document.createElement(\"span\");for (t.classList.add(\"control-panel__icon--disabled\"), i.classList.add(\"control-panel__icon--disabled\"), t.classList.add(\"icon-uni30\"), i.classList.add(\"icon-uni30\"); this.dom.record.firstChild;) {\n\t          this.dom.record.removeChild(this.dom.record.firstChild);\n\t        }this.dom.record.appendChild(t), this.dom.record.appendChild(i), this.dom.record.disabled = !0;\n\t      } }, enableRecord: { after: function after() {\n\t        var t = document.createElement(\"span\"),\n\t            i = document.createElement(\"span\");for (t.classList.add(\"icon-uni24\"), i.classList.add(\"icon-Active_Call-33\"); this.dom.record.firstChild;) {\n\t          this.dom.record.removeChild(this.dom.record.firstChild);\n\t        }this.dom.record.appendChild(t), this.dom.record.appendChild(i), this.dom.record.disabled = !1;\n\t      } }, park: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        var i = document.createElement(\"span\"),\n\t            e = document.createElement(\"span\");for (i.classList.add(\"icon-uni2E\"), e.classList.add(\"icon-uni2E\"); this.dom.park.firstChild;) {\n\t          this.dom.park.removeChild(this.dom.park.firstChild);\n\t        }this.dom.park.appendChild(i), this.dom.park.appendChild(e), this.props.isPark = !0;\n\t      }, error: function error(t) {\n\t        console.error(t), this.props.isPark = !1;\n\t      } }, disablePark: { after: function after() {\n\t        var t = document.createElement(\"span\"),\n\t            i = document.createElement(\"span\");for (t.classList.add(\"control-panel__icon--disabled\"), i.classList.add(\"control-panel__icon--disabled\"), t.classList.add(\"icon-uni2E\"), i.classList.add(\"icon-uni2E\"); this.dom.park.firstChild;) {\n\t          this.dom.park.removeChild(this.dom.park.firstChild);\n\t        }this.dom.park.appendChild(t), this.dom.park.appendChild(i), this.dom.park.disabled = !0;\n\t      } }, enablePark: { after: function after() {\n\t        var t = document.createElement(\"span\"),\n\t            i = document.createElement(\"span\");for (t.classList.add(\"icon-uni22\"), i.classList.add(\"icon-uni2E\"); this.dom.park.firstChild;) {\n\t          this.dom.park.removeChild(this.dom.park.firstChild);\n\t        }this.dom.park.appendChild(t), this.dom.park.appendChild(i), this.dom.park.disabled = !1;\n\t      } }, dtmf: { method: function method(t, i) {\n\t        return this.props.dtmfNumber = i, t();\n\t      } }, minimize: { after: function after() {\n\t        this.dom.bar.classList.remove(\"display-none\"), this.dom.header.classList.add(\"display-none\"), this.dom.content.classList.add(\"display-none\"), this.root.firstChild.style.height = \"auto\", this.props.minimized = !0;\n\t      } }, resume: { after: function after() {\n\t        this.dom.bar.classList.add(\"display-none\"), this.dom.header.classList.remove(\"display-none\"), this.dom.content.classList.remove(\"display-none\"), this.root.firstChild.style.height = this.props.height + \"px\", this.props.minimized = !1;\n\t      } }, keypad: { method: function method(t) {\n\t        this.dom[\"contral-panel\"].classList.add(\"display-none\"), this.dom[\"dialing-panel\"].classList.remove(\"display-none\"), this.dom.mask.classList.remove(\"display-none\");\n\t      } }, hideKeypad: { method: function method(t) {\n\t        this.dom[\"contral-panel\"].classList.remove(\"display-none\"), this.dom[\"dialing-panel\"].classList.add(\"display-none\"), this.dom.mask.classList.add(\"display-none\");\n\t      } }, queryContacts: { method: function method(t) {\n\t        return t();\n\t      } }, getOutboundCallerID: { method: function method(t) {\n\t        return t();\n\t      } } }, this.on(\"click\", function (t) {\n\t    var i = this;[\"hangup\", \"hold\", \"mute\", \"readyFlip\", \"readyTransfer\", \"record\", \"keypad\", \"park\"].forEach(function (e) {\n\t      if (t.target === i.dom[e] || t.target.parentNode === i.dom[e]) {\n\t        if (i.props.isHold && (\"record\" === e || \"park\" === e || \"readyFlip\" === e)) return;console.log(i.props.isHold), console.log(e), i[e]();\n\t      }\n\t    }), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].forEach(function (e) {\n\t      t.target !== i.dom[\"dial-button-\" + e] && t.target.parentNode !== i.dom[\"dial-button-\" + e] || i.dtmf(e);\n\t    }), t.target !== this.dom.bar && t.target.parentNode !== this.dom.bar || this.resume(), t.target === this.dom.mask && this.hideKeypad();\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=\"rc-panel rc-call-panel\">\n        <section data-info=header class=\"rc-panel__header rc-panel__header--center\">\n            <div>\n                <div data-info=name class=number>Number</div>\n                <span class=blink data-info=time>Dialing</span>\n            </div>\n        </section>\n        <section data-info=content class=rc-panel__content>\n            <div class=\"rc-call-panel__center control-panel\" data-info=contral-panel>\n                <div class=control-panel__line>\n                    <div class=control-panel__item>\n                        <button data-info=hold class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                            <span class=icon-uni28></span>\n                            <span class=icon-uni35></span>\n                        </button>\n                        <div class=text-center>Hold</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=keypad class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                            <span class=icon-uni21></span>\n                            <span class=icon-uni2D></span>\n                        </button>\n                        <div class=text-center>Keypad</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=record class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                            <span class=icon-uni24></span>\n                            <span class=icon-Active_Call-33></span>\n                        </button>\n                        <div class=text-center>Record</div>\n                    </div>\n                    \n                </div>\n                <div class=control-panel__line>\n                    <div class=control-panel__item>\n                        <button data-info=readyFlip class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                            <span class=icon-uni27></span>\n                            <span class=icon-uni34></span>\n                        </button>\n                        <div class=text-center>Flip</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=readyTransfer class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                            <span class=icon-uni23></span>\n                            <span class=icon-uni2F></span>\n                        </button>\n                        <div class=text-center>Transfer</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=park class=\"rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button\">\n                            <span class=icon-uni22></span>\n                            <span class=icon-uni2E></span>\n                        </button>\n                        <div class=text-center>Park</div>\n                    </div>\n                </div>\n            </div>\n            <div class=\"rc-call-panel__center dialing-panel display-none\" data-info=dialing-panel>\n                <div class=rc-dial-pad__line>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-1>\n                        <div class=dial-button__number>1</div>\n                    </button>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-2>\n                        <div class=dial-button__number>2</div>\n                        <div class=dial-button__symbol>ABC</div>\n                    </button>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-3>\n                        <div class=dial-button__number>3</div>\n                        <div class=dial-button__symbol>DEF</div>\n                    </button>\n                </div>\n                <div class=rc-dial-pad__line>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-4>\n                        <div class=dial-button__number>4</div>\n                        <div class=dial-button__symbol>GHI</div>\n                    </button>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-5>\n                        <div class=dial-button__number>5</div>\n                        <div class=dial-button__symbol>JKL</div>\n                    </button>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-6>\n                        <div class=dial-button__number>6</div>\n                        <div class=dial-button__symbol>MNO</div>\n                    </button>\n                </div>\n                <div class=rc-dial-pad__line>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-7>\n                        <div class=dial-button__number>7</div>\n                        <div class=dial-button__symbol>PQRS</div>\n                    </button>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-8>\n                        <div class=dial-button__number>8</div>\n                        <div class=dial-button__symbol>TUV</div>\n                    </button>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-9>\n                        <div class=dial-button__number>9</div>\n                        <div class=dial-button__symbol>WXYZ</div>\n                    </button>\n                </div>\n                <div class=rc-dial-pad__line>\n                    <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-0>\n                        <div class=dial-button__number>0</div>\n                        <div class=dial-button__symbol>+</div>\n                    </button>\n                </div>\n            </div>\n            <div class=\"rc-call-panel__mask display-none\" data-info=mask></div>\n            <div class=\"advance-panel display-none\" data-info=advance-panel>\n                <contact-picker data-info=contact-picker></contact-picker>\n                <dropdown class=display-none data-info=dropdown></dropdown>\n            </div>\n            <div class=rc-call-panel__footer>\n                <div class=action-panel>\n                    <button data-info=mute class=\"display-none rc-button rc-button--round action-panel__action\">\n                        <span class=icon-uniCE></span>\n                    </button>\n                    <button data-info=hangup class=\"rc-button rc-button--negative rc-button--round action-panel__action\">\n                        <span class=icon-uni44></span>\n                    </button>\n                </div>\n            </div>\n        </section>\n        <div data-info=bar class=\"bar display-none\">\n            <span data-info=bar-name class=bar__name>bar</span>\n            <span data-info=bar-time class=bar__time>00:00</span>\n        </div>\n        <video data-info=local class=display-none hidden=hidden muted></video>\n        <video data-info=remote class=display-none hidden=hidden></video>\n    </div>\n","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-call-panel {\n    background-color: #fafafa;\n}\n.rc-call-panel .rc-panel__content {\n    padding: .9em 1.1em;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: end;\n    -ms-flex-pack: end;\n    justify-content: flex-end\n}\n.rc-call-panel .rc-panel__content--min {\n    -webkit-box-pack: start;\n    -ms-flex-pack: start;\n    justify-content: flex-start;\n}\n.rc-call-panel .time-wrapper {\n    min-height: 15px;\n}\n.rc-call-panel .action-panel {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: justify;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    margin-top: 10px\n}\n.rc-call-panel .action-panel__action {\n    width: 100%;\n}\n.rc-call-panel .action-panel__action > [class*=\"icon-\"] {\n    font-size: 1.6em;\n}\n.rc-call-panel .action-panel__action--mr {\n    margin-right: 10px;\n}\n.rc-call-panel .control-panel {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center\n}\n.rc-call-panel .control-panel__title {\n    padding: .1em .3em;\n}\n.rc-call-panel .control-panel__line {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: justify;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    margin-bottom: 10px;\n}\n.rc-call-panel .control-panel__item {\n    color: #337ab7;\n}\n.rc-call-panel .control-panel__button {\n    margin-bottom: 3px;\n}\n.rc-call-panel .control-panel__button > [class*=\"icon-\"] {\n    font-size: 4em;\n}\n.rc-call-panel .control-panel__icon {}\n.rc-call-panel .control-panel__icon--disabled {\n    color: #ddd;\n}\n.rc-call-panel .bar {\n    width: 100%;\n    height: 30px;\n    background-color: #e74c3c;\n    text-align: center;\n    line-height: 2;\n    color: #fafafa;\n    cursor: pointer\n}\n.rc-call-panel .bar__name {\n    margin-right: 10px;\n}\n.rc-call-panel .dialing-panel, .rc-call-panel .advance-panel {\n    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n    position: relative;\n    z-index: 2;\n    background: #fafafa;\n}\n.rc-call-panel .dialing-panel {\n    padding: .5em .7em;\n    border-radius: 3px;\n    font-size: 1.2em;\n}\n.rc-call-panel .advance-panel {}\n.rc-call-panel .advance-panel__button {\n    position: absolute;\n    top: 12px;\n    right: 10px;\n    padding: 0;\n    width: 10px;\n    height: 10px;\n}\n.rc-call-panel .number {\n    margin-top: 10px;\n    font-size: 1.6em;\n    margin-bottom: 5px;\n}\n.rc-call-panel .blink {\n    -webkit-animation: blink-animation 1.2s linear infinite;\n    animation: blink-animation 1.2s linear infinite;\n}\n/* We need to use some element from dial pad */\n.rc-call-panel .rc-dial-pad {}\n.rc-call-panel .rc-dial-pad__line {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n}\n.rc-call-panel .rc-dial-pad__line > .dial-button {\n    margin: 4px 8px;\n    width: 3.2em;\n    height: 3.2em;\n    color: #337ab7;\n    border-color: #337ab7;\n}\n.rc-call-panel .rc-dial-pad__line > .dial-button > .dial-button__number {}\n.rc-call-panel .rc-dial-pad__line > .dial-button > .dial-button__symbol {\n    font-size: .5em;\n}\n.rc-call-panel .rc-dial-pad__line > .dial-button:hover {\n    background-color: #337ab7;\n    color: #fafafa;\n}\n.rc-call-panel__reply {\n    width: 100%;\n}\n.rc-call-panel__center {\n    /* fill out all flex panel */\n    height: 100%;\n}\n.rc-call-panel__footer {}\n.rc-call-panel__mask {\n    position: absolute;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    z-index: 1;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: #000;\n    opacity: .3;\n}\n.rc-call-panel__mask::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n@-webkit-keyframes blink-animation {\n    0% { opacity: 1; }\n    50% { opacity: .3; }\n    100% { opacity: 1; }\n}\n@keyframes blink-animation {\n    0% { opacity: 1; }\n    50% { opacity: .3; }\n    100% { opacity: 1; }\n}\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['compose-text'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = w.action(\"interaction\"), this.actions.init = { after: function after() {\n\t      var t = this;w.customize(this, \"contact-picker\", { actions: { autoComplete: { method: function method() {\n\t              return t.queryContacts(this.props.inputValue);\n\t            } } } }), w.customize(this, \"dropdown\", { actions: { getData: { method: function method() {\n\t              return t.getOutboundCallerID();\n\t            }, after: function after(t) {\n\t              var n = this;t.forEach(function (t) {\n\t                return n.addItem(t);\n\t              });\n\t            } }, switchTitle: { method: function method(n) {\n\t              t.props.fromNumber = n;\n\t            } } } });\n\t    } }, this.actions.mount = { after: function after() {\n\t      this.props.dropdown.getData();\n\t    } }, this.actions.send = { method: function method(t) {\n\t      return this.props.text = this.dom.text.value, this.props.fromNumber = this.props.dropdown.getSelected(), this.props.toNumber = this.props[\"contact-picker\"].getInput(), t();\n\t    }, after: function after(t) {\n\t      \"Sent\" === t.json().messageStatus && this.sent();\n\t    } }, this.actions.sent = { after: function after() {\n\t      this.dom.send.textContent = \"Success!\", this.dom.text.value = \"\";\n\t    } }, this.actions.readyToSend = { after: function after() {\n\t      this.dom.send.textContent = \"Send\";\n\t    } }, this.actions.getOutboundCallerID = { method: function method(t) {\n\t      return t();\n\t    } }, this.actions.queryContacts = { method: function method(t, n) {\n\t      return this.props.to = n, t();\n\t    } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=\"rc-panel rc-compose-text\">\n    <div class=\"rc-panel__header --colored\">\n        <h5 class=text-center>\n            Compose text\n        </h5>\n        <contact-picker data-info=contact-picker></contact-picker>\n        <dropdown data-info=dropdown></dropdown>\n    </div>\n    <div class=rc-panel__content>\n        <textarea class=\"rc-textarea rc-compose-text__textarea\" placeholder=\"Type any text...\" data-info=text data-event=focus:readyToSend></textarea>\n        <button class=\"rc-button --circle --positive rc-compose-text__send\" data-info=send data-event=click:send>\n            <span class=icon-uniB1></span>\n        </button>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['conference'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = { init: { method: function method() {\n\t        this.getConferenceInfo();\n\t      }, after: function after() {\n\t        var t = w.t(this.data.lang);this.dom.dialInNumberLabel.textContent = t(\"conference-dialinnumber-text\"), this.dom.hostCodeLabel.textContent = t(\"conference-hostcode-text\"), this.dom.participantCodeLabel.textContent = t(\"conference-participantcode-text\"), this.dom.inviteWithTextButton.textContent = t(\"conference-invitewithtext-text\"), this.dom.joinAsHostButton.textContent = t(\"conference-joinashost-text\");\n\t      } }, getConferenceInfo: { method: function method(t) {\n\t        var e = this;return Promise.resolve(t()).then(function (t) {\n\t          return t && (e.props.dialInNumber = t.phoneNumber), e.props.inviteMessage = \"Test\", t;\n\t        });\n\t      }, after: function after(t) {\n\t        t && (this.dom.dialInNumber.textContent = t.phoneNumber, this.dom.hostCode.textContent = t.hostCode, this.dom.participantCode.textContent = t.participantCode, this.enable());\n\t      } }, inviteWithText: { method: function method(t) {\n\t        return t();\n\t      } }, joinAsHost: { method: function method(t) {\n\t        return t();\n\t      } }, enable: { method: function method() {\n\t        this.dom.inviteWithTextButton.disabled = !1, this.dom.joinAsHostButton.disabled = !1;\n\t      } } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=\"rc-panel rc-conference --color\">\n    <div class=rc-panel__header></div>\n    <div class=\"rc-panel__content rc-conference__content\">\n        <div class=rc-conference__line>\n            <label class=\"__label --color\" data-info=dialInNumberLabel></label>\n            <div class=\"__value --right\" data-info=dialInNumber>\n            </div>\n        </div>\n        <div class=rc-conference__line>\n            <label class=\"__label --color\" data-info=hostCodeLabel></label>\n            <div class=\"__value --right\" data-info=hostCode>\n            </div>\n        </div>\n        <div class=rc-conference__line>\n            <label class=\"__label --color\" data-info=participantCodeLabel></label>\n            <div class=\"__value --right\" data-info=participantCode>\n            </div>\n        </div>\n        <div class=rc-conference__buttons>\n            <button class=\"rc-button --clean --round __button\" data-info=inviteWithTextButton data-event=click:inviteWithText disabled=disabled>\n            </button>\n            <button class=\"rc-button --positive --round __button\" data-info=joinAsHostButton data-event=click:joinAsHost disabled=disabled>\n            </button>\n        </div>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['contact-detail'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  function e(e, n) {\n\t    n.emails.forEach(function (n) {\n\t      var i = '<div class=\\'rc-contact-detail__section-line\\'>\\n                                <label class=\"__label\">Email</label>\\n                                <div class=\"__value\">\\n                                    ' + n + \"\\n                                </div>\\n                            </div>\",\n\t          t = document.createElement(\"div\");t.innerHTML = i, e.appendChild(t);\n\t    });\n\t  }function n(e, n) {\n\t    var i = '<div class=\"rc-contact-detail__section-line\">\\n                            <label class=\"__label\">Extension</label>\\n                            <div class=\"__value\">' + n.extension + \"</div>\\n                        </div>\",\n\t        t = document.createElement(\"div\");t.innerHTML = i, e.appendChild(t), n.phoneNumbers.forEach(function (n) {\n\t      i = '<div class=\"rc-contact-detail__section-line\">\\n                            <label class=\"__label\">Direct Number</label>\\n                            <div class=\"__value\">' + n + \"</div>\\n                        </div>\", t = document.createElement(\"div\"), t.innerHTML = i, e.appendChild(t);\n\t    });\n\t  }var i = w.transition(\"fade\");this.actions = { init: { method: function method(e) {\n\t        return e();\n\t      }, after: function after(t) {\n\t        t && (this.dom.displayName.textContent = t.displayName, e(this.dom.emails, t), n(this.dom.phoneNumbers, t)), i.init(this.root), i.in(this.root);\n\t      } } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=rc-contact-detail>\n    <div class=\"rc-panel__header rc-contact-detail__info\">\n        <div class=\"rc-avatar --small __avatar\"></div>\n        <div class=__name data-info=displayName>\n        </div>\n    </div>\n    <div class=rc-panel__content>\n        <section class=rc-contact-detail__section data-info=emails>\n            \n        </section>\n        <section class=rc-contact-detail__section data-info=phoneNumbers>\n        </section>\n    </div>    \n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['contact-item'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = { init: { before: function before() {\n\t        this.props.contact = null;\n\t      }, method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        this.props.contact = t, this.dom.name.textContent = t.name;\n\t      } }, select: { method: function method(t) {\n\t        return t();\n\t      } } }, this.on(\"click\", function () {\n\t    this.select();\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=rc-contact-item data-event=click:select>\n        <a class=rc-contact-item__body>\n            <span class=__contact data-info=name></span>\n        </a>\n    </div>\n","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['contact-picker-item'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.props = { contact: null, hovered: !1, focused: !1 }, this.actions = { init: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        this.props.contact = t, this.dom.name.textContent = t.name, this.dom.value.textContent = t.value;\n\t      } }, select: { method: function method(t) {\n\t        return t();\n\t      } }, hover: { after: function after(t) {\n\t        t ? this.root.firstChild.classList.add(\"hover\") : this.root.firstChild.classList.remove(\"hover\"), this.props.hovered = t;\n\t      } }, focus: { after: function after(t) {\n\t        t ? this.root.firstChild.classList.add(\"rc-contact--focus\") : this.root.firstChild.classList.remove(\"rc-contact--focus\"), this.props.focused = t;\n\t      } } }, this.on(\"click\", function (t) {\n\t    this.select();\n\t  }), this.on(\"mouseover\", function (t) {\n\t    this.hover(!0);\n\t  }), this.on(\"mouseout\", function (t) {\n\t    this.hover(!1);\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=\"rc-contact rc-list__item\" data-event=click:select>\n    <div class=rc-contact__name data-info=name></div>\n    <div class=rc-contact__value data-info=value></div>\n</div>","style":"\n    .rc-contact {\n    }\n.rc-contact--focus {\n    background: #64B5F6\n}\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['contact-picker'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction _interopRequireDefault(t) {\n\t  return t && t.__esModule ? t : { default: t };\n\t}function _readyAC() {\n\t  var t = this;return this.props.show ? void this.autoComplete() : (timeout && (clearTimeout(timeout), timeout = !1), void (timeout = setTimeout(function () {\n\t    t.autoComplete();\n\t  }, 500)));\n\t}var _leopard = __webpack_require__(2),\n\t    _leopard2 = _interopRequireDefault(_leopard),\n\t    timeout;w.register(function () {\n\t  var t = w.transition(\"enter\"),\n\t      o = w.transition(\"fade\");this.props = { limit: 10, show: !1, whiteList: null, contacts: [] }, this.actions = { init: { method: function method(t) {\n\t        var o = this;return this.data.whiteList && (this.props.whiteList = this.data.whiteList.slice()), document.addEventListener(\"click\", function (t) {\n\t          for (var i = t.target; i.parentNode;) {\n\t            if (i === o.root || o.props.whiteList && o.props.whiteList.indexOf(i) > -1) return;i = i.parentNode;\n\t          }o.hide();\n\t        }), t();\n\t      } }, mount: { method: function method(t) {\n\t        t();\n\t      }, after: function after() {\n\t        t.init(this.dom.contacts), o.init(this.dom.contacts), this.dom.contacts.transition = \"\\n                transform .25s cubic-bezier(0.4, 0.0, 0.2, 1),\\n                opacity .08s cubic-bezier(0.4, 0.0, 0.2, 1)\\n                \", this.data.contact && (this.dom.input.value = this.data.contact);\n\t      } }, hide: { after: function after() {\n\t        var i = this;this.props.show && setTimeout(function () {\n\t          i.props.show = !1, console.log(\"out\"), t.out(i.dom.contacts), o.out(i.dom.contacts);\n\t        }, 50);\n\t      } }, show: { after: function after() {\n\t        this.props.show || (this.props.show = !0, t.in(this.dom.contacts), o.in(this.dom.contacts));\n\t      } }, getInput: { method: function method() {\n\t        return this.dom.input.value;\n\t      } }, appendInput: { before: function before(t) {\n\t        this.dom.input.value += t, this.dom.input.focus();\n\t      } }, setInput: { before: function before(t) {\n\t        this.dom.input.value = t, this.dom.input.focus(), this.props.input = t;\n\t      } }, disable: { method: function method() {\n\t        this.dom.input.readOnly = !0;\n\t      } }, focus: { method: function method() {\n\t        this.dom.input.focus();\n\t      } }, autoComplete: { before: function before() {\n\t        _leopard2.default.stop();\n\t      }, method: function method(t) {\n\t        return this.props.inputValue = this.dom.input.value, t();\n\t      }, after: function after(t) {\n\t        var o = this;if (_leopard2.default.stop(), t) {\n\t          for (; this.dom.contacts.firstChild;) {\n\t            this.dom.contacts.removeChild(this.dom.contacts.firstChild);\n\t          }t.length > 0 ? this.show() : this.hide(), this.props.contacts.length = 0;var i = this;this.props.limit;_leopard2.default.start({ autoStop: !0, strategy: \"batch\", limit: 1e3 }), t.forEach(function (t) {\n\t            _leopard2.default.put(1, function () {\n\t              var n = w(\"contact-picker-item\", { actions: { init: { method: function method() {\n\t                      return t;\n\t                    } }, select: { method: function method() {\n\t                      i.setInput(this.props.contact.value), i.hide();\n\t                    } }, hover: { before: function before(t) {\n\t                      t && i.props.contacts.forEach(function (t) {\n\t                        t.props.focused && t.focus(!1), t.props.hovered && t.hover(!1);\n\t                      });\n\t                    } }, focus: { before: function before(t) {\n\t                      t && i.props.contacts.forEach(function (t) {\n\t                        t.props.focused && t.focus(!1), t.props.hovered && t.hover(!1);\n\t                      });\n\t                    } } } });n.mount(o.dom.contacts), o.props.contacts.push(n);\n\t            });\n\t          });\n\t        }\n\t      } } }, this.on(\"input\", \"input\", function (t) {\n\t    console.log(\"input\"), this.setInput(this.dom.input.value), \"\" === this.dom.input.value ? this.hide() : _readyAC.call(this);\n\t  }), this.on(\"keydown\", \"input\", function (t) {\n\t    if (38 === t.keyCode) {\n\t      t.preventDefault();var o = this.props.contacts.findIndex(function (t) {\n\t        return t.props.hovered;\n\t      });o === -1 && (o = this.props.contacts.findIndex(function (t) {\n\t        return t.props.focused;\n\t      })), o === -1 && (o = 0);var i = this.props.contacts[o];0 === o && (o = this.props.contacts.length), this.props.contacts[o - 1].focus(!0);\n\t    } else if (40 === t.keyCode) {\n\t      t.preventDefault();var o = this.props.contacts.findIndex(function (t) {\n\t        return t.props.hovered;\n\t      });o === -1 && (o = this.props.contacts.findIndex(function (t) {\n\t        return t.props.focused;\n\t      })), o === -1 && (o = 0);var i = this.props.contacts[o];o === this.props.contacts.length - 1 && (o = -1), this.props.contacts[o + 1].focus(!0);\n\t    } else if (13 === t.keyCode) {\n\t      t.preventDefault();var o = this.props.contacts.findIndex(function (t) {\n\t        return t.props.hovered;\n\t      });o === -1 && (o = this.props.contacts.findIndex(function (t) {\n\t        return t.props.focused;\n\t      })), o === -1 && (o = 0);var i = this.props.contacts[o];i && this.setInput(i.props.contact.value), this.hide();\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar Emitter = function Emitter() {\n\t  this.uid = 0;\n\t  this.handlers = [];\n\t  for (var i = 0; i < 1000; i++) {\n\t    this.handlers.push([]);\n\t  }\n\t};\n\tEmitter.prototype.on = function (level, callback) {\n\t  this.handlers[level].push({\n\t    id: this.uid++,\n\t    action: callback\n\t  });\n\t};\n\tEmitter.prototype.emit = function (level) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  this.handlers[level].forEach(function (handler) {\n\t    if (typeof handler.action === 'function') handler.action.apply(handler, args);\n\t  });\n\t};\n\tEmitter.prototype.once = function (level, callback) {\n\t  var _this = this;\n\t\n\t  var id = this.uid;\n\t  this.on(level, function () {\n\t    callback.apply(undefined, arguments);\n\t    var handler = _this.handlers[level].find(function (handler) {\n\t      return handler.id === id;\n\t    });\n\t    _this.handlers[level].splice(_this.handlers[level].indexOf(handler), 1);\n\t    // delete handler\n\t  });\n\t};\n\tvar singletonEmitter = new Emitter()\n\t\n\t// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\t\n\t// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n\t\n\t// MIT license\n\t\n\t;(function () {\n\t  var lastTime = 0;\n\t  var vendors = ['ms', 'moz', 'webkit', 'o'];\n\t  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n\t    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n\t    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n\t  }\n\t\n\t  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n\t    var currTime = new Date().getTime();\n\t    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t    var id = window.setTimeout(function () {\n\t      callback(currTime + timeToCall);\n\t    }, timeToCall);\n\t    lastTime = currTime + timeToCall;\n\t    return id;\n\t  };\n\t  /* istanbul ignore if */\n\t  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n\t    clearTimeout(id);\n\t  };\n\t})();\n\t\n\t// @license http://opensource.org/licenses/MIT\n\t// copyright Paul Irish 2015\n\t\n\t// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n\t//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n\t// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\t\n\t// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n\t// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\t\n\t(function () {\n\t\n\t  if ('performance' in window == false) {\n\t    window.performance = {};\n\t  }\n\t  /* istanbul ignore next */\n\t  Date.now = Date.now || function () {\n\t    // thanks IE8\n\t    return new Date().getTime();\n\t  };\n\t\n\t  if ('now' in window.performance == false) {\n\t\n\t    var nowOffset = Date.now();\n\t    /* istanbul ignore next */\n\t    if (window.performance.timing && window.performance.timing.navigationStart) {\n\t      nowOffset = window.performance.timing.navigationStart;\n\t    }\n\t\n\t    window.performance.now = function now() {\n\t      return Date.now() - nowOffset;\n\t    };\n\t  }\n\t})();\n\t\n\tvar queue = [];\n\tvar counter = 0;\n\tvar levels = 1000;\n\t\n\tfor (var i = 0; i < levels; i++) {\n\t  queue.push([]);\n\t}function run(count) {\n\t  for (var i = 0; i < queue.length; i++) {\n\t    if (count < 1) break;\n\t    var level = queue[i];\n\t    while (level.length) {\n\t      if (count < 1) break;\n\t      counter--;\n\t      // the bigger of level, the less emergent to complete\n\t      // So we deduce more for higher level (lower priority) actions\n\t      count--;\n\t      var callback = level.shift();\n\t      if (callback && typeof callback === 'function') callback();\n\t      if (!level.length) {\n\t        singletonEmitter.emit(i);\n\t      }\n\t    }\n\t    /* istanbul ignore if */\n\t    if (i === queue.length - 1 && counter === 0) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\tfunction enqueue(priority, callback, times) {\n\t  if (!times) {\n\t    queue[priority].push(callback);\n\t    counter++;\n\t  } else {\n\t    while (times--) {\n\t      queue[priority].push(callback);\n\t      counter++;\n\t    }\n\t  }\n\t}\n\tfunction flush() {\n\t  for (var _i = 0; _i < levels; _i++) {\n\t    queue[_i].length = 0;\n\t  }counter = 0;\n\t}\n\t\n\tvar perFrame = 16;\n\t\n\t// options\n\tvar expectedFrame = perFrame;\n\tvar limit = 1000;\n\tvar count = limit;\n\tvar strategy = 'normal';\n\tvar perf = 2;\n\tvar autoStop = false;\n\t\n\tvar isRunning = false;\n\tvar accelerate = 1; // for slow start\n\t\n\tvar scriptStart;\n\tvar scriptEnd;\n\tvar styleStart;\n\tvar styleEnd;\n\t\n\tvar styleDuration;\n\tvar scriptDuration;\n\t\n\tfunction frame(frameStart) {\n\t  if (!isRunning) return;\n\t  // calculate metrix\n\t  styleEnd = frameStart;\n\t  styleDuration = styleStart ? styleEnd - styleStart : expectedFrame;\n\t  scriptDuration = scriptEnd - scriptStart;\n\t\n\t  var inc = true;\n\t  var dec = true;\n\t  // calculate limit\n\t  if (strategy === 'batch') {\n\t    // will try to batch up all update\n\t    inc = scriptDuration < expectedFrame + 1;\n\t    dec = scriptDuration >= expectedFrame + 1;\n\t  } else {\n\t    inc = styleDuration >= expectedFrame && styleDuration < expectedFrame + 1 && styleDuration !== 0;\n\t    dec = styleDuration >= expectedFrame + 1;\n\t  }\n\t  if (inc) {\n\t    accelerate = accelerate * perf;\n\t    count += accelerate;\n\t  } else if (dec) {\n\t    accelerate = 1;\n\t    count = Math.floor(count / 2);\n\t    /* istanbul ignore next */\n\t  } else if (styleDuration === 0) {\n\t      // This is a skipped frame\n\t    }\n\t  if (count < 1) count = 1;\n\t  scriptStart = window.performance.now();\n\t  var continueRun = run(count);\n\t  if (!continueRun && autoStop) return;\n\t  scriptEnd = window.performance.now();\n\t  styleStart = frameStart;\n\t\n\t  window.requestAnimationFrame(frame);\n\t  if (window && window.requestIdleCallback) {\n\t    // For browsers which support requestIdleCallback\n\t    /* istanbul ignore next */\n\t    window.requestIdleCallback(function (deadline) {\n\t      if (deadline.timeRemaining() > 0) {\n\t        var ratio = deadline.timeRemaining() / perFrame;\n\t        run(Math.floor(count * ratio));\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tfunction stop() {\n\t  accelerate = 1; // for slow start\n\t  count = limit;\n\t  isRunning = false;\n\t  flush();\n\t}\n\tfunction start() {\n\t  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t  if (!isRunning) window.requestAnimationFrame(frame);\n\t  options.limit && (limit = count = options.limit);\n\t  options.expectedFrame && (expectedFrame = options.expectedFrame);\n\t  options.strategy && (strategy = options.strategy);\n\t  options.perf && (perf = options.perf);\n\t  options.autoStop && (autoStop = options.autoStop);\n\t  scriptStart = null;\n\t  scriptEnd = null;\n\t  styleStart = null;\n\t  styleEnd = null;\n\t  isRunning = true;\n\t}\n\tfunction put(priority, callback, times) {\n\t  enqueue(priority, callback, times);\n\t}\n\tfunction getCount() {\n\t  return count;\n\t}\n\t\n\tvar Leopard = {\n\t  on: singletonEmitter.on.bind(singletonEmitter),\n\t  once: singletonEmitter.once.bind(singletonEmitter),\n\t  start: start,\n\t  stop: stop,\n\t  put: put,\n\t  get limit() {\n\t    return getCount();\n\t  }\n\t};\n\t\n\tif (( false ? 'undefined' : _typeof(exports)) === 'object') module.exports = Leopard;else if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  return Leopard;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else window.Leopard = Leopard;\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=rc-contact-picker>\n    <input class=\"rc-input rc-input--clean\" data-info=input placeholder=\"\">\n    \n    <div class=\"rc-contact-picker__contacts rc-list\" data-info=contacts>\n        <contact-picker-item dynamic></contact-picker-item>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['contacts'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  function t(t, n) {\n\t    return w(\"contact-item\", { actions: { init: { method: function method() {\n\t            return n;\n\t          } }, select: { method: function method() {\n\t            t.selectContact(this.props.contact);\n\t          } } } });\n\t  }this.data = { loadingContacts: 30, searchBox: !0 }, this.actions = { init: { before: function before() {\n\t        this.props.selectedContact = null, this.props.contactItemWidgets = [], this.props.currentIndex = 0;\n\t      }, after: function after() {\n\t        \"undefined\" == typeof this.data.searchBox || this.data.searchBox || this.dom.header.classList.add(\"display-none\");\n\t      } }, fetchContacts: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(n) {\n\t        var o = this;this.props.contactItemWidgets.length > 0 || (n.forEach(function (n) {\n\t          var e = t(o, n);o.props.contactItemWidgets.push(e);\n\t        }), this.displayContacts(this.props.currentIndex));\n\t      } }, displayContacts: { method: function method(t, n) {\n\t        var o = this;return this.props.contactItemWidgets.slice(n, n + this.data.loadingContacts).forEach(function (t) {\n\t          return t.mount(o.dom.contacts);\n\t        }), this.props.currentIndex = n + this.data.loadingContacts, t();\n\t      }, after: function after() {}, error: function error(t) {\n\t        console.error(t);\n\t      } }, fetchRelatedContact: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {\n\t        this.pinContacts();\n\t      } }, pinContacts: { method: function method() {\n\t        var n = this;Object.keys(this.props.relateContacts).filter(function (t) {\n\t          var o = n.props.contactItemWidgets.filter(function (o) {\n\t            var e = o.props.contact.id == t;return e && o.mount(n.dom[\"pin-contacts\"]), e;\n\t          });return 0 === o.length;\n\t        }).forEach(function (o) {\n\t          var e = n.props.relateContacts[o];e.name = e.displayName, t(n, e).mount(n.dom[\"pin-contacts\"]);\n\t        });\n\t      } }, search: { method: function method() {\n\t        var t = this,\n\t            n = this.dom.searchText.value;this.props.contactItemWidgets.forEach(function (o) {\n\t          o.props.contact.name.toLowerCase().indexOf(n.toLowerCase()) > -1 ? o.mount(t.dom.contacts) : o.unmount();\n\t        });\n\t      } }, selectContact: { method: function method(t, n) {\n\t        return this.props.selectedContact = n, t();\n\t      } }, input: { method: function method(t, n) {\n\t        \"searchText\" === n.target && this.search();\n\t      } }, reachBottom: { before: function before() {}, method: function method(t) {\n\t        return t();\n\t      }, after: function after() {\n\t        var t = this.dom.contacts.offsetHeight;this.displayContacts(this.props.currentIndex), this.dom.container.scrollTop = this.dom.contacts.offsetHeight - t;\n\t      } }, focus: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {} } }, this.on(\"click\", \"searchText\", function (t) {\n\t    this.focus();\n\t  }), this.on(\"scroll\", \"container\", function (t) {\n\t    t.target.scrollHeight - t.target.scrollTop < t.target.offsetHeight + 10 && this.reachBottom();\n\t  }), this.on(\"input\", \"searchText\", function (t) {\n\t    this.search();\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=rc-panel>\n        <div class=\"rc-panel__header --flat\" data-info=header>\n            <div data-info=search-box class=rc-contacts__searchBox>\n                <input class=__input type=text data-info=searchText>\n            </div>\n        </div>\n        <div class=rc-panel__content data-info=container>\n            <div class=rc-contacts__list>\n                <div data-info=pin-contacts class=rc-contacts__pins>\n                </div>\n                <div data-info=contacts>\n                    <contact-item dynamic></contact-item>\n                </div>\n            </div>\n        </div>\n    </div>\n","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['conversation-advanced'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  function t(t) {\n\t    return t < 10 ? \"0\" + t : t;\n\t  }var e = (w.transition(\"fade\"), 0);this.props = { syncedMessages: [], toNumbers: [], toNumber: null, toExt: null, fromNumbers: [], fromNumber: null, fromExt: null, width: 250, height: 400, profileImage: null, remoteVideo: null, localVideo: null, originalLoadingPeriod: 72, loadingPeriod: 72, limitOfRetry: 3 }, this.actions = { init: { method: function method() {}, after: function after() {\n\t        var t = this;this.props.syncedMessages = [], this.props.toNumbers = [], this.data.toNumber && (this.props.toNumber = this.data.toNumber), this.data.toExt && (this.props.toExt = this.data.toExt), this.data.fromExt && (this.props.fromExt = this.data.fromExt), this.data.fromNumber && (this.props.fromNumber = this.data.fromNumber), this.data.fromNumbers && (this.props.fromNumbers = this.data.fromNumbers), this.data.width && (this.props.width = this.data.width), this.data.height && (this.props.height = this.data.height), this.data.remoteVideo && (this.props.remoteVideo = this.data.remoteVideo), this.data.localVideo && (this.props.localVideo = this.data.localVideo), this.props.files = this.dom.files, this.props.files.addEventListener(\"change\", function (e) {\n\t          t.props.files = t.dom.files.files, t.sendFax();\n\t        }), this.root.firstChild.style.width = this.props.width + \"px\", this.root.firstChild.style.height = this.props.height + \"px\", this.dom.panel.style.opacity = 0, this.dom.panel.style.transition = \"opacity .1s cubic-bezier(0.4, 0.0, 0.2, 1)\";var e = this;w.customize(this, \"dropdown\", { data: {}, actions: { mount: { after: function after() {} }, getData: { method: function method() {\n\t                return e.getOutboundCallerID();\n\t              }, after: function after(t) {\n\t                var e = this;t.forEach(function (t) {\n\t                  return e.addItem(t);\n\t                });\n\t              } } } });\n\t      } }, mount: { method: function method(t) {\n\t        var e = this,\n\t            o = this.props.contact = this.data.contact;o.msg && this.appendMessages(o.msg), this.scrollToAnchor(), this.setTitle(o.displayName), this.props.profileImage = o.profileImage, this.getAvatar().then(function (t) {\n\t          return e.dom[\"profile-img\"].src = t;\n\t        });\n\t      }, after: function after() {\n\t        var t = this;this.dom.input.value = this.data.message || \"\", requestAnimationFrame(function () {\n\t          return t.dom.input.focus();\n\t        }), setTimeout(function () {\n\t          return t.dom.panel.style.opacity = 1;\n\t        }, 125);\n\t      } }, unmount: { after: function after() {\n\t        e = 0;\n\t      } }, setTitle: { after: function after(t) {\n\t        this.dom.header.textContent = t;\n\t      } }, send: { before: function before() {\n\t        console.log(this.props.fromExt), console.log(this.props.toExt), this.props.message = this.dom.input.value, this.dom.input.value = \"\";var t = new Date(),\n\t            e = this.addBubble(null, \"SMS\", this.props.message, \"Outgoing\", t.getHours() + \":\" + t.getMinutes() + \":\" + t.getSeconds());return this.scrollToBottom(), e;\n\t      }, method: function method(t, e) {\n\t        var o = this;return this.props.fromNumber = this.data.fromNumber || this.props.fromNumber, this.props.toNumber = this.data.toNumber || this.props.toNumber, t().then(function (t) {\n\t          return e.setAttribute(\"data-id\", t.id), o.unconfirm = o.unconfirm || [], o.unconfirm.push(e), t;\n\t        }).catch(function (t) {\n\t          return e.parentNode.removeChild(e);\n\t        });\n\t      }, after: function after(t) {} }, sendFax: { before: function before() {}, method: function method(t) {\n\t        var e = !1;return Array.from(this.props.files).forEach(function (t) {\n\t          console.log(t), t.size > 10485760 && (e = !0);\n\t        }), e ? this.showErrorMessage(\"The file you have selected is too large. The maximum size is 10MB.\") : t();\n\t      } }, showErrorMessage: { before: function before(t) {\n\t        this.dom[\"error-mask\"].classList.remove(\"display-none\"), this.dom[\"error-message\"].textContent = t;\n\t      } }, hideErrorMessage: { before: function before() {\n\t        this.dom[\"error-mask\"].classList.add(\"display-none\"), this.dom[\"error-message\"].textContent = \"\";\n\t      } }, addBubble: { after: function after(t, e, o, n, i, s) {\n\t        var r,\n\t            a = \"Inbound\" === n,\n\t            c = this.props.contact.msg && this.props.contact.msg.find(function (e) {\n\t          return e.id === t;\n\t        });return \"SMS\" === e || \"Pager\" === e ? r = this.createSMSTemplate(t, o, a, i) : \"VoiceMail\" === e ? r = this.createVoiceMailTemplate(t, o, a, i) : \"Voice\" === e ? r = this.createCallLogTemplate(t, o, a, i) : \"Fax\" === e && (r = this.createFaxTemplate(t, o, a, i)), c && (c.dom = r), s ? this.dom.conversations.insertBefore(r, this.dom.conversations.firstChild) : this.dom.conversations.appendChild(r), this.dom.conversations.lastChild;\n\t      } }, markBubble: { method: function method(t, e) {\n\t        var o = this;e.dom.addEventListener(\"mouseover\", function (t) {\n\t          if (o.props.fromNumbers) {\n\t            var n = e.from,\n\t                i = e.to;o.props.contact.extension == n || o.props.fromNumbers.indexOf(n) > -1 ? (o.dom[\"from-number\"].textContent = n, o.dom[\"to-number\"].textContent = i) : (o.dom[\"from-number\"].textContent = i, o.dom[\"to-number\"].textContent = n), o.props.contact.msg.filter(function (t) {\n\t              return t.from == n || t.from == i || t.to == i || t.to == n;\n\t            }).filter(function (t) {\n\t              return t.dom;\n\t            }).map(function (t) {\n\t              return t.dom;\n\t            }).map(function (t) {\n\t              t.classList.add(\"conversations__conv--marked\"), t.previousSibling && t.previousSibling.classList && t.previousSibling.classList.contains(\"conversations__conv--ts\") && t.previousSibling.classList.add(\"conversations__conv--marked\");\n\t            });\n\t          }\n\t        }), e.dom.addEventListener(\"mouseout\", function (t) {\n\t          if (o.props.fromNumbers) {\n\t            var n = e.from,\n\t                i = e.to;o.props.contact.extension == n || o.props.fromNumbers.indexOf(n) > -1 ? (o.dom[\"from-number\"].textContent = n, o.dom[\"to-number\"].textContent = i) : (o.dom[\"from-number\"].textContent = i, o.dom[\"to-number\"].textContent = n), o.props.contact.msg.filter(function (t) {\n\t              return t.dom;\n\t            }).map(function (t) {\n\t              return t.dom;\n\t            }).map(function (t) {\n\t              t.classList.remove(\"conversations__conv--marked\"), t.previousSibling && t.previousSibling.classList && t.previousSibling.classList.contains(\"conversations__conv--marked\") && t.previousSibling.classList.remove(\"conversations__conv--marked\");\n\t            });\n\t          }\n\t        });\n\t      } }, createSMSTemplate: { method: function method(t, e, o, n, i) {\n\t        var s = document.createElement(\"div\");return s.innerHTML = \"<div class='clearfix conversations__conv'>\\n                                <div\\n                                    data-tooltip='\" + i + \"' \\n                                    class='conversations__bubble \" + (n ? \"conversations__bubble--opponent\" : \"conversations__bubble--self\") + \" '>\\n                                    \" + o + \"\\n                                </div>\\n                            </div>\", s.firstChild;\n\t      } }, createFaxTemplate: { method: function method(t, e, o, n, i) {\n\t        if (\"Outgoing Fax\" !== o) {\n\t          this.props.transformee = o.uri;var s = document.createElement(\"div\");return s.innerHTML = \"<div class='clearfix conversations__conv'>\\n                                <div\\n                                    data-tooltip='\" + i + \"'\\n                                    class='conversations__bubble \" + (n ? \"conversations__bubble--opponent\" : \"conversations__bubble--self\") + \" --voice voice-bubble'>\\n\\n                                    <a target=\\\"_blank\\\" href='\" + this.transformURL() + \"'>\\n                                        <span class='icon-uniCB'></span>\\n                                    </a>\\n                                </div>\\n                            </div>\", s.firstChild;\n\t        }\n\t      } }, createVoiceMailTemplate: { method: function method(t, e, o, n, i) {\n\t        var s = this,\n\t            r = null,\n\t            a = (this.transformURL(), document.createElement(\"div\"));a.innerHTML = \"<div class='clearfix conversations__conv'>\\n                                <div\\n                                    data-tooltip='\" + i + \"'\\n                                    class=' conversations__bubble \\n                                            \" + (n ? \"conversations__bubble--opponent\" : \"conversations__bubble--self\") + \" \\n                                            conversations__bubble--voice \\n                                            voice-bubble'>\\n                                    <span class='voice-bubble__play icon-uniA5'></span>\\n                                    <span class='voice-bubble__duration'>\" + o.vmDuration + \" s</span>\\n                                </div>\\n                            </div>\";var c = a.firstChild.querySelector(\".voice-bubble\"),\n\t            d = 1;2 * o.vmDuration > 167 ? d = 2 * o.vmDuration / 167 : 2 * o.vmDuration < 65 && (d = 2 * o.vmDuration / 65);var u = 2 * o.vmDuration / d,\n\t            m = !1;return c.style.width = u + \"px\", c.addEventListener(\"click\", function (t) {\n\t          r || (s.props.transformee = o.uri, r = new Audio(s.transformURL()));var e;m ? r.pause() : r.play(), r.addEventListener(\"pause\", function (t) {\n\t            m = !1;\n\t          }), r.addEventListener(\"playing\", function (t) {\n\t            m = !0, e = requestAnimationFrame(function t() {\n\t              if (m) {\n\t                var e = 2 * r.currentTime / d;c.style.background = \"linear-gradient( 90deg, #eee \" + e + \"px, white \" + e + \"px, white )\", requestAnimationFrame(t);\n\t              }\n\t            });\n\t          });\n\t        }), a.firstChild;\n\t      } }, createCallLogTemplate: { method: function method(t, e, o, n, i) {\n\t        var s = this,\n\t            r = document.createElement(\"div\");if (\"string\" == typeof o) r.innerHTML = \"<div class='clearfix conversations__conv'>\\n                                    <div\\n                                        data-tooltip='\" + i + \"'\\n                                        class='conversations__bubble \" + (n ? \"conversations__bubble--opponent\" : \"conversations__bubble--self\") + \" \\n                                            conversations__bubble--log'>\\n                                        <span class='bubble--log icon-uniAE'>\\n                                        <span>\" + o + \"</span>\\n                                    </div>\\n                                </div>\", r = r.firstChild;else {\n\t          r.innerHTML = \"<div class='clearfix conversations__conv'>\\n                                    <div\\n                                        data-tooltip='\" + i + \"'\\n                                        class='conversations__bubble \" + (n ? \"conversations__bubble--opponent\" : \"conversations__bubble--self\") + \" \\n                                            conversations__bubble--log'>\\n                                        <span class='bubble--log icon-uniAE'>\\n                                        <span>Phone Call</span>\\n                                    </div>\\n                                </div>\", this.props.fileURL = o.uri;this.getFileInfo().then(function (t) {\n\t            if (t.duration && 0 != t.duration) {\n\t              t.vmDuration = t.duration, t.uri = t.contentUri;var o = s.createVoiceMailTemplate(e, t, n, i);r.innerHTML = \"\", r.appendChild(o);\n\t            }\n\t          }).catch(function (t) {\n\t            return console.error(t);\n\t          });r.addEventListener(\"click\", function (t) {\n\t            s.props.transformee = o.contentUri;var e = new Audio(s.transformURL());e.play();\n\t          });\n\t        }return r;\n\t      } }, reachTop: { before: function before() {}, method: function method(t) {\n\t        return !this.isLoading && (this.isLoading = !0, this.dom.loading.classList.remove(\"display-none\"), t());\n\t      }, after: function after(t) {\n\t        if (t && (this.isLoading = !1, this.dom.loading.classList.add(\"display-none\")), t && t.length) {\n\t          var o = this.dom.conversations.offsetHeight - this.dom.container.scrollTop;this.prependMessages(t.slice().reverse(), !1), this.dom.container.scrollTop = this.dom.conversations.offsetHeight - o, e = 0, this.props.loadingPeriod = this.props.originalLoadingPeriod;\n\t        } else if (t && !t.length) {\n\t          if (e++ > this.props.limitOfRetry) return;this.props.loadingPeriod *= 10, this.reachTop();\n\t        }\n\t      } }, addTimestamp: { method: function method(t, e, o) {\n\t        var n = document.createElement(\"div\");n.innerHTML = \"<div class='clearfix conversations__conv conversations__conv--ts'>\\n                                <div class='timestamp'>\\n                                    \" + e + \"\\n                                </div>\\n                            </div>\", o ? this.dom.conversations.insertBefore(n.firstChild, this.dom.conversations.firstChild) : this.dom.conversations.appendChild(n.firstChild);\n\t      } }, parseMessages: { method: function method(e, o, n) {\n\t        var i = this;o.map(function (e) {\n\t          var o = new Date(e.time);return e.displayTime = (\"\\n                    \" + t(o.getHours()) + \":\\n                    \" + t(o.getMinutes()) + \":\\n                    \" + t(o.getSeconds()) + \"\\n                    \").trim(), e.status.sendConfirmed = !0, e.status.receiveConfirmed = !0, e;\n\t        }).filter(function (t) {\n\t          return \"Outgoing Fax\" !== t.subject;\n\t        }).forEach(function (t) {\n\t          i.addBubble(t.id, t.type, t.subject, t.direction, t.displayTime, n);var e = new Date(t.time),\n\t              o = e.getDate(),\n\t              s = e.getMonth() + 1;(!n && o > i.props.convDate && s >= i.props.convMonth || n && o < i.props.convDate && s <= i.props.convMonth) && i.addTimestamp(s + \"/\" + o, n), i.props.convDate = o, i.props.convMonth = s;\n\t        });\n\t      } }, appendMessages: { method: function method(t, e, o) {\n\t        e && this.parseMessages(e, !1);\n\t      }, after: function after(t) {\n\t        var e = arguments.length <= 1 || void 0 === arguments[1] || arguments[1];e && this.scrollToBottom();\n\t      } }, prependMessages: { before: function before() {}, method: function method(t, e, o) {\n\t        this.props.contact.msg = this.props.contact.msg || [], e && this.parseMessages(e, !0);\n\t      }, after: function after(t) {\n\t        var e = arguments.length <= 1 || void 0 === arguments[1] || arguments[1];e && this.scrollToBottom();\n\t      } }, addIncomingMessages: { method: function method(t) {\n\t        var e = this;this.props.contact.msg = this.props.contact.msg || [], this.parseMessages(this.props.contact.msg.filter(function (t) {\n\t          return !t.status.receiveConfirmed;\n\t        }).filter(function (t) {\n\t          return e.props.syncedMessages.indexOf(t.id) === -1;\n\t        }).map(function (t) {\n\t          return e.props.syncedMessages.push(t.id), t;\n\t        }).filter(function (t) {\n\t          return \"Inbound\" === t.direction;\n\t        }), !1);\n\t      }, after: function after() {\n\t        this.scrollToBottom();\n\t      } }, confirmMessages: { method: function method(t) {\n\t        var e = this;return this.unconfirm ? (this.props.contact.msg = this.props.contact.msg || [], this.props.contact.msg.filter(function (t) {\n\t          return !t.status.sendConfirmed;\n\t        }).map(function (t) {\n\t          var o = e.unconfirm.findIndex(function (e) {\n\t            return e.getAttribute(\"data-id\") == t.id;\n\t          }),\n\t              n = e.unconfirm[o] || null;return n && (n.removeAttribute(\"data-id\"), t.dom = n, t.status.sendConfirmed = !0, e.unconfirm.splice(o, 1)), n;\n\t        })) : [];\n\t      } }, getAvatar: { method: function method(t) {\n\t        return t();\n\t      } }, transformURL: { method: function method(t) {\n\t        return t();\n\t      } }, getFileInfo: { method: function method(t) {\n\t        return t();\n\t      } }, scrollToAnchor: { after: function after() {\n\t        var t,\n\t            e = this;this.data.anchorContent && (t = this.props.contact.msg.find(function (t) {\n\t          return t.id == e.data.anchorContent.id;\n\t        })) && t.dom && (this.dom.container.scrollTop = t.dom.offsetTop - t.dom.offsetHeight);\n\t      } }, warnBubble: { after: function after(t) {} }, scrollToBottom: { after: function after() {\n\t        this.dom.container.scrollTop = this.dom.container.scrollHeight;\n\t      } }, setOutboundCallerID: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        this.props.fromNumber || this.setSender(t[0]), this.setSenderCandidates(t);\n\t      } }, queryContacts: { method: function method(t, e) {\n\t        return this.props.to = e, t();\n\t      } }, setSender: { method: function method(t, e) {\n\t        this.props.fromNumber = e;\n\t      } }, setSenderCandidates: { method: function method(t, e) {\n\t        this.props.fromNumbers = e;\n\t      } }, setReceiver: { method: function method(t, e) {\n\t        console.log(e), this.props.toNumber = e;\n\t      } }, setReceiverCandidates: { method: function method(t, e) {\n\t        console.log(e), this.props.toNumbers = e;\n\t      } }, callout: { method: function method(t) {\n\t        return t();\n\t      } }, back: { after: function after() {} } }, this.on(\"click\", function (t) {\n\t    t.target === this.dom.back && this.back(), t.target === this.dom[\"error-mask\"] && this.hideErrorMessage(), t.target !== this.dom.callout && t.target.parentNode !== this.dom.callout || this.callout();\n\t  }), this.on(\"keydown\", function (t) {\n\t    t.target === this.dom.input && 13 === t.keyCode && (this.send(), t.preventDefault());\n\t  }), this.on(\"scroll\", function (t) {\n\t    t.target === this.dom.container && 0 === t.target.scrollTop && this.reachTop();\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=\"rc-panel rc-conversation\">\n        <div data-info=header-wrapper class=\"rc-panel__header rc-panel__header--colored\">\n            <span class=\"close icon-uni3E\" data-info=back></span>\n            <div class=header>\n                <div class=avatar-wrapper>\n                    <img class=avatar data-info=profile-img src=\"\">\n                </div>\n                <div class=header-title data-info=header></div>\n            </div>\n        </div>\n        <div class=\"rc-panel__content container\" data-info=panel>\n            \n            <div class=content data-info=container>\n                <div class=\"conversations__loading display-none\" data-info=loading>\n                    loading...\n                </div>\n                <table cellspacing=0 cellpadding=0 class=table>\n                    <tbody>\n                        <tr>\n                            <td>\n                                <div class=conversations data-info=conversations>\n                                </div>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n            <div class=textarea-wrapper>\n                <textarea data-info=input placeholder=\"Type a message...\"></textarea>\n                <div class=\"conversations__actions actions\">\n                    <div class=actions__action>\n                        <input data-info=files type=file multiple=multiple>\n                        <span class=icon-uniA6></span>\n                    </div>\n                    <div class=actions__action>\n                        <span class=\"icon-ActionButtons_Filters callout\" data-info=callout></span>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class=\"mask display-none\" data-info=error-mask>\n            <div class=modal data-info=error-message>\n            </div>\n        </div>\n    </div>\n","style":"/* rc-input.--round, rc-button.--round */\n\n/* rc-panel */\n\n/* TODO */\n.rc-conversation {\n    background-color: #fff;\n}\n.rc-conversation .close {\n    position: absolute;\n    cursor: pointer;\n}\n.rc-conversation .container {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    background-color: #fafafa;\n\n    /* Adjust all conversation related font size */\n    font-size: .8em;\n    -webkit-transition: -webkit-transform .2s ease-in;\n    transition: -webkit-transform .2s ease-in;\n    transition: transform .2s ease-in;\n    transition: transform .2s ease-in, -webkit-transform .2s ease-in;\n}\n.rc-conversation .content {\n    overflow: auto;\n    height: 100%;\n}\n.rc-conversation .textarea-wrapper {\n    position: relative;\n    width: 100%;\n}\n.rc-conversation .textarea-wrapper > textarea {\n    padding: .9em 1.1em;\n    width: 100%;\n    border: 0;\n    border-top: 1px solid #BDC3C7;\n    resize: none;\n}\n.rc-conversation .bar {\n    margin-bottom: 5px;\n}\n.rc-conversation .hint {\n    padding: .5em .7em;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n\n    /* overlay bubbles */\n    float: left;\n    position: relative;\n    width: 48%;\n    text-align: center;\n    font-size: .9em\n}\n.rc-conversation .hint--right {\n    float: right;\n}\n.rc-conversation .callout {}\n.rc-conversation .mask {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(10,10,10,.2);\n}\n.rc-conversation .modal {\n    box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);\n    padding: .9em 1.1em;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    position: absolute;\n    z-index: 2;\n    top: 20%;\n    left: 5%;\n    width: 90%;\n    font-size: .9em;\n    border-radius: 4px;\n    background-color: #fff;\n    text-align: center\n}\n.rc-conversation .modal > .rc-button {\n    width: 100%;\n    margin-top: auto;\n    -ms-flex-item-align: center;\n    align-self: center;\n}\n.rc-conversation .timestamp {\n    padding: .5em .7em;\n    text-align: center;\n    color: #bdc3c7;\n}\n.rc-conversation .header {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n}\n.rc-conversation .header-title {\n    -ms-flex-item-align: center;\n    align-self: center;\n    font-size: 1.2em;\n}\n.rc-conversation .avatar-wrapper {\n    width: 40px;\n    height: 40px;\n    margin-right: .8em;\n    border-radius: 50%;\n    overflow: hidden;\n    line-height: 2;\n}\n.rc-conversation .avatar {\n    max-width: 100%;\n}\n.rc-conversation .conversations {}\n.rc-conversation .conversations__conv {\n    padding-left: 1em;\n    padding-right: 1em;\n}\n.rc-conversation .conversations__conv--marked {\n    background-color: #eee;\n}\n.rc-conversation .conversations__bubble {\n    padding: .5em .7em;\n    position: relative;\n    max-width: 77%;\n    word-break: break-all;\n    border: 1px solid #bdc3c7;\n    border-radius: 10px;\n    margin-bottom: 5px;\n}\n.rc-conversation .conversations__bubble--opponent {\n    float: left;\n    background-color: #fefefe;\n    border-bottom-left-radius: 0;\n}\n.rc-conversation .conversations__bubble--opponent:after {\n    left: 100%;\n}\n.rc-conversation .conversations__bubble--self {\n    float: right;\n    background-color: #fefefe;\n    border-bottom-right-radius: 0;\n}\n.rc-conversation .conversations__bubble--self:after {\n    right: 100%;\n}\n.rc-conversation .conversations__bubble--log {\n\n    /*background-color: $conversation-bubble-log-color;*/\n\n    /*border-color: $conversation-bubble-log-color;*/\n}\n.rc-conversation .conversations__bubble--voice {\n\n    /*background-color: $conversation-bubble-voice-color;*/\n\n    /*border-color: $conversation-bubble-voice-color;*/\n}\n.rc-conversation .conversations__bubble:hover {}\n.rc-conversation .conversations__bubble:hover:after {\n    box-sizing: border-box;\n    width: 60px;\n    position: absolute;\n    z-index: 2;\n    content: attr(data-tooltip);\n\n    /* centering */\n    top: 3px;\n    background-color: #000;\n    color: #fff;\n    font-size: .8em;\n    border-radius: 2px;\n    padding: .5em .7em;\n    text-align: center;\n\n    /*min-width: 100%;*/\n    word-break: normal;\n}\n.rc-conversation .conversations__timestamp {\n    text-align: center;\n    color: #bdc3c7;\n}\n.rc-conversation .conversations__loading {\n    padding: .5em .7em;\n    text-align: center;\n}\n.rc-conversation .conversations__actions {\n    position: absolute;\n\n    /* as same as the normal-padding */\n    bottom: .5em;\n    right: 10px;\n}\n.rc-conversation .actions {\n    cursor: pointer;\n    font-size: 1.2em;\n    color: #878787\n}\n.rc-conversation .actions__action {\n    position: relative;\n    overflow: hidden;\n    float: left;\n    padding-left: 5px;\n}\n.rc-conversation .actions__action > input {\n\n    /* file input hack in Facebook's conversation window */\n    bottom: 0;\n    cursor: inherit;\n    font-size: 1000px !important;\n    height: 300px;\n    margin: 0;\n    opacity: 0;\n    padding: 0;\n    position: absolute;\n    right: 0;\n}\n.rc-conversation .actions__action > input:hover + span {\n    color: #bdc3c7;\n}\n.rc-conversation .actions__action > span {}\n.rc-conversation .actions__action > span:hover {\n    color: #bdc3c7;\n}\n.rc-conversation .voice-bubble {\n    min-width: 65px;\n    cursor: pointer;\n    -webkit-transition: background .1s ease-in-out;\n    transition: background .1s ease-in-out\n}\n.rc-conversation .voice-bubble__play {}\n.rc-conversation .voice-bubble__duration {}\n.rc-conversation .table {\n    table-layout: fixed;\n    width: 100%;\n    height: 100%;\n}\n.rc-conversation .table td {\n    vertical-align: bottom;\n    padding: 0;\n}\n\n","imports":{"scripts":["https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.3.0/js/md5.min.js"],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['conversation-item-voice'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=clearfix>\n    <div data-tooltip=$ class=\"conversations__bubble --self\">\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['conversation'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  var t = w.transition(\"fade\");this.actions = { init: { method: function method() {}, after: function after() {\n\t        var t = this;w.customize(this, \"contact-picker\", { data: { contact: t.data.toNumber }, actions: { autoComplete: { method: function method() {\n\t                return t.queryContacts(this.props.inputValue);\n\t              } } } }), w.customize(this, \"dropdown\", { data: { defaultValue: t.data.fromNumber }, actions: { getData: { method: function method() {\n\t                return t.getOutboundCallerID();\n\t              }, after: function after(t) {\n\t                var e = this;t.forEach(function (t) {\n\t                  return e.addItem(t);\n\t                });\n\t              } }, switchTitle: { method: function method(e) {\n\t                t.props.fromNumber = e;\n\t              } } } });\n\t      } }, mount: { method: function method() {\n\t        this.data.new || (this.refs[\"contact-picker\"].disable(), this.refs.dropdown.disable());\n\t      }, after: function after() {\n\t        var e = this;this.refs.dropdown.getData(), this.dom.input.value = this.data.message || \"\", t.init(this.root), t.in(this.root, { after: function after() {\n\t            return e.refs[\"contact-picker\"].focus();\n\t          } });\n\t      } }, enter: { method: function method(t, e) {\n\t        13 === e.keyCode && (this.send(), e.preventDefault());\n\t      } }, send: { before: function before() {\n\t        this.props.message = this.dom.input.value, this.dom.input.value = \"\";var t = new Date(),\n\t            e = this.addBubble(this.props.message, \"Outgoing\", t.getHours() + \":\" + t.getMinutes() + \":\" + t.getSeconds());return this.scrollToBottom(), e;\n\t      }, method: function method(t, e) {\n\t        var n = this;return this.props.fromNumber = this.data.fromNumber || this.props.fromNumber, this.props.toNumber = this.data.toNumber || this.refs[\"contact-picker\"].dom.input.value, t().then(function (t) {\n\t          return e.setAttribute(\"data-id\", t.id), n.unconfirm = n.unconfirm || [], n.unconfirm.push(e), t;\n\t        }).catch(function (t) {\n\t          return e.parentNode.removeChild(e);\n\t        });\n\t      }, after: function after(t) {} }, addBubble: { after: function after(t, e, n, o) {\n\t        var i = \"Inbound\" === e,\n\t            r = \"<div class='clearfix'>\\n                                    <div\\n                                        data-tooltip='\" + n + \"' \\n                                        class='conversations__bubble \" + (i ? \"--opponent\" : \"--self\") + \" '>\\n                                        \" + t + \"\\n                                    </div>\\n                                </div>\",\n\t            s = document.createElement(\"div\");return s.innerHTML = r, o ? this.dom.conversations.insertBefore(s.childNodes[0], this.dom.conversations.firstChild) : this.dom.conversations.appendChild(s.childNodes[0]), this.dom.conversations.lastChild;\n\t      } }, disable: { after: function after() {\n\t        this.refs[\"contact-picker\"].disable(), this.refs.dropdown.disable();\n\t      } }, scroll: { method: function method(t, e) {\n\t        0 === e.target.scrollTop && this.reachTop();\n\t      } }, reachTop: { before: function before() {}, method: function method(t) {\n\t        var e = this;if (!this.isLoading) return this.isLoading = !0, this.dom.loading.classList.remove(\"display-none\"), t().then(function (t) {\n\t          return e.isLoading = !1, e.dom.loading.classList.add(\"display-none\"), t;\n\t        });\n\t      }, after: function after(t) {\n\t        if (t) {\n\t          var e = this.dom.conversations.offsetHeight;this.prependMessages(t, !1), this.dom.container.scrollTop = this.dom.conversations.offsetHeight - e;\n\t        }\n\t      } }, appendMessages: { method: function method(t, e, n) {\n\t        var o = this;e && e.map(function (t) {\n\t          var e = new Date(t.lastModifiedTime);return t.time = e.getHours() + \":\" + e.getMinutes() + \":\" + e.getSeconds(), t;\n\t        }).forEach(function (t) {\n\t          return o.addBubble(t.subject, t.direction, t.time);\n\t        });\n\t      }, after: function after(t) {\n\t        var e = arguments.length <= 1 || void 0 === arguments[1] || arguments[1];e && this.scrollToBottom();\n\t      } }, prependMessages: { before: function before() {}, method: function method(t, e, n) {\n\t        var o = this;e && e.map(function (t) {\n\t          var e = new Date(t.lastModifiedTime);return t.time = e.getHours() + \":\" + e.getMinutes() + \":\" + e.getSeconds(), t;\n\t        }).forEach(function (t) {\n\t          return o.addBubble(t.subject, t.direction, t.time, !0);\n\t        });\n\t      }, after: function after(t) {\n\t        var e = arguments.length <= 1 || void 0 === arguments[1] || arguments[1];e && this.scrollToBottom();\n\t      } }, warnBubble: { after: function after(t) {} }, scrollToBottom: { after: function after() {\n\t        this.dom.container.scrollTop = this.dom.container.scrollHeight;\n\t      } }, getOutboundCallerID: { method: function method(t) {\n\t        return t();\n\t      } }, queryContacts: { method: function method(t, e) {\n\t        return this.props.to = e, t();\n\t      } }, addIncomingMessages: { method: function method(t, e) {\n\t        var n = this;e.filter(function (t) {\n\t          return \"Alive\" === t.availability;\n\t        }).filter(function (t) {\n\t          return \"Received\" === t.messageStatus;\n\t        }).filter(function (t) {\n\t          return \"Inbound\" === t.direction;\n\t        }).filter(function (t) {\n\t          return \"Unread\" === t.readStatus;\n\t        }).map(function (t) {\n\t          console.log(t);var e = new Date(t.lastModifiedTime);return t.time = e.getHours() + \":\" + e.getMinutes() + \":\" + e.getSeconds(), t;\n\t        }).forEach(function (t) {\n\t          return n.addBubble(t.subject, t.direction, t.time);\n\t        });\n\t      }, after: this.scrollToBottom }, confirmMessages: { method: function method(t, e) {\n\t        return this.unconfirm && e ? this.unconfirm.filter(function (t) {\n\t          return e.map(function (t) {\n\t            return t.id;\n\t          }).indexOf(parseInt(t.getAttribute(\"data-id\"))) > -1;\n\t        }).forEach(function (t) {\n\t          return t.removeAttribute(\"data-id\");\n\t        }) : [];\n\t      } } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=\"rc-panel rc-conversation\">\n        <div class=\"rc-panel__header --colored\" data-info=header>\n            <contact-picker data-info=contact-picker></contact-picker>\n        </div>\n        <div class=\"rc-panel__content rc-conversation__container\" data-info=panel>\n            <dropdown class=\"\" data-info=dropdown></dropdown>\n            <div class=rc-conversation__content data-info=container data-event=scroll:scroll>\n                <div class=\"conversations__loading display-none\" data-info=loading>\n                    loading...\n                </div>\n                <div class=conversations data-info=conversations>\n                </div>\n            </div>\n            <div class=rc-conversation__textarea-wrapper>\n                <textarea data-info=input data-event=keydown:enter placeholder=messages...></textarea>\n            </div>\n        </div>\n    </div>\n","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['dial-pad'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar _slicedToArray = function () {\n\t  function t(t, e) {\n\t    var o = [],\n\t        i = !0,\n\t        r = !1,\n\t        n = void 0;try {\n\t      for (var a, s = t[Symbol.iterator](); !(i = (a = s.next()).done) && (o.push(a.value), !e || o.length !== e); i = !0) {}\n\t    } catch (t) {\n\t      r = !0, n = t;\n\t    } finally {\n\t      try {\n\t        !i && s.return && s.return();\n\t      } finally {\n\t        if (r) throw n;\n\t      }\n\t    }return o;\n\t  }return function (e, o) {\n\t    if (Array.isArray(e)) return e;if (Symbol.iterator in Object(e)) return t(e, o);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t  };\n\t}();w.register(function () {\n\t  function t(t) {\n\t    var o = t.trans,\n\t        i = t.layerHozTrans,\n\t        r = t.layerVerticalTrans,\n\t        n = (t.initPosition, t.transitionStart),\n\t        a = t.transitionTo,\n\t        s = t.createLayer;return function (t) {\n\t      var l = (t.srcScene, t.targetScene),\n\t          d = t.srcDOM,\n\t          u = t.targetDOM,\n\t          h = t.transitionEnd;l && (l.style.display = \"block\");var c = d.getBoundingClientRect(),\n\t          p = u.getBoundingClientRect(),\n\t          m = { width: d.offsetWidth, height: d.offsetHeight, left: c.left, top: c.top };console.log(m);var f = { width: u.offsetWidth, height: u.offsetHeight, left: p.left, top: p.top },\n\t          y = s({ src: m, target: f }),\n\t          g = _slicedToArray(y, 2),\n\t          b = g[0],\n\t          v = g[1],\n\t          w = e(b, { overflow: \"hidden\" }),\n\t          C = e(v, { position: \"fixed\" }),\n\t          N = e(m, { position: \"absolute\" });N.style.marginBottom = window.getComputedStyle(d).marginBottom, N.style.marginTop = window.getComputedStyle(d).marginTop;var T = { src: d, target: u, layerHoz: w, layerVertical: C };l && (l.style.display = \"none\"), document.body.appendChild(C), d.parentNode.insertBefore(N, d), C.appendChild(w), w.appendChild(d), d.style.position = \"absolute\", d.style.transition = o, w.style.transition = i, C.style.transition = r, n({ src: m, target: f, layerHoz: b, layerVertical: v, dom: T });var x = function x() {\n\t        l && (l.style.display = \"block\"), C.parentNode.removeChild(C), N.parentNode.removeChild(N), h();\n\t      };setTimeout(function () {\n\t        return a(x, { src: m, target: f, layerHoz: b, layerVertical: v, dom: T });\n\t      }, 17);\n\t    };\n\t  }function e(t, e) {\n\t    var o = e.overflow,\n\t        i = void 0 === o ? \"inherite\" : o,\n\t        r = e.position,\n\t        n = void 0 === r ? \"absolute\" : r,\n\t        a = document.createElement(\"div\");return a.style.width = t.width + \"px\", a.style.height = t.height + \"px\", a.style.left = t.left + \"px\", a.style.top = t.top + \"px\", a.style.position = n, a.style.overflow = i, a;\n\t  }this.data = { autoComplete: !0, outboundID: !0 }, this.props = { fromNumber: null, toNumber: null, isListenToKeyboard: !1, remoteVideo: null, localVideo: null, pad: !0 }, this.actions = { init: { before: function before() {}, method: function method() {}, after: function after() {\n\t        var t = this,\n\t            e = this.data;e.color, e.lang, e.logo;this.props.remoteVideo = this.data.remoteVideo, this.props.localVideo = this.data.localVideo, this.data.pad && (this.props.pad = this.data.pad), this.props.pad || this.dom.container.classList.add(\"display-none\"), w.customize(this, \"contact-picker\", { data: { whiteList: [this.dom[\"dial-button-0\"], this.dom[\"dial-button-1\"], this.dom[\"dial-button-2\"], this.dom[\"dial-button-3\"], this.dom[\"dial-button-4\"], this.dom[\"dial-button-5\"], this.dom[\"dial-button-6\"], this.dom[\"dial-button-7\"], this.dom[\"dial-button-8\"], this.dom[\"dial-button-9\"]] }, actions: { autoComplete: { method: function method() {\n\t                return t.data.autoComplete ? (t.props.toNumber !== this.dom.input.value && t.numberChange(), t.queryContacts(this.props.inputValue)) : [];\n\t              } }, setInput: { after: function after() {\n\t                t.props.toNumber !== this.dom.input.value && t.numberChange();\n\t              } } } }), w.customize(this, \"dropdown\", { actions: { getData: { method: function method() {\n\t                return t.getOutboundCallerID();\n\t              } }, switchTitle: { method: function method(e) {\n\t                t.props.fromNumber = e;\n\t              } } } });\n\t      } }, mount: { before: function before() {}, method: function method() {}, after: function after() {\n\t        var t = this;this.refs.dropdown.getData(), requestAnimationFrame(function () {\n\t          return t.refs[\"contact-picker\"].focus();\n\t        }), this.data.outboundID || this.dom.dropdown.classList.add(\"display-none\"), this.listenToKeyboard(!0);\n\t      } }, unmount: { method: function method(t) {\n\t        this.listenToKeyboard(!1);\n\t      } }, dialing: { method: function method(t, e) {\n\t        var o = this.refs[\"contact-picker\"];return o.appendInput(e), o.autoComplete(), this.props.toNumber = o.dom.input.value, t();\n\t      }, after: function after() {\n\t        this.refs[\"contact-picker\"].dom.input.focus();\n\t      } }, callout: { before: function before() {\n\t        var t = this;if (!this.props.toNumber || !this.props.fromNumber) throw console.error(\"from- or to-Number is missing.\"), Error(\"from- or to-Number is missing.\");var e = this.dom.callout;return new Promise(function (i, r) {\n\t          o({ targetScene: t.dom.callWaiting, srcDOM: t.dom.callout, targetDOM: t.dom.callWaiting, transitionEnd: function transitionEnd() {\n\t              e.style.top = \"auto\", e.style.left = \"auto\", e.style.width = \"3.2em\", e.style.height = \"3.2em\", e.style.background = \"#2ecc71\", e.style.position = \"static\", t.dom[\"callout-line\"].appendChild(e), i();\n\t            } });\n\t        });\n\t      }, method: function method(t, e) {\n\t        var o = this.refs[\"contact-picker\"];return this.props.toNumber = o.dom.input.value, t();\n\t      }, after: function after() {} }, disable: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        this.dom[\"disabled-mask\"].classList.remove(\"display-none\"), this.dom.container.classList.add(\"blur\"), t && (this.dom[\"disabled-mask-text\"].textContent = t);\n\t      } }, getOutboundCallerID: { method: function method(t) {\n\t        return t();\n\t      } }, queryContacts: { method: function method(t, e) {\n\t        return this.props.toNumber = e, t();\n\t      } }, number: { method: function method(t, e) {\n\t        this.refs[\"contact-picker\"].setInput(e), this.props.toNumber !== this.refs[\"contact-picker\"].dom.input.value && this.numberChange();\n\t      } }, numberChange: { method: function method(t) {\n\t        this.props.toNumber = this.refs[\"contact-picker\"].dom.input.value;\n\t      } }, listenToKeyboard: { method: function method(t, e) {\n\t        return this.props.isListenToKeyboard = !!e, t();\n\t      } } }, this.on(\"click\", function (t) {\n\t    var e = this;[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, \"#\", \"*\"].forEach(function (o) {\n\t      t.target !== e.dom[\"dial-button-\" + o] && t.target.parentNode !== e.dom[\"dial-button-\" + o] || e.dialing(o);\n\t    }), t.target !== this.dom.callout && t.target.parentNode !== this.dom.callout || this.callout();\n\t  });var o = t({ trans: \"all .375s cubic-bezier(0.4, 0.0, 0.2, 1)\", layerHozTrans: \"all .1s ease-in\", layerVerticalTrans: \"all .1s ease-out\", transitionStart: function transitionStart(t) {\n\t      var e = t.src,\n\t          o = (t.target, t.layerHoz),\n\t          i = t.layerVertical,\n\t          r = t.dom,\n\t          n = r.src;n.style.left = (o.width - e.width) / 2 + \"px\", n.style.top = (i.height - e.width) / 2 + \"px\";\n\t    }, transitionTo: function transitionTo(t, e) {\n\t      var o = (e.src, e.target),\n\t          i = (e.layerHoz, e.layerVertical, e.dom),\n\t          r = i.src,\n\t          n = 0,\n\t          a = Math.sqrt(o.width / 2 * o.width / 2 + o.height / 2 * o.height / 2);r.style.position = \"absolute\", r.style.width = 2 * a + \"px\", r.style.height = 2 * a + \"px\", r.style.left = o.width / 2 - a + \"px\", r.style.top = o.height / 2 - a + \"px\", r.style.background = \"#fff\", i.layerHoz.style.left = o.left + \"px\", i.layerVertical.style.top = o.top + \"px\", r.addEventListener(\"transitionend\", function (e) {\n\t        3 === ++n && t();\n\t      });\n\t    }, createLayer: function createLayer(t) {\n\t      var e = t.src,\n\t          o = t.target;return [{ width: o.width, height: o.height, left: e.left - (o.width - e.width) / 2, top: 0 }, { width: o.width, height: o.height, left: 0, top: e.top - (o.height - e.height) / 2 }];\n\t    } });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div data-info=panel class=\"rc-panel rc-dial-pad\">\n        <div class=\"rc-panel__header rc-panel__header--colored\" data-info=header>\n            <contact-picker data-info=contact-picker></contact-picker>\n        </div>\n        \n        <div class=pad-container data-info=container>\n            <div class=rc-panel__content>\n                <dropdown data-info=dropdown></dropdown>\n                <div data-info=dialing-panel class=margin-top-1>\n                    <div class=rc-dial-pad__line>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-1>\n                            <div class=dial-button__number>1</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-2>\n                            <div class=dial-button__number>2</div>\n                            <div class=dial-button__symbol>ABC</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-3>\n                            <div class=dial-button__number>3</div>\n                            <div class=dial-button__symbol>DEF</div>\n                        </button>\n                    </div>\n                    <div class=rc-dial-pad__line>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-4>\n                            <div class=dial-button__number>4</div>\n                            <div class=dial-button__symbol>GHI</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-5>\n                            <div class=dial-button__number>5</div>\n                            <div class=dial-button__symbol>JKL</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-6>\n                            <div class=dial-button__number>6</div>\n                            <div class=dial-button__symbol>MNO</div>\n                        </button>\n                    </div>\n                    <div class=rc-dial-pad__line>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-7>\n                            <div class=dial-button__number>7</div>\n                            <div class=dial-button__symbol>PQRS</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-8>\n                            <div class=dial-button__number>8</div>\n                            <div class=dial-button__symbol>TUV</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-9>\n                            <div class=dial-button__number>9</div>\n                            <div class=dial-button__symbol>WXYZ</div>\n                        </button>\n                    </div>\n                    <div class=rc-dial-pad__line>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-*>\n                            <div class=dial-button__number>*</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-0>\n                            <div class=dial-button__number>0</div>\n                            <div class=dial-button__symbol>+</div>\n                        </button>\n                        <button class=\"rc-button rc-button--circle dial-button dial-button--color\" data-info=dial-button-#>\n                            <div class=dial-button__number>#</div>\n                        </button>\n                    </div>\n                    <div data-info=callout-line class=rc-dial-pad__line>\n                        <button class=\"rc-button rc-button--circle rc-dial-pad__call-button rc-dial-pad__call-button--color\" data-info=callout>\n                            <span class=icon-ActionButtons_Filters></span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n            \n        </div>\n        <div class=\"rc-dial-pad__mask display-none\" data-info=disabled-mask>\n            <p data-info=disabled-mask-text>Your account doesn't not have Web Phone permission.</p>\n        </div>\n        <div class=call-waiting data-info=callWaiting></div>\n    </div>\n","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-dial-pad .call-waiting {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: #fafafa;\n    z-index: -1;\n}\n.rc-dial-pad .blur {\n    filter: blur(2px);\n    -webkit-filter: blur(2px);\n}\n.rc-dial-pad .pad-container {\n    height: 100%;\n}\n.rc-dial-pad__line {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n}\n.rc-dial-pad__line > .dial-button {\n    margin: 3px 6px;\n    width: 3.2em;\n    height: 3.2em;\n    color: #337ab7;\n    border-color: #337ab7;\n}\n.rc-dial-pad__line > .dial-button > .dial-button__number {\n    font-size: 1.3em;\n}\n.rc-dial-pad__line > .dial-button > .dial-button__symbol {\n    font-size: .5em;\n}\n.rc-dial-pad__line > .dial-button:hover {\n    background-color: #337ab7;\n    color: #fafafa;\n}\n.rc-dial-pad__mask {\n    position: absolute;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.rc-dial-pad__mask > p {\n    font-weight: bold;\n    text-align: center;\n}\n.rc-dial-pad__mask::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.rc-dial-pad__call-button {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    /*position: absolute;*/\n    /*top:    5px;*/\n    /*right:  5px;*/\n    width: 3.2em;\n    height: 3.2em;\n    background-color: #2ecc71;\n    border-color: #2ecc71;\n    -webkit-transition: all .08s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: all .08s cubic-bezier(0.4, 0.0, 0.2, 1);\n}\n.rc-dial-pad__call-button > span {\n    color: #fafafa;\n    font-size: 1.3em;\n}\n.rc-dial-pad__call-button:hover {\n    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n    background-color: #2ecc71;\n    border-color: #2ecc71;\n}\n\n\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['dropdown'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  var t = w.transition(\"enlarge\");this.props = { items: [] }, this.actions = { init: { after: function after() {\n\t        this.data.defaultValue && this.switchTitle(this.data.defaultValue), t.init(this.dom.list), this.data.height && (this.dom.dropdown.style.height = this.data.height + \"px\");\n\t      } }, mount: { after: function after() {\n\t        var t = this;document.addEventListener(\"click\", function (i) {\n\t          for (var o = i.target; o.parentNode;) {\n\t            if (o = o.parentNode, o === t.root) return;\n\t          }\n\t        });\n\t      } }, collapse: { after: function after() {\n\t        console.log(\"collapse\"), t.toggle(this.dom.list), this.dom[\"dropdown-icon\"].classList.toggle(\"icon-uni2462\"), this.dom[\"dropdown-icon\"].classList.toggle(\"icon-uni2463\");\n\t      } }, hide: { after: function after() {\n\t        console.log(\"hide\"), t.out(this.dom.list), this.dom[\"dropdown-icon\"].classList.remove(\"icon-uni2462\"), this.dom[\"dropdown-icon\"].classList.add(\"icon-uni2463\");\n\t      } }, getData: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        var i = this;this.props.items && this.props.items.length || (this.props.items = t, t = t.map(function (t) {\n\t          return 0 === t.indexOf(\"+\") ? t.substring(1) : t;\n\t        }), t.forEach(function (t) {\n\t          return i.addItem(t);\n\t        }), this.switchTitle(t[0]));\n\t      } }, addItem: { after: function after(t) {\n\t        var i = this,\n\t            o = document.createElement(\"div\");o.classList.add(\"rc-list__item\", \"rc-dropdown__item\"), o.textContent = t, o.addEventListener(\"click\", function (o) {\n\t          i.switchTitle(t), i.hide();\n\t        }), this.dom.list.appendChild(o);\n\t      } }, getSelected: { method: function method() {\n\t        return this.dom[\"dropdown-text\"].textContent;\n\t      } }, disable: { method: function method() {\n\t        this.dom.dropdown.disabled = !0;\n\t      } }, switchTitle: { method: function method(t, i) {\n\t        return this.dom[\"dropdown-text\"].textContent = i, t(i);\n\t      } } }, this.on(\"click\", \"dropdown\", function () {\n\t    this.collapse();\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=rc-dropdown>\n        <button class=\"rc-dropdown__trigger rc-button\" data-info=dropdown>\n            <span>From: </span>\n            <span data-info=dropdown-text></span>\n            <span data-info=dropdown-icon class=\"icon-uni2463 rc-dropdown__icon\"></span>\n        </button>\n        <div class=\"rc-dropdown__list rc-list\" data-info=list>\n        </div>\n    </div>\n","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-dropdown {\n    /* used as a positioned reference */\n    position: relative\n}\n.rc-dropdown__trigger {\n    padding: .5em .7em;\n    width: 100%;\n    background: inherit;\n    border: 0;\n    border-bottom: 1px solid #bdc3c7;\n    font-size: .8em\n}\n.rc-dropdown__list {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    position: absolute;\n    width: 100%;\n    max-height: 200px;\n    overflow: auto;\n    background: #fff\n}\n.rc-dropdown__item {\n    padding: .9em 1.1em;\n    font-size: .8em;\n    text-align: center;\n    cursor: pointer\n}\n.rc-dropdown__item:hover {\n    background: #ecf0f1\n}\n.rc-dropdown__icon {\n    margin-left: 5px\n}\n\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['message-detail'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = { init: {}, mount: {} };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=rc-panel>\n    <div class=rc-panel__content>\n        <div class=rc-message-detail>\n            <div>Conversation with</div>\n            <div class=rc-message-detail__contact>\n                <div class=__name>Colin Liu</div>\n                <div><span>6508370092</span></div>\n            </div>\n            <img class=\"rc-avatar --big rc-message-detail__avatar\">\n            \n            <div>&nbsp</div>\n            <div class=\"rc-button --positive rc-message-detail__button\">\n                Call\n            </div>\n            <div class=\"rc-button --positive rc-message-detail__button\">\n                Send\n            </div>\n        \n        </div>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['message-item-fax'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = {}, this.actions.init = { method: function method(t) {\n\t      return t();\n\t    }, after: function after(t) {\n\t      var e = this,\n\t          n = w.t(this.data.lang);w.customize(this, \"message-item\", { data: e.data, actions: { init: { method: function method() {\n\t              return t;\n\t            }, after: function after() {\n\t              this.setShortText();\n\t            } }, setShortText: { method: function method() {\n\t              return n(\"message-item-fax-text\");\n\t            } }, viewInfo: { method: function method() {\n\t              e.viewInfo();\n\t            } }, enter: { method: function method() {\n\t              e.enter();\n\t            } } } }), this.props.message = t;\n\t    } }, this.actions.viewInfo = { method: function method(t) {\n\t      return t();\n\t    } }, this.actions.enter = { method: function method(t) {\n\t      return t();\n\t    }, after: function after() {} };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div>\n    <message-item></message-item>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['message-item-text'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = {}, this.actions.init = { method: function method(t) {\n\t      return t();\n\t    }, after: function after(t) {\n\t      var n = this;w.customize(this, \"message-item\", { data: n.data, actions: { init: { method: function method() {\n\t              return t;\n\t            }, after: function after() {\n\t              this.setShortText();\n\t            } }, setShortText: { method: function method() {\n\t              return t.subject;\n\t            } }, viewInfo: { method: function method() {\n\t              n.viewInfo();\n\t            } }, enter: { method: function method() {\n\t              n.enter();\n\t            } } } }), this.props.message = t;\n\t    } }, this.actions.viewInfo = { method: function method(t) {\n\t      return t();\n\t    } }, this.actions.enter = { method: function method(t) {\n\t      return t();\n\t    }, after: function after() {} };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div>\n    <message-item></message-item>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['message-item-voicemail'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = {}, this.actions.init = { method: function method(t) {\n\t      return t();\n\t    }, after: function after(t) {\n\t      var e = this,\n\t          n = w.t(this.data.lang);w.customize(this, \"message-item\", { data: e.data, actions: { init: { method: function method() {\n\t              return t;\n\t            }, after: function after() {\n\t              this.setShortText();\n\t            } }, setShortText: { method: function method() {\n\t              return n(\"message-item-voicemail-text\");\n\t            } }, viewInfo: { method: function method() {\n\t              e.viewInfo();\n\t            } }, enter: { method: function method() {\n\t              e.enter();\n\t            } } } }), this.props.message = t;\n\t    } }, this.actions.viewInfo = { method: function method(t) {\n\t      return t();\n\t    } }, this.actions.enter = { method: function method(t) {\n\t      return t();\n\t    }, after: function after() {} };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div>\n    <message-item></message-item>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['message-item'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  this.actions = {}, this.actions.init = { method: function method(t) {\n\t      var n = t();return this.props.message = n, n;\n\t    }, after: function after(t) {\n\t      \"Unread\" === t.readStatus && (this.dom.icon.classList.add(\"--not-read\"), this.dom.contact.classList.add(\"--not-read\")), this.dom.icon.classList.add(\"--\" + t.type.toLowerCase()), this.dom.time.textContent = t.time, this.dom.contact.textContent = t.contact;\n\t    } }, this.actions.setShortText = { method: function method(t) {\n\t      return t();\n\t    }, after: function after(t) {\n\t      this.dom.text.textContent = t;\n\t    } }, this.actions.open = { method: function method(t) {\n\t      return t();\n\t    } }, this.actions.viewInfo = { method: function method(t, n) {\n\t      return n.stopPropagation(), t();\n\t    } }, this.actions.enter = { method: function method(t) {\n\t      return t();\n\t    }, after: function after() {} };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div data-info=message class=rc-message-item data-event=click:open>\n    <i data-info=icon class=rc-message-item__icon></i>\n    <a class=rc-message-item__info data-event=click:viewInfo></a>\n    <span class=rc-message-item__time data-info=time></span>\n    <div class=rc-message-item__body>\n        <span class=__contact data-info=contact data-event=click:enter>\n        </span>\n        <div class=__text data-info=text data-event=click:enter>\n        </div>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['messages'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  function e(e, t) {\n\t    e.classList.contains(\"--active\") === !1 && (e.classList.add(\"--active\"), t.classList.remove(\"--active\"));\n\t  }function t(e, t, s) {\n\t    return w(e, { data: s.data, actions: { init: { method: function method() {\n\t            return t;\n\t          } }, viewInfo: { method: function method() {\n\t            s.viewMessageInfo(this.props.message);\n\t          } }, enter: { method: function method() {\n\t            return s.enterMessage(this.props.message);\n\t          } } } });\n\t  }function s(e, s) {\n\t    e.forEach(function (e) {\n\t      var i = null;i = \"Fax\" === e.type ? t(\"message-item-fax\", e, s) : \"VoiceMail\" === e.type ? t(\"message-item-voicemail\", e, s) : t(\"message-item-text\", e, s), i.mount(s.dom.messages), s.props.widgetItems.push(i);\n\t    });\n\t  }function i(e, t) {\n\t    e.forEach(function (e) {\n\t      \"all\" === t ? e.show() : t.indexOf(e.props.message.type.toLowerCase()) >= 0 ? e.show() : e.hide();\n\t    });\n\t  }var n = null;this.actions = { init: { before: function before() {\n\t        this.props.widgetItems = [];\n\t      }, after: function after() {\n\t        w.t(this.data.lang);\n\t      } }, mount: { after: function after() {\n\t        this.refreshMessages();\n\t      } }, enableTab: { after: function after(t, s) {\n\t        e(t.target, n), n = t.target, i(this.props.widgetItems, t.target.getAttribute(\"data-value\"));\n\t      } }, refreshMessages: { method: function method(e) {\n\t        return e();\n\t      }, after: function after(e) {\n\t        console.log(e);for (var t = this.dom.messages; t.firstChild;) {\n\t          t.removeChild(t.firstChild);\n\t        }s(e, this);\n\t      } }, viewMessageInfo: { method: function method(e, t) {\n\t        return this.props.selectedMessage = t, e();\n\t      } }, enterMessage: { method: function method(e, t) {\n\t        return this.props.selectedMessage = t, e();\n\t      } }, compose: { before: function before() {\n\t        this.dom.compose.classList.add(\"--active\");\n\t      }, method: function method(e) {\n\t        return new Promise(function (t) {\n\t          return setTimeout(function () {\n\t            return t(e());\n\t          }, 500);\n\t        });\n\t      }, after: function after() {\n\t        var e = this;setTimeout(function () {\n\t          return e.dom.compose.classList.remove(\"--active\");\n\t        }, 1e3);\n\t      } } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=\"rc-panel rc-messages\">\n    <div class=\"rc-panel__header --flat\">\n        <div class=rc-contacts__searchBox>\n            <input class=__input type=text data-info=searchText data-event=input:search>\n        </div>\n    </div>\n    <div class=rc-panel__content>\n        <button class=\"rc-button --circle compose-button\" data-info=compose data-event=click:compose>\n        </button>\n        <div data-info=messages>\n            <message-item-text dynamic></message-item-text>\n            <message-item-fax dynamic></message-item-fax>\n            <message-item-voicemail dynamic></message-item-voicemail>\n        </div>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['notification'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar slideDown = w.transition(\"slide-down\");w.register(function () {\n\t  this.actions = { mount: { method: function method() {}, after: function after() {\n\t        slideDown.in(this.root);\n\t      } }, msg: { method: function method(t, n) {\n\t        return this.dom.msg.textContent = n, t();\n\t      } }, show: { method: function method(t, n, o) {\n\t        var i = this;return this.mount(n), t(), new Promise(function (t) {\n\t          setTimeout(function () {\n\t            slideDown.out(i.root, { after: function after() {\n\t                return t(i.unmount());\n\t              } });\n\t          }, o);\n\t        });\n\t      } } };\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div>\n    <div class=rc-notification data-event=click:unmount>\n        <span class=rc-notification__icon></span>\n        <span class=rc-notification__text data-info=msg>Error occur</span>\n    </div>\n</div>","style":null,"imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['rc-phone-incontact'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction _interopRequireDefault(e) {\n\t  return e && e.__esModule ? e : { default: e };\n\t}var _factory = __webpack_require__(2),\n\t    _factory2 = _interopRequireDefault(_factory),\n\t    _eventemitter = __webpack_require__(64),\n\t    _eventemitter2 = _interopRequireDefault(_eventemitter),\n\t    factory = new _factory2.default();w.register(function () {\n\t  this.props = { ee: new _eventemitter2.default() }, this.actions = factory.create(\"incontact\", { init: { before: function before() {\n\t        this.props.key = this.data.key, this.props.secret = this.data.secret, this.props.sandbox = \"true\" === this.data.sandbox;\n\t      } }, mount: { after: function after() {\n\t        var e = this,\n\t            t = w(\"auth-panel\", { data: { oauth: !0 }, actions: factory.create(\"auth-panel\", { login: { after: function after() {\n\t                e.dom[\"auth-panel\"].parentNode.removeChild(e.dom[\"auth-panel\"]), this.unmount(), e.dom.waiting.hidden = !1, e.dom[\"main-panel\"].hidden = !1, webPhone(null, { width: e.data.width, height: e.data.height }, e), e.props.ee.trigger(\"loggedin\");\n\t              } } }) });t.mount(this.dom[\"auth-panel\"]);\n\t      } }, setSize: { method: function method() {} }, on: { method: function method(e, t, a) {\n\t        this.props.ee.on(t, a);\n\t      } } });\n\t});var webPhone = function webPhone(e, t, a) {\n\t  var n = t.width,\n\t      i = t.height,\n\t      o = w(\"call-panel\", { data: { target: \"#call-panel\", width: n, height: i, advance: !1 }, actions: factory.create(\"call-panel\") });w(\"call-panel-incoming\", { data: { target: \"#call-panel-incoming\", width: n, height: i, remoteVideo: o.props.remoteVideo, localVideo: o.props.localVideo, simple: !0 }, actions: factory.create(\"call-panel-incoming\", { accept: { after: function after() {\n\t          this.unmount(), o.setName(this.props.name), o.mount(\"#call-panel\"), o.start();\n\t        } }, mount: { after: function after() {\n\t          a.props.ee.trigger(\"incoming\");\n\t        } } }) });\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcServices = __webpack_require__(3);\n\t\n\tvar _rcServices2 = _interopRequireDefault(_rcServices);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction extend(base, mixin) {\n\t    // FIXME: avoid create function in for loop\n\t    Object.keys(mixin).forEach(function (action) {\n\t        if (base[action]) {\n\t            Object.keys(mixin[action]).forEach(function (hook) {\n\t                var origin = base[action][hook];\n\t                var mix = mixin[action][hook];\n\t                base[action][hook] = function () {\n\t                    var result;\n\t                    if (origin) {\n\t                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t                            args[_key] = arguments[_key];\n\t                        }\n\t\n\t                        result = origin.call.apply(origin, [this].concat(args));\n\t                    }\n\t                    mix.call(this);\n\t                    return result;\n\t                };\n\t            });\n\t        } else {\n\t            base[action] = mixin[action];\n\t        }\n\t    });\n\t    return base;\n\t} // TODO: use dependency injection\n\t\n\t\n\tvar Factory = function Factory() {};\n\t\n\tFactory.prototype.create = function (type) {\n\t    var mixin = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    return extend(_rcServices2.default[type], mixin);\n\t};\n\t\n\texports.default = Factory;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _phoneService = __webpack_require__(12);\n\t\n\tvar _phoneService2 = _interopRequireDefault(_phoneService);\n\t\n\tvar _loginService = __webpack_require__(51);\n\t\n\tvar _loginService2 = _interopRequireDefault(_loginService);\n\t\n\tvar _callLogService = __webpack_require__(52);\n\t\n\tvar _callLogService2 = _interopRequireDefault(_callLogService);\n\t\n\tvar _accountService = __webpack_require__(54);\n\t\n\tvar _accountService2 = _interopRequireDefault(_accountService);\n\t\n\tvar _rcContactService = __webpack_require__(55);\n\t\n\tvar _rcContactService2 = _interopRequireDefault(_rcContactService);\n\t\n\tvar _contactSearchService = __webpack_require__(57);\n\t\n\tvar _contactSearchService2 = _interopRequireDefault(_contactSearchService);\n\t\n\tvar _rcContactSearchProvider = __webpack_require__(58);\n\t\n\tvar _rcContactSearchProvider2 = _interopRequireDefault(_rcContactSearchProvider);\n\t\n\tvar _rcMessageService = __webpack_require__(59);\n\t\n\tvar _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n\t\n\tvar _rcMessageProvider = __webpack_require__(60);\n\t\n\tvar _rcMessageProvider2 = _interopRequireDefault(_rcMessageProvider);\n\t\n\tvar _rcConferenceService = __webpack_require__(61);\n\t\n\tvar _rcConferenceService2 = _interopRequireDefault(_rcConferenceService);\n\t\n\tvar _rcConversationService = __webpack_require__(62);\n\t\n\tvar _rcConversationService2 = _interopRequireDefault(_rcConversationService);\n\t\n\tvar _blueimpMd = __webpack_require__(63);\n\t\n\tvar _blueimpMd2 = _interopRequireDefault(_blueimpMd);\n\t\n\tvar _rcConfig = __webpack_require__(11);\n\t\n\tvar _rcConfig2 = _interopRequireDefault(_rcConfig);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar dialPadSearchProviders = [_rcContactSearchProvider2.default];\n\t\n\tvar services = {};\n\tservices['incontact'] = {\n\t    init: {\n\t        after: function after() {\n\t            /// critical, inject app key & secret into service\n\t            (0, _rcSdk.injectSDK)({\n\t                key: this.props.key,\n\t                secret: this.props.secret,\n\t                sandbox: this.props.sandbox\n\t            });\n\t        }\n\t    },\n\t    checkLogin: {\n\t        method: function method() {\n\t            return _loginService2.default.checkLoginStatus();\n\t        }\n\t    }\n\t};\n\tservices['rcPhone'] = {\n\t    init: {\n\t        after: function after() {\n\t            /// critical, inject app key & secret into service\n\t            (0, _rcSdk.injectSDK)({\n\t                key: this.props.key,\n\t                secret: this.props.secret,\n\t                sandbox: this.props.sandbox\n\t            });\n\t        }\n\t    },\n\t    loadData: {\n\t        method: function method() {\n\t            _rcMessageService2.default.subscribeToMessageUpdate();\n\t            // rcMessageService.syncMessages(this.props.cachedMessageHours);\n\t            _accountService2.default.getAccountInfo();\n\t            _accountService2.default.getPhoneNumber();\n\t            _rcContactService2.default.cacheContacts();\n\t            _phoneService2.default.init({\n\t                incomingAudio: _rcConfig2.default.incomingAudio,\n\t                outgoingAudio: _rcConfig2.default.outgoingAudio\n\t            });\n\t            _callLogService2.default.getCallLogs();\n\t        }\n\t    },\n\t    checkLogin: {\n\t        method: function method() {\n\t            return _loginService2.default.checkLoginStatus();\n\t        }\n\t    },\n\t    logout: {\n\t        method: function method() {\n\t            return _loginService2.default.logout();\n\t        }\n\t    }\n\t};\n\tservices['auth-panel'] = {\n\t    login: {\n\t        method: function method() {\n\t            // return loginService.login(\n\t            //     this.props.username,\n\t            //     this.props.extension,\n\t            //     this.props.password\n\t            // )\n\t            return _loginService2.default.oauth();\n\t        }\n\t    }\n\t};\n\tservices['dial-pad'] = {\n\t    mount: {\n\t        after: function after() {\n\t            if (!_accountService2.default.hasServiceFeature('VoipCalling')) this.disable();\n\t        }\n\t    },\n\t    callout: {\n\t        method: function method() {\n\t            console.log('real call');\n\t            return _phoneService2.default.call(this.props.fromNumber, this.props.toNumber, {\n\t                remoteVideo: this.props.remoteVideo,\n\t                localVideo: this.props.localVideo\n\t            });\n\t        }\n\t    },\n\t    queryContacts: {\n\t        method: function method() {\n\t            var _this = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this.props.toNumber);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    },\n\t    getOutboundCallerID: {\n\t        method: function method() {\n\t            return _accountService2.default.getPhoneNumber().then(function () {\n\t                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n\t            });\n\t        }\n\t    }\n\t};\n\t\n\tservices['conference'] = {\n\t    getConferenceInfo: {\n\t        method: function method() {\n\t            return _rcConferenceService2.default.getConferenceInfo();\n\t        }\n\t    }\n\t};\n\tservices['call-log'] = {\n\t    init: {\n\t        method: function method() {\n\t            return _callLogService2.default.getCallLogs();\n\t        }\n\t    }\n\t};\n\t\n\tservices['time-line'] = {\n\t    mount: {\n\t        after: function after() {\n\t            var _this2 = this;\n\t\n\t            _rcMessageService2.default.subscribeToMessageUpdate();\n\t            _rcMessageProvider2.default.onMessageUpdated(function (msg) {\n\t                _this2.updateTimeline(_rcConversationService2.default.syncContent(_this2.props.contacts, msg));\n\t                if (_this2.props.currentConv) {\n\t                    _this2.props.currentConv.confirmMessages();\n\t                    _this2.props.currentConv.addIncomingMessages();\n\t                }\n\t            });\n\t            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n\t                return _this2.props.contacts = contacts;\n\t            });\n\t        }\n\t    },\n\t    fetchData: {\n\t        method: function method() {\n\t            return Promise.all([_rcContactService2.default.cacheContacts(), // first one must be the contacts\n\t            _rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs()]).then(function (result) {\n\t                return _rcConversationService2.default.organizeContent.apply(_rcConversationService2.default, _toConsumableArray(result));\n\t            });\n\t        }\n\t    }\n\t};\n\t\n\tservices['contacts'] = {\n\t    mount: {\n\t        after: function after() {\n\t            this.fetchContacts();\n\t        }\n\t    },\n\t    fetchRelatedContact: {\n\t        method: function method() {\n\t            var _this3 = this;\n\t\n\t            return Promise.all([_rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs(), _rcContactService2.default.cacheContacts()]).then(function (result) {\n\t                var _result = _slicedToArray(result, 3);\n\t\n\t                var msgs = _result[0];\n\t                var logs = _result[1];\n\t                var contacts = _result[2];\n\t\n\t                _this3.props.contacts = contacts.reduce(function (result, contact) {\n\t                    result[contact.id] = contact;\n\t                    return result;\n\t                }, {});\n\t                return _rcConversationService2.default.getConversations(contacts, msgs, logs);\n\t            }).then(function (relateContacts) {\n\t                _this3.props.relateContacts = relateContacts;\n\t                return relateContacts;\n\t            }).then(function (relateContacts) {\n\t                return Object.keys(relateContacts).map(function (index) {\n\t                    // adapt to messages template format\n\t                    relateContacts[index].msg[0].contact = relateContacts[index].displayName;\n\t                    // for conversation-advance temaplate\n\t                    relateContacts[index].msg[0].contactId = index;\n\t                    return relateContacts[index].msg[0];\n\t                });\n\t            });\n\t        }\n\t    },\n\t    fetchContacts: {\n\t        method: function method() {\n\t            var _this4 = this;\n\t\n\t            // var dialPadSearchFunctions = dialPadSearchProviders.map(provider => {\n\t            //     return provider.searchAll();\n\t            // });\n\t            // return contactSearchService.query(dialPadSearchFunctions);\n\t            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n\t                _this4.props.contacts = contacts.reduce(function (result, contact) {\n\t                    result[contact.id] = contact;\n\t                    return result;\n\t                }, {});\n\t                return contacts.map(function (contact) {\n\t                    return {\n\t                        name: contact.displayName,\n\t                        type: 'rc',\n\t                        id: contact.id\n\t                    };\n\t                });\n\t            }).catch(function (e) {\n\t                return console.error(e);\n\t            });\n\t        }\n\t    }\n\t};\n\t\n\tservices['conversation-advanced'] = {\n\t    init: {\n\t        after: function after() {}\n\t    },\n\t    mount: {\n\t        after: function after() {\n\t            var _this5 = this;\n\t\n\t            return _accountService2.default.getAccountInfo()\n\t            // FIXME: set props from outside is a anti-pattern\n\t            .then(function (info) {\n\t                return _this5.props.fromExt = info.extensionNumber;\n\t            }).then(function () {\n\t                _this5.setOutboundCallerID();\n\t            });\n\t        }\n\t    },\n\t    send: {\n\t        method: function method() {\n\t            if (!this.props.toNumber || this.props.toNumber === this.props.toExt) {\n\t                return _rcMessageService2.default.sendPagerMessage(this.props.message, this.props.fromExt, this.props.toExt);\n\t            } else {\n\t                return _rcMessageService2.default.sendSMSMessage(this.props.message, this.props.fromNumber, this.props.toNumber);\n\t            }\n\t        }\n\t    },\n\t    sendFax: {\n\t        method: function method() {\n\t            _rcMessageService2.default.sendFax(this.props.files, this.props.toNumber || this.props.toExt);\n\t        }\n\t    },\n\t    callout: {\n\t        method: function method() {\n\t            return _phoneService2.default.call(this.props.fromNumber || this.props.fromExt, this.props.toNumber || this.props.toExt, {\n\t                remoteVideo: this.props.remoteVideo,\n\t                localVideo: this.props.localVideo\n\t            });\n\t        }\n\t    },\n\t    reachTop: {\n\t        method: function method() {\n\t            console.log('load content');\n\t            return _rcConversationService2.default.loadContent(this.props.contact, this.props.loadingPeriod);\n\t        }\n\t    },\n\t    getAvatar: {\n\t        method: function method() {\n\t            var _this6 = this;\n\t\n\t            if (!this.props.profileImage) return Promise.resolve('https://www.gravatar.com/avatar/' + (0, _blueimpMd2.default)(this.props.contact.id) + '?d=retro');\n\t            return _rcSdk.RC.sdk.platform().get(this.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken())).then(function (r) {\n\t                return r.response();\n\t            }).then(function (r) {\n\t                // Real contact, no avatar\n\t                if (r.status === 204 || r.status === 404) {\n\t                    var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n\t                    return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n\t                } else {\n\t                    // Real contact, has avatar\n\t                    return;\n\t                    _this6.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken());\n\t                }\n\t            }).catch(function (e) {\n\t                // Real contact, no avatar\n\t                var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n\t                return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n\t            });\n\t        }\n\t    },\n\t    transformURL: {\n\t        method: function method() {\n\t            return this.props.transformee + ('?access_token=' + _rcContactService2.default.accessToken());\n\t        }\n\t    },\n\t    getFileInfo: {\n\t        method: function method() {\n\t            console.log(this.props.fileURL);\n\t            return _rcSdk.RC.sdk.platform().get(this.props.fileURL).then(function (r) {\n\t                return r.json();\n\t            });\n\t        }\n\t    },\n\t    setOutboundCallerID: {\n\t        method: function method() {\n\t            return _accountService2.default.getPhoneNumber().then(function () {\n\t                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n\t            });\n\t        }\n\t    }\n\t};\n\tservices['call-panel'] = {\n\t    init: {\n\t        after: function after() {\n\t            var _this7 = this;\n\t\n\t            _phoneService2.default.init({\n\t                incomingAudio: _rcConfig2.default.incomingAudio,\n\t                outgoingAudio: _rcConfig2.default.outgoingAudio\n\t            });\n\t            _phoneService2.default.on('progress', function () {\n\t                if (!_this7._mounted) {\n\t                    _this7.mount(_this7.props.target);\n\t                }\n\t            });\n\t            _phoneService2.default.on('bye', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('terminated', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('rejected', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('failed', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('accepted', function () {\n\t                console.log('accept');\n\t                _this7.start();\n\t            });\n\t        }\n\t    },\n\t    mount: {\n\t        after: function after() {}\n\t    },\n\t    getContact: {\n\t        method: function method() {\n\t            var _this8 = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this8.props.name);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    },\n\t    hangup: {\n\t        method: function method() {\n\t            return _phoneService2.default.hangup();\n\t        }\n\t    },\n\t    hold: {\n\t        method: function method() {\n\t            return _phoneService2.default.hold(!this.props.isHold);\n\t        }\n\t    },\n\t    mute: {\n\t        method: function method() {\n\t            return _phoneService2.default.mute(!this.props.isMute);\n\t        }\n\t    },\n\t    flip: {\n\t        method: function method() {\n\t            return _phoneService2.default.flip(this.props.actionNumber);\n\t        }\n\t    },\n\t    transfer: {\n\t        method: function method() {\n\t            return _phoneService2.default.transfer(this.props.actionNumber);\n\t        }\n\t    },\n\t    record: {\n\t        method: function method() {\n\t            console.log(this.props.isRecord);\n\t            return _phoneService2.default.record(!this.props.isRecord);\n\t        }\n\t    },\n\t    park: {\n\t        method: function method() {\n\t            return _phoneService2.default.park();\n\t        }\n\t    },\n\t    dtmf: {\n\t        method: function method(number) {\n\t            return _phoneService2.default.dtmf(this.props.dtmfNumber);\n\t        }\n\t    },\n\t    queryContacts: {\n\t        method: function method() {\n\t            var _this9 = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this9.props.inputValue);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    },\n\t    getOutboundCallerID: {\n\t        method: function method() {\n\t            return _accountService2.default.getPhoneNumber().then(function () {\n\t                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n\t            });\n\t        }\n\t    }\n\t};\n\tservices['call-panel-incoming'] = {\n\t    init: {\n\t        method: function method() {\n\t            var _this10 = this;\n\t\n\t            _phoneService2.default.on('invite', function (session) {\n\t                _this10.props.session = session;\n\t                var name = session.request.from.displayName || session.request.from.friendlyName.split(\"@\")[0];\n\t                _this10.setName(name);\n\t                _this10.mount(_this10.props.target);\n\t                _phoneService2.default.on('terminated', function () {\n\t                    _this10.unmount();\n\t                });\n\t                _phoneService2.default.on('failed', function () {\n\t                    _this10.unmount();\n\t                });\n\t            });\n\t        }\n\t    },\n\t    accept: {\n\t        method: function method() {\n\t            return _phoneService2.default.accept({\n\t                remoteVideo: this.props.remoteVideo,\n\t                localVideo: this.props.localVideo\n\t            });\n\t        }\n\t    },\n\t    reject: {\n\t        method: function method() {\n\t            return _phoneService2.default.reject();\n\t        }\n\t    },\n\t    forward: {\n\t        method: function method() {\n\t            return _phoneService2.default.forward(this.props.actionNumber);\n\t        }\n\t    },\n\t    queryContacts: {\n\t        method: function method() {\n\t            var _this11 = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this11.props.inputValue);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    }\n\t};\n\texports.default = services;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.RC = exports.injectSDK = undefined;\n\t\n\tvar _ringcentralBundle = __webpack_require__(5);\n\t\n\tvar _ringcentralBundle2 = _interopRequireDefault(_ringcentralBundle);\n\t\n\tvar _rcConfig = __webpack_require__(11);\n\t\n\tvar _rcConfig2 = _interopRequireDefault(_rcConfig);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar holder = {};\n\t\n\t// for dependency injection\n\tvar sdk = function () {\n\t    return holder.sdk;\n\t}();\n\t\n\tvar injectSDK = function injectSDK(_ref) {\n\t    var key = _ref.key;\n\t    var secret = _ref.secret;\n\t    var sandbox = _ref.sandbox;\n\t\n\t    holder.sdk = new _ringcentralBundle2.default({\n\t        appKey: key,\n\t        appSecret: secret,\n\t        server: sandbox ? _ringcentralBundle2.default.server.sandbox : _ringcentralBundle2.default.server.production\n\t    });\n\t};\n\texports.injectSDK = injectSDK;\n\texports.RC = holder;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"SDK\"] = factory();\n\t\telse\n\t\t\troot[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"SDK\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"/build/\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(2);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Copyright (c) 2014, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n\t * additional grant of patent rights can be found in the PATENTS file in\n\t * the same directory.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var iteratorSymbol =\n\t    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    // If outerFn provided, then outerFn.prototype instanceof Generator.\n\t    var generator = Object.create((outerFn || Generator).prototype);\n\t    var context = new Context(tryLocsList || []);\n\t\n\t    // The ._invoke method unifies the implementations of the .next,\n\t    // .throw, and .return methods.\n\t    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\t\n\t    return generator;\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function Generator() {}\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  // Helper for defining the .next, .throw, and .return methods of the\n\t  // Iterator interface in terms of a single ._invoke method.\n\t  function defineIteratorMethods(prototype) {\n\t    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n\t      prototype[method] = function(arg) {\n\t        return this._invoke(method, arg);\n\t      };\n\t    });\n\t  }\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    if (Object.setPrototypeOf) {\n\t      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n\t    } else {\n\t      genFun.__proto__ = GeneratorFunctionPrototype;\n\t    }\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  // Within the body of any async function, `await x` is transformed to\n\t  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n\t  // `value instanceof AwaitArgument` to determine if the yielded value is\n\t  // meant to be awaited. Some may consider the name of this method too\n\t  // cutesy, but they are curmudgeons.\n\t  runtime.awrap = function(arg) {\n\t    return new AwaitArgument(arg);\n\t  };\n\t\n\t  function AwaitArgument(arg) {\n\t    this.arg = arg;\n\t  }\n\t\n\t  function AsyncIterator(generator) {\n\t    // This invoke function is written in a style that assumes some\n\t    // calling function (or Promise) will handle exceptions.\n\t    function invoke(method, arg) {\n\t      var result = generator[method](arg);\n\t      var value = result.value;\n\t      return value instanceof AwaitArgument\n\t        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)\n\t        : Promise.resolve(value).then(function(unwrapped) {\n\t            // When a yielded Promise is resolved, its final value becomes\n\t            // the .value of the Promise<{value,done}> result for the\n\t            // current iteration. If the Promise is rejected, however, the\n\t            // result for this iteration will be rejected with the same\n\t            // reason. Note that rejections of yielded Promises are not\n\t            // thrown back into the generator function, as is the case\n\t            // when an awaited Promise is rejected. This difference in\n\t            // behavior between yield and await is important, because it\n\t            // allows the consumer to decide what to do with the yielded\n\t            // rejection (swallow it and continue, manually .throw it back\n\t            // into the generator, abandon iteration, whatever). With\n\t            // await, by contrast, there is no opportunity to examine the\n\t            // rejection reason outside the generator function, so the\n\t            // only option is to throw it from the await expression, and\n\t            // let the generator function handle the exception.\n\t            result.value = unwrapped;\n\t            return result;\n\t          });\n\t    }\n\t\n\t    if (typeof process === \"object\" && process.domain) {\n\t      invoke = process.domain.bind(invoke);\n\t    }\n\t\n\t    var invokeNext = invoke.bind(generator, \"next\");\n\t    var invokeThrow = invoke.bind(generator, \"throw\");\n\t    var invokeReturn = invoke.bind(generator, \"return\");\n\t    var previousPromise;\n\t\n\t    function enqueue(method, arg) {\n\t      function callInvokeWithMethodAndArg() {\n\t        return invoke(method, arg);\n\t      }\n\t\n\t      return previousPromise =\n\t        // If enqueue has been called before, then we want to wait until\n\t        // all previous Promises have been resolved before calling invoke,\n\t        // so that results are always delivered in the correct order. If\n\t        // enqueue has not been called before, then it is important to\n\t        // call invoke immediately, without waiting on a callback to fire,\n\t        // so that the async generator function has the opportunity to do\n\t        // any necessary setup in a predictable way. This predictability\n\t        // is why the Promise constructor synchronously invokes its\n\t        // executor callback, and why async functions synchronously\n\t        // execute code before the first await. Since we implement simple\n\t        // async functions in terms of async generators, it is especially\n\t        // important to get this right, even though it requires care.\n\t        previousPromise ? previousPromise.then(\n\t          callInvokeWithMethodAndArg,\n\t          // Avoid propagating failures to Promises returned by later\n\t          // invocations of the iterator.\n\t          callInvokeWithMethodAndArg\n\t        ) : new Promise(function (resolve) {\n\t          resolve(callInvokeWithMethodAndArg());\n\t        });\n\t    }\n\t\n\t    // Define the unified helper method that is used to implement .next,\n\t    // .throw, and .return (see defineIteratorMethods).\n\t    this._invoke = enqueue;\n\t  }\n\t\n\t  defineIteratorMethods(AsyncIterator.prototype);\n\t\n\t  // Note that simple async functions are implemented on top of\n\t  // AsyncIterator objects; they just return a Promise for the value of\n\t  // the final result produced by the iterator.\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    var iter = new AsyncIterator(\n\t      wrap(innerFn, outerFn, self, tryLocsList)\n\t    );\n\t\n\t    return runtime.isGeneratorFunction(outerFn)\n\t      ? iter // If outerFn is a generator, return the full iterator.\n\t      : iter.next().then(function(result) {\n\t          return result.done ? result.value : iter.next();\n\t        });\n\t  };\n\t\n\t  function makeInvokeMethod(innerFn, self, context) {\n\t    var state = GenStateSuspendedStart;\n\t\n\t    return function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        if (method === \"throw\") {\n\t          throw arg;\n\t        }\n\t\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          if (method === \"return\" ||\n\t              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n\t            // A return or throw (when the delegate iterator has no throw\n\t            // method) always terminates the yield* loop.\n\t            context.delegate = null;\n\t\n\t            // If the delegate iterator has a return method, give it a\n\t            // chance to clean up.\n\t            var returnMethod = delegate.iterator[\"return\"];\n\t            if (returnMethod) {\n\t              var record = tryCatch(returnMethod, delegate.iterator, arg);\n\t              if (record.type === \"throw\") {\n\t                // If the return method threw an exception, let that\n\t                // exception prevail over the original return or throw.\n\t                method = \"throw\";\n\t                arg = record.arg;\n\t                continue;\n\t              }\n\t            }\n\t\n\t            if (method === \"return\") {\n\t              // Continue with the outer return, now that the delegate\n\t              // iterator has been terminated.\n\t              continue;\n\t            }\n\t          }\n\t\n\t          var record = tryCatch(\n\t            delegate.iterator[method],\n\t            delegate.iterator,\n\t            arg\n\t          );\n\t\n\t          if (record.type === \"throw\") {\n\t            context.delegate = null;\n\t\n\t            // Like returning generator.throw(uncaught), but without the\n\t            // overhead of an extra function call.\n\t            method = \"throw\";\n\t            arg = record.arg;\n\t            continue;\n\t          }\n\t\n\t          // Delegate generator ran and handled its own exceptions so\n\t          // regardless of what the method was, we continue as if it is\n\t          // \"next\" with an undefined arg.\n\t          method = \"next\";\n\t          arg = undefined;\n\t\n\t          var info = record.arg;\n\t          if (info.done) {\n\t            context[delegate.resultName] = info.value;\n\t            context.next = delegate.nextLoc;\n\t          } else {\n\t            state = GenStateSuspendedYield;\n\t            return info;\n\t          }\n\t\n\t          context.delegate = null;\n\t        }\n\t\n\t        if (method === \"next\") {\n\t          context._sent = arg;\n\t\n\t          if (state === GenStateSuspendedYield) {\n\t            context.sent = arg;\n\t          } else {\n\t            context.sent = undefined;\n\t          }\n\t        } else if (method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw arg;\n\t          }\n\t\n\t          if (context.dispatchException(arg)) {\n\t            // If the dispatched exception was caught by a catch block,\n\t            // then let that catch block handle the exception normally.\n\t            method = \"next\";\n\t            arg = undefined;\n\t          }\n\t\n\t        } else if (method === \"return\") {\n\t          context.abrupt(\"return\", arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          var info = {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            if (context.delegate && method === \"next\") {\n\t              // Deliberately forget the last sent value so that we don't\n\t              // accidentally pass it on to the delegate.\n\t              arg = undefined;\n\t            }\n\t          } else {\n\t            return info;\n\t          }\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t          // Dispatch the exception by looping back around to the\n\t          // context.dispatchException(arg) call above.\n\t          method = \"throw\";\n\t          arg = record.arg;\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  // Define Generator.prototype.{next,throw,return} in terms of the\n\t  // unified ._invoke helper method.\n\t  defineIteratorMethods(Gp);\n\t\n\t  Gp[iteratorSymbol] = function() {\n\t    return this;\n\t  };\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset(true);\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function(skipTempReset) {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      this.sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      if (!skipTempReset) {\n\t        for (var name in this) {\n\t          // Not sure about the optimal order of these conditions:\n\t          if (name.charAt(0) === \"t\" &&\n\t              hasOwn.call(this, name) &&\n\t              !isNaN(+name.slice(1))) {\n\t            this[name] = undefined;\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t        return !!caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") &&\n\t            this.prev < entry.finallyLoc) {\n\t          var finallyEntry = entry;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (finallyEntry &&\n\t          (type === \"break\" ||\n\t           type === \"continue\") &&\n\t          finallyEntry.tryLoc <= arg &&\n\t          arg <= finallyEntry.finallyLoc) {\n\t        // Ignore the finally entry if control is not jumping to a\n\t        // location outside the try/catch block.\n\t        finallyEntry = null;\n\t      }\n\t\n\t      var record = finallyEntry ? finallyEntry.completion : {};\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (finallyEntry) {\n\t        this.next = finallyEntry.finallyLoc;\n\t      } else {\n\t        this.complete(record);\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = record.arg;\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.finallyLoc === finallyLoc) {\n\t          this.complete(entry.completion, entry.afterLoc);\n\t          resetTryEntry(entry);\n\t          return ContinueSentinel;\n\t        }\n\t      }\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // Among the various tricks for obtaining a reference to the global\n\t  // object, this seems to be the most reliable technique that does not\n\t  // use indirect eval (which violates Content Security Policy).\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this\n\t);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tvar Utils = _interopRequireWildcard(_Utils);\n\t\n\tvar _Cache = __webpack_require__(12);\n\t\n\tvar _Cache2 = _interopRequireDefault(_Cache);\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar Externals = _interopRequireWildcard(_Externals);\n\t\n\tvar _Observable = __webpack_require__(13);\n\t\n\tvar _Observable2 = _interopRequireDefault(_Observable);\n\t\n\tvar _Queue = __webpack_require__(14);\n\t\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\t\n\tvar _Client = __webpack_require__(15);\n\t\n\tvar _Client2 = _interopRequireDefault(_Client);\n\t\n\tvar _ApiResponse = __webpack_require__(16);\n\t\n\tvar _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n\t\n\tvar _ClientMock = __webpack_require__(17);\n\t\n\tvar _ClientMock2 = _interopRequireDefault(_ClientMock);\n\t\n\tvar _Mock = __webpack_require__(19);\n\t\n\tvar _Mock2 = _interopRequireDefault(_Mock);\n\t\n\tvar _Registry = __webpack_require__(18);\n\t\n\tvar _Registry2 = _interopRequireDefault(_Registry);\n\t\n\tvar _Platform = __webpack_require__(20);\n\t\n\tvar _Platform2 = _interopRequireDefault(_Platform);\n\t\n\tvar _Auth = __webpack_require__(21);\n\t\n\tvar _Auth2 = _interopRequireDefault(_Auth);\n\t\n\tvar _PubnubFactory = __webpack_require__(22);\n\t\n\tvar _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);\n\t\n\tvar _Subscription = __webpack_require__(24);\n\t\n\tvar _Subscription2 = _interopRequireDefault(_Subscription);\n\t\n\tvar _CachedSubscription = __webpack_require__(25);\n\t\n\tvar _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar SDK = function () {\n\t\n\t    /**\n\t     * @namespace RingCentral\n\t     * @constructor\n\t     * @param {object} [options]\n\t     * @param {string} [options.server]\n\t     * @param {string} [options.cachePrefix]\n\t     * @param {string} [options.appSecret]\n\t     * @param {string} [options.appKey]\n\t     * @param {string} [options.appName]\n\t     * @param {string} [options.appVersion]\n\t     * @param {string} [options.pubnubFactory]\n\t     * @param {string} [options.client]\n\t     */\n\t\n\t    function SDK(options) {\n\t        _classCallCheck(this, SDK);\n\t\n\t        options = options || {};\n\t\n\t        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);\n\t\n\t        this._client = options.client || new _Client2.default();\n\t\n\t        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);\n\t\n\t        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;\n\t    }\n\t\n\t    /**\n\t     * @return {Platform}\n\t     */\n\t\n\t\n\t    SDK.prototype.platform = function platform() {\n\t        return this._platform;\n\t    };\n\t\n\t    /**\n\t     * @return {Subscription}\n\t     */\n\t\n\t\n\t    SDK.prototype.createSubscription = function createSubscription() {\n\t        return new _Subscription2.default(this._pubnubFactory, this._platform);\n\t    };\n\t\n\t    /**\n\t     * @return {CachedSubscription}\n\t     */\n\t\n\t\n\t    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {\n\t        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);\n\t    };\n\t\n\t    /**\n\t     * @return {Cache}\n\t     */\n\t\n\t\n\t    SDK.prototype.cache = function cache() {\n\t        return this._cache;\n\t    };\n\t\n\t    SDK.handleAuthRedirect = function handleAuthRedirect(origin) {\n\t        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);\n\t    };\n\t\n\t    return SDK;\n\t}();\n\t\n\tSDK.version = '2.0.6';\n\tSDK.server = {\n\t    sandbox: 'https://platform.devtest.ringcentral.com',\n\t    production: 'https://platform.ringcentral.com'\n\t};\n\tSDK.core = {\n\t    Cache: _Cache2.default,\n\t    Observable: _Observable2.default,\n\t    Utils: Utils,\n\t    Externals: Externals,\n\t    Queue: _Queue2.default\n\t};\n\tSDK.http = {\n\t    Client: _Client2.default,\n\t    ApiResponse: _ApiResponse2.default\n\t};\n\tSDK.platform = {\n\t    Auth: _Auth2.default,\n\t    Platform: _Platform2.default\n\t};\n\tSDK.subscription = {\n\t    Subscription: _Subscription2.default\n\t};\n\tSDK.mocks = {\n\t    Client: _ClientMock2.default,\n\t    Registry: _Registry2.default,\n\t    Mock: _Mock2.default\n\t};\n\tSDK.pubnub = {\n\t    PubnubMockFactory: _PubnubFactory2.default\n\t};\n\t\n\t\n\tmodule.exports = SDK;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\texports.queryStringify = queryStringify;\n\texports.parseQueryString = parseQueryString;\n\texports.isFunction = isFunction;\n\texports.isArray = isArray;\n\texports.isObject = isObject;\n\texports.isObjectObject = isObjectObject;\n\texports.isPlainObject = isPlainObject;\n\texports.poll = poll;\n\texports.stopPolling = stopPolling;\n\texports.isNodeJS = isNodeJS;\n\texports.isBrowser = isBrowser;\n\texports.delay = delay;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\t/**\n\t * TODO Replace with something better\n\t * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n\t * @param {object} parameters\n\t * @returns {string}\n\t */\n\tfunction queryStringify(parameters) {\n\t\n\t    var array = [];\n\t\n\t    parameters = parameters || {};\n\t\n\t    Object.keys(parameters).forEach(function (k) {\n\t\n\t        var v = parameters[k];\n\t\n\t        if (isArray(v)) {\n\t            v.forEach(function (vv) {\n\t                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));\n\t            });\n\t        } else {\n\t            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));\n\t        }\n\t    });\n\t\n\t    return array.join('&');\n\t}\n\t\n\t/**\n\t * TODO Replace with something better\n\t * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n\t * @param {string} queryString\n\t * @returns {object}\n\t */\n\tfunction parseQueryString(queryString) {\n\t\n\t    var argsParsed = {};\n\t\n\t    queryString.split('&').forEach(function (arg) {\n\t\n\t        arg = decodeURIComponent(arg);\n\t\n\t        if (arg.indexOf('=') == -1) {\n\t\n\t            argsParsed[arg.trim()] = true;\n\t        } else {\n\t\n\t            var pair = arg.split('='),\n\t                key = pair[0].trim(),\n\t                value = pair[1].trim();\n\t\n\t            if (key in argsParsed) {\n\t                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];\n\t                argsParsed[key].push(value);\n\t            } else {\n\t                argsParsed[key] = value;\n\t            }\n\t        }\n\t    });\n\t\n\t    return argsParsed;\n\t}\n\t\n\t/**\n\t * @param obj\n\t * @return {boolean}\n\t */\n\tfunction isFunction(obj) {\n\t    return typeof obj === \"function\";\n\t}\n\t\n\t/**\n\t * @param obj\n\t * @return {boolean}\n\t */\n\tfunction isArray(obj) {\n\t    return Array.isArray ? Array.isArray(obj) : typeof obj === \"array\";\n\t}\n\t\n\tfunction isObject(o) {\n\t    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);\n\t}\n\t\n\tfunction isObjectObject(o) {\n\t    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n\t}\n\t\n\tfunction isPlainObject(o) {\n\t    var ctor, prot;\n\t\n\t    if (isObjectObject(o) === false) return false;\n\t\n\t    // If has modified constructor\n\t    ctor = o.constructor;\n\t    if (typeof ctor !== 'function') return false;\n\t\n\t    // If has modified prototype\n\t    prot = ctor.prototype;\n\t    if (isObjectObject(prot) === false) return false;\n\t\n\t    // If constructor does not have an Object-specific method\n\t    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n\t        return false;\n\t    }\n\t\n\t    // Most likely a plain Object\n\t    return true;\n\t}\n\t\n\t/**\n\t * @param fn\n\t * @param interval\n\t * @param timeout\n\t */\n\tfunction poll(fn, interval, timeout) {\n\t    //NodeJS.Timer|number\n\t\n\t    module.exports.stopPolling(timeout);\n\t\n\t    interval = interval || 1000;\n\t\n\t    var next = function next(delay) {\n\t\n\t        delay = delay || interval;\n\t\n\t        interval = delay;\n\t\n\t        return setTimeout(function () {\n\t\n\t            fn(next, delay);\n\t        }, delay);\n\t    };\n\t\n\t    return next();\n\t}\n\t\n\tfunction stopPolling(timeout) {\n\t    if (timeout) clearTimeout(timeout);\n\t}\n\t\n\tfunction isNodeJS() {\n\t    return typeof process !== 'undefined';\n\t}\n\t\n\tfunction isBrowser() {\n\t    return typeof window !== 'undefined';\n\t}\n\t\n\tfunction delay(timeout) {\n\t    return new _Externals.Promise(function (resolve, reject) {\n\t        setTimeout(function () {\n\t            resolve(null);\n\t        }, timeout);\n\t    });\n\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;\n\t\n\tvar _es6Promise = __webpack_require__(5);\n\t\n\tvar _es6Promise2 = _interopRequireDefault(_es6Promise);\n\t\n\tvar _nodeFetch = __webpack_require__(10);\n\t\n\tvar _nodeFetch2 = _interopRequireDefault(_nodeFetch);\n\t\n\tvar _pubnub = __webpack_require__(11);\n\t\n\tvar _pubnub2 = _interopRequireDefault(_pubnub);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar root = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function(\"return this;\")();\n\t\n\tvar Promise = exports.Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;\n\t\n\tvar fetch = exports.fetch = root.fetch || _nodeFetch2.default;\n\tvar Request = exports.Request = root.Request || fetch.Request;\n\tvar Response = exports.Response = root.Response || fetch.Response;\n\tvar Headers = exports.Headers = root.Headers || fetch.Headers;\n\t\n\tvar PUBNUB = exports.PUBNUB = root.PUBNUB || _pubnub2.default;\n\t\n\tvar localStorage = exports.localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   2.2.0\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$toString = {}.toString;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    function lib$es6$promise$asap$$asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$default = lib$es6$promise$asap$$asap;\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      var nextTick = process.nextTick;\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // setImmediate should be used instead instead\n\t      var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n\t      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n\t        nextTick = setImmediate;\n\t      }\n\t      return function() {\n\t        nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertex() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"vertx\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFullfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$default(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n\t      if (maybeThenable.constructor === promise.constructor) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\t\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      var enumerator = this;\n\t\n\t      enumerator._instanceConstructor = Constructor;\n\t      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (enumerator._validateInput(input)) {\n\t        enumerator._input     = input;\n\t        enumerator.length     = input.length;\n\t        enumerator._remaining = input.length;\n\t\n\t        enumerator._init();\n\t\n\t        if (enumerator.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t        } else {\n\t          enumerator.length = enumerator.length || 0;\n\t          enumerator._enumerate();\n\t          if (enumerator._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n\t      return lib$es6$promise$utils$$isArray(input);\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n\t      this._result = new Array(this.length);\n\t    };\n\t\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var enumerator = this;\n\t\n\t      var length  = enumerator.length;\n\t      var promise = enumerator.promise;\n\t      var input   = enumerator._input;\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        enumerator._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var enumerator = this;\n\t      var c = enumerator._instanceConstructor;\n\t\n\t      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n\t        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          entry._onerror = null;\n\t          enumerator._settledAt(entry._state, i, entry._result);\n\t        } else {\n\t          enumerator._willSettleAt(c.resolve(entry), i);\n\t        }\n\t      } else {\n\t        enumerator._remaining--;\n\t        enumerator._result[i] = entry;\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var enumerator = this;\n\t      var promise = enumerator.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        enumerator._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          enumerator._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (enumerator._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$es6$promise$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t    var lib$es6$promise$promise$$counter = 0;\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promises eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this._id = lib$es6$promise$promise$$counter++;\n\t      this._state = undefined;\n\t      this._result = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n\t          lib$es6$promise$promise$$needsResolver();\n\t        }\n\t\n\t        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n\t          lib$es6$promise$promise$$needsNew();\n\t        }\n\t\n\t        lib$es6$promise$$internal$$initializePromise(this, resolver);\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$default;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: function(onFulfillment, onRejection) {\n\t        var parent = this;\n\t        var state = parent._state;\n\t\n\t        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n\t          return this;\n\t        }\n\t\n\t        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t        var result = parent._result;\n\t\n\t        if (state) {\n\t          var callback = arguments[state - 1];\n\t          lib$es6$promise$asap$$default(function(){\n\t            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n\t          });\n\t        } else {\n\t          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t        }\n\t\n\t        return child;\n\t      },\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(9)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, (function() { return this; }()), __webpack_require__(8)(module)))\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(7).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, __webpack_require__(6).clearImmediate))\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\t\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\t\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports) {\n\t\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\n\t\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports) {\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  var support = {\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob();\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this._initBody(bodyInit)\n\t    this.type = 'default'\n\t    this.url = null\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  self.Headers = Headers;\n\t  self.Request = Request;\n\t  self.Response = Response;\n\t\n\t  self.fetch = function(input, init) {\n\t    var request\n\t    if (Request.prototype.isPrototypeOf(input) && !init) {\n\t      request = input\n\t    } else {\n\t      request = new Request(input, init)\n\t    }\n\t\n\t    return new Promise(function(resolve, reject) {\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return;\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var status = (xhr.status === 1223) ? 204 : xhr.status\n\t        if (status < 100 || status > 599) {\n\t          reject(new TypeError('Network request failed'))\n\t          return\n\t        }\n\t        var options = {\n\t          status: status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})();\n\t\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(module) {// Version: 3.7.16\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t/* =-=========================     JSON     =============================-= */\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t\n\t(window['JSON'] && window['JSON']['stringify']) || (function () {\n\t    window['JSON'] || (window['JSON'] = {});\n\t\n\t    function toJSON(key) {\n\t        try      { return this.valueOf() }\n\t        catch(e) { return null }\n\t    }\n\t\n\t    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t        gap,\n\t        indent,\n\t        meta = {    // table of character substitutions\n\t            '\\b': '\\\\b',\n\t            '\\t': '\\\\t',\n\t            '\\n': '\\\\n',\n\t            '\\f': '\\\\f',\n\t            '\\r': '\\\\r',\n\t            '\"' : '\\\\\"',\n\t            '\\\\': '\\\\\\\\'\n\t        },\n\t        rep;\n\t\n\t    function quote(string) {\n\t        escapable.lastIndex = 0;\n\t        return escapable.test(string) ?\n\t            '\"' + string.replace(escapable, function (a) {\n\t                var c = meta[a];\n\t                return typeof c === 'string' ? c :\n\t                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t            }) + '\"' :\n\t            '\"' + string + '\"';\n\t    }\n\t\n\t    function str(key, holder) {\n\t        var i,          // The loop counter.\n\t            k,          // The member key.\n\t            v,          // The member value.\n\t            length,\n\t            partial,\n\t            mind  = gap,\n\t            value = holder[key];\n\t\n\t        if (value && typeof value === 'object') {\n\t            value = toJSON.call( value, key );\n\t        }\n\t\n\t        if (typeof rep === 'function') {\n\t            value = rep.call(holder, key, value);\n\t        }\n\t\n\t        switch (typeof value) {\n\t        case 'string':\n\t            return quote(value);\n\t\n\t        case 'number':\n\t            return isFinite(value) ? String(value) : 'null';\n\t\n\t        case 'boolean':\n\t        case 'null':\n\t            return String(value);\n\t\n\t        case 'object':\n\t\n\t            if (!value) {\n\t                return 'null';\n\t            }\n\t\n\t            gap += indent;\n\t            partial = [];\n\t\n\t            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\t\n\t                length = value.length;\n\t                for (i = 0; i < length; i += 1) {\n\t                    partial[i] = str(i, value) || 'null';\n\t                }\n\t\n\t                v = partial.length === 0 ? '[]' :\n\t                    gap ? '[\\n' + gap +\n\t                            partial.join(',\\n' + gap) + '\\n' +\n\t                                mind + ']' :\n\t                          '[' + partial.join(',') + ']';\n\t                gap = mind;\n\t                return v;\n\t            }\n\t            if (rep && typeof rep === 'object') {\n\t                length = rep.length;\n\t                for (i = 0; i < length; i += 1) {\n\t                    k = rep[i];\n\t                    if (typeof k === 'string') {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (k in value) {\n\t                    if (Object.hasOwnProperty.call(value, k)) {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t\n\t            v = partial.length === 0 ? '{}' :\n\t                gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n\t                        mind + '}' : '{' + partial.join(',') + '}';\n\t            gap = mind;\n\t            return v;\n\t        }\n\t    }\n\t\n\t    if (typeof JSON['stringify'] !== 'function') {\n\t        JSON['stringify'] = function (value, replacer, space) {\n\t            var i;\n\t            gap = '';\n\t            indent = '';\n\t\n\t            if (typeof space === 'number') {\n\t                for (i = 0; i < space; i += 1) {\n\t                    indent += ' ';\n\t                }\n\t            } else if (typeof space === 'string') {\n\t                indent = space;\n\t            }\n\t            rep = replacer;\n\t            if (replacer && typeof replacer !== 'function' &&\n\t                    (typeof replacer !== 'object' ||\n\t                     typeof replacer.length !== 'number')) {\n\t                throw new Error('JSON.stringify');\n\t            }\n\t            return str('', {'': value});\n\t        };\n\t    }\n\t\n\t    if (typeof JSON['parse'] !== 'function') {\n\t        // JSON is parsed on the server for security.\n\t        JSON['parse'] = function (text) {return eval('('+text+')')};\n\t    }\n\t}());\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t/* =-=========================     UTIL     =============================-= */\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t\n\twindow['PUBNUB'] || (function() {\n\tvar NOW             = 1\n\t,   READY           = false\n\t,   READY_BUFFER    = []\n\t,   PRESENCE_SUFFIX = '-pnpres'\n\t,   DEF_WINDOWING   = 10     // MILLISECONDS.\n\t,   DEF_TIMEOUT     = 10000  // MILLISECONDS.\n\t,   DEF_SUB_TIMEOUT = 310    // SECONDS.\n\t,   DEF_KEEPALIVE   = 60     // SECONDS (FOR TIMESYNC).\n\t,   SECOND          = 1000   // A THOUSAND MILLISECONDS.\n\t,   URLBIT          = '/'\n\t,   PARAMSBIT       = '&'\n\t,   PRESENCE_HB_THRESHOLD = 5\n\t,   PRESENCE_HB_DEFAULT  = 30\n\t,   SDK_VER         = '3.7.16'\n\t,   REPL            = /{([\\w\\-]+)}/g;\n\t\n\t/**\n\t * UTILITIES\n\t */\n\tfunction unique() { return'x'+ ++NOW+''+(+new Date) }\n\tfunction rnow()   { return+new Date }\n\t\n\t/**\n\t * NEXTORIGIN\n\t * ==========\n\t * var next_origin = nextorigin();\n\t */\n\tvar nextorigin = (function() {\n\t    var max = 20\n\t    ,   ori = Math.floor(Math.random() * max);\n\t    return function( origin, failover ) {\n\t        return origin.indexOf('pubsub.') > 0\n\t            && origin.replace(\n\t             'pubsub', 'ps' + (\n\t                failover ? generate_uuid().split('-')[0] :\n\t                (++ori < max? ori : ori=1)\n\t            ) ) || origin;\n\t    }\n\t})();\n\t\n\t\n\t/**\n\t * Build Url\n\t * =======\n\t *\n\t */\n\tfunction build_url( url_components, url_params ) {\n\t    var url    = url_components.join(URLBIT)\n\t    ,   params = [];\n\t\n\t    if (!url_params) return url;\n\t\n\t    each( url_params, function( key, value ) {\n\t        var value_str = (typeof value == 'object')?JSON['stringify'](value):value;\n\t        (typeof value != 'undefined' &&\n\t            value != null && encode(value_str).length > 0\n\t        ) && params.push(key + \"=\" + encode(value_str));\n\t    } );\n\t\n\t    url += \"?\" + params.join(PARAMSBIT);\n\t    return url;\n\t}\n\t\n\t/**\n\t * UPDATER\n\t * =======\n\t * var timestamp = unique();\n\t */\n\tfunction updater( fun, rate ) {\n\t    var timeout\n\t    ,   last   = 0\n\t    ,   runnit = function() {\n\t        if (last + rate > rnow()) {\n\t            clearTimeout(timeout);\n\t            timeout = setTimeout( runnit, rate );\n\t        }\n\t        else {\n\t            last = rnow();\n\t            fun();\n\t        }\n\t    };\n\t\n\t    return runnit;\n\t}\n\t\n\t/**\n\t * GREP\n\t * ====\n\t * var list = grep( [1,2,3], function(item) { return item % 2 } )\n\t */\n\tfunction grep( list, fun ) {\n\t    var fin = [];\n\t    each( list || [], function(l) { fun(l) && fin.push(l) } );\n\t    return fin\n\t}\n\t\n\t/**\n\t * SUPPLANT\n\t * ========\n\t * var text = supplant( 'Hello {name}!', { name : 'John' } )\n\t */\n\tfunction supplant( str, values ) {\n\t    return str.replace( REPL, function( _, match ) {\n\t        return values[match] || _\n\t    } );\n\t}\n\t\n\t/**\n\t * timeout\n\t * =======\n\t * timeout( function(){}, 100 );\n\t */\n\tfunction timeout( fun, wait ) {\n\t    return setTimeout( fun, wait );\n\t}\n\t\n\t/**\n\t * uuid\n\t * ====\n\t * var my_uuid = generate_uuid();\n\t */\n\tfunction generate_uuid(callback) {\n\t    var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,\n\t    function(c) {\n\t        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n\t        return v.toString(16);\n\t    });\n\t    if (callback) callback(u);\n\t    return u;\n\t}\n\t\n\tfunction isArray(arg) {\n\t  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n\t  //return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n\t}\n\t\n\t/**\n\t * EACH\n\t * ====\n\t * each( [1,2,3], function(item) { } )\n\t */\n\tfunction each( o, f) {\n\t    if ( !o || !f ) return;\n\t\n\t    if ( isArray(o) )\n\t        for ( var i = 0, l = o.length; i < l; )\n\t            f.call( o[i], o[i], i++ );\n\t    else\n\t        for ( var i in o )\n\t            o.hasOwnProperty    &&\n\t            o.hasOwnProperty(i) &&\n\t            f.call( o[i], i, o[i] );\n\t}\n\t\n\t/**\n\t * MAP\n\t * ===\n\t * var list = map( [1,2,3], function(item) { return item + 1 } )\n\t */\n\tfunction map( list, fun ) {\n\t    var fin = [];\n\t    each( list || [], function( k, v ) { fin.push(fun( k, v )) } );\n\t    return fin;\n\t}\n\t\n\t\n\tfunction pam_encode(str) {\n\t  return encodeURIComponent(str).replace(/[!'()*~]/g, function(c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t  });\n\t}\n\t\n\t/**\n\t * ENCODE\n\t * ======\n\t * var encoded_data = encode('path');\n\t */\n\tfunction encode(path) { return encodeURIComponent(path) }\n\t\n\t/**\n\t * Generate Subscription Channel List\n\t * ==================================\n\t * generate_channel_list(channels_object);\n\t */\n\tfunction generate_channel_list(channels, nopresence) {\n\t    var list = [];\n\t    each( channels, function( channel, status ) {\n\t        if (nopresence) {\n\t            if(channel.search('-pnpres') < 0) {\n\t                if (status.subscribed) list.push(channel);\n\t            }\n\t        } else {\n\t            if (status.subscribed) list.push(channel);\n\t        }\n\t    });\n\t    return list.sort();\n\t}\n\t\n\t/**\n\t * Generate Subscription Channel Groups List\n\t * ==================================\n\t * generate_channel_group_list(channels_groups object);\n\t */\n\tfunction generate_channel_group_list(channel_groups, nopresence) {\n\t    var list = [];\n\t    each(channel_groups, function( channel_group, status ) {\n\t        if (nopresence) {\n\t            if(channel_group.search('-pnpres') < 0) {\n\t                if (status.subscribed) list.push(channel_group);\n\t            }\n\t        } else {\n\t            if (status.subscribed) list.push(channel_group);\n\t        }\n\t    });\n\t    return list.sort();\n\t}\n\t\n\t// PUBNUB READY TO CONNECT\n\tfunction ready() { timeout( function() {\n\t    if (READY) return;\n\t    READY = 1;\n\t    each( READY_BUFFER, function(connect) { connect() } );\n\t}, SECOND ); }\n\t\n\tfunction PNmessage(args) {\n\t    msg = args || {'apns' : {}},\n\t    msg['getPubnubMessage'] = function() {\n\t        var m = {};\n\t\n\t        if (Object.keys(msg['apns']).length) {\n\t            m['pn_apns'] = {\n\t                    'aps' : {\n\t                        'alert' : msg['apns']['alert'] ,\n\t                        'badge' : msg['apns']['badge']\n\t                    }\n\t            }\n\t            for (var k in msg['apns']) {\n\t                m['pn_apns'][k] = msg['apns'][k];\n\t            }\n\t            var exclude1 = ['badge','alert'];\n\t            for (var k in exclude1) {\n\t                delete m['pn_apns'][exclude1[k]];\n\t            }\n\t        }\n\t\n\t\n\t\n\t        if (msg['gcm']) {\n\t            m['pn_gcm'] = {\n\t                'data' : msg['gcm']\n\t            }\n\t        }\n\t\n\t        for (var k in msg) {\n\t            m[k] = msg[k];\n\t        }\n\t        var exclude = ['apns','gcm','publish', 'channel','callback','error'];\n\t        for (var k in exclude) {\n\t            delete m[exclude[k]];\n\t        }\n\t\n\t        return m;\n\t    };\n\t    msg['publish'] = function() {\n\t\n\t        var m = msg.getPubnubMessage();\n\t\n\t        if (msg['pubnub'] && msg['channel']) {\n\t            msg['pubnub'].publish({\n\t                'message' : m,\n\t                'channel' : msg['channel'],\n\t                'callback' : msg['callback'],\n\t                'error' : msg['error']\n\t            })\n\t        }\n\t    };\n\t    return msg;\n\t}\n\t\n\tfunction PN_API(setup) {\n\t    var SUB_WINDOWING =  +setup['windowing']   || DEF_WINDOWING\n\t    ,   SUB_TIMEOUT   = (+setup['timeout']     || DEF_SUB_TIMEOUT) * SECOND\n\t    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n\t    ,   TIME_CHECK    = setup['timecheck']     || 0\n\t    ,   NOLEAVE       = setup['noleave']       || 0\n\t    ,   PUBLISH_KEY   = setup['publish_key']\n\t    ,   SUBSCRIBE_KEY = setup['subscribe_key']\n\t    ,   AUTH_KEY      = setup['auth_key']      || ''\n\t    ,   SECRET_KEY    = setup['secret_key']    || ''\n\t    ,   hmac_SHA256   = setup['hmac_SHA256']\n\t    ,   SSL           = setup['ssl']            ? 's' : ''\n\t    ,   ORIGIN        = 'http'+SSL+'://'+(setup['origin']||'pubsub.pubnub.com')\n\t    ,   STD_ORIGIN    = nextorigin(ORIGIN)\n\t    ,   SUB_ORIGIN    = nextorigin(ORIGIN)\n\t    ,   CONNECT       = function(){}\n\t    ,   PUB_QUEUE     = []\n\t    ,   CLOAK         = true\n\t    ,   TIME_DRIFT    = 0\n\t    ,   SUB_CALLBACK  = 0\n\t    ,   SUB_CHANNEL   = 0\n\t    ,   SUB_RECEIVER  = 0\n\t    ,   SUB_RESTORE   = setup['restore'] || 0\n\t    ,   SUB_BUFF_WAIT = 0\n\t    ,   TIMETOKEN     = 0\n\t    ,   RESUMED       = false\n\t    ,   CHANNELS      = {}\n\t    ,   CHANNEL_GROUPS       = {}\n\t    ,   SUB_ERROR     = function(){}\n\t    ,   STATE         = {}\n\t    ,   PRESENCE_HB_TIMEOUT  = null\n\t    ,   PRESENCE_HB          = validate_presence_heartbeat(\n\t        setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']\n\t    )\n\t    ,   PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) -1\n\t    ,   PRESENCE_HB_RUNNING  = false\n\t    ,   NO_WAIT_FOR_PENDING  = setup['no_wait_for_pending']\n\t    ,   COMPATIBLE_35 = setup['compatible_3.5']  || false\n\t    ,   xdr           = setup['xdr']\n\t    ,   params        = setup['params'] || {}\n\t    ,   error         = setup['error']      || function() {}\n\t    ,   _is_online    = setup['_is_online'] || function() { return 1 }\n\t    ,   jsonp_cb      = setup['jsonp_cb']   || function() { return 0 }\n\t    ,   db            = setup['db']         || {'get': function(){}, 'set': function(){}}\n\t    ,   CIPHER_KEY    = setup['cipher_key']\n\t    ,   UUID          = setup['uuid'] || ( !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY+'uuid') || '')\n\t    ,   USE_INSTANCEID = setup['instance_id'] || false\n\t    ,   INSTANCEID    = ''\n\t    ,   shutdown      = setup['shutdown']\n\t    ,   use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined')?setup['use_send_beacon']:true\n\t    ,   sendBeacon    = (use_send_beacon)?setup['sendBeacon']:null\n\t    ,   _poll_timer\n\t    ,   _poll_timer2;\n\t\n\t    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n\t\n\t    var crypto_obj    = setup['crypto_obj'] ||\n\t        {\n\t            'encrypt' : function(a,key){ return a},\n\t            'decrypt' : function(b,key){return b}\n\t        };\n\t\n\t    function _get_url_params(data) {\n\t        if (!data) data = {};\n\t        each( params , function( key, value ) {\n\t            if (!(key in data)) data[key] = value;\n\t        });\n\t        return data;\n\t    }\n\t\n\t    function _object_to_key_list(o) {\n\t        var l = []\n\t        each( o , function( key, value ) {\n\t            l.push(key);\n\t        });\n\t        return l;\n\t    }\n\t    function _object_to_key_list_sorted(o) {\n\t        return _object_to_key_list(o).sort();\n\t    }\n\t\n\t    function _get_pam_sign_input_from_params(params) {\n\t        var si = \"\";\n\t        var l = _object_to_key_list_sorted(params);\n\t\n\t        for (var i in l) {\n\t            var k = l[i]\n\t            si += k + \"=\" + pam_encode(params[k]) ;\n\t            if (i != l.length - 1) si += \"&\"\n\t        }\n\t        return si;\n\t    }\n\t\n\t    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n\t        var err = false;\n\t\n\t        if (typeof heartbeat === 'undefined') {\n\t            return cur_heartbeat;\n\t        }\n\t\n\t        if (typeof heartbeat === 'number') {\n\t            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0)\n\t                err = false;\n\t            else\n\t                err = true;\n\t        } else if(typeof heartbeat === 'boolean'){\n\t            if (!heartbeat) {\n\t                return 0;\n\t            } else {\n\t                return PRESENCE_HB_DEFAULT;\n\t            }\n\t        } else {\n\t            err = true;\n\t        }\n\t\n\t        if (err) {\n\t            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n\t            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n\t        } else return heartbeat;\n\t    }\n\t\n\t    function encrypt(input, key) {\n\t        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n\t    }\n\t    function decrypt(input, key) {\n\t        return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||\n\t               crypto_obj['decrypt'](input, CIPHER_KEY) ||\n\t               input;\n\t    }\n\t\n\t    function error_common(message, callback) {\n\t        callback && callback({ 'error' : message || \"error occurred\"});\n\t        error && error(message);\n\t    }\n\t    function _presence_heartbeat() {\n\t\n\t        clearTimeout(PRESENCE_HB_TIMEOUT);\n\t\n\t        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||\n\t            PRESENCE_HB_INTERVAL < 1 ||\n\t            (!generate_channel_list(CHANNELS,true).length  && !generate_channel_group_list(CHANNEL_GROUPS, true).length ) )\n\t        {\n\t            PRESENCE_HB_RUNNING = false;\n\t            return;\n\t        }\n\t\n\t        PRESENCE_HB_RUNNING = true;\n\t        SELF['presence_heartbeat']({\n\t            'callback' : function(r) {\n\t                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n\t            },\n\t            'error' : function(e) {\n\t                error && error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n\t                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n\t            }\n\t        });\n\t    }\n\t\n\t    function start_presence_heartbeat() {\n\t        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n\t    }\n\t\n\t    function publish(next) {\n\t\n\t        if (NO_WAIT_FOR_PENDING) {\n\t            if (!PUB_QUEUE.length) return;\n\t        } else {\n\t            if (next) PUB_QUEUE.sending = 0;\n\t            if ( PUB_QUEUE.sending || !PUB_QUEUE.length ) return;\n\t            PUB_QUEUE.sending = 1;\n\t        }\n\t\n\t        xdr(PUB_QUEUE.shift());\n\t    }\n\t    function each_channel_group(callback) {\n\t        var count = 0;\n\t\n\t        each( generate_channel_group_list(CHANNEL_GROUPS), function(channel_group) {\n\t            var chang = CHANNEL_GROUPS[channel_group];\n\t\n\t            if (!chang) return;\n\t\n\t            count++;\n\t            (callback||function(){})(chang);\n\t        } );\n\t\n\t        return count;\n\t    }\n\t\n\t    function each_channel(callback) {\n\t        var count = 0;\n\t\n\t        each( generate_channel_list(CHANNELS), function(channel) {\n\t            var chan = CHANNELS[channel];\n\t\n\t            if (!chan) return;\n\t\n\t            count++;\n\t            (callback||function(){})(chan);\n\t        } );\n\t\n\t        return count;\n\t    }\n\t    function _invoke_callback(response, callback, err) {\n\t        if (typeof response == 'object') {\n\t            if (response['error']) {\n\t                var callback_data = {};\n\t\n\t                if (response['message']) {\n\t                    callback_data['message'] = response['message'];\n\t                }\n\t\n\t                if (response['payload']) {\n\t                    callback_data['payload'] = response['payload'];\n\t                }\n\t\n\t                err && err(callback_data);\n\t                return;\n\t\n\t            }\n\t            if (response['payload']) {\n\t                if (response['next_page'])\n\t                    callback && callback(response['payload'], response['next_page']);\n\t                else\n\t                    callback && callback(response['payload']);\n\t                return;\n\t            }\n\t        }\n\t        callback && callback(response);\n\t    }\n\t\n\t    function _invoke_error(response,err) {\n\t\n\t        if (typeof response == 'object' && response['error']) {\n\t                var callback_data = {};\n\t\n\t                if (response['message']) {\n\t                    callback_data['message'] = response['message'];\n\t                }\n\t\n\t                if (response['payload']) {\n\t                    callback_data['payload'] = response['payload'];\n\t                }\n\t                \n\t                err && err(callback_data);\n\t                return;\n\t        } else {\n\t            err && err(response);\n\t        }\n\t    }\n\t    function CR(args, callback, url1, data) {\n\t            var callback        = args['callback']      || callback\n\t            ,   err             = args['error']         || error\n\t            ,   jsonp           = jsonp_cb();\n\t\n\t            data = data || {};\n\t            \n\t            if (!data['auth']) {\n\t                data['auth'] = args['auth_key'] || AUTH_KEY;\n\t            }\n\t            \n\t            var url = [\n\t                    STD_ORIGIN, 'v1', 'channel-registration',\n\t                    'sub-key', SUBSCRIBE_KEY\n\t                ];\n\t\n\t            url.push.apply(url,url1);\n\t            \n\t            if (jsonp) data['callback']              = jsonp;\n\t            \n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t\n\t    }\n\t\n\t    // Announce Leave Event\n\t    var SELF = {\n\t        'LEAVE' : function( channel, blocking, auth_key, callback, error ) {\n\t\n\t            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n\t            ,   origin = nextorigin(ORIGIN)\n\t            ,   callback = callback || function(){}\n\t            ,   err      = error    || function(){}\n\t            ,   url\n\t            ,   params\n\t            ,   jsonp  = jsonp_cb();\n\t\n\t            // Prevent Leaving a Presence Channel\n\t            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\t\n\t\n\t            if (COMPATIBLE_35) {\n\t                if (!SSL)         return false;\n\t                if (jsonp == '0') return false;\n\t            }\n\t\n\t            if (NOLEAVE)  return false;\n\t\n\t            if (jsonp != '0') data['callback'] = jsonp;\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            url = [\n\t                    origin, 'v2', 'presence', 'sub_key',\n\t                    SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'\n\t                ];\n\t\n\t            params = _get_url_params(data);\n\t\n\t\n\t            if (sendBeacon) {\n\t                url_string = build_url(url, params);\n\t                if (sendBeacon(url_string)) {\n\t                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n\t                    return true;\n\t                }\n\t            }\n\t\n\t\n\t            xdr({\n\t                blocking : blocking || SSL,\n\t                timeout  : 2000,\n\t                callback : jsonp,\n\t                data     : params,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t            return true;\n\t        },\n\t        'LEAVE_GROUP' : function( channel_group, blocking, auth_key, callback, error ) {\n\t\n\t            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n\t            ,   origin = nextorigin(ORIGIN)\n\t            ,   url\n\t            ,   params\n\t            ,   callback = callback || function(){}\n\t            ,   err      = error    || function(){}\n\t            ,   jsonp  = jsonp_cb();\n\t\n\t            // Prevent Leaving a Presence Channel Group\n\t            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\t\n\t            if (COMPATIBLE_35) {\n\t                if (!SSL)         return false;\n\t                if (jsonp == '0') return false;\n\t            }\n\t\n\t            if (NOLEAVE)  return false;\n\t\n\t            if (jsonp != '0') data['callback'] = jsonp;\n\t\n\t            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            url = [\n\t                    origin, 'v2', 'presence', 'sub_key',\n\t                    SUBSCRIBE_KEY, 'channel', encode(','), 'leave'\n\t            ];\n\t\n\t            params = _get_url_params(data);\n\t\n\t            if (sendBeacon) {\n\t                url_string = build_url(url, params);\n\t                if (sendBeacon(url_string)) {\n\t                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            xdr({\n\t                blocking : blocking || SSL,\n\t                timeout  : 5000,\n\t                callback : jsonp,\n\t                data     : params,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t            return true;\n\t        },\n\t        'set_resumed' : function(resumed) {\n\t                RESUMED = resumed;\n\t        },\n\t        'get_cipher_key' : function() {\n\t            return CIPHER_KEY;\n\t        },\n\t        'set_cipher_key' : function(key) {\n\t            CIPHER_KEY = key;\n\t        },\n\t        'raw_encrypt' : function(input, key) {\n\t            return encrypt(input, key);\n\t        },\n\t        'raw_decrypt' : function(input, key) {\n\t            return decrypt(input, key);\n\t        },\n\t        'get_heartbeat' : function() {\n\t            return PRESENCE_HB;\n\t        },\n\t        \n\t        'set_heartbeat' : function(heartbeat, heartbeat_interval) {\n\t            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);\n\t            PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;\n\t            if (PRESENCE_HB == 2) {\n\t                PRESENCE_HB_INTERVAL = 1;\n\t            }\n\t            CONNECT();\n\t            _presence_heartbeat();\n\t        },\n\t        \n\t        'get_heartbeat_interval' : function() {\n\t            return PRESENCE_HB_INTERVAL;\n\t        },\n\t        \n\t        'set_heartbeat_interval' : function(heartbeat_interval) {\n\t            PRESENCE_HB_INTERVAL = heartbeat_interval;\n\t            _presence_heartbeat();\n\t        },\n\t        \n\t        'get_version' : function() {\n\t            return SDK_VER;\n\t        },\n\t        'getGcmMessageObject' : function(obj) {\n\t            return {\n\t                'data' : obj\n\t            }\n\t        },\n\t        'getApnsMessageObject' : function(obj) {\n\t            var x =  {\n\t                'aps' : { 'badge' : 1, 'alert' : ''}\n\t            }\n\t            for (k in obj) {\n\t                k[x] = obj[k];\n\t            }\n\t            return x;\n\t        },\n\t        'newPnMessage' : function() {\n\t            var x = {};\n\t            if (gcm) x['pn_gcm'] = gcm;\n\t            if (apns) x['pn_apns'] = apns;\n\t            for ( k in n ) {\n\t                x[k] = n[k];\n\t            }\n\t            return x;\n\t        },\n\t\n\t        '_add_param' : function(key,val) {\n\t            params[key] = val;\n\t        },\n\t\n\t        'channel_group' : function(args, callback) {\n\t            var ns_ch       = args['channel_group']\n\t            ,   callback    = callback         || args['callback']\n\t            ,   channels    = args['channels'] || args['channel']\n\t            ,   cloak       = args['cloak']\n\t            ,   namespace\n\t            ,   channel_group\n\t            ,   url = []\n\t            ,   data = {}\n\t            ,   mode = args['mode'] || 'add';\n\t\n\t\n\t            if (ns_ch) {\n\t                var ns_ch_a = ns_ch.split(':');\n\t\n\t                if (ns_ch_a.length > 1) {\n\t                    namespace = (ns_ch_a[0] === '*')?null:ns_ch_a[0];\n\t\n\t                    channel_group = ns_ch_a[1];\n\t                } else {\n\t                    channel_group = ns_ch_a[0];\n\t                }\n\t            }\n\t\n\t            namespace && url.push('namespace') && url.push(encode(namespace));\n\t\n\t            url.push('channel-group');\n\t\n\t            if (channel_group && channel_group !== '*') {\n\t                url.push(channel_group);\n\t            }\n\t\n\t            if (channels ) {\n\t                if (isArray(channels)) {\n\t                    channels = channels.join(',');\n\t                }\n\t                data[mode] = channels;\n\t                data['cloak'] = (CLOAK)?'true':'false';\n\t            } else {\n\t                if (mode === 'remove') url.push('remove');\n\t            }\n\t\n\t            if (typeof cloak != 'undefined') data['cloak'] = (cloak)?'true':'false';\n\t\n\t            CR(args, callback, url, data);\n\t        },\n\t\n\t        'channel_group_list_groups' : function(args, callback) {\n\t            var namespace;\n\t\n\t            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n\t            if (namespace) {\n\t                args[\"channel_group\"] = namespace + \":*\";\n\t            }\n\t\n\t            SELF['channel_group'](args, callback);\n\t        },\n\t\n\t        'channel_group_list_channels' : function(args, callback) {\n\t            if (!args['channel_group']) return error('Missing Channel Group');\n\t            SELF['channel_group'](args, callback);\n\t        },\n\t\n\t        'channel_group_remove_channel' : function(args, callback) {\n\t            if (!args['channel_group']) return error('Missing Channel Group');\n\t            if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n\t\n\t            args['mode'] = 'remove';\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_remove_group' : function(args, callback) {\n\t            if (!args['channel_group']) return error('Missing Channel Group');\n\t            if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n\t\n\t            args['mode'] = 'remove';\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_add_channel' : function(args, callback) {\n\t           if (!args['channel_group']) return error('Missing Channel Group');\n\t           if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_cloak' : function(args, callback) {\n\t            if (typeof args['cloak'] == 'undefined') {\n\t                callback(CLOAK);\n\t                return;\n\t            }\n\t            CLOAK = args['cloak'];\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_list_namespaces' : function(args, callback) {\n\t            var url = ['namespace'];\n\t            CR(args, callback, url);\n\t        },\n\t        'channel_group_remove_namespace' : function(args, callback) {\n\t            var url = ['namespace',args['namespace'],'remove'];\n\t            CR(args, callback, url);\n\t        },\n\t\n\t        /*\n\t            PUBNUB.history({\n\t                channel  : 'my_chat_channel',\n\t                limit    : 100,\n\t                callback : function(history) { }\n\t            });\n\t        */\n\t        'history' : function( args, callback ) {\n\t            var callback         = args['callback'] || callback\n\t            ,   count            = args['count']    || args['limit'] || 100\n\t            ,   reverse          = args['reverse']  || \"false\"\n\t            ,   err              = args['error']    || function(){}\n\t            ,   auth_key         = args['auth_key'] || AUTH_KEY\n\t            ,   cipher_key       = args['cipher_key']\n\t            ,   channel          = args['channel']\n\t            ,   channel_group    = args['channel_group']\n\t            ,   start            = args['start']\n\t            ,   end              = args['end']\n\t            ,   include_token    = args['include_token']\n\t            ,   string_msg_token = args['string_message_token'] || false\n\t            ,   params           = {}\n\t            ,   jsonp            = jsonp_cb();\n\t\n\t            // Make sure we have a Channel\n\t            if (!channel && !channel_group) return error('Missing Channel');\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            params['stringtoken'] = 'true';\n\t            params['count']       = count;\n\t            params['reverse']     = reverse;\n\t            params['auth']        = auth_key;\n\t\n\t            if (channel_group) {\n\t                params['channel-group'] = channel_group;\n\t                if (!channel) {\n\t                    channel = ','; \n\t                }\n\t            }\n\t            if (jsonp) params['callback']              = jsonp;\n\t            if (start) params['start']                 = start;\n\t            if (end)   params['end']                   = end;\n\t            if (include_token) params['include_token'] = 'true';\n\t            if (string_msg_token) params['string_message_token'] = 'true';\n\t\n\t            // Send Message\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(params),\n\t                success  : function(response) {\n\t                    if (typeof response == 'object' && response['error']) {\n\t                        err({'message' : response['message'], 'payload' : response['payload']});\n\t                        return;\n\t                    }\n\t                    var messages = response[0];\n\t                    var decrypted_messages = [];\n\t                    for (var a = 0; a < messages.length; a++) {\n\t                        if (include_token) {\n\t                            var new_message = decrypt(messages[a]['message'],cipher_key);\n\t                            var timetoken = messages[a]['timetoken'];\n\t                            try {\n\t                                decrypted_messages['push']({\"message\" : JSON['parse'](new_message), \"timetoken\" : timetoken});\n\t                            } catch (e) {\n\t                                decrypted_messages['push'](({\"message\" : new_message, \"timetoken\" : timetoken}));\n\t                            }\n\t                        } else {\n\t                            var new_message = decrypt(messages[a],cipher_key);\n\t                            try {\n\t                                decrypted_messages['push'](JSON['parse'](new_message));\n\t                            } catch (e) {\n\t                                decrypted_messages['push']((new_message));\n\t                            }     \n\t                        }\n\t                    }\n\t                    callback([decrypted_messages, response[1], response[2]]);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v2', 'history', 'sub-key',\n\t                    SUBSCRIBE_KEY, 'channel', encode(channel)\n\t                ]\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.replay({\n\t                source      : 'my_channel',\n\t                destination : 'new_channel'\n\t            });\n\t        */\n\t        'replay' : function(args, callback) {\n\t            var callback    = callback || args['callback'] || function(){}\n\t            ,   auth_key    = args['auth_key'] || AUTH_KEY\n\t            ,   source      = args['source']\n\t            ,   destination = args['destination']\n\t            ,   stop        = args['stop']\n\t            ,   start       = args['start']\n\t            ,   end         = args['end']\n\t            ,   reverse     = args['reverse']\n\t            ,   limit       = args['limit']\n\t            ,   jsonp       = jsonp_cb()\n\t            ,   data        = {}\n\t            ,   url;\n\t\n\t            // Check User Input\n\t            if (!source)        return error('Missing Source Channel');\n\t            if (!destination)   return error('Missing Destination Channel');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            // Setup URL Params\n\t            if (jsonp != '0') data['callback'] = jsonp;\n\t            if (stop)         data['stop']     = 'all';\n\t            if (reverse)      data['reverse']  = 'true';\n\t            if (start)        data['start']    = start;\n\t            if (end)          data['end']      = end;\n\t            if (limit)        data['count']    = limit;\n\t\n\t            data['auth'] = auth_key;\n\t\n\t            // Compose URL Parts\n\t            url = [\n\t                STD_ORIGIN, 'v1', 'replay',\n\t                PUBLISH_KEY, SUBSCRIBE_KEY,\n\t                source, destination\n\t            ];\n\t\n\t            // Start (or Stop) Replay!\n\t            xdr({\n\t                callback : jsonp,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function() { callback([ 0, 'Disconnected' ]) },\n\t                url      : url,\n\t                data     : _get_url_params(data)\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.auth('AJFLKAJSDKLA');\n\t        */\n\t        'auth' : function(auth) {\n\t            AUTH_KEY = auth;\n\t            CONNECT();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.time(function(time){ });\n\t        */\n\t        'time' : function(callback) {\n\t            var jsonp = jsonp_cb();\n\t\n\t            var data = { 'uuid' : UUID, 'auth' : AUTH_KEY }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                timeout  : SECOND * 5,\n\t                url      : [STD_ORIGIN, 'time', jsonp],\n\t                success  : function(response) { callback(response[0]) },\n\t                fail     : function() { callback(0) }\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.publish({\n\t                channel : 'my_chat_channel',\n\t                message : 'hello!'\n\t            });\n\t        */\n\t        'publish' : function( args, callback ) {\n\t            var msg      = args['message'];\n\t            if (!msg) return error('Missing Message');\n\t\n\t            var callback = callback || args['callback'] || msg['callback'] || function(){}\n\t            ,   channel  = args['channel'] || msg['channel']\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   cipher_key = args['cipher_key']\n\t            ,   err      = args['error'] || msg['error'] || function() {}\n\t            ,   post     = args['post'] || false\n\t            ,   store    = ('store_in_history' in args) ? args['store_in_history']: true\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   add_msg  = 'push'\n\t            ,   params\n\t            ,   url;\n\t\n\t            if (args['prepend']) add_msg = 'unshift'\n\t\n\t            if (!channel)       return error('Missing Channel');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            if (msg['getPubnubMessage']) {\n\t                msg = msg['getPubnubMessage']();\n\t            }\n\t\n\t            // If trying to send Object\n\t            msg = JSON['stringify'](encrypt(msg, cipher_key));\n\t\n\t            // Create URL\n\t            url = [\n\t                STD_ORIGIN, 'publish',\n\t                PUBLISH_KEY, SUBSCRIBE_KEY,\n\t                0, encode(channel),\n\t                jsonp, encode(msg)\n\t            ];\n\t\n\t            params = { 'uuid' : UUID, 'auth' : auth_key }\n\t\n\t            if (!store) params['store'] =\"0\"\n\t\n\t            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n\t\n\t            // Queue Message Send\n\t            PUB_QUEUE[add_msg]({\n\t                callback : jsonp,\n\t                timeout  : SECOND * 5,\n\t                url      : url,\n\t                data     : _get_url_params(params),\n\t                fail     : function(response){\n\t                    _invoke_error(response, err);\n\t                    publish(1);\n\t                },\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                    publish(1);\n\t                },\n\t                mode     : (post)?'POST':'GET'\n\t            });\n\t\n\t            // Send Message\n\t            publish();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.unsubscribe({ channel : 'my_chat' });\n\t        */\n\t        'unsubscribe' : function(args, callback) {\n\t            var channel       = args['channel']\n\t            ,   channel_group = args['channel_group']\n\t            ,   auth_key      = args['auth_key']    || AUTH_KEY\n\t            ,   callback      = callback            || args['callback'] || function(){}\n\t            ,   err           = args['error']       || function(){};\n\t\n\t            TIMETOKEN   = 0;\n\t            SUB_RESTORE = 1;   // REVISIT !!!!\n\t\n\t            if (channel) {\n\t\n\t                // Prepare LeaveChannel(s)\n\t                var leave_c = map( (\n\t                    channel.join ? channel.join(',') : ''+channel\n\t                ).split(','), function(channel) {\n\t                    if (!CHANNELS[channel]) return;\n\t                    return channel;\n\t                } ).join(',');\n\t\n\t                // Prepare Channel(s)\n\t                channel = map( (\n\t                    channel.join ? channel.join(',') : ''+channel\n\t                ).split(','), function(channel) {\n\t                    if (!CHANNELS[channel]) return;\n\t                    return channel + ',' + channel + PRESENCE_SUFFIX;\n\t                } ).join(',');\n\t\n\t                // Iterate over Channels\n\t                each(channel.split(','), function(ch) {\n\t                    if (!ch) return;\n\t                    CHANNELS[ch] = 0;\n\t                    if (ch in STATE) delete STATE[ch];\n\t                } );\n\t\n\t                var CB_CALLED = true;\n\t                if (READY) {\n\t                    CB_CALLED = SELF['LEAVE'](leave_c, 0 , auth_key, callback, err);\n\t                }\n\t                if (!CB_CALLED) callback({action : \"leave\"});\n\t            }\n\t\n\t            if (channel_group) {\n\t\n\t                // Prepare channel group(s)\n\t                var leave_gc = map( (\n\t                    channel_group.join ? channel_group.join(',') : ''+channel_group\n\t                ).split(','), function(channel_group) {\n\t                    if (!CHANNEL_GROUPS[channel_group]) return;\n\t                    return channel_group;\n\t                } ).join(',');\n\t\n\t                // Prepare channel group(s)\n\t                channel_group = map( (\n\t                    channel_group.join ? channel_group.join(',') : ''+channel_group\n\t                ).split(','), function(channel_group) {\n\t                    if (!CHANNEL_GROUPS[channel_group]) return;\n\t                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n\t                } ).join(',');\n\t\n\t                // Iterate over channel groups\n\t                each( channel_group.split(','), function(chg) {\n\t                    if (!chg) return;\n\t                    CHANNEL_GROUPS[chg] = 0;\n\t                    if (chg in STATE) delete STATE[chg];\n\t                } );\n\t\n\t                var CB_CALLED = true;\n\t                if (READY) {\n\t                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0 , auth_key, callback, err);\n\t                }\n\t                if (!CB_CALLED) callback({action : \"leave\"});\n\t            }\n\t\n\t            // Reset Connection if Count Less\n\t            CONNECT();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.subscribe({\n\t                channel  : 'my_chat'\n\t                callback : function(message) { }\n\t            });\n\t        */\n\t        'subscribe' : function( args, callback ) {\n\t            var channel         = args['channel']\n\t            ,   channel_group   = args['channel_group']\n\t            ,   callback        = callback            || args['callback']\n\t            ,   callback        = callback            || args['message']\n\t            ,   connect         = args['connect']     || function(){}\n\t            ,   reconnect       = args['reconnect']   || function(){}\n\t            ,   disconnect      = args['disconnect']  || function(){}\n\t            ,   SUB_ERROR       = args['error']       || SUB_ERROR || function(){}\n\t            ,   idlecb          = args['idle']        || function(){}\n\t            ,   presence        = args['presence']    || 0\n\t            ,   noheresync      = args['noheresync']  || 0\n\t            ,   backfill        = args['backfill']    || 0\n\t            ,   timetoken       = args['timetoken']   || 0\n\t            ,   sub_timeout     = args['timeout']     || SUB_TIMEOUT\n\t            ,   windowing       = args['windowing']   || SUB_WINDOWING\n\t            ,   state           = args['state']\n\t            ,   heartbeat       = args['heartbeat'] || args['pnexpires']\n\t            ,   heartbeat_interval = args['heartbeat_interval']\n\t            ,   restore         = args['restore'] || SUB_RESTORE;\n\t\n\t            AUTH_KEY            = args['auth_key']    || AUTH_KEY;\n\t\n\t            // Restore Enabled?\n\t            SUB_RESTORE = restore;\n\t\n\t            // Always Reset the TT\n\t            TIMETOKEN = timetoken;\n\t\n\t            // Make sure we have a Channel\n\t            if (!channel && !channel_group) {\n\t                return error('Missing Channel');\n\t            }\n\t\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n\t                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n\t            }\n\t\n\t            // Setup Channel(s)\n\t            if (channel) {\n\t                each( (channel.join ? channel.join(',') : ''+channel).split(','),\n\t                function(channel) {\n\t                    var settings = CHANNELS[channel] || {};\n\t\n\t                    // Store Channel State\n\t                    CHANNELS[SUB_CHANNEL = channel] = {\n\t                        name         : channel,\n\t                        connected    : settings.connected,\n\t                        disconnected : settings.disconnected,\n\t                        subscribed   : 1,\n\t                        callback     : SUB_CALLBACK = callback,\n\t                        'cipher_key' : args['cipher_key'],\n\t                        connect      : connect,\n\t                        disconnect   : disconnect,\n\t                        reconnect    : reconnect\n\t                    };\n\t\n\t                    if (state) {\n\t                        if (channel in state) {\n\t                            STATE[channel] = state[channel];\n\t                        } else {\n\t                            STATE[channel] = state;\n\t                        }\n\t                    }\n\t\n\t                    // Presence Enabled?\n\t                    if (!presence) return;\n\t\n\t                    // Subscribe Presence Channel\n\t                    SELF['subscribe']({\n\t                        'channel'  : channel + PRESENCE_SUFFIX,\n\t                        'callback' : presence,\n\t                        'restore'  : restore\n\t                    });\n\t\n\t                    // Presence Subscribed?\n\t                    if (settings.subscribed) return;\n\t\n\t                    // See Who's Here Now?\n\t                    if (noheresync) return;\n\t                    SELF['here_now']({\n\t                        'channel'  : channel,\n\t                        'data'     : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n\t                        'callback' : function(here) {\n\t                            each( 'uuids' in here ? here['uuids'] : [],\n\t                            function(uid) { presence( {\n\t                                'action'    : 'join',\n\t                                'uuid'      : uid,\n\t                                'timestamp' : Math.floor(rnow() / 1000),\n\t                                'occupancy' : here['occupancy'] || 1\n\t                            }, here, channel ); } );\n\t                        }\n\t                    });\n\t                } );\n\t            }\n\t\n\t            // Setup Channel Groups\n\t            if (channel_group) {\n\t                each( (channel_group.join ? channel_group.join(',') : ''+channel_group).split(','),\n\t                function(channel_group) {\n\t                    var settings = CHANNEL_GROUPS[channel_group] || {};\n\t\n\t                    CHANNEL_GROUPS[channel_group] = {\n\t                        name         : channel_group,\n\t                        connected    : settings.connected,\n\t                        disconnected : settings.disconnected,\n\t                        subscribed   : 1,\n\t                        callback     : SUB_CALLBACK = callback,\n\t                        'cipher_key' : args['cipher_key'],\n\t                        connect      : connect,\n\t                        disconnect   : disconnect,\n\t                        reconnect    : reconnect\n\t                    };\n\t\n\t                    // Presence Enabled?\n\t                    if (!presence) return;\n\t\n\t                    // Subscribe Presence Channel\n\t                    SELF['subscribe']({\n\t                        'channel_group'  : channel_group + PRESENCE_SUFFIX,\n\t                        'callback' : presence,\n\t                        'restore'  : restore,\n\t                        'auth_key' : AUTH_KEY\n\t                    });\n\t\n\t                    // Presence Subscribed?\n\t                    if (settings.subscribed) return;\n\t\n\t                    // See Who's Here Now?\n\t                    if (noheresync) return;\n\t                    SELF['here_now']({\n\t                        'channel_group'  : channel_group,\n\t                        'data'           : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n\t                        'callback' : function(here) {\n\t                            each( 'uuids' in here ? here['uuids'] : [],\n\t                            function(uid) { presence( {\n\t                                'action'    : 'join',\n\t                                'uuid'      : uid,\n\t                                'timestamp' : Math.floor(rnow() / 1000),\n\t                                'occupancy' : here['occupancy'] || 1\n\t                            }, here, channel_group ); } );\n\t                        }\n\t                    });\n\t                } );\n\t            }\n\t\n\t\n\t            // Test Network Connection\n\t            function _test_connection(success) {\n\t                if (success) {\n\t                    // Begin Next Socket Connection\n\t                    timeout( CONNECT, windowing);\n\t                }\n\t                else {\n\t                    // New Origin on Failed Connection\n\t                    STD_ORIGIN = nextorigin( ORIGIN, 1 );\n\t                    SUB_ORIGIN = nextorigin( ORIGIN, 1 );\n\t\n\t                    // Re-test Connection\n\t                    timeout( function() {\n\t                        SELF['time'](_test_connection);\n\t                    }, SECOND );\n\t                }\n\t\n\t                // Disconnect & Reconnect\n\t                each_channel(function(channel){\n\t                    // Reconnect\n\t                    if (success && channel.disconnected) {\n\t                        channel.disconnected = 0;\n\t                        return channel.reconnect(channel.name);\n\t                    }\n\t\n\t                    // Disconnect\n\t                    if (!success && !channel.disconnected) {\n\t                        channel.disconnected = 1;\n\t                        channel.disconnect(channel.name);\n\t                    }\n\t                });\n\t                \n\t                // Disconnect & Reconnect for channel groups\n\t                each_channel_group(function(channel_group){\n\t                    // Reconnect\n\t                    if (success && channel_group.disconnected) {\n\t                        channel_group.disconnected = 0;\n\t                        return channel_group.reconnect(channel_group.name);\n\t                    }\n\t\n\t                    // Disconnect\n\t                    if (!success && !channel_group.disconnected) {\n\t                        channel_group.disconnected = 1;\n\t                        channel_group.disconnect(channel_group.name);\n\t                    }\n\t                });\n\t            }\n\t\n\t            // Evented Subscribe\n\t            function _connect() {\n\t                var jsonp           = jsonp_cb()\n\t                ,   channels        = generate_channel_list(CHANNELS).join(',')\n\t                ,   channel_groups  = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n\t\n\t                // Stop Connection\n\t                if (!channels && !channel_groups) return;\n\t\n\t                if (!channels) channels = ',';\n\t\n\t                // Connect to PubNub Subscribe Servers\n\t                _reset_offline();\n\t\n\t                var data = _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY });\n\t\n\t                if (channel_groups) {\n\t                    data['channel-group'] = channel_groups;\n\t                }\n\t\n\t\n\t                var st = JSON.stringify(STATE);\n\t                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n\t\n\t                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n\t\n\t                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t                start_presence_heartbeat();\n\t                SUB_RECEIVER = xdr({\n\t                    timeout  : sub_timeout,\n\t                    callback : jsonp,\n\t                    fail     : function(response) {\n\t                        if (response && response['error'] && response['service']) {\n\t                            _invoke_error(response, SUB_ERROR);\n\t                            _test_connection(1);\n\t                        } else {\n\t                            SELF['time'](function(success){\n\t                                !success && ( _invoke_error(response, SUB_ERROR));\n\t                                _test_connection(success);\n\t                            });\n\t                        }\n\t                    },\n\t                    data     : _get_url_params(data),\n\t                    url      : [\n\t                        SUB_ORIGIN, 'subscribe',\n\t                        SUBSCRIBE_KEY, encode(channels),\n\t                        jsonp, TIMETOKEN\n\t                    ],\n\t                    success : function(messages) {\n\t\n\t                        // Check for Errors\n\t                        if (!messages || (\n\t                            typeof messages == 'object' &&\n\t                            'error' in messages         &&\n\t                            messages['error']\n\t                        )) {\n\t                            SUB_ERROR(messages['error']);\n\t                            return timeout( CONNECT, SECOND );\n\t                        }\n\t\n\t                        // User Idle Callback\n\t                        idlecb(messages[1]);\n\t\n\t                        // Restore Previous Connection Point if Needed\n\t                        TIMETOKEN = !TIMETOKEN               &&\n\t                                    SUB_RESTORE              &&\n\t                                    db['get'](SUBSCRIBE_KEY) || messages[1];\n\t\n\t                        /*\n\t                        // Connect\n\t                        each_channel_registry(function(registry){\n\t                            if (registry.connected) return;\n\t                            registry.connected = 1;\n\t                            registry.connect(channel.name);\n\t                        });\n\t                        */\n\t\n\t                        // Connect\n\t                        each_channel(function(channel){\n\t                            if (channel.connected) return;\n\t                            channel.connected = 1;\n\t                            channel.connect(channel.name);\n\t                        });\n\t\n\t                        // Connect for channel groups\n\t                        each_channel_group(function(channel_group){\n\t                            if (channel_group.connected) return;\n\t                            channel_group.connected = 1;\n\t                            channel_group.connect(channel_group.name);\n\t                        });\n\t\n\t                        if (RESUMED && !SUB_RESTORE) {\n\t                                TIMETOKEN = 0;\n\t                                RESUMED = false;\n\t                                // Update Saved Timetoken\n\t                                db['set']( SUBSCRIBE_KEY, 0 );\n\t                                timeout( _connect, windowing );\n\t                                return;\n\t                        }\n\t\n\t                        // Invoke Memory Catchup and Receive Up to 100\n\t                        // Previous Messages from the Queue.\n\t                        if (backfill) {\n\t                            TIMETOKEN = 10000;\n\t                            backfill  = 0;\n\t                        }\n\t\n\t                        // Update Saved Timetoken\n\t                        db['set']( SUBSCRIBE_KEY, messages[1] );\n\t\n\t                        // Route Channel <---> Callback for Message\n\t                        var next_callback = (function() {\n\t                            var channels = '';\n\t                            var channels2 = '';\n\t\n\t                            if (messages.length > 3) {\n\t                                channels  = messages[3];\n\t                                channels2 = messages[2];\n\t                            } else if (messages.length > 2) {\n\t                                channels = messages[2];\n\t                            } else {\n\t                                channels =  map(\n\t                                    generate_channel_list(CHANNELS), function(chan) { return map(\n\t                                        Array(messages[0].length)\n\t                                        .join(',').split(','),\n\t                                        function() { return chan; }\n\t                                    ) }).join(',')\n\t                            }\n\t\n\t                            var list  = channels.split(',');\n\t                            var list2 = (channels2)?channels2.split(','):[];\n\t\n\t                            return function() {\n\t                                var channel  = list.shift()||SUB_CHANNEL;\n\t                                var channel2 = list2.shift();\n\t\n\t                                var chobj = {};\n\t\n\t                                if (channel2) {\n\t                                    if (channel && channel.indexOf('-pnpres') >= 0 \n\t                                        && channel2.indexOf('-pnpres') < 0) {\n\t                                        channel2 += '-pnpres';\n\t                                    }\n\t                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || {'callback' : function(){}};\n\t                                } else {\n\t                                    chobj = CHANNELS[channel];\n\t                                }\n\t\n\t                                var r = [\n\t                                    chobj\n\t                                    .callback||SUB_CALLBACK,\n\t                                    channel.split(PRESENCE_SUFFIX)[0]\n\t                                ];\n\t                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n\t                                return r;\n\t                            };\n\t                        })();\n\t\n\t                        var latency = detect_latency(+messages[1]);\n\t                        each( messages[0], function(msg) {\n\t                            var next = next_callback();\n\t                            var decrypted_msg = decrypt(msg,\n\t                                (CHANNELS[next[1]])?CHANNELS[next[1]]['cipher_key']:null);\n\t                            next[0] && next[0]( decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n\t                        });\n\t\n\t                        timeout( _connect, windowing );\n\t                    }\n\t                });\n\t            }\n\t\n\t            CONNECT = function() {\n\t                _reset_offline();\n\t                timeout( _connect, windowing );\n\t            };\n\t\n\t            // Reduce Status Flicker\n\t            if (!READY) return READY_BUFFER.push(CONNECT);\n\t\n\t            // Connect Now\n\t            CONNECT();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n\t        */\n\t        'here_now' : function( args, callback ) {\n\t            var callback = args['callback'] || callback\n\t            ,   debug    = args['debug']\n\t            ,   err      = args['error']    || function(){}\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   channel  = args['channel']\n\t            ,   channel_group = args['channel_group']\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   uuids    = ('uuids' in args) ? args['uuids'] : true\n\t            ,   state    = args['state']\n\t            ,   data     = { 'uuid' : UUID, 'auth' : auth_key };\n\t\n\t            if (!uuids) data['disable_uuids'] = 1;\n\t            if (state) data['state'] = 1;\n\t\n\t            // Make sure we have a Channel\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            var url = [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub_key', SUBSCRIBE_KEY\n\t                ];\n\t\n\t            channel && url.push('channel') && url.push(encode(channel));\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            if (channel_group) {\n\t                data['channel-group'] = channel_group;\n\t                !channel && url.push('channel') && url.push(','); \n\t            }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                debug    : debug,\n\t                url      : url\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n\t        */\n\t        'where_now' : function( args, callback ) {\n\t            var callback = args['callback'] || callback\n\t            ,   err      = args['error']    || function(){}\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   uuid     = args['uuid']     || UUID\n\t            ,   data     = { 'auth' : auth_key };\n\t\n\t            // Make sure we have a Channel\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub_key', SUBSCRIBE_KEY,\n\t                    'uuid', encode(uuid)\n\t                ]\n\t            });\n\t        },\n\t\n\t        'state' : function(args, callback) {\n\t            var callback = args['callback'] || callback || function(r) {}\n\t            ,   err      = args['error']    || function(){}\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   state    = args['state']\n\t            ,   uuid     = args['uuid'] || UUID\n\t            ,   channel  = args['channel']\n\t            ,   channel_group = args['channel_group']\n\t            ,   url\n\t            ,   data     = _get_url_params({ 'auth' : auth_key });\n\t\n\t            // Make sure we have a Channel\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t            if (!uuid) return error('Missing UUID');\n\t            if (!channel && !channel_group) return error('Missing Channel');\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            if (typeof channel != 'undefined'\n\t                && CHANNELS[channel] && CHANNELS[channel].subscribed ) {\n\t                if (state) STATE[channel] = state;\n\t            }\n\t\n\t            if (typeof channel_group != 'undefined'\n\t                && CHANNEL_GROUPS[channel_group]\n\t                && CHANNEL_GROUPS[channel_group].subscribed\n\t                ) {\n\t                if (state) STATE[channel_group] = state;\n\t                data['channel-group'] = channel_group;\n\t\n\t                if (!channel) {\n\t                    channel = ',';\n\t                }\n\t            }\n\t\n\t            data['state'] = JSON.stringify(state);\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            if (state) {\n\t                url      = [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub-key', SUBSCRIBE_KEY,\n\t                    'channel', channel,\n\t                    'uuid', uuid, 'data'\n\t                ]\n\t            } else {\n\t                url      = [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub-key', SUBSCRIBE_KEY,\n\t                    'channel', channel,\n\t                    'uuid', encode(uuid)\n\t                ]\n\t            }\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t\n\t            });\n\t\n\t        },\n\t\n\t        /*\n\t            PUBNUB.grant({\n\t                channel  : 'my_chat',\n\t                callback : fun,\n\t                error    : fun,\n\t                ttl      : 24 * 60, // Minutes\n\t                read     : true,\n\t                write    : true,\n\t                auth_key : '3y8uiajdklytowsj'\n\t            });\n\t        */\n\t        'grant' : function( args, callback ) {\n\t            var callback        = args['callback'] || callback\n\t            ,   err             = args['error']    || function(){}\n\t            ,   channel         = args['channel']  || args['channels']\n\t            ,   channel_group   = args['channel_group']\n\t            ,   jsonp           = jsonp_cb()\n\t            ,   ttl             = args['ttl']\n\t            ,   r               = (args['read'] )?\"1\":\"0\"\n\t            ,   w               = (args['write'])?\"1\":\"0\"\n\t            ,   m               = (args['manage'])?\"1\":\"0\"\n\t            ,   auth_key        = args['auth_key'] || args['auth_keys'];\n\t\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SECRET_KEY)    return error('Missing Secret Key');\n\t\n\t            var timestamp  = Math.floor(new Date().getTime() / 1000)\n\t            ,   sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\"\n\t                    + \"grant\" + \"\\n\";\n\t\n\t            var data = {\n\t                'w'         : w,\n\t                'r'         : r,\n\t                'timestamp' : timestamp\n\t            };\n\t            if (args['manage']) {\n\t                data['m'] = m;\n\t            }\n\t            if (isArray(channel)) {\n\t                channel = channel['join'](',');\n\t            }\n\t            if (isArray(auth_key)) {\n\t                auth_key = auth_key['join'](',');\n\t            }\n\t            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n\t            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n\t                data['channel-group'] = channel_group;\n\t            }\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t            if (ttl || ttl === 0) data['ttl'] = ttl;\n\t\n\t            if (auth_key) data['auth'] = auth_key;\n\t\n\t            data = _get_url_params(data)\n\t\n\t            if (!auth_key) delete data['auth'];\n\t\n\t            sign_input += _get_pam_sign_input_from_params(data);\n\t\n\t            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n\t\n\t            signature = signature.replace( /\\+/g, \"-\" );\n\t            signature = signature.replace( /\\//g, \"_\" );\n\t\n\t            data['signature'] = signature;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : data,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v1', 'auth', 'grant' ,\n\t                    'sub-key', SUBSCRIBE_KEY\n\t                ]\n\t            });\n\t        },\n\t\n\t        /*\n\t         PUBNUB.mobile_gw_provision ({\n\t         device_id: 'A655FBA9931AB',\n\t         op       : 'add' | 'remove',\n\t         gw_type  : 'apns' | 'gcm',\n\t         channel  : 'my_chat',\n\t         callback : fun,\n\t         error    : fun,\n\t         });\n\t         */\n\t\n\t        'mobile_gw_provision' : function( args ) {\n\t\n\t            var callback = args['callback'] || function(){}\n\t                ,   auth_key       = args['auth_key'] || AUTH_KEY\n\t                ,   err            = args['error'] || function() {}\n\t                ,   jsonp          = jsonp_cb()\n\t                ,   channel        = args['channel']\n\t                ,   op             = args['op']\n\t                ,   gw_type        = args['gw_type']\n\t                ,   device_id      = args['device_id']\n\t                ,   params\n\t                ,   url;\n\t\n\t            if (!device_id)     return error('Missing Device ID (device_id)');\n\t            if (!gw_type)       return error('Missing GW Type (gw_type: gcm or apns)');\n\t            if (!op)            return error('Missing GW Operation (op: add or remove)');\n\t            if (!channel)       return error('Missing gw destination Channel (channel)');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            // Create URL\n\t            url = [\n\t                STD_ORIGIN, 'v1/push/sub-key',\n\t                SUBSCRIBE_KEY, 'devices', device_id\n\t            ];\n\t\n\t            params = { 'uuid' : UUID, 'auth' : auth_key, 'type': gw_type};\n\t\n\t            if (op == \"add\") {\n\t                params['add'] = channel;\n\t            } else if (op == \"remove\") {\n\t                params['remove'] = channel;\n\t            }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : params,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t\n\t        },\n\t\n\t        /*\n\t            PUBNUB.audit({\n\t                channel  : 'my_chat',\n\t                callback : fun,\n\t                error    : fun,\n\t                read     : true,\n\t                write    : true,\n\t                auth_key : '3y8uiajdklytowsj'\n\t            });\n\t        */\n\t        'audit' : function( args, callback ) {\n\t            var callback        = args['callback'] || callback\n\t            ,   err             = args['error']    || function(){}\n\t            ,   channel         = args['channel']\n\t            ,   channel_group   = args['channel_group']\n\t            ,   auth_key        = args['auth_key']\n\t            ,   jsonp           = jsonp_cb();\n\t\n\t            // Make sure we have a Channel\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SECRET_KEY)    return error('Missing Secret Key');\n\t\n\t            var timestamp  = Math.floor(new Date().getTime() / 1000)\n\t            ,   sign_input = SUBSCRIBE_KEY + \"\\n\"\n\t                + PUBLISH_KEY + \"\\n\"\n\t                + \"audit\" + \"\\n\";\n\t\n\t            var data = {'timestamp' : timestamp };\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n\t            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n\t                data['channel-group'] = channel_group;\n\t            }\n\t            if (auth_key) data['auth']    = auth_key;\n\t\n\t            data = _get_url_params(data);\n\t\n\t            if (!auth_key) delete data['auth'];\n\t\n\t            sign_input += _get_pam_sign_input_from_params(data);\n\t\n\t            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n\t\n\t            signature = signature.replace( /\\+/g, \"-\" );\n\t            signature = signature.replace( /\\//g, \"_\" );\n\t\n\t            data['signature'] = signature;\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : data,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v1', 'auth', 'audit' ,\n\t                    'sub-key', SUBSCRIBE_KEY\n\t                ]\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.revoke({\n\t                channel  : 'my_chat',\n\t                callback : fun,\n\t                error    : fun,\n\t                auth_key : '3y8uiajdklytowsj'\n\t            });\n\t        */\n\t        'revoke' : function( args, callback ) {\n\t            args['read']  = false;\n\t            args['write'] = false;\n\t            SELF['grant']( args, callback );\n\t        },\n\t        'set_uuid' : function(uuid) {\n\t            UUID = uuid;\n\t            CONNECT();\n\t        },\n\t        'get_uuid' : function() {\n\t            return UUID;\n\t        },\n\t        'isArray'  : function(arg) {\n\t            return isArray(arg);\n\t        },\n\t        'get_subscibed_channels' : function() {\n\t            return generate_channel_list(CHANNELS, true);\n\t        },\n\t        'presence_heartbeat' : function(args) {\n\t            var callback = args['callback'] || function() {}\n\t            var err      = args['error']    || function() {}\n\t            var jsonp    = jsonp_cb();\n\t            var data     = { 'uuid' : UUID, 'auth' : AUTH_KEY };\n\t\n\t            var st = JSON['stringify'](STATE);\n\t            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n\t\n\t            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            var channels        = encode(generate_channel_list(CHANNELS, true)['join'](','));\n\t            var channel_groups  = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n\t\n\t            if (!channels) channels = ',';\n\t            if (channel_groups) data['channel-group'] = channel_groups;\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                timeout  : SECOND * 5,\n\t                url      : [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub-key', SUBSCRIBE_KEY,\n\t                    'channel' , channels,\n\t                    'heartbeat'\n\t                ],\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) { _invoke_error(response, err); }\n\t            });\n\t        },\n\t        'stop_timers': function () {\n\t            clearTimeout(_poll_timer);\n\t            clearTimeout(_poll_timer2);\n\t            clearTimeout(PRESENCE_HB_TIMEOUT);\n\t        },\n\t        'shutdown': function () {\n\t            SELF['stop_timers']();\n\t            shutdown && shutdown();\n\t        },\n\t\n\t        // Expose PUBNUB Functions\n\t        'xdr'           : xdr,\n\t        'ready'         : ready,\n\t        'db'            : db,\n\t        'uuid'          : generate_uuid,\n\t        'map'           : map,\n\t        'each'          : each,\n\t        'each-channel'  : each_channel,\n\t        'grep'          : grep,\n\t        'offline'       : function(){ _reset_offline(\n\t            1, { \"message\" : \"Offline. Please check your network settings.\" })\n\t        },\n\t        'supplant'      : supplant,\n\t        'now'           : rnow,\n\t        'unique'        : unique,\n\t        'updater'       : updater\n\t    };\n\t\n\t    function _poll_online() {\n\t        _is_online() || _reset_offline( 1, {\n\t            \"error\" : \"Offline. Please check your network settings. \"\n\t        });\n\t        _poll_timer && clearTimeout(_poll_timer);\n\t        _poll_timer = timeout( _poll_online, SECOND );\n\t    }\n\t\n\t    function _poll_online2() {\n\t        if (!TIME_CHECK) return;\n\t        SELF['time'](function(success){\n\t            detect_time_detla( function(){}, success );\n\t            success || _reset_offline( 1, {\n\t                \"error\" : \"Heartbeat failed to connect to Pubnub Servers.\" +\n\t                    \"Please check your network settings.\"\n\t                });\n\t            _poll_timer2 && clearTimeout(_poll_timer2);\n\t            _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n\t        });\n\t    }\n\t\n\t    function _reset_offline(err, msg) {\n\t        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n\t        SUB_RECEIVER = null;\n\t\n\t        clearTimeout(_poll_timer);\n\t        clearTimeout(_poll_timer2);\n\t    }\n\t    \n\t    if (!UUID) UUID = SELF['uuid']();\n\t    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n\t    db['set']( SUBSCRIBE_KEY + 'uuid', UUID );\n\t\n\t    _poll_timer  = timeout( _poll_online,  SECOND    );\n\t    _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n\t    PRESENCE_HB_TIMEOUT = timeout(\n\t        start_presence_heartbeat,\n\t        ( PRESENCE_HB_INTERVAL - 3 ) * SECOND\n\t    );\n\t\n\t    // Detect Age of Message\n\t    function detect_latency(tt) {\n\t        var adjusted_time = rnow() - TIME_DRIFT;\n\t        return adjusted_time - tt / 10000;\n\t    }\n\t\n\t    detect_time_detla();\n\t    function detect_time_detla( cb, time ) {\n\t        var stime = rnow();\n\t\n\t        time && calculate(time) || SELF['time'](calculate);\n\t\n\t        function calculate(time) {\n\t            if (!time) return;\n\t            var ptime   = time / 10000\n\t            ,   latency = (rnow() - stime) / 2;\n\t            TIME_DRIFT = rnow() - (ptime + latency);\n\t            cb && cb(TIME_DRIFT);\n\t        }\n\t    }\n\t\n\t    return SELF;\n\t}\n\tfunction crypto_obj() {\n\t\n\t    function SHA256(s) {\n\t        return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);\n\t    }\n\t\n\t    var iv = \"0123456789012345\";\n\t\n\t    var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];\n\t    var allowedKeyLengths = [128, 256];\n\t    var allowedModes = ['ecb', 'cbc'];\n\t\n\t    var defaultOptions = {\n\t        'encryptKey': true,\n\t        'keyEncoding': 'utf8',\n\t        'keyLength': 256,\n\t        'mode': 'cbc'\n\t    };\n\t\n\t    function parse_options(options) {\n\t\n\t        // Defaults\n\t        options = options || {};\n\t        if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];\n\t        if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];\n\t        if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];\n\t        if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];\n\t\n\t        // Validation\n\t        if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];\n\t        if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];\n\t        if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];\n\t\n\t        return options;\n\t\n\t    }\n\t\n\t    function decode_key(key, options) {\n\t        if (options['keyEncoding'] == 'base64') {\n\t            return CryptoJS['enc']['Base64']['parse'](key);\n\t        } else if (options['keyEncoding'] == 'hex') {\n\t            return CryptoJS['enc']['Hex']['parse'](key);\n\t        } else {\n\t            return key;\n\t        }\n\t    }\n\t\n\t    function get_padded_key(key, options) {\n\t        key = decode_key(key, options);\n\t        if (options['encryptKey']) {\n\t            return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));\n\t        } else {\n\t            return key;\n\t        }\n\t    }\n\t\n\t    function get_mode(options) {\n\t        if (options['mode'] == 'ecb') {\n\t            return CryptoJS['mode']['ECB'];\n\t        } else {\n\t            return CryptoJS['mode']['CBC'];\n\t        }\n\t    }\n\t\n\t    function get_iv(options) {\n\t        return (options['mode'] == 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;\n\t    }\n\t\n\t    return {\n\t\n\t        'encrypt': function(data, key, options) {\n\t            if (!key) return data;\n\t            options = parse_options(options);\n\t            var iv = get_iv(options);\n\t            var mode = get_mode(options);\n\t            var cipher_key = get_padded_key(key, options);\n\t            var hex_message = JSON['stringify'](data);\n\t            var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, {'iv': iv, 'mode': mode})['ciphertext'];\n\t            var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);\n\t            return base_64_encrypted || data;\n\t        },\n\t\n\t        'decrypt': function(data, key, options) {\n\t            if (!key) return data;\n\t            options = parse_options(options);\n\t            var iv = get_iv(options);\n\t            var mode = get_mode(options);\n\t            var cipher_key = get_padded_key(key, options);\n\t            try {\n\t                var binary_enc = CryptoJS['enc']['Base64']['parse'](data);\n\t                var json_plain = CryptoJS['AES']['decrypt']({'ciphertext': binary_enc}, cipher_key, {'iv': iv, 'mode': mode})['toString'](CryptoJS['enc']['Utf8']);\n\t                var plaintext = JSON['parse'](json_plain);\n\t                return plaintext;\n\t            }\n\t            catch (e) {\n\t                return undefined;\n\t            }\n\t        }\n\t    };\n\t}\n\t/**\n\t * UTIL LOCALS\n\t */\n\t\n\tvar SWF             = 'https://pubnub.a.ssl.fastly.net/pubnub.swf'\n\t,   ASYNC           = 'async'\n\t,   UA              = navigator.userAgent\n\t,   PNSDK           = 'PubNub-JS-' + 'Web' + '/' + '3.7.16'\n\t,   XORIGN          = UA.indexOf('MSIE 6') == -1;\n\t\n\t/**\n\t * CONSOLE COMPATIBILITY\n\t */\n\twindow.console || (window.console=window.console||{});\n\tconsole.log    || (\n\t    console.log   =\n\t    console.error =\n\t    ((window.opera||{}).postError||function(){})\n\t);\n\t\n\t/**\n\t * LOCAL STORAGE OR COOKIE\n\t */\n\tvar db = (function(){\n\t    var store = {};\n\t    var ls = false;\n\t    try {\n\t        ls = window['localStorage'];\n\t    } catch (e) { }\n\t    var cookieGet = function(key) {\n\t        if (document.cookie.indexOf(key) == -1) return null;\n\t        return ((document.cookie||'').match(\n\t            RegExp(key+'=([^;]+)')\n\t        )||[])[1] || null;\n\t    };\n\t    var cookieSet = function( key, value ) {\n\t        document.cookie = key + '=' + value +\n\t            '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';\n\t    };\n\t    var cookieTest = (function() {\n\t        try {\n\t            cookieSet('pnctest', '1');\n\t            return cookieGet('pnctest') === '1';\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    }());\n\t    return {\n\t        'get' : function(key) {\n\t            try {\n\t                if (ls) return ls.getItem(key);\n\t                if (cookieTest) return cookieGet(key);\n\t                return store[key];\n\t            } catch(e) {\n\t                return store[key];\n\t            }\n\t        },\n\t        'set' : function( key, value ) {\n\t            try {\n\t                if (ls) return ls.setItem( key, value ) && 0;\n\t                if (cookieTest) cookieSet( key, value );\n\t                store[key] = value;\n\t            } catch(e) {\n\t                store[key] = value;\n\t            }\n\t        }\n\t    };\n\t})();\n\t\n\tfunction get_hmac_SHA256(data,key) {\n\t    var hash = CryptoJS['HmacSHA256'](data, key);\n\t    return hash.toString(CryptoJS['enc']['Base64']);\n\t}\n\t\n\t/**\n\t * $\n\t * =\n\t * var div = $('divid');\n\t */\n\tfunction $(id) { return document.getElementById(id) }\n\t\n\t/**\n\t * ERROR\n\t * =====\n\t * error('message');\n\t */\n\tfunction error(message) { console['error'](message) }\n\t\n\t/**\n\t * SEARCH\n\t * ======\n\t * var elements = search('a div span');\n\t */\n\tfunction search( elements, start) {\n\t    var list = [];\n\t    each( elements.split(/\\s+/), function(el) {\n\t        each( (start || document).getElementsByTagName(el), function(node) {\n\t            list.push(node);\n\t        } );\n\t    });\n\t    return list;\n\t}\n\t\n\t/**\n\t * BIND\n\t * ====\n\t * bind( 'keydown', search('a')[0], function(element) {\n\t *     ...\n\t * } );\n\t */\n\tfunction bind( type, el, fun ) {\n\t    each( type.split(','), function(etype) {\n\t        var rapfun = function(e) {\n\t            if (!e) e = window.event;\n\t            if (!fun(e)) {\n\t                e.cancelBubble = true;\n\t                e.preventDefault  && e.preventDefault();\n\t                e.stopPropagation && e.stopPropagation();\n\t            }\n\t        };\n\t\n\t        if ( el.addEventListener ) el.addEventListener( etype, rapfun, false );\n\t        else if ( el.attachEvent ) el.attachEvent( 'on' + etype, rapfun );\n\t        else  el[ 'on' + etype ] = rapfun;\n\t    } );\n\t}\n\t\n\t/**\n\t * UNBIND\n\t * ======\n\t * unbind( 'keydown', search('a')[0] );\n\t */\n\tfunction unbind( type, el, fun ) {\n\t    if ( el.removeEventListener ) el.removeEventListener( type, false );\n\t    else if ( el.detachEvent ) el.detachEvent( 'on' + type, false );\n\t    else  el[ 'on' + type ] = null;\n\t}\n\t\n\t/**\n\t * HEAD\n\t * ====\n\t * head().appendChild(elm);\n\t */\n\tfunction head() { return search('head')[0] }\n\t\n\t/**\n\t * ATTR\n\t * ====\n\t * var attribute = attr( node, 'attribute' );\n\t */\n\tfunction attr( node, attribute, value ) {\n\t    if (value) node.setAttribute( attribute, value );\n\t    else return node && node.getAttribute && node.getAttribute(attribute);\n\t}\n\t\n\t/**\n\t * CSS\n\t * ===\n\t * var obj = create('div');\n\t */\n\tfunction css( element, styles ) {\n\t    for (var style in styles) if (styles.hasOwnProperty(style))\n\t        try {element.style[style] = styles[style] + (\n\t            '|width|height|top|left|'.indexOf(style) > 0 &&\n\t            typeof styles[style] == 'number'\n\t            ? 'px' : ''\n\t        )}catch(e){}\n\t}\n\t\n\t/**\n\t * CREATE\n\t * ======\n\t * var obj = create('div');\n\t */\n\tfunction create(element) { return document.createElement(element) }\n\t\n\t\n\t/**\n\t * jsonp_cb\n\t * ========\n\t * var callback = jsonp_cb();\n\t */\n\tfunction jsonp_cb() { return XORIGN || FDomainRequest() ? 0 : unique() }\n\t\n\t\n\t\n\t/**\n\t * EVENTS\n\t * ======\n\t * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {\n\t *     // Do Stuff with message\n\t * } );\n\t *\n\t * PUBNUB.events.fire( 'you-stepped-on-flower', \"message-data\" );\n\t * PUBNUB.events.fire( 'you-stepped-on-flower', {message:\"data\"} );\n\t * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );\n\t *\n\t */\n\tvar events = {\n\t    'list'   : {},\n\t    'unbind' : function( name ) { events.list[name] = [] },\n\t    'bind'   : function( name, fun ) {\n\t        (events.list[name] = events.list[name] || []).push(fun);\n\t    },\n\t    'fire' : function( name, data ) {\n\t        each(\n\t            events.list[name] || [],\n\t            function(fun) { fun(data) }\n\t        );\n\t    }\n\t};\n\t\n\t/**\n\t * XDR Cross Domain Request\n\t * ========================\n\t *  xdr({\n\t *     url     : ['http://www.blah.com/url'],\n\t *     success : function(response) {},\n\t *     fail    : function() {}\n\t *  });\n\t */\n\tfunction xdr( setup ) {\n\t    if (XORIGN || FDomainRequest()) return ajax(setup);\n\t\n\t    var script    = create('script')\n\t    ,   callback  = setup.callback\n\t    ,   id        = unique()\n\t    ,   finished  = 0\n\t    ,   xhrtme    = setup.timeout || DEF_TIMEOUT\n\t    ,   timer     = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n\t    ,   fail      = setup.fail    || function(){}\n\t    ,   data      = setup.data    || {}\n\t    ,   success   = setup.success || function(){}\n\t    ,   append    = function() { head().appendChild(script) }\n\t    ,   done      = function( failed, response ) {\n\t            if (finished) return;\n\t            finished = 1;\n\t\n\t            script.onerror = null;\n\t            clearTimeout(timer);\n\t\n\t            (failed || !response) || success(response);\n\t\n\t            timeout( function() {\n\t                failed && fail();\n\t                var s = $(id)\n\t                ,   p = s && s.parentNode;\n\t                p && p.removeChild(s);\n\t            }, SECOND );\n\t        };\n\t\n\t    window[callback] = function(response) {\n\t        done( 0, response );\n\t    };\n\t\n\t    if (!setup.blocking) script[ASYNC] = ASYNC;\n\t\n\t    script.onerror = function() { done(1) };\n\t    script.src     = build_url( setup.url, data );\n\t\n\t    attr( script, 'id', id );\n\t\n\t    append();\n\t    return done;\n\t}\n\t\n\t/**\n\t * CORS XHR Request\n\t * ================\n\t *  xdr({\n\t *     url     : ['http://www.blah.com/url'],\n\t *     success : function(response) {},\n\t *     fail    : function() {}\n\t *  });\n\t */\n\tfunction ajax( setup ) {\n\t    var xhr, response\n\t    ,   finished = function() {\n\t            if (loaded) return;\n\t            loaded = 1;\n\t\n\t            clearTimeout(timer);\n\t\n\t            try       { response = JSON['parse'](xhr.responseText); }\n\t            catch (r) { return done(1); }\n\t\n\t            complete = 1;\n\t            success(response);\n\t        }\n\t    ,   complete = 0\n\t    ,   loaded   = 0\n\t    ,   xhrtme   = setup.timeout || DEF_TIMEOUT\n\t    ,   timer    = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n\t    ,   fail     = setup.fail    || function(){}\n\t    ,   data     = setup.data    || {}\n\t    ,   success  = setup.success || function(){}\n\t    ,   async    = !(setup.blocking)\n\t    ,   done     = function(failed,response) {\n\t            if (complete) return;\n\t            complete = 1;\n\t\n\t            clearTimeout(timer);\n\t\n\t            if (xhr) {\n\t                xhr.onerror = xhr.onload = null;\n\t                xhr.abort && xhr.abort();\n\t                xhr = null;\n\t            }\n\t\n\t            failed && fail(response);\n\t        };\n\t\n\t    // Send\n\t    try {\n\t        xhr = FDomainRequest()      ||\n\t              window.XDomainRequest &&\n\t              new XDomainRequest()  ||\n\t              new XMLHttpRequest();\n\t\n\t        xhr.onerror = xhr.onabort   = function(e){ done(\n\t            1, e || (xhr && xhr.responseText) || { \"error\" : \"Network Connection Error\"}\n\t        ) };\n\t        xhr.onload  = xhr.onloadend = finished;\n\t        xhr.onreadystatechange = function() {\n\t            if (xhr && xhr.readyState == 4) {\n\t                switch(xhr.status) {\n\t                    case 200:\n\t                        break;\n\t                    default:\n\t                        try {\n\t                            response = JSON['parse'](xhr.responseText);\n\t                            done(1,response);\n\t                        }\n\t                        catch (r) { return done(1, {status : xhr.status, payload : null, message : xhr.responseText}); }\n\t                        return;\n\t                }\n\t            }\n\t        }\n\t\n\t        var url = build_url(setup.url,data);\n\t\n\t        xhr.open( 'GET', url, async );\n\t        if (async) xhr.timeout = xhrtme;\n\t        xhr.send();\n\t    }\n\t    catch(eee) {\n\t        done(0);\n\t        XORIGN = 0;\n\t        return xdr(setup);\n\t    }\n\t\n\t    // Return 'done'\n\t    return done;\n\t}\n\t\n\t// Test Connection State\n\tfunction _is_online() {\n\t    if (!('onLine' in navigator)) return 1;\n\t    try       { return navigator['onLine'] }\n\t    catch (e) { return true }\n\t}\n\t\n\t\n\tfunction sendBeacon(url) {\n\t    if (!('sendBeacon' in navigator)) return false;\n\t\n\t    return navigator['sendBeacon'](url);\n\t}\n\t\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t/* =-=========================     PUBNUB     ===========================-= */\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t\n\tvar PDIV          = $('pubnub') || 0\n\t,   CREATE_PUBNUB = function(setup) {\n\t\n\t    // Force JSONP if requested from user.\n\t    if (setup['jsonp'])  XORIGN = 0;\n\t    else                 XORIGN = UA.indexOf('MSIE 6') == -1;\n\t\n\t    var SUBSCRIBE_KEY = setup['subscribe_key'] || ''\n\t    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n\t    ,   UUID          = setup['uuid'] || db['get'](SUBSCRIBE_KEY+'uuid')||'';\n\t\n\t    var leave_on_unload = setup['leave_on_unload'] || 0;\n\t\n\t    setup['xdr']        = xdr;\n\t    setup['db']         = db;\n\t    setup['error']      = setup['error'] || error;\n\t    setup['_is_online'] = _is_online;\n\t    setup['jsonp_cb']   = jsonp_cb;\n\t    setup['hmac_SHA256']= get_hmac_SHA256;\n\t    setup['crypto_obj'] = crypto_obj();\n\t    setup['sendBeacon'] = sendBeacon;\n\t    setup['params']     = { 'pnsdk' : PNSDK }\n\t\n\t    var SELF = function(setup) {\n\t        return CREATE_PUBNUB(setup);\n\t    };\n\t\n\t    var PN = PN_API(setup);\n\t\n\t    for (var prop in PN) {\n\t        if (PN.hasOwnProperty(prop)) {\n\t            SELF[prop] = PN[prop];\n\t        }\n\t    }\n\t    SELF['css']         = css;\n\t    SELF['$']           = $;\n\t    SELF['create']      = create;\n\t    SELF['bind']        = bind;\n\t    SELF['head']        = head;\n\t    SELF['search']      = search;\n\t    SELF['attr']        = attr;\n\t    SELF['events']      = events;\n\t    SELF['init']        = SELF;\n\t    SELF['secure']      = SELF;\n\t    SELF['crypto_obj']  = crypto_obj(); // export to instance\n\t\n\t\n\t    // Add Leave Functions\n\t    bind( 'beforeunload', window, function() {\n\t        if (leave_on_unload) SELF['each-channel'](function(ch){ SELF['LEAVE']( ch.name, 0 ) });\n\t        return true;\n\t    } );\n\t\n\t    // Return without Testing\n\t    if (setup['notest']) return SELF;\n\t\n\t    bind( 'offline', window,   SELF['offline'] );\n\t    bind( 'offline', document, SELF['offline'] );\n\t\n\t    // Return PUBNUB Socket Object\n\t    return SELF;\n\t};\n\tCREATE_PUBNUB['init']   = CREATE_PUBNUB;\n\tCREATE_PUBNUB['secure'] = CREATE_PUBNUB;\n\tCREATE_PUBNUB['crypto_obj'] = crypto_obj(); // export to constructor\n\t\n\t// Bind for PUBNUB Readiness to Subscribe\n\tif (document.readyState === 'complete') {\n\t    timeout( ready, 0 );\n\t}\n\telse {\n\t    bind( 'load', window, function(){ timeout( ready, 0 ) } );\n\t}\n\t\n\tvar pdiv = PDIV || {};\n\t\n\t// CREATE A PUBNUB GLOBAL OBJECT\n\tPUBNUB = CREATE_PUBNUB({\n\t    'notest'        : 1,\n\t    'publish_key'   : attr( pdiv, 'pub-key' ),\n\t    'subscribe_key' : attr( pdiv, 'sub-key' ),\n\t    'ssl'           : !document.location.href.indexOf('https') ||\n\t                      attr( pdiv, 'ssl' ) == 'on',\n\t    'origin'        : attr( pdiv, 'origin' ),\n\t    'uuid'          : attr( pdiv, 'uuid' )\n\t});\n\t\n\t// jQuery Interface\n\twindow['jQuery'] && (window['jQuery']['PUBNUB'] = CREATE_PUBNUB);\n\t\n\t// For Modern JS + Testling.js - http://testling.com/\n\ttypeof(module) !== 'undefined' && (module['exports'] = PUBNUB) && ready();\n\t\n\tvar pubnubs = $('pubnubs') || 0;\n\t\n\t// LEAVE NOW IF NO PDIV.\n\tif (!PDIV) return;\n\t\n\t// PUBNUB Flash Socket\n\tcss( PDIV, { 'position' : 'absolute', 'top' : -SECOND } );\n\t\n\tif ('opera' in window || attr( PDIV, 'flash' )) PDIV['innerHTML'] =\n\t    '<object id=pubnubs data='  + SWF +\n\t    '><param name=movie value=' + SWF +\n\t    '><param name=allowscriptaccess value=always></object>';\n\t\n\t// Create Interface for Opera Flash\n\tPUBNUB['rdx'] = function( id, data ) {\n\t    if (!data) return FDomainRequest[id]['onerror']();\n\t    FDomainRequest[id]['responseText'] = unescape(data);\n\t    FDomainRequest[id]['onload']();\n\t};\n\t\n\tfunction FDomainRequest() {\n\t    if (!pubnubs || !pubnubs['get']) return 0;\n\t\n\t    var fdomainrequest = {\n\t        'id'    : FDomainRequest['id']++,\n\t        'send'  : function() {},\n\t        'abort' : function() { fdomainrequest['id'] = {} },\n\t        'open'  : function( method, url ) {\n\t            FDomainRequest[fdomainrequest['id']] = fdomainrequest;\n\t            pubnubs['get']( fdomainrequest['id'], url );\n\t        }\n\t    };\n\t\n\t    return fdomainrequest;\n\t}\n\tFDomainRequest['id'] = SECOND;\n\t\n\t})();\n\t(function(){\n\t\n\t// ---------------------------------------------------------------------------\n\t// WEBSOCKET INTERFACE\n\t// ---------------------------------------------------------------------------\n\tvar WS = PUBNUB['ws'] = function( url, protocols ) {\n\t    if (!(this instanceof WS)) return new WS( url, protocols );\n\t\n\t    var self     = this\n\t    ,   url      = self.url      = url || ''\n\t    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'\n\t    ,   bits     = url.split('/')\n\t    ,   setup    = {\n\t         'ssl'           : bits[0] === 'wss:'\n\t        ,'origin'        : bits[2]\n\t        ,'publish_key'   : bits[3]\n\t        ,'subscribe_key' : bits[4]\n\t        ,'channel'       : bits[5]\n\t    };\n\t\n\t    // READY STATES\n\t    self['CONNECTING'] = 0; // The connection is not yet open.\n\t    self['OPEN']       = 1; // The connection is open and ready to communicate.\n\t    self['CLOSING']    = 2; // The connection is in the process of closing.\n\t    self['CLOSED']     = 3; // The connection is closed or couldn't be opened.\n\t\n\t    // CLOSE STATES\n\t    self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.\n\t    self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.\n\t    self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.\n\t    self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.\n\t    self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.\n\t    self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.\n\t    self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.\n\t\n\t    // Events Default\n\t    self['onclose']   = self['onerror'] =\n\t    self['onmessage'] = self['onopen']  =\n\t    self['onsend']    =  function(){};\n\t\n\t    // Attributes\n\t    self['binaryType']     = '';\n\t    self['extensions']     = '';\n\t    self['bufferedAmount'] = 0;\n\t    self['trasnmitting']   = false;\n\t    self['buffer']         = [];\n\t    self['readyState']     = self['CONNECTING'];\n\t\n\t    // Close if no setup.\n\t    if (!url) {\n\t        self['readyState'] = self['CLOSED'];\n\t        self['onclose']({\n\t            'code'     : self['CLOSE_ABNORMAL'],\n\t            'reason'   : 'Missing URL',\n\t            'wasClean' : true\n\t        });\n\t        return self;\n\t    }\n\t\n\t    // PubNub WebSocket Emulation\n\t    self.pubnub       = PUBNUB['init'](setup);\n\t    self.pubnub.setup = setup;\n\t    self.setup        = setup;\n\t\n\t    self.pubnub['subscribe']({\n\t        'restore'    : false,\n\t        'channel'    : setup['channel'],\n\t        'disconnect' : self['onerror'],\n\t        'reconnect'  : self['onopen'],\n\t        'error'      : function() {\n\t            self['onclose']({\n\t                'code'     : self['CLOSE_ABNORMAL'],\n\t                'reason'   : 'Missing URL',\n\t                'wasClean' : false\n\t            });\n\t        },\n\t        'callback'   : function(message) {\n\t            self['onmessage']({ 'data' : message });\n\t        },\n\t        'connect'    : function() {\n\t            self['readyState'] = self['OPEN'];\n\t            self['onopen']();\n\t        }\n\t    });\n\t};\n\t\n\t// ---------------------------------------------------------------------------\n\t// WEBSOCKET SEND\n\t// ---------------------------------------------------------------------------\n\tWS.prototype.send = function(data) {\n\t    var self = this;\n\t    self.pubnub['publish']({\n\t        'channel'  : self.pubnub.setup['channel'],\n\t        'message'  : data,\n\t        'callback' : function(response) {\n\t            self['onsend']({ 'data' : response });\n\t        }\n\t    });\n\t};\n\t\n\t// ---------------------------------------------------------------------------\n\t// WEBSOCKET CLOSE\n\t// ---------------------------------------------------------------------------\n\tWS.prototype.close = function() {\n\t    var self = this;\n\t    self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });\n\t    self['readyState'] = self['CLOSED'];\n\t    self['onclose']({});\n\t};\n\t\n\t})();\n\t/*\n\tCryptoJS v3.1.2\n\tcode.google.com/p/crypto-js\n\t(c) 2009-2013 by Jeff Mott. All rights reserved.\n\tcode.google.com/p/crypto-js/wiki/License\n\t*/\n\tvar CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\n\tr=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n\t32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n\t2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\n\tu=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);\n\ta._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,\n\td)).finalize(c)}}});var t=f.algo={};return f}(Math);\n\t\n\t// SHA256\n\t(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=\n\tc[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\n\td[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);\n\t\n\t// HMAC SHA256\n\t(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;\"string\"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=\n\tthis._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();\n\t\n\t// Base64\n\t(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join(\"\")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<\n\tl;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"}})();\n\t\n\t// BlockCipher\n\t(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},\n\t_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),\n\tf=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,\n\tm,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,\n\tE,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/\n\t4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);\n\t(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,\n\tl)}})();\n\t\n\t// Cipher\n\tCryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},\n\tfinalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return(\"string\"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return(\"string\"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=\n\tc[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,\n\te,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,\n\tthis,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,\n\t1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},\n\tdecrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return\"string\"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,\n\tb.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();\n\t\n\t// AES\n\t(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,\n\t16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>\n\t8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=\n\td[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();\n\t\n\t// Mode ECB\n\tCryptoJS.mode.ECB = (function () {\n\t    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\t\n\t    ECB.Encryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.encryptBlock(words, offset);\n\t        }\n\t    });\n\t\n\t    ECB.Decryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.decryptBlock(words, offset);\n\t        }\n\t    });\n\t\n\t    return ECB;\n\t}());// Moved to hmac-sha-256.js\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module)))\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Cache = function () {\n\t    function Cache(storage, prefix) {\n\t        _classCallCheck(this, Cache);\n\t\n\t        this.setPrefix(prefix);\n\t        this._storage = storage;\n\t    }\n\t\n\t    Cache.prototype.setPrefix = function setPrefix(prefix) {\n\t        this._prefix = prefix || Cache.defaultPrefix;\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype.setItem = function setItem(key, data) {\n\t        this._storage[this._prefixKey(key)] = JSON.stringify(data);\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype.removeItem = function removeItem(key) {\n\t        delete this._storage[this._prefixKey(key)];\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype.getItem = function getItem(key) {\n\t        var item = this._storage[this._prefixKey(key)];\n\t        if (!item) return null;\n\t        return JSON.parse(item);\n\t    };\n\t\n\t    Cache.prototype.clean = function clean() {\n\t\n\t        for (var key in this._storage) {\n\t\n\t            if (!this._storage.hasOwnProperty(key)) continue;\n\t\n\t            if (key.indexOf(this._prefix) === 0) {\n\t                delete this._storage[key];\n\t            }\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype._prefixKey = function _prefixKey(key) {\n\t        return this._prefix + key;\n\t    };\n\t\n\t    return Cache;\n\t}();\n\t\n\tCache.defaultPrefix = 'rc-';\n\texports.default = Cache;\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Observable = function () {\n\t    function Observable() {\n\t        _classCallCheck(this, Observable);\n\t\n\t        this.off();\n\t    }\n\t\n\t    Observable.prototype.hasListeners = function hasListeners(event) {\n\t        return event in this._listeners;\n\t    };\n\t\n\t    Observable.prototype.on = function on(events, callback) {\n\t        var _this = this;\n\t\n\t        if (typeof events == 'string') events = [events];\n\t        if (!events) throw new Error('No events to subscribe to');\n\t        if (typeof callback !== 'function') throw new Error('Callback must be a function');\n\t\n\t        events.forEach(function (event) {\n\t\n\t            if (!_this.hasListeners(event)) _this._listeners[event] = [];\n\t\n\t            _this._listeners[event].push(callback);\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Observable.prototype.emit = function emit(event) {\n\t        var _this2 = this;\n\t\n\t        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t            args[_key - 1] = arguments[_key];\n\t        }\n\t\n\t        var result = null;\n\t\n\t        if (!this.hasListeners(event)) return null;\n\t\n\t        this._listeners[event].some(function (callback) {\n\t\n\t            result = callback.apply(_this2, args);\n\t            return result === false;\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    Observable.prototype.off = function off(event, callback) {\n\t        var _this3 = this;\n\t\n\t        if (!event) {\n\t\n\t            this._listeners = {};\n\t        } else {\n\t\n\t            if (!callback) {\n\t\n\t                delete this._listeners[event];\n\t            } else {\n\t\n\t                if (!this.hasListeners(event)) return this;\n\t\n\t                this._listeners[event].forEach(function (cb, i) {\n\t\n\t                    if (cb === callback) delete _this3._listeners[event][i];\n\t                });\n\t            }\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    return Observable;\n\t}();\n\t\n\texports.default = Observable;\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Queue = function () {\n\t    function Queue(cache, cacheId) {\n\t        _classCallCheck(this, Queue);\n\t\n\t        this._cache = cache;\n\t        this._cacheId = cacheId;\n\t        this._promise = null;\n\t    }\n\t\n\t    Queue.prototype.isPaused = function isPaused() {\n\t\n\t        var time = this._cache.getItem(this._cacheId);\n\t\n\t        return !!time && Date.now() - parseInt(time) < Queue._releaseTimeout;\n\t    };\n\t\n\t    Queue.prototype.pause = function pause() {\n\t        this._cache.setItem(this._cacheId, Date.now());\n\t        return this;\n\t    };\n\t\n\t    Queue.prototype.resume = function resume() {\n\t        this._cache.removeItem(this._cacheId);\n\t        return this;\n\t    };\n\t\n\t    Queue.prototype.poll = function poll() {\n\t        var _this = this;\n\t\n\t        if (this._promise) return this._promise;\n\t\n\t        this._promise = new _Externals.Promise(function (resolve, reject) {\n\t\n\t            (0, _Utils.poll)(function (next) {\n\t\n\t                if (_this.isPaused()) return next();\n\t\n\t                _this._promise = null;\n\t\n\t                _this.resume(); // this is actually not needed but why not\n\t\n\t                resolve(null);\n\t            }, Queue._pollInterval);\n\t        });\n\t\n\t        return this._promise;\n\t    };\n\t\n\t    return Queue;\n\t}();\n\t\n\tQueue._pollInterval = 250;\n\tQueue._releaseTimeout = 5000;\n\texports.default = Queue;\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.findHeaderName = findHeaderName;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _ApiResponse = __webpack_require__(16);\n\t\n\tvar _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Client = function (_Observable) {\n\t    _inherits(Client, _Observable);\n\t\n\t    function Client() {\n\t        var _temp, _this, _ret;\n\t\n\t        _classCallCheck(this, Client);\n\t\n\t        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t            args[_key] = arguments[_key];\n\t        }\n\t\n\t        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Observable.call.apply(_Observable, [this].concat(args))), _this), _this.events = {\n\t            beforeRequest: 'beforeRequest',\n\t            requestSuccess: 'requestSuccess',\n\t            requestError: 'requestError'\n\t        }, _temp), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t    Client.prototype.sendRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n\t            var apiResponse;\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            apiResponse = new _ApiResponse2.default(request);\n\t                            _context.prev = 1;\n\t\n\t\n\t                            //TODO Stop request if listeners return false\n\t                            this.emit(this.events.beforeRequest, apiResponse);\n\t\n\t                            _context.next = 5;\n\t                            return this._loadResponse(request);\n\t\n\t                        case 5:\n\t                            apiResponse._response = _context.sent;\n\t                            _context.next = 8;\n\t                            return apiResponse._init();\n\t\n\t                        case 8:\n\t                            if (apiResponse.ok()) {\n\t                                _context.next = 10;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Response has unsuccessful status');\n\t\n\t                        case 10:\n\t\n\t                            this.emit(this.events.requestSuccess, apiResponse);\n\t\n\t                            return _context.abrupt(\"return\", apiResponse);\n\t\n\t                        case 14:\n\t                            _context.prev = 14;\n\t                            _context.t0 = _context[\"catch\"](1);\n\t\n\t\n\t                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);\n\t\n\t                            this.emit(this.events.requestError, _context.t0);\n\t\n\t                            throw _context.t0;\n\t\n\t                        case 19:\n\t                        case \"end\":\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this, [[1, 14]]);\n\t        }));\n\t\n\t        function sendRequest(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return sendRequest;\n\t    }();\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @return {Promise<Response>}\n\t     * @private\n\t     */\n\t\n\t\n\t    Client.prototype._loadResponse = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {\n\t            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t                while (1) {\n\t                    switch (_context2.prev = _context2.next) {\n\t                        case 0:\n\t                            _context2.next = 2;\n\t                            return _Externals.fetch.call(null, request);\n\t\n\t                        case 2:\n\t                            return _context2.abrupt(\"return\", _context2.sent);\n\t\n\t                        case 3:\n\t                        case \"end\":\n\t                            return _context2.stop();\n\t                    }\n\t                }\n\t            }, _callee2, this);\n\t        }));\n\t\n\t        function _loadResponse(_x2) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _loadResponse;\n\t    }();\n\t\n\t    /**\n\t     * Wraps the JS Error object with transaction information\n\t     * @param {Error|IApiError} e\n\t     * @param {ApiResponse} apiResponse\n\t     * @return {IApiError}\n\t     */\n\t\n\t\n\t    Client.prototype.makeError = function makeError(e, apiResponse) {\n\t\n\t        // Wrap only if regular error\n\t        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {\n\t\n\t            e.apiResponse = apiResponse;\n\t            e.originalMessage = e.message;\n\t            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;\n\t        }\n\t\n\t        return e;\n\t    };\n\t\n\t    /**\n\t     *\n\t     * @param {object} init\n\t     * @param {object} [init.url]\n\t     * @param {object} [init.body]\n\t     * @param {string} [init.method]\n\t     * @param {object} [init.query]\n\t     * @param {object} [init.headers]\n\t     * @return {Request}\n\t     */\n\t\n\t\n\t    Client.prototype.createRequest = function createRequest(init) {\n\t\n\t        init = init || {};\n\t        init.headers = init.headers || {};\n\t\n\t        // Sanity checks\n\t        if (!init.url) throw new Error('Url is not defined');\n\t        if (!init.method) init.method = 'GET';\n\t        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {\n\t            throw new Error('Method has wrong value: ' + init.method);\n\t        }\n\t\n\t        // Defaults\n\t        init.credentials = init.credentials || 'include';\n\t        init.mode = init.mode || 'cors';\n\t\n\t        // Append Query String\n\t        if (init.query) {\n\t            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);\n\t        }\n\t\n\t        if (!findHeaderName('Accept', init.headers)) {\n\t            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;\n\t        }\n\t\n\t        // Serialize body\n\t        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {\n\t\n\t            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);\n\t\n\t            if (!contentTypeHeaderName) {\n\t                contentTypeHeaderName = _ApiResponse2.default._contentType;\n\t                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;\n\t            }\n\t\n\t            var contentType = init.headers[contentTypeHeaderName];\n\t\n\t            // Assign a new encoded body\n\t            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {\n\t                init.body = JSON.stringify(init.body);\n\t            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {\n\t                init.body = (0, _Utils.queryStringify)(init.body);\n\t            }\n\t        }\n\t\n\t        // Create a request with encoded body\n\t        var req = new _Externals.Request(init.url, init);\n\t\n\t        // Keep the original body accessible directly (for mocks)\n\t        req.originalBody = init.body;\n\t\n\t        return req;\n\t    };\n\t\n\t    return Client;\n\t}(_Observable3.default);\n\t\n\tClient._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];\n\texports.default = Client;\n\tfunction findHeaderName(name, headers) {\n\t    name = name.toLowerCase();\n\t    return Object.keys(headers).reduce(function (res, key) {\n\t        if (res) return res;\n\t        if (name == key.toLowerCase()) return key;\n\t        return res;\n\t    }, null);\n\t}\n\t\n\t/**\n\t * @name IApiError\n\t * @property {string} stack\n\t * @property {string} originalMessage\n\t * @property {ApiResponse} apiResponse\n\t */\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ApiResponse = function () {\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @param {Response} response\n\t     * @param {string} responseText\n\t     */\n\t\n\t    function ApiResponse(request, response, responseText) {\n\t        _classCallCheck(this, ApiResponse);\n\t\n\t        /** @type {Request} */\n\t        this._request = request;\n\t\n\t        /** @type {Response} */\n\t        this._response = response;\n\t\n\t        this._text = responseText;\n\t        this._json = null;\n\t        this._multipart = [];\n\t    }\n\t\n\t    ApiResponse.prototype._init = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            if (!(this._isMultipart() || this._isJson())) {\n\t                                _context.next = 4;\n\t                                break;\n\t                            }\n\t\n\t                            _context.next = 3;\n\t                            return this.response().text();\n\t\n\t                        case 3:\n\t                            this._text = _context.sent;\n\t\n\t                        case 4:\n\t                            return _context.abrupt('return', this);\n\t\n\t                        case 5:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function _init() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _init;\n\t    }();\n\t\n\t    /**\n\t     * @return {Response}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.response = function response() {\n\t        return this._response;\n\t    };\n\t\n\t    /**\n\t     * @return {Request}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.request = function request() {\n\t        return this._request;\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.ok = function ok() {\n\t        return this._response && this._response.ok;\n\t    };\n\t\n\t    /**\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.text = function text() {\n\t        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');\n\t        return this._text;\n\t    };\n\t\n\t    /**\n\t     * @return {object}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.json = function json() {\n\t        if (!this._isJson()) throw new Error('Response is not JSON');\n\t        if (!this._json) {\n\t            this._json = this._text ? JSON.parse(this._text) : null;\n\t        }\n\t        return this._json;\n\t    };\n\t\n\t    /**\n\t     * @param [skipOKCheck]\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.error = function error(skipOKCheck) {\n\t\n\t        if (this.ok() && !skipOKCheck) return null;\n\t\n\t        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');\n\t\n\t        try {\n\t\n\t            if (this.json().message) message = this.json().message;\n\t            if (this.json().error_description) message = this.json().error_description;\n\t            if (this.json().description) message = this.json().description;\n\t        } catch (e) {}\n\t\n\t        return message;\n\t    };\n\t\n\t    /**\n\t     * @return {ApiResponse[]}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.multipart = function multipart() {\n\t\n\t        if (!this._isMultipart()) throw new Error('Response is not multipart');\n\t\n\t        if (!this._multipart.length) {\n\t\n\t            // Step 1. Split multipart response\n\t\n\t            var text = this.text();\n\t\n\t            if (!text) throw new Error('No response body');\n\t\n\t            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];\n\t\n\t            if (!boundary) throw new Error('Cannot find boundary');\n\t\n\t            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);\n\t\n\t            if (parts[0].trim() === '') parts.shift();\n\t            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();\n\t\n\t            if (parts.length < 1) throw new Error('No parts in body');\n\t\n\t            // Step 2. Parse status info\n\t\n\t            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();\n\t\n\t            // Step 3. Parse all other parts\n\t\n\t            this._multipart = parts.map(function (part, i) {\n\t\n\t                var status = statusInfo.response[i].status;\n\t\n\t                return ApiResponse.create(part, status);\n\t            });\n\t        }\n\t\n\t        return this._multipart;\n\t    };\n\t\n\t    ApiResponse.prototype._isContentType = function _isContentType(contentType) {\n\t        return this._getContentType().indexOf(contentType) > -1;\n\t    };\n\t\n\t    ApiResponse.prototype._getContentType = function _getContentType() {\n\t        return this._response.headers.get(ApiResponse._contentType) || '';\n\t    };\n\t\n\t    ApiResponse.prototype._isMultipart = function _isMultipart() {\n\t        return this._isContentType(ApiResponse._multipartContentType);\n\t    };\n\t\n\t    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {\n\t        return this._isContentType(ApiResponse._urlencodedContentType);\n\t    };\n\t\n\t    ApiResponse.prototype._isJson = function _isJson() {\n\t        return this._isContentType(ApiResponse._jsonContentType);\n\t    };\n\t\n\t    /**\n\t     * Method is used to create ApiResponse object from string parts of multipart/mixed response\n\t     * @param {string} [text]\n\t     * @param {number} [status]\n\t     * @param {string} [statusText]\n\t     * @return {ApiResponse}\n\t     */\n\t\n\t\n\t    ApiResponse.create = function create(text, status, statusText) {\n\t\n\t        text = text || '';\n\t        status = status || 200;\n\t        statusText = statusText || 'OK';\n\t\n\t        text = text.replace(/\\r/g, '');\n\t\n\t        var headers = new _Externals.Headers(),\n\t            headersAndBody = text.split(ApiResponse._bodySeparator),\n\t            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';\n\t\n\t        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;\n\t\n\t        (headersText || '').split('\\n').forEach(function (header) {\n\t\n\t            var split = header.trim().split(ApiResponse._headerSeparator),\n\t                key = split.shift().trim(),\n\t                value = split.join(ApiResponse._headerSeparator).trim();\n\t\n\t            if (key) headers.append(key, value);\n\t        });\n\t\n\t        return new ApiResponse(null, new _Externals.Response(text ? text : null, {\n\t            headers: headers,\n\t            status: status,\n\t            statusText: statusText\n\t        }), text);\n\t    };\n\t\n\t    return ApiResponse;\n\t}();\n\t\n\tApiResponse._contentType = 'Content-Type';\n\tApiResponse._jsonContentType = 'application/json';\n\tApiResponse._multipartContentType = 'multipart/mixed';\n\tApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';\n\tApiResponse._headerSeparator = ':';\n\tApiResponse._bodySeparator = '\\n\\n';\n\tApiResponse._boundarySeparator = '--';\n\texports.default = ApiResponse;\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Registry = __webpack_require__(18);\n\t\n\tvar _Registry2 = _interopRequireDefault(_Registry);\n\t\n\tvar _Client = __webpack_require__(15);\n\t\n\tvar _Client2 = _interopRequireDefault(_Client);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Client = function (_HttpClient) {\n\t    _inherits(Client, _HttpClient);\n\t\n\t    function Client() {\n\t        _classCallCheck(this, Client);\n\t\n\t        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));\n\t\n\t        _this._registry = new _Registry2.default();\n\t        return _this;\n\t    }\n\t\n\t    Client.prototype.registry = function registry() {\n\t        return this._registry;\n\t    };\n\t\n\t    Client.prototype._loadResponse = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n\t            var mock;\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            mock = this._registry.find(request);\n\t                            _context.next = 3;\n\t                            return mock.getResponse(request);\n\t\n\t                        case 3:\n\t                            return _context.abrupt('return', _context.sent);\n\t\n\t                        case 4:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function _loadResponse(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _loadResponse;\n\t    }();\n\t\n\t    return Client;\n\t}(_Client2.default);\n\t\n\texports.default = Client;\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Mock = __webpack_require__(19);\n\t\n\tvar _Mock2 = _interopRequireDefault(_Mock);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Registry = function () {\n\t    function Registry() {\n\t        _classCallCheck(this, Registry);\n\t\n\t        this._mocks = [];\n\t    }\n\t\n\t    Registry.prototype.add = function add(mock) {\n\t        this._mocks.push(mock);\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.clear = function clear() {\n\t        this._mocks = [];\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.find = function find(request) {\n\t\n\t        //console.log('Registry is looking for', request);\n\t\n\t        var mock = this._mocks.shift();\n\t\n\t        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);\n\t\n\t        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());\n\t\n\t        return mock;\n\t    };\n\t\n\t    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText) {\n\t\n\t        this.add(new _Mock2.default(method, path, response, status, statusText));\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.authentication = function authentication() {\n\t\n\t        this.apiCall('POST', '/restapi/oauth/token', {\n\t            'access_token': 'ACCESS_TOKEN',\n\t            'token_type': 'bearer',\n\t            'expires_in': 3600,\n\t            'refresh_token': 'REFRESH_TOKEN',\n\t            'refresh_token_expires_in': 60480,\n\t            'scope': 'SMS RCM Foo Boo',\n\t            'expireTime': new Date().getTime() + 3600000\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.logout = function logout() {\n\t\n\t        this.apiCall('POST', '/restapi/oauth/revoke', {});\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.presenceLoad = function presenceLoad(id) {\n\t\n\t        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {\n\t            \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id + \"/presence\",\n\t            \"extension\": {\n\t                \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id,\n\t                \"id\": id,\n\t                \"extensionNumber\": \"101\"\n\t            },\n\t            \"activeCalls\": [],\n\t            \"presenceStatus\": \"Available\",\n\t            \"telephonyStatus\": \"Ringing\",\n\t            \"userStatus\": \"Available\",\n\t            \"dndStatus\": \"TakeAllCalls\",\n\t            \"extensionId\": id\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {\n\t\n\t        expiresIn = expiresIn || 15 * 60 * 60;\n\t\n\t        var date = new Date();\n\t\n\t        this.apiCall('POST', '/restapi/v1.0/subscription', {\n\t            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],\n\t            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),\n\t            'expiresIn': expiresIn,\n\t            'deliveryMode': {\n\t                'transportType': 'PubNub',\n\t                'encryption': false,\n\t                'address': '123_foo',\n\t                'subscriberKey': 'sub-c-foo',\n\t                'secretKey': 'sec-c-bar'\n\t            },\n\t            'id': 'foo-bar-baz',\n\t            'creationTime': date.toISOString(),\n\t            'status': 'Active',\n\t            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {\n\t\n\t        id = id || '1';\n\t\n\t        var date = new Date();\n\t\n\t        this.apiCall('POST', '/restapi/v1.0/subscription', {\n\t            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],\n\t            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),\n\t            'deliveryMode': {\n\t                'transportType': 'PubNub',\n\t                'encryption': true,\n\t                'address': '123_foo',\n\t                'subscriberKey': 'sub-c-foo',\n\t                'secretKey': 'sec-c-bar',\n\t                'encryptionAlgorithm': 'AES',\n\t                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='\n\t            },\n\t            'creationTime': date.toISOString(),\n\t            'id': 'foo-bar-baz',\n\t            'status': 'Active',\n\t            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {\n\t\n\t        if (!failure) {\n\t\n\t            this.apiCall('POST', '/restapi/oauth/token', {\n\t                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',\n\t                'token_type': 'bearer',\n\t                'expires_in': 3600,\n\t                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',\n\t                'refresh_token_expires_in': 60480,\n\t                'scope': 'SMS RCM Foo Boo'\n\t            });\n\t        } else {\n\t\n\t            this.apiCall('POST', '/restapi/oauth/token', {\n\t                'message': 'Wrong token',\n\t                'error_description': 'Wrong token',\n\t                'description': 'Wrong token'\n\t            }, 400);\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    return Registry;\n\t}();\n\t\n\texports.default = Registry;\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _ApiResponse = __webpack_require__(16);\n\t\n\tvar _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Mock = function () {\n\t    function Mock(method, path, json, status, statusText, delay) {\n\t        _classCallCheck(this, Mock);\n\t\n\t        this._method = method.toUpperCase();\n\t        this._path = path;\n\t        this._json = json || {};\n\t        this._delay = delay || 10;\n\t        this._status = status || 200;\n\t        this._statusText = statusText || 'OK';\n\t    }\n\t\n\t    Mock.prototype.path = function path() {\n\t        return this._path;\n\t    };\n\t\n\t    Mock.prototype.method = function method() {\n\t        return this._method;\n\t    };\n\t\n\t    Mock.prototype.test = function test(request) {\n\t\n\t        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;\n\t    };\n\t\n\t    Mock.prototype.getResponse = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            _context.next = 2;\n\t                            return (0, _Utils.delay)(this._delay);\n\t\n\t                        case 2:\n\t                            return _context.abrupt('return', this.createResponse(this._json));\n\t\n\t                        case 3:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function getResponse(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return getResponse;\n\t    }();\n\t\n\t    Mock.prototype.createResponse = function createResponse(json, init) {\n\t\n\t        init = init || {};\n\t\n\t        init.status = init.status || this._status;\n\t        init.statusText = init.statusText || this._statusText;\n\t\n\t        var str = JSON.stringify(json),\n\t            res = new _Externals.Response(str, init);\n\t\n\t        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);\n\t\n\t        return res;\n\t    };\n\t\n\t    return Mock;\n\t}();\n\t\n\texports.default = Mock;\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _Queue = __webpack_require__(14);\n\t\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\t\n\tvar _Auth = __webpack_require__(21);\n\t\n\tvar _Auth2 = _interopRequireDefault(_Auth);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Platform = function (_Observable) {\n\t    _inherits(Platform, _Observable);\n\t\n\t    // 10 hours\n\t\n\t    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {\n\t        _classCallCheck(this, Platform);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n\t\n\t        _this.events = {\n\t            beforeLogin: 'beforeLogin',\n\t            loginSuccess: 'loginSuccess',\n\t            loginError: 'loginError',\n\t            beforeRefresh: 'beforeRefresh',\n\t            refreshSuccess: 'refreshSuccess',\n\t            refreshError: 'refreshError',\n\t            beforeLogout: 'beforeLogout',\n\t            logoutSuccess: 'logoutSuccess',\n\t            logoutError: 'logoutError'\n\t        };\n\t\n\t\n\t        _this._server = server;\n\t        _this._appKey = appKey;\n\t        _this._appSecret = appSecret;\n\t\n\t        /** @type {Cache} */\n\t        _this._cache = cache;\n\t\n\t        /** @type {Client} */\n\t        _this._client = client;\n\t\n\t        _this._queue = new _Queue2.default(_this._cache, Platform._cacheId + '-refresh');\n\t\n\t        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);\n\t\n\t        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;\n\t\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * @return {Auth}\n\t     */\n\t    // 1 week\n\t\n\t\n\t    Platform.prototype.auth = function auth() {\n\t        return this._auth;\n\t    };\n\t\n\t    /**\n\t     * @return {Client}\n\t     */\n\t\n\t\n\t    Platform.prototype.client = function client() {\n\t        return this._client;\n\t    };\n\t\n\t    /**\n\t     * @param {string} path\n\t     * @param {object} [options]\n\t     * @param {boolean} [options.addServer]\n\t     * @param {string} [options.addMethod]\n\t     * @param {boolean} [options.addToken]\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    Platform.prototype.createUrl = function createUrl(path, options) {\n\t\n\t        path = path || '';\n\t        options = options || {};\n\t\n\t        var builtUrl = '',\n\t            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;\n\t\n\t        if (options.addServer && !hasHttp) builtUrl += this._server;\n\t\n\t        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;\n\t\n\t        builtUrl += path;\n\t\n\t        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';\n\t\n\t        if (options.addMethod) builtUrl += '_method=' + options.addMethod;\n\t        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();\n\t\n\t        return builtUrl;\n\t    };\n\t\n\t    /**\n\t     * @param {string} options.redirectUri\n\t     * @param {string} options.state\n\t     * @param {string} options.brandId\n\t     * @param {string} options.display\n\t     * @param {string} options.prompt\n\t     * @param {object} [options]\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    Platform.prototype.authUrl = function authUrl(options) {\n\t\n\t        options = options || {};\n\t\n\t        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({\n\t            'response_type': 'code',\n\t            'redirect_uri': options.redirectUri || '',\n\t            'client_id': this._appKey,\n\t            'state': options.state || '',\n\t            'brand_id': options.brandId || '',\n\t            'display': options.display || '',\n\t            'prompt': options.prompt || ''\n\t        }), { addServer: true });\n\t    };\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @return {Object}\n\t     */\n\t\n\t\n\t    Platform.prototype.parseAuthRedirectUrl = function parseAuthRedirectUrl(url) {\n\t\n\t        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),\n\t            error = qs.error_description || qs.error;\n\t\n\t        if (error) {\n\t            var e = new Error(error);\n\t            e.error = qs.error;\n\t            throw e;\n\t        }\n\t\n\t        return qs;\n\t    };\n\t\n\t    /**\n\t     * Convenience method to handle 3-legged OAuth\n\t     *\n\t     * Attention! This is an experimental method and it's signature and behavior may change without notice.\n\t     *\n\t     * @experimental\n\t     * @param {number} [options.width]\n\t     * @param {number} [options.height]\n\t     * @param {object} [options.login] additional options for login()\n\t     * @param {string} [options.origin]\n\t     * @param {string} [options.property] name of window.postMessage's event data property\n\t     * @param {string} [options.target] target for window.open()\n\t     * @param {string} options.url\n\t     * @return {Promise}\n\t     */\n\t\n\t\n\t    Platform.prototype.authWindow = function authWindow(options) {\n\t        var _this2 = this;\n\t\n\t        return new _Externals.Promise(function (resolve, reject) {\n\t\n\t            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');\n\t\n\t            if (!options.url) throw new Error('Missing mandatory URL parameter');\n\t\n\t            options = options || {};\n\t            options.url = options.url || 400;\n\t            options.width = options.width || 400;\n\t            options.height = options.height || 600;\n\t            options.origin = options.origin || window.location.origin;\n\t            options.property = options.property || 'RCAuthorizationCode';\n\t            options.target = options.target || '_blank';\n\t\n\t            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;\n\t            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;\n\t\n\t            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;\n\t            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\t\n\t            var left = width / 2 - options.width / 2 + dualScreenLeft;\n\t            var top = height / 2 - options.height / 2 + dualScreenTop;\n\t            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');\n\t\n\t            if (window.focus) win.focus();\n\t\n\t            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';\n\t            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';\n\t            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';\n\t\n\t            var eventListener = function eventListener(e) {\n\t\n\t                if (e.origin != options.origin) return;\n\t                if (!e.data || !e.data[options.property]) return; // keep waiting\n\t\n\t                win.close();\n\t                window[eventRemoveMethod](messageEvent, eventListener);\n\t\n\t                try {\n\t\n\t                    var loginOptions = _this2.parseAuthRedirectUrl(e.data[options.property]);\n\t\n\t                    if (!loginOptions.code) throw new Error('No authorization code');\n\t\n\t                    resolve(loginOptions);\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            };\n\t\n\t            window[eventMethod](messageEvent, eventListener, false);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @return {Promise<boolean>}\n\t     */\n\t\n\t\n\t    Platform.prototype.loggedIn = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            _context.prev = 0;\n\t                            _context.next = 3;\n\t                            return this._ensureAuthentication();\n\t\n\t                        case 3:\n\t                            return _context.abrupt(\"return\", true);\n\t\n\t                        case 6:\n\t                            _context.prev = 6;\n\t                            _context.t0 = _context[\"catch\"](0);\n\t                            return _context.abrupt(\"return\", false);\n\t\n\t                        case 9:\n\t                        case \"end\":\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this, [[0, 6]]);\n\t        }));\n\t\n\t        function loggedIn() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return loggedIn;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} options.username\n\t     * @param {string} options.password\n\t     * @param {string} options.extension\n\t     * @param {string} options.code\n\t     * @param {string} options.redirectUri\n\t     * @param {string} options.endpointId\n\t     * @param {string} options.remember\n\t     * @param {string} options.accessTokenTtl\n\t     * @param {string} options.refreshTokenTtl\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.login = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {\n\t            var body, apiResponse, json;\n\t            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t                while (1) {\n\t                    switch (_context2.prev = _context2.next) {\n\t                        case 0:\n\t                            _context2.prev = 0;\n\t\n\t\n\t                            options = options || {};\n\t\n\t                            this.emit(this.events.beforeLogin);\n\t\n\t                            body = {};\n\t\n\t\n\t                            if (!options.code) {\n\t\n\t                                body.grant_type = 'password';\n\t                                body.username = options.username;\n\t                                body.password = options.password;\n\t                                body.extension = options.extension || '';\n\t                            } else if (options.code) {\n\t\n\t                                body.grant_type = 'authorization_code';\n\t                                body.code = options.code;\n\t                                body.redirect_uri = options.redirectUri;\n\t                                //body.client_id = this.getCredentials().key; // not needed\n\t                            }\n\t\n\t                            if (options.endpointId) body.endpoint_id = options.endpointId;\n\t                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;\n\t                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;\n\t                            if (options.remember && !options.refreshTokenTtl) body.refreshTokenTtl = options.remember ? Platform._refreshTokenTtlRemember : Platform._refreshTokenTtl;\n\t\n\t                            _context2.next = 11;\n\t                            return this._tokenRequest(Platform._tokenEndpoint, body);\n\t\n\t                        case 11:\n\t                            apiResponse = _context2.sent;\n\t                            json = apiResponse.json();\n\t\n\t\n\t                            this._auth.setData(json);\n\t\n\t                            this.emit(this.events.loginSuccess, apiResponse);\n\t\n\t                            return _context2.abrupt(\"return\", apiResponse);\n\t\n\t                        case 18:\n\t                            _context2.prev = 18;\n\t                            _context2.t0 = _context2[\"catch\"](0);\n\t\n\t\n\t                            this._cache.clean();\n\t\n\t                            this.emit(this.events.loginError, _context2.t0);\n\t\n\t                            throw _context2.t0;\n\t\n\t                        case 23:\n\t                        case \"end\":\n\t                            return _context2.stop();\n\t                    }\n\t                }\n\t            }, _callee2, this, [[0, 18]]);\n\t        }));\n\t\n\t        function login(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return login;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.refresh = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n\t            var res, json;\n\t            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n\t                while (1) {\n\t                    switch (_context3.prev = _context3.next) {\n\t                        case 0:\n\t                            _context3.prev = 0;\n\t\n\t\n\t                            this.emit(this.events.beforeRefresh);\n\t\n\t                            if (!this._queue.isPaused()) {\n\t                                _context3.next = 9;\n\t                                break;\n\t                            }\n\t\n\t                            _context3.next = 5;\n\t                            return this._queue.poll();\n\t\n\t                        case 5:\n\t                            if (this._isAccessTokenValid()) {\n\t                                _context3.next = 7;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Automatic authentification timeout');\n\t\n\t                        case 7:\n\t\n\t                            this.emit(this.events.refreshSuccess, null);\n\t\n\t                            return _context3.abrupt(\"return\", null);\n\t\n\t                        case 9:\n\t\n\t                            this._queue.pause();\n\t\n\t                            // Make sure all existing AJAX calls had a chance to reach the server\n\t                            _context3.next = 12;\n\t                            return (0, _Utils.delay)(Platform._refreshDelayMs);\n\t\n\t                        case 12:\n\t                            if (this._auth.refreshToken()) {\n\t                                _context3.next = 14;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Refresh token is missing');\n\t\n\t                        case 14:\n\t                            if (this._auth.refreshTokenValid()) {\n\t                                _context3.next = 16;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Refresh token has expired');\n\t\n\t                        case 16:\n\t                            if (this._queue.isPaused()) {\n\t                                _context3.next = 18;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Queue was resumed before refresh call');\n\t\n\t                        case 18:\n\t                            _context3.next = 20;\n\t                            return this._tokenRequest(Platform._tokenEndpoint, {\n\t                                \"grant_type\": \"refresh_token\",\n\t                                \"refresh_token\": this._auth.refreshToken(),\n\t                                \"access_token_ttl\": this._auth.data().expires_in + 1,\n\t                                \"refresh_token_ttl\": this._auth.data().refresh_token_expires_in + 1\n\t                            });\n\t\n\t                        case 20:\n\t                            res = _context3.sent;\n\t                            json = res.json();\n\t\n\t                            if (json.access_token) {\n\t                                _context3.next = 24;\n\t                                break;\n\t                            }\n\t\n\t                            throw this._client.makeError(new Error('Malformed OAuth response'), res);\n\t\n\t                        case 24:\n\t\n\t                            this._auth.setData(json);\n\t                            this._queue.resume();\n\t\n\t                            this.emit(this.events.refreshSuccess, res);\n\t\n\t                            return _context3.abrupt(\"return\", res);\n\t\n\t                        case 30:\n\t                            _context3.prev = 30;\n\t                            _context3.t0 = _context3[\"catch\"](0);\n\t\n\t\n\t                            _context3.t0 = this._client.makeError(_context3.t0);\n\t\n\t                            if (Platform._clearCacheOnRefreshError) {\n\t                                this._cache.clean();\n\t                            }\n\t\n\t                            this.emit(this.events.refreshError, _context3.t0);\n\t\n\t                            throw _context3.t0;\n\t\n\t                        case 36:\n\t                        case \"end\":\n\t                            return _context3.stop();\n\t                    }\n\t                }\n\t            }, _callee3, this, [[0, 30]]);\n\t        }));\n\t\n\t        function refresh() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return refresh;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.logout = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n\t            var res;\n\t            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n\t                while (1) {\n\t                    switch (_context4.prev = _context4.next) {\n\t                        case 0:\n\t                            _context4.prev = 0;\n\t\n\t\n\t                            this.emit(this.events.beforeLogout);\n\t\n\t                            this._queue.pause();\n\t\n\t                            _context4.next = 5;\n\t                            return this._tokenRequest(Platform._revokeEndpoint, {\n\t                                token: this._auth.accessToken()\n\t                            });\n\t\n\t                        case 5:\n\t                            res = _context4.sent;\n\t\n\t\n\t                            this._queue.resume();\n\t                            this._cache.clean();\n\t\n\t                            this.emit(this.events.logoutSuccess, res);\n\t\n\t                            return _context4.abrupt(\"return\", res);\n\t\n\t                        case 12:\n\t                            _context4.prev = 12;\n\t                            _context4.t0 = _context4[\"catch\"](0);\n\t\n\t\n\t                            this._queue.resume();\n\t\n\t                            this.emit(this.events.logoutError, _context4.t0);\n\t\n\t                            throw _context4.t0;\n\t\n\t                        case 17:\n\t                        case \"end\":\n\t                            return _context4.stop();\n\t                    }\n\t                }\n\t            }, _callee4, this, [[0, 12]]);\n\t        }));\n\t\n\t        function logout() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return logout;\n\t    }();\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @param {object} [options]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<Request>}\n\t     */\n\t\n\t\n\t    Platform.prototype.inflateRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(request, options) {\n\t            return regeneratorRuntime.wrap(function _callee5$(_context5) {\n\t                while (1) {\n\t                    switch (_context5.prev = _context5.next) {\n\t                        case 0:\n\t\n\t                            options = options || {};\n\t\n\t                            if (!options.skipAuthCheck) {\n\t                                _context5.next = 3;\n\t                                break;\n\t                            }\n\t\n\t                            return _context5.abrupt(\"return\", request);\n\t\n\t                        case 3:\n\t                            _context5.next = 5;\n\t                            return this._ensureAuthentication();\n\t\n\t                        case 5:\n\t\n\t                            request.headers.set('X-User-Agent', this._userAgent);\n\t                            request.headers.set('Client-Id', this._appKey);\n\t                            request.headers.set('Authorization', this._authHeader());\n\t                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...\n\t\n\t                            return _context5.abrupt(\"return\", request);\n\t\n\t                        case 9:\n\t                        case \"end\":\n\t                            return _context5.stop();\n\t                    }\n\t                }\n\t            }, _callee5, this);\n\t        }));\n\t\n\t        function inflateRequest(_x2, _x3) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return inflateRequest;\n\t    }();\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @param {object} [options]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.sendRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {\n\t            return regeneratorRuntime.wrap(function _callee6$(_context6) {\n\t                while (1) {\n\t                    switch (_context6.prev = _context6.next) {\n\t                        case 0:\n\t                            _context6.prev = 0;\n\t                            _context6.next = 3;\n\t                            return this.inflateRequest(request, options);\n\t\n\t                        case 3:\n\t                            request = _context6.sent;\n\t                            _context6.next = 6;\n\t                            return this._client.sendRequest(request);\n\t\n\t                        case 6:\n\t                            return _context6.abrupt(\"return\", _context6.sent);\n\t\n\t                        case 9:\n\t                            _context6.prev = 9;\n\t                            _context6.t0 = _context6[\"catch\"](0);\n\t\n\t                            if (!(!_context6.t0.apiResponse || !_context6.t0.apiResponse.response() || _context6.t0.apiResponse.response().status != 401)) {\n\t                                _context6.next = 13;\n\t                                break;\n\t                            }\n\t\n\t                            throw _context6.t0;\n\t\n\t                        case 13:\n\t\n\t                            this._auth.cancelAccessToken();\n\t\n\t                            _context6.next = 16;\n\t                            return this.sendRequest(request, options);\n\t\n\t                        case 16:\n\t                            return _context6.abrupt(\"return\", _context6.sent);\n\t\n\t                        case 17:\n\t                        case \"end\":\n\t                            return _context6.stop();\n\t                    }\n\t                }\n\t            }, _callee6, this, [[0, 9]]);\n\t        }));\n\t\n\t        function sendRequest(_x4, _x5) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return sendRequest;\n\t    }();\n\t\n\t    /**\n\t     * General purpose function to send anything to server\n\t     * @param {string} options.url\n\t     * @param {object} [options.body]\n\t     * @param {string} [options.method]\n\t     * @param {object} [options.query]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.send = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {\n\t            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t            return regeneratorRuntime.wrap(function _callee7$(_context7) {\n\t                while (1) {\n\t                    switch (_context7.prev = _context7.next) {\n\t                        case 0:\n\t\n\t                            //FIXME https://github.com/bitinn/node-fetch/issues/43\n\t                            options.url = this.createUrl(options.url, { addServer: true });\n\t\n\t                            _context7.next = 3;\n\t                            return this.sendRequest(this._client.createRequest(options), options);\n\t\n\t                        case 3:\n\t                            return _context7.abrupt(\"return\", _context7.sent);\n\t\n\t                        case 4:\n\t                        case \"end\":\n\t                            return _context7.stop();\n\t                    }\n\t                }\n\t            }, _callee7, this);\n\t        }));\n\t\n\t        function send(_x6) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return send;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {object} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.get = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(url, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee8$(_context8) {\n\t                while (1) {\n\t                    switch (_context8.prev = _context8.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'GET';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            _context8.next = 6;\n\t                            return this.send(options);\n\t\n\t                        case 6:\n\t                            return _context8.abrupt(\"return\", _context8.sent);\n\t\n\t                        case 7:\n\t                        case \"end\":\n\t                            return _context8.stop();\n\t                    }\n\t                }\n\t            }, _callee8, this);\n\t        }));\n\t\n\t        function get(_x8, _x9, _x10) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return get;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {object} body\n\t     * @param {object} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.post = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, body, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee9$(_context9) {\n\t                while (1) {\n\t                    switch (_context9.prev = _context9.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'POST';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            options.body = body;\n\t                            _context9.next = 7;\n\t                            return this.send(options);\n\t\n\t                        case 7:\n\t                            return _context9.abrupt(\"return\", _context9.sent);\n\t\n\t                        case 8:\n\t                        case \"end\":\n\t                            return _context9.stop();\n\t                    }\n\t                }\n\t            }, _callee9, this);\n\t        }));\n\t\n\t        function post(_x11, _x12, _x13, _x14) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return post;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {object} [body]\n\t     * @param {object} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.put = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee10$(_context10) {\n\t                while (1) {\n\t                    switch (_context10.prev = _context10.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'PUT';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            options.body = body;\n\t                            _context10.next = 7;\n\t                            return this.send(options);\n\t\n\t                        case 7:\n\t                            return _context10.abrupt(\"return\", _context10.sent);\n\t\n\t                        case 8:\n\t                        case \"end\":\n\t                            return _context10.stop();\n\t                    }\n\t                }\n\t            }, _callee10, this);\n\t        }));\n\t\n\t        function put(_x15, _x16, _x17, _x18) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return put;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {string} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype['delete'] = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee11$(_context11) {\n\t                while (1) {\n\t                    switch (_context11.prev = _context11.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'DELETE';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            _context11.next = 6;\n\t                            return this.send(options);\n\t\n\t                        case 6:\n\t                            return _context11.abrupt(\"return\", _context11.sent);\n\t\n\t                        case 7:\n\t                        case \"end\":\n\t                            return _context11.stop();\n\t                    }\n\t                }\n\t            }, _callee11, this);\n\t        }));\n\t\n\t        function _delete(_x19, _x20, _x21) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _delete;\n\t    }();\n\t\n\t    Platform.prototype._tokenRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(path, body) {\n\t            return regeneratorRuntime.wrap(function _callee12$(_context12) {\n\t                while (1) {\n\t                    switch (_context12.prev = _context12.next) {\n\t                        case 0:\n\t                            _context12.next = 2;\n\t                            return this.send({\n\t                                url: path,\n\t                                skipAuthCheck: true,\n\t                                body: body,\n\t                                method: 'POST',\n\t                                headers: {\n\t                                    'Authorization': 'Basic ' + this._apiKey(),\n\t                                    'Content-Type': 'application/x-www-form-urlencoded'\n\t                                }\n\t                            });\n\t\n\t                        case 2:\n\t                            return _context12.abrupt(\"return\", _context12.sent);\n\t\n\t                        case 3:\n\t                        case \"end\":\n\t                            return _context12.stop();\n\t                    }\n\t                }\n\t            }, _callee12, this);\n\t        }));\n\t\n\t        function _tokenRequest(_x22, _x23) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _tokenRequest;\n\t    }();\n\t\n\t    Platform.prototype._ensureAuthentication = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {\n\t            return regeneratorRuntime.wrap(function _callee13$(_context13) {\n\t                while (1) {\n\t                    switch (_context13.prev = _context13.next) {\n\t                        case 0:\n\t                            if (!this._isAccessTokenValid()) {\n\t                                _context13.next = 2;\n\t                                break;\n\t                            }\n\t\n\t                            return _context13.abrupt(\"return\", null);\n\t\n\t                        case 2:\n\t                            _context13.next = 4;\n\t                            return this.refresh();\n\t\n\t                        case 4:\n\t                            return _context13.abrupt(\"return\", _context13.sent);\n\t\n\t                        case 5:\n\t                        case \"end\":\n\t                            return _context13.stop();\n\t                    }\n\t                }\n\t            }, _callee13, this);\n\t        }));\n\t\n\t        function _ensureAuthentication() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _ensureAuthentication;\n\t    }();\n\t\n\t    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {\n\t\n\t        return this._auth.accessTokenValid() && !this._queue.isPaused();\n\t    };\n\t\n\t    Platform.prototype._apiKey = function _apiKey() {\n\t        var apiKey = this._appKey + ':' + this._appSecret;\n\t        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');\n\t    };\n\t\n\t    Platform.prototype._authHeader = function _authHeader() {\n\t        var token = this._auth.accessToken();\n\t        return this._auth.tokenType() + (token ? ' ' + token : '');\n\t    };\n\t\n\t    return Platform;\n\t}(_Observable3.default);\n\t\n\tPlatform._urlPrefix = '/restapi';\n\tPlatform._apiVersion = 'v1.0';\n\tPlatform._refreshTokenTtl = 10 * 60 * 60;\n\tPlatform._refreshTokenTtlRemember = 7 * 24 * 60 * 60;\n\tPlatform._tokenEndpoint = '/restapi/oauth/token';\n\tPlatform._revokeEndpoint = '/restapi/oauth/revoke';\n\tPlatform._authorizeEndpoint = '/restapi/oauth/authorize';\n\tPlatform._refreshDelayMs = 100;\n\tPlatform._cacheId = 'platform';\n\tPlatform._clearCacheOnRefreshError = false;\n\texports.default = Platform;\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Auth = function () {\n\t    function Auth(cache, cacheId) {\n\t        _classCallCheck(this, Auth);\n\t\n\t        /** @type {Cache} */\n\t        this._cache = cache;\n\t        this._cacheId = cacheId;\n\t    } // 1 minute\n\t\n\t\n\t    Auth.prototype.accessToken = function accessToken() {\n\t        return this.data().access_token;\n\t    };\n\t\n\t    Auth.prototype.refreshToken = function refreshToken() {\n\t        return this.data().refresh_token;\n\t    };\n\t\n\t    Auth.prototype.tokenType = function tokenType() {\n\t        return this.data().token_type;\n\t    };\n\t\n\t    /**\n\t     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}\n\t     */\n\t\n\t\n\t    Auth.prototype.data = function data() {\n\t\n\t        return this._cache.getItem(this._cacheId) || {\n\t            token_type: '',\n\t            access_token: '',\n\t            expires_in: 0,\n\t            refresh_token: '',\n\t            refresh_token_expires_in: 0\n\t        };\n\t    };\n\t\n\t    /**\n\t     * @param {object} newData\n\t     * @return {Auth}\n\t     */\n\t\n\t\n\t    Auth.prototype.setData = function setData(newData) {\n\t\n\t        newData = newData || {};\n\t\n\t        var data = this.data();\n\t\n\t        Object.keys(newData).forEach(function (key) {\n\t            data[key] = newData[key];\n\t        });\n\t\n\t        data.expire_time = Date.now() + data.expires_in * 1000;\n\t        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;\n\t\n\t        this._cache.setItem(this._cacheId, data);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Check if there is a valid (not expired) access token\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    Auth.prototype.accessTokenValid = function accessTokenValid() {\n\t\n\t        var authData = this.data();\n\t        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();\n\t    };\n\t\n\t    /**\n\t     * Check if there is a valid (not expired) access token\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    Auth.prototype.refreshTokenValid = function refreshTokenValid() {\n\t\n\t        return this.data().refresh_token_expire_time > Date.now();\n\t    };\n\t\n\t    /**\n\t     * @return {Auth}\n\t     */\n\t\n\t\n\t    Auth.prototype.cancelAccessToken = function cancelAccessToken() {\n\t\n\t        return this.setData({\n\t            access_token: '',\n\t            expires_in: 0\n\t        });\n\t    };\n\t\n\t    /**\n\t     * This method sets a special authentication mode used in Service Web\n\t     * @return {Auth}\n\t     */\n\t\n\t\n\t    Auth.prototype.forceAuthentication = function forceAuthentication() {\n\t\n\t        this.setData({\n\t            token_type: Auth.forcedTokenType,\n\t            access_token: '',\n\t            expires_in: 0,\n\t            refresh_token: '',\n\t            refresh_token_expires_in: 0\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    return Auth;\n\t}();\n\t\n\t//export interface IAuthData {\n\t//    remember?:boolean;\n\t//    token_type?:string;\n\t//    access_token?:string;\n\t//    expires_in?:number; // actually it's string\n\t//    expire_time?:number;\n\t//    refresh_token?:string;\n\t//    refresh_token_expires_in?:number; // actually it's string\n\t//    refresh_token_expire_time?:number;\n\t//    scope?:string;\n\t//}\n\t\n\t\n\tAuth.refreshHandicapMs = 60 * 1000;\n\tAuth.forcedTokenType = 'forced';\n\texports.default = Auth;\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _PubnubMock = __webpack_require__(23);\n\t\n\tvar _PubnubMock2 = _interopRequireDefault(_PubnubMock);\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar PubnubMockFactory = function () {\n\t    function PubnubMockFactory() {\n\t        _classCallCheck(this, PubnubMockFactory);\n\t\n\t        this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n\t    }\n\t\n\t    PubnubMockFactory.prototype.init = function init(options) {\n\t        return new _PubnubMock2.default(options);\n\t    };\n\t\n\t    return PubnubMockFactory;\n\t}();\n\t\n\texports.default = PubnubMockFactory;\n\t\n\t/***/ },\n\t/* 23 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar PubnubMock = function (_Observable) {\n\t    _inherits(PubnubMock, _Observable);\n\t\n\t    function PubnubMock(options) {\n\t        _classCallCheck(this, PubnubMock);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n\t\n\t        _this.options = options;\n\t        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n\t        return _this;\n\t    }\n\t\n\t    PubnubMock.prototype.ready = function ready() {};\n\t\n\t    PubnubMock.prototype.subscribe = function subscribe(options) {\n\t        this.on('message-' + options.channel, options.message);\n\t    };\n\t\n\t    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {\n\t        this.off('message-' + options.channel);\n\t    };\n\t\n\t    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {\n\t        this.emit('message-' + channel, msg, 'env', channel);\n\t    };\n\t\n\t    return PubnubMock;\n\t}(_Observable3.default);\n\t\n\texports.default = PubnubMock;\n\t\n\t/***/ },\n\t/* 24 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _Client = __webpack_require__(15);\n\t\n\tvar _Client2 = _interopRequireDefault(_Client);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Subscription = function (_Observable) {\n\t    _inherits(Subscription, _Observable);\n\t\n\t    function Subscription(pubnubFactory, platform) {\n\t        _classCallCheck(this, Subscription);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n\t\n\t        _this.events = {\n\t            notification: 'notification',\n\t            removeSuccess: 'removeSuccess',\n\t            removeError: 'removeError',\n\t            renewSuccess: 'renewSuccess',\n\t            renewError: 'renewError',\n\t            subscribeSuccess: 'subscribeSuccess',\n\t            subscribeError: 'subscribeError'\n\t        };\n\t\n\t\n\t        _this._pubnubFactory = pubnubFactory;\n\t        _this._platform = platform;\n\t        _this._pubnub = null;\n\t        _this._timeout = null;\n\t        _this._subscription = {};\n\t\n\t        return _this;\n\t    }\n\t\n\t    Subscription.prototype.subscribed = function subscribed() {\n\t\n\t        return !!(this._subscription.id && this._subscription.deliveryMode && this._subscription.deliveryMode.subscriberKey && this._subscription.deliveryMode.address);\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    Subscription.prototype.alive = function alive() {\n\t        return this.subscribed() && Date.now() < this.expirationTime();\n\t    };\n\t\n\t    Subscription.prototype.expirationTime = function expirationTime() {\n\t        return new Date(this._subscription.expirationTime || 0).getTime() - Subscription._renewHandicapMs;\n\t    };\n\t\n\t    Subscription.prototype.setSubscription = function setSubscription(subscription) {\n\t\n\t        subscription = subscription || {};\n\t\n\t        this._clearTimeout();\n\t\n\t        this._subscription = subscription;\n\t\n\t        if (!this._pubnub) this._subscribeAtPubnub();\n\t\n\t        this._setTimeout();\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype.subscription = function subscription() {\n\t        return this._subscription;\n\t    };\n\t\n\t    /**\n\t     * Creates or updates subscription if there is an active one\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.register = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            if (!this.alive()) {\n\t                                _context.next = 6;\n\t                                break;\n\t                            }\n\t\n\t                            _context.next = 3;\n\t                            return this.renew();\n\t\n\t                        case 3:\n\t                            return _context.abrupt('return', _context.sent);\n\t\n\t                        case 6:\n\t                            _context.next = 8;\n\t                            return this.subscribe();\n\t\n\t                        case 8:\n\t                            return _context.abrupt('return', _context.sent);\n\t\n\t                        case 9:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function register() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return register;\n\t    }();\n\t\n\t    Subscription.prototype.eventFilters = function eventFilters() {\n\t        return this._subscription.eventFilters || [];\n\t    };\n\t\n\t    /**\n\t     * @param {string[]} events\n\t     * @return {Subscription}\n\t     */\n\t\n\t\n\t    Subscription.prototype.addEventFilters = function addEventFilters(events) {\n\t        this.setEventFilters(this.eventFilters().concat(events));\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * @param {string[]} events\n\t     * @return {Subscription}\n\t     */\n\t\n\t\n\t    Subscription.prototype.setEventFilters = function setEventFilters(events) {\n\t        this._subscription.eventFilters = events;\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.subscribe = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n\t            var response, json;\n\t            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t                while (1) {\n\t                    switch (_context2.prev = _context2.next) {\n\t                        case 0:\n\t                            _context2.prev = 0;\n\t\n\t\n\t                            this._clearTimeout();\n\t\n\t                            if (this.eventFilters().length) {\n\t                                _context2.next = 4;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Events are undefined');\n\t\n\t                        case 4:\n\t                            _context2.next = 6;\n\t                            return this._platform.post('/restapi/v1.0/subscription', {\n\t                                eventFilters: this._getFullEventFilters(),\n\t                                deliveryMode: {\n\t                                    transportType: 'PubNub'\n\t                                }\n\t                            });\n\t\n\t                        case 6:\n\t                            response = _context2.sent;\n\t                            json = response.json();\n\t\n\t\n\t                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);\n\t\n\t                            return _context2.abrupt('return', response);\n\t\n\t                        case 12:\n\t                            _context2.prev = 12;\n\t                            _context2.t0 = _context2['catch'](0);\n\t\n\t\n\t                            _context2.t0 = this._platform.client().makeError(_context2.t0);\n\t\n\t                            this.reset().emit(this.events.subscribeError, _context2.t0);\n\t\n\t                            throw _context2.t0;\n\t\n\t                        case 17:\n\t                        case 'end':\n\t                            return _context2.stop();\n\t                    }\n\t                }\n\t            }, _callee2, this, [[0, 12]]);\n\t        }));\n\t\n\t        function subscribe() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return subscribe;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.renew = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n\t            var response, json;\n\t            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n\t                while (1) {\n\t                    switch (_context3.prev = _context3.next) {\n\t                        case 0:\n\t                            _context3.prev = 0;\n\t\n\t\n\t                            this._clearTimeout();\n\t\n\t                            if (this.subscribed()) {\n\t                                _context3.next = 4;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('No subscription');\n\t\n\t                        case 4:\n\t                            if (this.eventFilters().length) {\n\t                                _context3.next = 6;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Events are undefined');\n\t\n\t                        case 6:\n\t                            _context3.next = 8;\n\t                            return this._platform.put('/restapi/v1.0/subscription/' + this._subscription.id, {\n\t                                eventFilters: this._getFullEventFilters()\n\t                            });\n\t\n\t                        case 8:\n\t                            response = _context3.sent;\n\t                            json = response.json();\n\t\n\t\n\t                            this.setSubscription(json).emit(this.events.renewSuccess, response);\n\t\n\t                            return _context3.abrupt('return', response);\n\t\n\t                        case 14:\n\t                            _context3.prev = 14;\n\t                            _context3.t0 = _context3['catch'](0);\n\t\n\t\n\t                            _context3.t0 = this._platform.client().makeError(_context3.t0);\n\t\n\t                            this.reset().emit(this.events.renewError, _context3.t0);\n\t\n\t                            throw _context3.t0;\n\t\n\t                        case 19:\n\t                        case 'end':\n\t                            return _context3.stop();\n\t                    }\n\t                }\n\t            }, _callee3, this, [[0, 14]]);\n\t        }));\n\t\n\t        function renew() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return renew;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.remove = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n\t            var response;\n\t            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n\t                while (1) {\n\t                    switch (_context4.prev = _context4.next) {\n\t                        case 0:\n\t                            _context4.prev = 0;\n\t\n\t                            if (this.subscribed()) {\n\t                                _context4.next = 3;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('No subscription');\n\t\n\t                        case 3:\n\t                            _context4.next = 5;\n\t                            return this._platform.delete('/restapi/v1.0/subscription/' + this._subscription.id);\n\t\n\t                        case 5:\n\t                            response = _context4.sent;\n\t\n\t\n\t                            this.reset().emit(this.events.removeSuccess, response);\n\t\n\t                            return _context4.abrupt('return', response);\n\t\n\t                        case 10:\n\t                            _context4.prev = 10;\n\t                            _context4.t0 = _context4['catch'](0);\n\t\n\t\n\t                            _context4.t0 = this._platform.client().makeError(_context4.t0);\n\t\n\t                            this.emit(this.events.removeError, _context4.t0);\n\t\n\t                            throw _context4.t0;\n\t\n\t                        case 15:\n\t                        case 'end':\n\t                            return _context4.stop();\n\t                    }\n\t                }\n\t            }, _callee4, this, [[0, 10]]);\n\t        }));\n\t\n\t        function remove() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return remove;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.resubscribe = function resubscribe() {\n\t\n\t        return this.reset().setEventFilters(this.eventFilters()).subscribe();\n\t    };\n\t\n\t    /**\n\t     * Remove subscription and disconnect from PUBNUB\n\t     * This method resets subscription at client side but backend is not notified\n\t     */\n\t\n\t\n\t    Subscription.prototype.reset = function reset() {\n\t        this._clearTimeout();\n\t        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this._subscription.deliveryMode.address });\n\t        this._subscription = {};\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {\n\t        var _this2 = this;\n\t\n\t        return this.eventFilters().map(function (event) {\n\t            return _this2._platform.createUrl(event);\n\t        });\n\t    };\n\t\n\t    Subscription.prototype._setTimeout = function _setTimeout() {\n\t        var _this3 = this;\n\t\n\t        this._clearTimeout();\n\t\n\t        if (!this.alive()) throw new Error('Subscription is not alive');\n\t\n\t        (0, _Utils.poll)(function (next) {\n\t\n\t            if (_this3.alive()) return next();\n\t\n\t            _this3.renew();\n\t        }, Subscription._pollInterval, this._timeout);\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._clearTimeout = function _clearTimeout() {\n\t\n\t        (0, _Utils.stopPolling)(this._timeout);\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._decrypt = function _decrypt(message) {\n\t\n\t        if (!this.subscribed()) throw new Error('No subscription');\n\t\n\t        if (this._subscription.deliveryMode.encryptionKey) {\n\t\n\t            var PUBNUB = this._pubnubFactory;\n\t\n\t            message = PUBNUB.crypto_obj.decrypt(message, this._subscription.deliveryMode.encryptionKey, {\n\t                encryptKey: false,\n\t                keyEncoding: 'base64',\n\t                keyLength: 128,\n\t                mode: 'ecb'\n\t            });\n\t        }\n\t\n\t        return message;\n\t    };\n\t\n\t    Subscription.prototype._notify = function _notify(message) {\n\t\n\t        this.emit(this.events.notification, this._decrypt(message));\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {\n\t\n\t        if (!this.alive()) throw new Error('Subscription is not alive');\n\t\n\t        var PUBNUB = this._pubnubFactory;\n\t\n\t        this._pubnub = PUBNUB.init({\n\t            ssl: true,\n\t            subscribe_key: this._subscription.deliveryMode.subscriberKey\n\t        });\n\t\n\t        this._pubnub.ready();\n\t\n\t        this._pubnub.subscribe({\n\t            channel: this._subscription.deliveryMode.address,\n\t            message: this._notify.bind(this),\n\t            connect: function connect() {}\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    return Subscription;\n\t}(_Observable3.default);\n\t\n\t//export interface ISubscription {\n\t//    id?:string;\n\t//    uri?: string;\n\t//    eventFilters?:string[];\n\t//    expirationTime?:string; // 2014-03-12T19:54:35.613Z\n\t//    expiresIn?:number;\n\t//    deliveryMode?: {\n\t//        transportType?:string;\n\t//        encryption?:boolean;\n\t//        address?:string;\n\t//        subscriberKey?:string;\n\t//        encryptionKey?:string;\n\t//        secretKey?:string;\n\t//    };\n\t//    creationTime?:string; // 2014-03-12T19:54:35.613Z\n\t//    status?:string; // Active\n\t//}\n\t\n\t\n\tSubscription._renewHandicapMs = 2 * 60 * 1000;\n\tSubscription._pollInterval = 10 * 1000;\n\texports.default = Subscription;\n\t\n\t/***/ },\n\t/* 25 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _Subscription2 = __webpack_require__(24);\n\t\n\tvar _Subscription3 = _interopRequireDefault(_Subscription2);\n\t\n\tvar _Queue = __webpack_require__(14);\n\t\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar CachedSubscription = function (_Subscription) {\n\t    _inherits(CachedSubscription, _Subscription);\n\t\n\t    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {\n\t        _classCallCheck(this, CachedSubscription);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));\n\t\n\t        _this._cache = cache;\n\t        _this._cacheKey = cacheKey;\n\t        _this._renewQueue = new _Queue2.default(_this._cache, cacheKey + '-renew');\n\t        _this._resubscribeQueue = new _Queue2.default(_this._cache, cacheKey + '-resubscribe');\n\t\n\t        _this.events = _extends({}, _this.events, {\n\t            queuedRenewSuccess: 'queuedRenewSuccess',\n\t            queuedRenewError: 'queuedRenewError',\n\t            queuedResubscribeSuccess: 'queuedResubscribeSuccess',\n\t            queuedResubscribeError: 'queuedResubscribeError'\n\t        });\n\t\n\t        _this.on(_this.events.renewError, function () {\n\t            _this.resubscribe();\n\t        });\n\t\n\t        _this.on([_this.events.subscribeSuccess, _this.events.renewSuccess], function () {\n\t            _this._cache.setItem(_this._cacheKey, _this.subscription());\n\t        });\n\t\n\t        _this.on(_this.events.removeSuccess, function () {\n\t            _this._cache.removeItem(_this._cacheKey);\n\t        });\n\t\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * TODO Combine with Platform.refresh and move elsewhere\n\t     * @param actionCb\n\t     * @param queue\n\t     * @param successEvent\n\t     * @param errorEvent\n\t     * @param errorMessage\n\t     * @return {*}\n\t     * @private\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype._queue = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(actionCb, queue, successEvent, errorEvent, errorMessage) {\n\t            var res;\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            _context.prev = 0;\n\t\n\t                            if (!queue.isPaused()) {\n\t                                _context.next = 8;\n\t                                break;\n\t                            }\n\t\n\t                            _context.next = 4;\n\t                            return queue.poll();\n\t\n\t                        case 4:\n\t                            if (this.alive()) {\n\t                                _context.next = 6;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error(errorMessage);\n\t\n\t                        case 6:\n\t\n\t                            this.emit(successEvent, null);\n\t\n\t                            return _context.abrupt('return', null);\n\t\n\t                        case 8:\n\t\n\t                            queue.pause();\n\t\n\t                            _context.next = 11;\n\t                            return actionCb.call(this);\n\t\n\t                        case 11:\n\t                            res = _context.sent;\n\t\n\t\n\t                            queue.resume();\n\t\n\t                            this.emit(successEvent, res);\n\t\n\t                            return _context.abrupt('return', res);\n\t\n\t                        case 17:\n\t                            _context.prev = 17;\n\t                            _context.t0 = _context['catch'](0);\n\t\n\t\n\t                            this.emit(errorEvent, _context.t0);\n\t\n\t                            throw _context.t0;\n\t\n\t                        case 21:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this, [[0, 17]]);\n\t        }));\n\t\n\t        function _queue(_x, _x2, _x3, _x4, _x5) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _queue;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype.renew = function renew() {\n\t\n\t        return this._queue(_Subscription.prototype.renew, this._renewQueue, this.events.queuedRenewSuccess, this.events.queuedRenewError, 'Subscription is not alive after renew timeout');\n\t    };\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype.resubscribe = function resubscribe() {\n\t\n\t        return this._queue(_Subscription.prototype.resubscribe, this._resubscribeQueue, this.events.queuedResubscribeSuccess, this.events.queuedResubscribeError, 'Subscription is not alive after resubscribe timeout');\n\t    };\n\t\n\t    /**\n\t     * @param {string[]} events\n\t     * @return {CachedSubscription}\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype.restore = function restore(events) {\n\t\n\t        var cachedSubscriptionData = this._cache.getItem(this._cacheKey);\n\t\n\t        if (cachedSubscriptionData) {\n\t            try {\n\t                this.setSubscription(cachedSubscriptionData);\n\t            } catch (e) {}\n\t        } else {\n\t            this.setEventFilters(events);\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    return CachedSubscription;\n\t}(_Subscription3.default);\n\t\n\texports.default = CachedSubscription;\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ringcentral-bundle.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(7).Buffer))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\t(function () {\n\t  try {\n\t    cachedSetTimeout = setTimeout;\n\t  } catch (e) {\n\t    cachedSetTimeout = function () {\n\t      throw new Error('setTimeout is not defined');\n\t    }\n\t  }\n\t  try {\n\t    cachedClearTimeout = clearTimeout;\n\t  } catch (e) {\n\t    cachedClearTimeout = function () {\n\t      throw new Error('clearTimeout is not defined');\n\t    }\n\t  }\n\t} ())\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = cachedSetTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    cachedClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        cachedSetTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(8)\n\tvar ieee754 = __webpack_require__(9)\n\tvar isArray = __webpack_require__(10)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\tvar rootParent = {}\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n\t *     on objects.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\tfunction typedArraySupport () {\n\t  function Bar () {}\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.foo = function () { return 42 }\n\t    arr.constructor = Bar\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        arr.constructor === Bar && // constructor can be set\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\t/**\n\t * Class: Buffer\n\t * =============\n\t *\n\t * The Buffer constructor returns instances of `Uint8Array` that are augmented\n\t * with function properties for all the node `Buffer` API functions. We use\n\t * `Uint8Array` so that square bracket notation works as expected -- it returns\n\t * a single octet.\n\t *\n\t * By augmenting the instances, we can avoid modifying the `Uint8Array`\n\t * prototype.\n\t */\n\tfunction Buffer (arg) {\n\t  if (!(this instanceof Buffer)) {\n\t    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n\t    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n\t    return new Buffer(arg)\n\t  }\n\t\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this.length = 0\n\t    this.parent = undefined\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    return fromNumber(this, arg)\n\t  }\n\t\n\t  // Slightly less common case.\n\t  if (typeof arg === 'string') {\n\t    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n\t  }\n\t\n\t  // Unusual.\n\t  return fromObject(this, arg)\n\t}\n\t\n\tfunction fromNumber (that, length) {\n\t  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < length; i++) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\t\n\t  // Assumption: byteLength() return value is always < kMaxLength.\n\t  var length = byteLength(string, encoding) | 0\n\t  that = allocate(that, length)\n\t\n\t  that.write(string, encoding)\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, object) {\n\t  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\t\n\t  if (isArray(object)) return fromArray(that, object)\n\t\n\t  if (object == null) {\n\t    throw new TypeError('must start with number, buffer, array or string')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined') {\n\t    if (object.buffer instanceof ArrayBuffer) {\n\t      return fromTypedArray(that, object)\n\t    }\n\t    if (object instanceof ArrayBuffer) {\n\t      return fromArrayBuffer(that, object)\n\t    }\n\t  }\n\t\n\t  if (object.length) return fromArrayLike(that, object)\n\t\n\t  return fromJsonObject(that, object)\n\t}\n\t\n\tfunction fromBuffer (that, buffer) {\n\t  var length = checked(buffer.length) | 0\n\t  that = allocate(that, length)\n\t  buffer.copy(that, 0, 0, length)\n\t  return that\n\t}\n\t\n\tfunction fromArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Duplicate of fromArray() to keep fromArray() monomorphic.\n\tfunction fromTypedArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  // Truncating the elements is probably not what people expect from typed\n\t  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n\t  // of the old Buffer constructor.\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    array.byteLength\n\t    that = Buffer._augment(new Uint8Array(array))\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromTypedArray(that, new Uint8Array(array))\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n\t// Returns a zero-length buffer for inputs that don't conform to the spec.\n\tfunction fromJsonObject (that, object) {\n\t  var array\n\t  var length = 0\n\t\n\t  if (object.type === 'Buffer' && isArray(object.data)) {\n\t    array = object.data\n\t    length = checked(array.length) | 0\n\t  }\n\t  that = allocate(that, length)\n\t\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t} else {\n\t  // pre-set for values that may exist in the future\n\t  Buffer.prototype.length = undefined\n\t  Buffer.prototype.parent = undefined\n\t}\n\t\n\tfunction allocate (that, length) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = Buffer._augment(new Uint8Array(length))\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that.length = length\n\t    that._isBuffer = true\n\t  }\n\t\n\t  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n\t  if (fromPool) that.parent = rootParent\n\t\n\t  return that\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (subject, encoding) {\n\t  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\t\n\t  var buf = new Buffer(subject, encoding)\n\t  delete buf.parent\n\t  return buf\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  var i = 0\n\t  var len = Math.min(x, y)\n\t  while (i < len) {\n\t    if (a[i] !== b[i]) break\n\t\n\t    ++i\n\t  }\n\t\n\t  if (i !== len) {\n\t    x = a[i]\n\t    y = b[i]\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'raw':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\t\n\t  if (list.length === 0) {\n\t    return new Buffer(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; i++) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buf = new Buffer(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    item.copy(buf, pos)\n\t    pos += item.length\n\t  }\n\t  return buf\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (typeof string !== 'string') string = '' + string\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'binary':\n\t      // Deprecated\n\t      case 'raw':\n\t      case 'raws':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  start = start | 0\n\t  end = end === undefined || end === Infinity ? this.length : end | 0\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t  if (start < 0) start = 0\n\t  if (end > this.length) end = this.length\n\t  if (end <= start) return ''\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'binary':\n\t        return binarySlice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return 0\n\t  return Buffer.compare(this, b)\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n\t  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n\t  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n\t  byteOffset >>= 0\n\t\n\t  if (this.length === 0) return -1\n\t  if (byteOffset >= this.length) return -1\n\t\n\t  // Negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\t\n\t  if (typeof val === 'string') {\n\t    if (val.length === 0) return -1 // special case: looking for empty string always fails\n\t    return String.prototype.indexOf.call(this, val, byteOffset)\n\t  }\n\t  if (Buffer.isBuffer(val)) {\n\t    return arrayIndexOf(this, val, byteOffset)\n\t  }\n\t  if (typeof val === 'number') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n\t      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n\t    }\n\t    return arrayIndexOf(this, [ val ], byteOffset)\n\t  }\n\t\n\t  function arrayIndexOf (arr, val, byteOffset) {\n\t    var foundIndex = -1\n\t    for (var i = 0; byteOffset + i < arr.length; i++) {\n\t      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n\t      } else {\n\t        foundIndex = -1\n\t      }\n\t    }\n\t    return -1\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\t// `get` is deprecated\n\tBuffer.prototype.get = function get (offset) {\n\t  console.log('.get() is deprecated. Access using array indexes instead.')\n\t  return this.readUInt8(offset)\n\t}\n\t\n\t// `set` is deprecated\n\tBuffer.prototype.set = function set (v, offset) {\n\t  console.log('.set() is deprecated. Access using array indexes instead.')\n\t  return this.writeUInt8(v, offset)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; i++) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) throw new Error('Invalid hex string')\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction binaryWrite (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    var swap = encoding\n\t    encoding = offset\n\t    offset = length | 0\n\t    length = swap\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'binary':\n\t        return binaryWrite(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction binarySlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; i++) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = Buffer._augment(this.subarray(start, end))\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; i++) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  if (newBuf.length) newBuf.parent = this.parent || this\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t  if (offset < 0) throw new RangeError('index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; i--) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; i++) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    target._set(this.subarray(start, start + len), targetStart)\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// fill(value, start=0, end=buffer.length)\n\tBuffer.prototype.fill = function fill (value, start, end) {\n\t  if (!value) value = 0\n\t  if (!start) start = 0\n\t  if (!end) end = this.length\n\t\n\t  if (end < start) throw new RangeError('end < start')\n\t\n\t  // Fill 0 bytes; we're done\n\t  if (end === start) return\n\t  if (this.length === 0) return\n\t\n\t  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n\t  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\t\n\t  var i\n\t  if (typeof value === 'number') {\n\t    for (i = start; i < end; i++) {\n\t      this[i] = value\n\t    }\n\t  } else {\n\t    var bytes = utf8ToBytes(value.toString())\n\t    var len = bytes.length\n\t    for (i = start; i < end; i++) {\n\t      this[i] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n\t * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n\t */\n\tBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n\t  if (typeof Uint8Array !== 'undefined') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t      return (new Buffer(this)).buffer\n\t    } else {\n\t      var buf = new Uint8Array(this.length)\n\t      for (var i = 0, len = buf.length; i < len; i += 1) {\n\t        buf[i] = this[i]\n\t      }\n\t      return buf.buffer\n\t    }\n\t  } else {\n\t    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n\t  }\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar BP = Buffer.prototype\n\t\n\t/**\n\t * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n\t */\n\tBuffer._augment = function _augment (arr) {\n\t  arr.constructor = Buffer\n\t  arr._isBuffer = true\n\t\n\t  // save reference to original Uint8Array set method before overwriting\n\t  arr._set = arr.set\n\t\n\t  // deprecated\n\t  arr.get = BP.get\n\t  arr.set = BP.set\n\t\n\t  arr.write = BP.write\n\t  arr.toString = BP.toString\n\t  arr.toLocaleString = BP.toString\n\t  arr.toJSON = BP.toJSON\n\t  arr.equals = BP.equals\n\t  arr.compare = BP.compare\n\t  arr.indexOf = BP.indexOf\n\t  arr.copy = BP.copy\n\t  arr.slice = BP.slice\n\t  arr.readUIntLE = BP.readUIntLE\n\t  arr.readUIntBE = BP.readUIntBE\n\t  arr.readUInt8 = BP.readUInt8\n\t  arr.readUInt16LE = BP.readUInt16LE\n\t  arr.readUInt16BE = BP.readUInt16BE\n\t  arr.readUInt32LE = BP.readUInt32LE\n\t  arr.readUInt32BE = BP.readUInt32BE\n\t  arr.readIntLE = BP.readIntLE\n\t  arr.readIntBE = BP.readIntBE\n\t  arr.readInt8 = BP.readInt8\n\t  arr.readInt16LE = BP.readInt16LE\n\t  arr.readInt16BE = BP.readInt16BE\n\t  arr.readInt32LE = BP.readInt32LE\n\t  arr.readInt32BE = BP.readInt32BE\n\t  arr.readFloatLE = BP.readFloatLE\n\t  arr.readFloatBE = BP.readFloatBE\n\t  arr.readDoubleLE = BP.readDoubleLE\n\t  arr.readDoubleBE = BP.readDoubleBE\n\t  arr.writeUInt8 = BP.writeUInt8\n\t  arr.writeUIntLE = BP.writeUIntLE\n\t  arr.writeUIntBE = BP.writeUIntBE\n\t  arr.writeUInt16LE = BP.writeUInt16LE\n\t  arr.writeUInt16BE = BP.writeUInt16BE\n\t  arr.writeUInt32LE = BP.writeUInt32LE\n\t  arr.writeUInt32BE = BP.writeUInt32BE\n\t  arr.writeIntLE = BP.writeIntLE\n\t  arr.writeIntBE = BP.writeIntBE\n\t  arr.writeInt8 = BP.writeInt8\n\t  arr.writeInt16LE = BP.writeInt16LE\n\t  arr.writeInt16BE = BP.writeInt16BE\n\t  arr.writeInt32LE = BP.writeInt32LE\n\t  arr.writeInt32BE = BP.writeInt32BE\n\t  arr.writeFloatLE = BP.writeFloatLE\n\t  arr.writeFloatBE = BP.writeFloatBE\n\t  arr.writeDoubleLE = BP.writeDoubleLE\n\t  arr.writeDoubleBE = BP.writeDoubleBE\n\t  arr.fill = BP.fill\n\t  arr.inspect = BP.inspect\n\t  arr.toArrayBuffer = BP.toArrayBuffer\n\t\n\t  return arr\n\t}\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; i++) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; i++) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\t;(function (exports) {\n\t\t'use strict';\n\t\n\t  var Arr = (typeof Uint8Array !== 'undefined')\n\t    ? Uint8Array\n\t    : Array\n\t\n\t\tvar PLUS   = '+'.charCodeAt(0)\n\t\tvar SLASH  = '/'.charCodeAt(0)\n\t\tvar NUMBER = '0'.charCodeAt(0)\n\t\tvar LOWER  = 'a'.charCodeAt(0)\n\t\tvar UPPER  = 'A'.charCodeAt(0)\n\t\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\t\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\t\n\t\tfunction decode (elt) {\n\t\t\tvar code = elt.charCodeAt(0)\n\t\t\tif (code === PLUS ||\n\t\t\t    code === PLUS_URL_SAFE)\n\t\t\t\treturn 62 // '+'\n\t\t\tif (code === SLASH ||\n\t\t\t    code === SLASH_URL_SAFE)\n\t\t\t\treturn 63 // '/'\n\t\t\tif (code < NUMBER)\n\t\t\t\treturn -1 //no match\n\t\t\tif (code < NUMBER + 10)\n\t\t\t\treturn code - NUMBER + 26 + 26\n\t\t\tif (code < UPPER + 26)\n\t\t\t\treturn code - UPPER\n\t\t\tif (code < LOWER + 26)\n\t\t\t\treturn code - LOWER + 26\n\t\t}\n\t\n\t\tfunction b64ToByteArray (b64) {\n\t\t\tvar i, j, l, tmp, placeHolders, arr\n\t\n\t\t\tif (b64.length % 4 > 0) {\n\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t\t}\n\t\n\t\t\t// the number of equal signs (place holders)\n\t\t\t// if there are two placeholders, than the two characters before it\n\t\t\t// represent one byte\n\t\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t\t// this is just a cheap hack to not do indexOf twice\n\t\t\tvar len = b64.length\n\t\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\t\n\t\t\t// base64 is 4/3 + up to two characters of the original data\n\t\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\t\n\t\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\t\n\t\t\tvar L = 0\n\t\n\t\t\tfunction push (v) {\n\t\t\t\tarr[L++] = v\n\t\t\t}\n\t\n\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\tif (placeHolders === 2) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t} else if (placeHolders === 1) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\treturn arr\n\t\t}\n\t\n\t\tfunction uint8ToBase64 (uint8) {\n\t\t\tvar i,\n\t\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\t\toutput = \"\",\n\t\t\t\ttemp, length\n\t\n\t\t\tfunction encode (num) {\n\t\t\t\treturn lookup.charAt(num)\n\t\t\t}\n\t\n\t\t\tfunction tripletToBase64 (num) {\n\t\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t\t}\n\t\n\t\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\t\toutput += tripletToBase64(temp)\n\t\t\t}\n\t\n\t\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\t\tswitch (extraBytes) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\t\toutput += '=='\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\t\toutput += '='\n\t\t\t\t\tbreak\n\t\t\t}\n\t\n\t\t\treturn output\n\t\t}\n\t\n\t\texports.toByteArray = b64ToByteArray\n\t\texports.fromByteArray = uint8ToBase64\n\t}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar config = {\n\t    key: '8mOtYiilT5OUPwwdeGgvpw',\n\t    secret: 'cqNn89RmR2SR76Kpp8xJaAdNzNOqR8Qfmjb0B-gDOHTw',\n\t\n\t    incomingAudio: '../src/assets/audio/incoming.ogg',\n\t    outgoingAudio: '../src/assets/audio/outgoing.ogg'\n\t};\n\texports.default = config;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _rcWebphone = __webpack_require__(13);\n\t\n\tvar _rcWebphone2 = _interopRequireDefault(_rcWebphone);\n\t\n\tvar _rcConfig = __webpack_require__(11);\n\t\n\tvar _rcConfig2 = _interopRequireDefault(_rcConfig);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar PhoneService = function () {\n\t    var webPhone;\n\t    var session;\n\t    var handlers = {\n\t        invite: [],\n\t        accepted: [],\n\t        progress: [],\n\t        rejected: [],\n\t        terminated: [],\n\t        failed: [],\n\t        bye: [],\n\t        refer: []\n\t    };\n\t    function listen(session) {\n\t        session.on('accepted', function () {\n\t            handlers['accepted'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('progress', function () {\n\t            handlers['progress'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('rejected', function () {\n\t            handlers['rejected'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('terminated', function () {\n\t            handlers['terminated'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('failed', function () {\n\t            handlers['failed'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('bye', function () {\n\t            handlers['bye'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('refer', function () {\n\t            handlers['refer'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t    }\n\t    return {\n\t        init: function init(options) {\n\t            return _rcSdk.RC.sdk.platform().post('/client-info/sip-provision', {\n\t                sipInfo: [{\n\t                    transport: 'WSS'\n\t                }]\n\t            }).then(function (res) {\n\t                return new _rcWebphone2.default(res.json(), { // optional\n\t                    appKey: _rcConfig2.default.key,\n\t                    logLevel: 1,\n\t                    audioHelper: {\n\t                        enabled: true, // enables audio feedback when web phone is ringing or making a call\n\t                        incoming: options.incomingAudio, // path to audio file for incoming call\n\t                        outgoing: options.outgoingAudio // path to aduotfile for outgoing call\n\t                    }\n\t                });\n\t            }).then(function (p) {\n\t                webPhone = p;\n\t                console.log(webPhone);\n\t                webPhone.userAgent.on('invite', function (s) {\n\t                    session = s;\n\t                    handlers['invite'].forEach(function (handler) {\n\t                        return handler(session);\n\t                    });\n\t                    listen(session);\n\t                });\n\t            }).catch(function (e) {\n\t                return console.error(e);\n\t            });\n\t        },\n\t        on: function on(name, callback) {\n\t            handlers[name].push(callback);\n\t        },\n\t        call: function call(fromNumber, toNumber, options) {\n\t            console.log(webPhone);\n\t            session = webPhone.userAgent.invite(toNumber, {\n\t                media: {\n\t                    render: {\n\t                        remote: options.remoteVideo,\n\t                        local: options.localVideo\n\t                    }\n\t                },\n\t                fromNumber: fromNumber\n\t            });\n\t            listen(session);\n\t        },\n\t        accept: function accept(options) {\n\t            console.log(session);\n\t            if (session.accept && !session.startTime) return session.accept({\n\t                media: {\n\t                    render: {\n\t                        remote: options.remoteVideo,\n\t                        local: options.localVideo\n\t                    }\n\t                }\n\t            });\n\t            return null;\n\t        },\n\t        reject: function reject() {\n\t            return session.reject();\n\t        },\n\t        hangup: function hangup() {\n\t            return session.bye();\n\t        },\n\t        hold: function hold(flag) {\n\t            if (flag) {\n\t                return session.hold().then(function () {\n\t                    return session;\n\t                });\n\t            }\n\t            return session.unhold().then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        mute: function mute(flag) {\n\t            if (flag) session.mute();else session.unmute();\n\t            return session;\n\t        },\n\t        flip: function flip(number) {\n\t            return session.flip(number).then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        forward: function forward(number) {\n\t            return session.forward(number).then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        transfer: function transfer(number) {\n\t            return session.transfer(number).then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        park: function park() {\n\t            return session.park().then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        dtmf: function dtmf(number) {\n\t            return session.dtmf(number);\n\t        },\n\t        record: function record(flag) {\n\t            if (flag) {\n\t                return session.startRecord().then(function () {\n\t                    return session;\n\t                });\n\t            } else {\n\t                return session.stopRecord().then(function () {\n\t                    return session;\n\t                });\n\t            }\n\t        }\n\t    };\n\t}();\n\texports.default = PhoneService;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _ringcentralWebPhone = __webpack_require__(14);\n\t\n\tvar _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _ringcentralWebPhone2.default;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {\n\t            return factory(SIP);\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module === 'object') {\n\t        module.exports = factory(require('sip.js'));\n\t        module.exports.default = module.exports; //ES6\n\t    } else {\n\t        root.RingCentral = root.RingCentral || {};\n\t        root.RingCentral.WebPhone = factory(root.SIP);\n\t    }\n\t}(this, function(SIP) {\n\t\n\t    var messages = {\n\t        park: {reqid: 1, command: 'callpark'},\n\t        startRecord: {reqid: 2, command: 'startcallrecord'},\n\t        stopRecord: {reqid: 3, command: 'stopcallrecord'},\n\t        flip: {reqid: 3, command: 'callflip', target: ''},\n\t        monitor: {reqid: 4, command: 'monitor'},\n\t        barge: {reqid: 5, command: 'barge'},\n\t        whisper: {reqid: 6, command: 'whisper'},\n\t        takeover: {reqid: 7, command: 'takeover'}\n\t    };\n\t\n\t    var responseTimeout = 10000;\n\t\n\t    function uuid() {\n\t        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t            return v.toString(16);\n\t        });\n\t    }\n\t\n\t    function delay(ms) {\n\t        return new Promise(function(resolve, reject) {\n\t            setTimeout(resolve, ms);\n\t        });\n\t    }\n\t\n\t    function extend(dst, src) {\n\t        src = src || {};\n\t        dst = dst || {};\n\t        Object.keys(src).forEach(function(k) {\n\t            dst[k] = src[k];\n\t        });\n\t        return dst;\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @param options\n\t     * @constructor\n\t     */\n\t    function AudioHelper(options) {\n\t\n\t        options = options || {};\n\t\n\t        this._enabled = !!options.enabled;\n\t        this._incoming = options.incoming || '../audio/incoming.ogg';\n\t        this._outgoing = options.outgoing || '../audio/outgoing.ogg';\n\t        this._audio = {};\n\t\n\t    }\n\t\n\t    AudioHelper.prototype._playSound = function(url, val, volume) {\n\t\n\t        if (!this._enabled) return this;\n\t\n\t        if (!this._audio[url]) {\n\t            if (val) {\n\t                this._audio[url] = new Audio();\n\t                this._audio[url].src = url;\n\t                this._audio[url].loop = true;\n\t                this._audio[url].volume = volume;\n\t                this._audio[url].play();\n\t            }\n\t        } else {\n\t            if (val) {\n\t                this._audio[url].currentTime = 0;\n\t                this._audio[url].play();\n\t            } else {\n\t                this._audio[url].pause();\n\t            }\n\t        }\n\t\n\t        return this;\n\t\n\t    };\n\t\n\t    AudioHelper.prototype.playIncoming = function(val) {\n\t        return this._playSound(this._incoming, val, 0.5);\n\t    };\n\t\n\t    AudioHelper.prototype.playOutgoing = function(val) {\n\t        return this._playSound(this._outgoing, val, 1);\n\t    };\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @param {object} regData\n\t     * @param {object} [options]\n\t     * @param {string} [options.uuid]\n\t     * @param {string} [options.appKey]\n\t     * @param {string} [options.appName]\n\t     * @param {string} [options.appVersion]\n\t     * @param {string} [options.audioHelper]\n\t     * @param {string} [options.onSession] fired each time UserAgent starts working with session\n\t     * @constructor\n\t     */\n\t    function WebPhone(regData, options) {\n\t\n\t        regData = regData || {};\n\t        options = options || {};\n\t\n\t        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;\n\t        this.sipFlags = regData.sipFlags;\n\t\n\t        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable\n\t        localStorage.setItem('rc-webPhone-uuid', id);\n\t\n\t        this.endpointHeader = 'P-rc-endpoint-id: ' + id;\n\t\n\t        var configuration = {\n\t            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,\n\t            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport\n\t                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy\n\t                : this.sipInfo.wsServers,\n\t            authorizationUser: this.sipInfo.authorizationId,\n\t            password: this.sipInfo.password,\n\t            traceSip: true,\n\t            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?\n\t            turnServers: [],\n\t            log: {\n\t                level: options.logLevel || 1 //FIXME LOG LEVEL 3\n\t            },\n\t            domain: this.sipInfo.domain,\n\t            autostart: true,\n\t            register: true,\n\t            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000\n\t        };\n\t\n\t        this.appKey = options.appKey;\n\t        this.appName = options.appName;\n\t        this.appVersion = options.appVersion;\n\t        this.userAgentHeader = 'RC-User-Agent: ' +\n\t                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +\n\t                               'RCWEBPHONE/' + WebPhone.version;\n\t\n\t        this.clientIdHeader = 'Client-id:' + options.appKey;\n\t\n\t        this.userAgent = new SIP.UA(configuration).register({\n\t            extraHeaders: [\n\t                this.endpointHeader,\n\t                this.userAgentHeader,\n\t                this.clientIdHeader\n\t            ]\n\t        });\n\t\n\t        this.userAgent.endpointHeader = this.endpointHeader;\n\t        this.userAgent.userAgentHeader = this.userAgentHeader;\n\t        this.userAgent.clientIdHeader = this.clientIdHeader;\n\t        this.userAgent.sipInfo = this.sipInfo;\n\t\n\t        this.userAgent.__invite = this.userAgent.invite;\n\t        this.userAgent.invite = invite;\n\t\n\t        this.userAgent.on('invite', function(session) {\n\t            this.userAgent.audioHelper.playIncoming(true);\n\t            patchSession(session);\n\t        }.bind(this));\n\t\n\t        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);\n\t\n\t        this.userAgent.onSession = options.onSession || null;\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    WebPhone.version = '0.3.1';\n\t    WebPhone.uuid = uuid;\n\t    WebPhone.delay = delay;\n\t    WebPhone.extend = extend;\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    function patchSession(session) {\n\t\n\t        if (session.__patched) return session;\n\t\n\t        session.__patched = true;\n\t\n\t        session.__sendRequest = session.sendRequest;\n\t        session.__receiveRequest = session.receiveRequest;\n\t        session.__receiveInviteResponse = session.receiveInviteResponse;\n\t        session.__receiveResponse = session.receiveResponse;\n\t        session.__accept = session.accept;\n\t        session.__hold = session.hold;\n\t        session.__unhold = session.unhold;\n\t        session.__dtmf = session.dtmf;\n\t\n\t        session.sendRequest = sendRequest;\n\t        session.receiveRequest = receiveRequest;\n\t        session.receiveInviteResponse = receiveInviteResponse;\n\t        session.receiveResponse = receiveResponse;\n\t        session.accept = accept;\n\t        session.hold = hold;\n\t        session.unhold = unhold;\n\t        session.dtmf = dtmf;\n\t\n\t        session.blindTransfer = blindTransfer;\n\t        session.transfer = transfer;\n\t        session.park = park;\n\t        session.forward = forward;\n\t        session.startRecord = startRecord;\n\t        session.stopRecord = stopRecord;\n\t        session.flip = flip;\n\t\n\t        session.on('replaced', patchSession);\n\t        // session.on('connecting', onConnecting);\n\t\n\t        // Audio\n\t        session.on('accepted', stopPlaying);\n\t        session.on('rejected', stopPlaying);\n\t        session.on('bye', stopPlaying);\n\t        session.on('terminated', stopPlaying);\n\t        session.on('cancel', stopPlaying);\n\t        session.on('failed', stopPlaying);\n\t        session.on('replaced', stopPlaying);\n\t        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);\n\t        session.mediaHandler.on('iceConnectionFailed', stopPlaying);\n\t\n\t        function stopPlaying() {\n\t            session.ua.audioHelper.playOutgoing(false);\n\t            session.ua.audioHelper.playIncoming(false);\n\t            session.removeListener('accepted', stopPlaying);\n\t            session.removeListener('rejected', stopPlaying);\n\t            session.removeListener('bye', stopPlaying);\n\t            session.removeListener('terminated', stopPlaying);\n\t            session.removeListener('cancel', stopPlaying);\n\t            session.removeListener('failed', stopPlaying);\n\t            session.removeListener('replaced', stopPlaying);\n\t            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);\n\t            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);\n\t        }\n\t\n\t        if (session.ua.onSession) session.ua.onSession(session);\n\t\n\t        return session;\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @private\n\t     * @param {SIP.Session} session\n\t     * @param {object} command\n\t     * @param {object} [options]\n\t     * @return {Promise}\n\t     */\n\t    function sendReceive(session, command, options) {\n\t\n\t        options = options || {};\n\t\n\t        extend(command, options);\n\t\n\t        var cseq = null;\n\t\n\t        return new Promise(function(resolve, reject) {\n\t\n\t            session.sendRequest(SIP.C.INFO, {\n\t                body: JSON.stringify({\n\t                    request: command\n\t                }),\n\t                extraHeaders: [\n\t                    \"Content-Type: application/json;charset=utf-8\",\n\t                    session.ua.userAgentHeader,\n\t                    session.ua.endpointHeader,\n\t                    session.ua.clientIdHeader\n\t                ],\n\t                receiveResponse: function(response) {\n\t                    var timeout = null;\n\t                    if (response.status_code === 200) {\n\t                        cseq = response.cseq;\n\t                        var onInfo = function(request) {\n\t                            if (response.cseq === cseq) {\n\t\n\t                                var body = request && request.body || '{}';\n\t                                var obj;\n\t\n\t                                try {\n\t                                    obj = JSON.parse(body);\n\t                                } catch (e) {\n\t                                    obj = {};\n\t                                }\n\t\n\t                                if (obj.response && obj.response.command === command.command) {\n\t                                    if (obj.response.result) {\n\t                                        if (obj.response.result.code == 0) {\n\t                                            return resolve(obj.response.result);\n\t                                        } else {\n\t                                            return reject(obj.response.result);\n\t                                        }\n\t                                    }\n\t                                }\n\t                                timeout && clearTimeout(timeout);\n\t                                session.removeListener('RC_SIP_INFO', onInfo);\n\t                                resolve(null); //FIXME What to resolve\n\t                            }\n\t                        };\n\t\n\t                        timeout = setTimeout(function() {\n\t                            reject(new Error('Timeout: no reply'));\n\t                            session.removeListener('RC_SIP_INFO', onInfo);\n\t                        }, responseTimeout);\n\t                        session.on('RC_SIP_INFO', onInfo);\n\t                    }\n\t                    else {\n\t                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));\n\t                    }\n\t                }\n\t            });\n\t\n\t        });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    function sendRequest(type, config) {\n\t        if (type == SIP.C.PRACK) {\n\t            type = SIP.C.ACK;\n\t        }\n\t        return this.__sendRequest(type, config);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Fired each time a provisional (100-199) response is received.\n\t     * Early media is supported by SIP.js library\n\t     * But in case it is sent without 100rel support we play it manually\n\t     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n\t     *\n\t     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n\t     * @param {SIP.Session} session\n\t     * @param response\n\t     * @param {funciton} cb\n\t     */\n\t    function patch100rel(session, response, cb) {\n\t\n\t        //Early media is supported by SIP.js library\n\t        //But in case it is sent without 100rel support we play it manually\n\t        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n\t        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\\n') !== -1) {\n\t            if (!response.hasHeader('require')) response.setHeader('require', '100rel');\n\t        }\n\t\n\t        return cb.call(session, response);\n\t\n\t    }\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param response\n\t     * @return {*}\n\t     */\n\t    function receiveInviteResponse(response) {\n\t        return patch100rel(this, response, this.__receiveInviteResponse);\n\t    }\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param response\n\t     * @return {*}\n\t     */\n\t    function receiveResponse(response) {\n\t        return patch100rel(this, response, this.__receiveResponse);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @private\n\t     * @param {SIP.Session} session\n\t     * @param {boolean} flag\n\t     * @return {Promise}\n\t     */\n\t    function setRecord(session, flag) {\n\t\n\t        var message = !!flag\n\t            ? messages.startRecord\n\t            : messages.stopRecord;\n\t\n\t        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {\n\t            return sendReceive(session, message)\n\t                .then(function(data) {\n\t                    session.__onRecord = !!flag;\n\t                    return data;\n\t                });\n\t        }\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @private\n\t     * @param {SIP.Session} session\n\t     * @param {boolean} flag\n\t     * @return {Promise}\n\t     */\n\t    function setHold(session, flag) {\n\t        return new Promise(function(resolve, reject) {\n\t\n\t            var options = {\n\t                eventHandlers: {\n\t                    succeeded: resolve,\n\t                    failed: reject\n\t                }\n\t            };\n\t\n\t            if (flag) {\n\t                session.__hold(options);\n\t            } else {\n\t                session.__unhold(options);\n\t            }\n\t\n\t        });\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.UA}\n\t     * @param number\n\t     * @param options\n\t     * @return {SIP.Session}\n\t     */\n\t    function invite(number, options) {\n\t\n\t        var ua = this;\n\t\n\t        options = options || {};\n\t        options.extraHeaders = options.extraHeaders || [];\n\t\n\t        options.extraHeaders.push(ua.userAgentHeader);\n\t        options.extraHeaders.push(ua.endpointHeader);\n\t        options.extraHeaders.push(ua.clientIdHeader);\n\t\n\t        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number\n\t\n\t        //FIXME Backend should know it already\n\t        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }\n\t\n\t        options.media = options.media || {};\n\t        options.media.constraints = options.media.constraints || {audio: true, video: false};\n\t\n\t        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n\t\n\t        ua.audioHelper.playOutgoing(true);\n\t\n\t        return patchSession(ua.__invite(number, options));\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param request\n\t     * @return {*}\n\t     */\n\t    function receiveRequest(request) {\n\t        var session = this;\n\t        switch (request.method) {\n\t            case SIP.C.INFO:\n\t                session.emit('RC_SIP_INFO', request);\n\t                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case\n\t                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n\t                    var contentType = request.getHeader('content-type');\n\t                    if (contentType.match(/^application\\/json/i)) {\n\t                        request.reply(200);\n\t                        return session;\n\t                    }\n\t                }\n\t                break;\n\t            //Refresh invite should not be rejected with 488\n\t            case SIP.C.INVITE:\n\t                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {\n\t                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {\n\t                        //TODO: check that SDP did not change\n\t                        session.logger.log('re-INVITE received');\n\t                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;\n\t                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {\n\t                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;\n\t                            session.setInvite2xxTimer(request, localSDP);\n\t                            session.setACKTimer();\n\t                        });\n\t                        return session;\n\t                    }\n\t                    //else will be rejected with 488 by SIP.js\n\t                }\n\t                break;\n\t            //We need to analize NOTIFY messages sometimes, so we fire an event\n\t            case SIP.C.NOTIFY:\n\t                session.emit('RC_SIP_NOTIFY', request);\n\t                break;\n\t        }\n\t        return session.__receiveRequest.apply(session, arguments);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param {object} options\n\t     * @return {Promise}\n\t     */\n\t    function accept(options) {\n\t\n\t        var session = this;\n\t\n\t        options = options || {};\n\t        options.extraHeaders = options.extraHeaders || [];\n\t\n\t        options.extraHeaders.push(session.ua.userAgentHeader);\n\t        options.extraHeaders.push(session.ua.endpointHeader);\n\t        options.extraHeaders.push(session.ua.clientIdHeader);\n\t\n\t        options.media = options.media || {};\n\t        options.media.constraints = options.media.constraints || {audio: true, video: false};\n\t\n\t        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n\t\n\t        return new Promise(function(resolve, reject) {\n\t\n\t            function onAnswered() {\n\t                resolve(session);\n\t                session.removeListener('failed', onFail);\n\t            }\n\t\n\t            function onFail(e) {\n\t                reject(e);\n\t                session.removeListener('accepted', onAnswered);\n\t            }\n\t\n\t            //TODO More events?\n\t            session.once('accepted', onAnswered);\n\t            session.once('failed', onFail);\n\t\n\t            session.__accept(options);\n\t\n\t        });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @param {string} dtmf\n\t     * @param {number} duration\n\t     * @return {Promise}\n\t     */\n\t    function dtmf(dtmf, duration) {\n\t        var session = this;\n\t        duration = parseInt(duration) || 1000;\n\t        var peer = session.mediaHandler.peerConnection;\n\t        var stream = session.getLocalStreams()[0];\n\t        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);\n\t        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {\n\t            return dtmfSender.insertDTMF(dtmf, duration);\n\t        }\n\t        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\\'t insert DTMF' : 'Unknown')));\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @return {Promise}\n\t     */\n\t    function hold() {\n\t        return setHold(this, true);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @return {Promise}\n\t     */\n\t    function unhold() {\n\t        return setHold(this, false);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @param {string} target\n\t     * @param {object} options\n\t     * @return {Promise}\n\t     */\n\t    function blindTransfer(target, options) {\n\t\n\t        options = options || {};\n\t\n\t        var session = this;\n\t        var extraHeaders = options.extraHeaders || [];\n\t        var originalTarget = target;\n\t\n\t        return new Promise(function(resolve, reject) {\n\t            //Blind Transfer is taken from SIP.js source\n\t\n\t            // Check Session Status\n\t            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {\n\t                throw new SIP.Exceptions.InvalidStateError(session.status);\n\t            }\n\t\n\t            // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n\t            // so try to make one ahead of time\n\t            try {\n\t                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n\t            } catch (e) {\n\t                session.logger.debug(\".refer() cannot parse Refer_To from\", target);\n\t                session.logger.debug(\"...falling through to normalizeTarget()\");\n\t            }\n\t\n\t            // Check target validity\n\t            target = session.ua.normalizeTarget(target);\n\t            if (!target) {\n\t                throw new TypeError('Invalid target: ' + originalTarget);\n\t            }\n\t\n\t            extraHeaders.push('Contact: ' + session.contact);\n\t            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n\t            extraHeaders.push('Refer-To: ' + target);\n\t            extraHeaders.push(session.ua.userAgentHeader);\n\t            extraHeaders.push(session.ua.endpointHeader);\n\t            extraHeaders.push(session.ua.clientIdHeader);\n\t\n\t            // Send the request\n\t            session.sendRequest(SIP.C.REFER, {\n\t                extraHeaders: extraHeaders,\n\t                body: options.body,\n\t                receiveResponse: function(response) {\n\t                    var timeout = null;\n\t                    if (response.status_code === 202) {\n\t                        var callId = response.call_id;\n\t\n\t                        var onNotify = function(request) {\n\t                            if (request.call_id === callId) {\n\t                                var body = request && request.body || '';\n\t                                switch (true) {\n\t                                    case /1[0-9]{2}/.test(body):\n\t                                        request.reply(200);\n\t                                        break;\n\t                                    case /2[0-9]{2}/.test(body):\n\t                                        session.terminate();\n\t                                        clearTimeout(timeout);\n\t                                        session.removeListener('RC_SIP_NOTIFY', onNotify);\n\t                                        resolve();\n\t                                        break;\n\t                                    default:\n\t                                        reject(body);\n\t                                        break;\n\t                                }\n\t                            }\n\t                        };\n\t\n\t                        timeout = setTimeout(function() {\n\t                            reject(new Error('Timeout: no reply'));\n\t                            session.removeListener('RC_SIP_NOTIFY', onNotify);\n\t                        }, responseTimeout);\n\t                        session.on('RC_SIP_NOTIFY', onNotify);\n\t                    }\n\t                    else {\n\t                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));\n\t                    }\n\t                }\n\t            });\n\t\n\t        });\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param {string} target\n\t     * @param {object} options\n\t     * @return {Promise}\n\t     */\n\t    function transfer(target, options) {\n\t\n\t        var session = this;\n\t\n\t        return (session.isOnHold() ? Promise.resolve(null) : session.hold())\n\t            .then(function() { return delay(300); })\n\t            .then(function() {\n\t                return session.blindTransfer(target, options);\n\t            });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param {string} target\n\t     * @param {object} acceptOptions\n\t     * @param {object} [transferOptions]\n\t     * @return {Promise}\n\t     */\n\t    function forward(target, acceptOptions, transferOptions) {\n\t\n\t        var interval = null,\n\t            session = this;\n\t\n\t        return session.accept(acceptOptions)\n\t            .then(function() {\n\t\n\t                return new Promise(function(resolve, reject) {\n\t                    interval = setInterval(function() {\n\t                        if (session.status === 12) {\n\t                            clearInterval(interval);\n\t                            session.mute();\n\t                            setTimeout(function() {\n\t                                resolve(session.transfer(target, transferOptions));\n\t                            }, 700);\n\t                        }\n\t                    }, 50);\n\t                });\n\t\n\t            });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @return {Promise}\n\t     */\n\t    function startRecord() {\n\t        return setRecord(this, true);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @return {Promise}\n\t     */\n\t    function stopRecord() {\n\t        return setRecord(this, false);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param target\n\t     * @return {Promise}\n\t     */\n\t    function flip(target) {\n\t        return sendReceive(this, messages.flip, {target: target});\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @return {Promise}\n\t     */\n\t    function park() {\n\t        return sendReceive(this, messages.park);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    return WebPhone;\n\t\n\t}));\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tmodule.exports = __webpack_require__(16)(__webpack_require__(49));\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @name SIP\n\t * @namespace\n\t */\n\t\"use strict\";\n\t\n\tmodule.exports = function (environment) {\n\t\n\tvar pkg = __webpack_require__(17);\n\t\n\tvar SIP = Object.defineProperties({}, {\n\t  version: {\n\t    get: function(){ return pkg.version; }\n\t  },\n\t  name: {\n\t    get: function(){ return pkg.title; }\n\t  }\n\t});\n\t\n\t__webpack_require__(18)(SIP, environment);\n\tSIP.LoggerFactory = __webpack_require__(19)(environment.console);\n\tSIP.EventEmitter = __webpack_require__(20)(environment.console);\n\tSIP.C = __webpack_require__(22)(SIP.name, SIP.version);\n\tSIP.Exceptions = __webpack_require__(23);\n\tSIP.Timers = __webpack_require__(24)(environment.timers);\n\tSIP.Transport = environment.Transport(SIP, environment.WebSocket);\n\t__webpack_require__(25)(SIP);\n\t__webpack_require__(26)(SIP);\n\t__webpack_require__(27)(SIP);\n\t__webpack_require__(28)(SIP);\n\t__webpack_require__(29)(SIP);\n\t__webpack_require__(30)(SIP);\n\t__webpack_require__(32)(SIP);\n\t__webpack_require__(33)(SIP);\n\tSIP.MediaHandler = __webpack_require__(34)(SIP.EventEmitter);\n\t__webpack_require__(35)(SIP);\n\t__webpack_require__(36)(SIP);\n\t__webpack_require__(37)(SIP, environment);\n\t__webpack_require__(39)(SIP);\n\tSIP.WebRTC = __webpack_require__(40)(SIP, environment);\n\t__webpack_require__(43)(SIP, environment);\n\tSIP.Hacks = __webpack_require__(44)(SIP);\n\t__webpack_require__(45)(SIP);\n\tSIP.DigestAuthentication = __webpack_require__(46)(SIP.Utils);\n\tSIP.Grammar = __webpack_require__(47)(SIP);\n\t\n\treturn SIP;\n\t};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"_args\": [\n\t\t\t[\n\t\t\t\t\"sip.js@0.7.5\",\n\t\t\t\t\"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\"\n\t\t\t]\n\t\t],\n\t\t\"_from\": \"sip.js@0.7.5\",\n\t\t\"_id\": \"sip.js@0.7.5\",\n\t\t\"_inCache\": true,\n\t\t\"_installable\": true,\n\t\t\"_location\": \"/sip.js\",\n\t\t\"_nodeVersion\": \"4.4.3\",\n\t\t\"_npmOperationalInternal\": {\n\t\t\t\"host\": \"packages-12-west.internal.npmjs.com\",\n\t\t\t\"tmp\": \"tmp/sip.js-0.7.5.tgz_1461594418690_0.5839933124370873\"\n\t\t},\n\t\t\"_npmUser\": {\n\t\t\t\"email\": \"1212jtraceur@gmail.com\",\n\t\t\t\"name\": \"josephfrazier\"\n\t\t},\n\t\t\"_npmVersion\": \"2.15.1\",\n\t\t\"_phantomChildren\": {},\n\t\t\"_requested\": {\n\t\t\t\"name\": \"sip.js\",\n\t\t\t\"raw\": \"sip.js@0.7.5\",\n\t\t\t\"rawSpec\": \"0.7.5\",\n\t\t\t\"scope\": null,\n\t\t\t\"spec\": \"0.7.5\",\n\t\t\t\"type\": \"version\"\n\t\t},\n\t\t\"_requiredBy\": [\n\t\t\t\"/ringcentral-web-phone\"\n\t\t],\n\t\t\"_resolved\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz\",\n\t\t\"_shasum\": \"86ace7051594f91b4551bdb8120a16c44962d3a2\",\n\t\t\"_shrinkwrap\": null,\n\t\t\"_spec\": \"sip.js@0.7.5\",\n\t\t\"_where\": \"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\",\n\t\t\"author\": {\n\t\t\t\"email\": \"developer@onsip.com\",\n\t\t\t\"name\": \"OnSIP\",\n\t\t\t\"url\": \"http://sipjs.com/authors/\"\n\t\t},\n\t\t\"browser\": {\n\t\t\t\"./src/environment.js\": \"./src/environment_browser.js\"\n\t\t},\n\t\t\"bugs\": {\n\t\t\t\"url\": \"https://github.com/onsip/SIP.js/issues\"\n\t\t},\n\t\t\"contributors\": [\n\t\t\t{\n\t\t\t\t\"url\": \"https://github.com/onsip/SIP.js/blob/master/THANKS.md\"\n\t\t\t}\n\t\t],\n\t\t\"dependencies\": {\n\t\t\t\"promiscuous\": \"^0.6.0\",\n\t\t\t\"ws\": \"^0.6.4\"\n\t\t},\n\t\t\"description\": \"A simple, intuitive, and powerful JavaScript signaling library\",\n\t\t\"devDependencies\": {\n\t\t\t\"beefy\": \"^2.1.5\",\n\t\t\t\"browserify\": \"^4.1.8\",\n\t\t\t\"grunt\": \"~0.4.0\",\n\t\t\t\"grunt-browserify\": \"^4.0.1\",\n\t\t\t\"grunt-cli\": \"~0.1.6\",\n\t\t\t\"grunt-contrib-copy\": \"^0.5.0\",\n\t\t\t\"grunt-contrib-jasmine\": \"^0.9.2\",\n\t\t\t\"grunt-contrib-jshint\": \">0.5.0\",\n\t\t\t\"grunt-contrib-uglify\": \"~0.2.0\",\n\t\t\t\"grunt-peg\": \"~1.3.1\",\n\t\t\t\"grunt-trimtrailingspaces\": \"^0.4.0\",\n\t\t\t\"pegjs\": \"^0.8.0\"\n\t\t},\n\t\t\"directories\": {},\n\t\t\"dist\": {\n\t\t\t\"shasum\": \"86ace7051594f91b4551bdb8120a16c44962d3a2\",\n\t\t\t\"tarball\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz\"\n\t\t},\n\t\t\"engines\": {\n\t\t\t\"node\": \">=0.8\"\n\t\t},\n\t\t\"gitHead\": \"bae44bd0359f4d70ded309a32361f04a04e78d6e\",\n\t\t\"homepage\": \"http://sipjs.com\",\n\t\t\"keywords\": [\n\t\t\t\"sip\",\n\t\t\t\"websocket\",\n\t\t\t\"webrtc\",\n\t\t\t\"library\",\n\t\t\t\"javascript\"\n\t\t],\n\t\t\"license\": \"MIT\",\n\t\t\"main\": \"src/index.js\",\n\t\t\"maintainers\": [\n\t\t\t{\n\t\t\t\t\"email\": \"eric.green@onsip.com\",\n\t\t\t\t\"name\": \"egreen_onsip\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"email\": \"james@onsip.com\",\n\t\t\t\t\"name\": \"james-criscuolo\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"email\": \"1212jtraceur@gmail.com\",\n\t\t\t\t\"name\": \"josephfrazier\"\n\t\t\t}\n\t\t],\n\t\t\"name\": \"sip.js\",\n\t\t\"optionalDependencies\": {\n\t\t\t\"promiscuous\": \"^0.6.0\"\n\t\t},\n\t\t\"readme\": \"ERROR: No README data found!\",\n\t\t\"repository\": {\n\t\t\t\"type\": \"git\",\n\t\t\t\"url\": \"git+https://github.com/onsip/SIP.js.git\"\n\t\t},\n\t\t\"scripts\": {\n\t\t\t\"build\": \"grunt build\",\n\t\t\t\"prepublish\": \"cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js\",\n\t\t\t\"repl\": \"beefy test/repl.js --open\",\n\t\t\t\"test\": \"grunt travis --verbose\"\n\t\t},\n\t\t\"title\": \"SIP.js\",\n\t\t\"version\": \"0.7.5\"\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Utils\n\t */\n\t\n\tmodule.exports = function (SIP, environment) {\n\tvar Utils;\n\t\n\tUtils= {\n\t\n\t  Promise: environment.Promise,\n\t\n\t  defer: function defer () {\n\t    var deferred = {};\n\t    deferred.promise = new Utils.Promise(function (resolve, reject) {\n\t      deferred.resolve = resolve;\n\t      deferred.reject = reject;\n\t    });\n\t    return deferred;\n\t  },\n\t\n\t  promisify: function promisify (object, methodName, callbacksFirst) {\n\t    var oldMethod = object[methodName];\n\t    return function promisifiedMethod (arg, onSuccess, onFailure) {\n\t      return new Utils.Promise(function (resolve, reject) {\n\t        var oldArgs = [arg, resolve, reject];\n\t        if (callbacksFirst) {\n\t          oldArgs = [resolve, reject, arg];\n\t        }\n\t        oldMethod.apply(object, oldArgs);\n\t      }).then(onSuccess, onFailure);\n\t    };\n\t  },\n\t\n\t  augment: function (object, constructor, args, override) {\n\t    var idx, proto;\n\t\n\t    // Add public properties from constructor's prototype onto object\n\t    proto = constructor.prototype;\n\t    for (idx in proto) {\n\t      if (override || object[idx] === undefined) {\n\t        object[idx] = proto[idx];\n\t      }\n\t    }\n\t\n\t    // Construct the object as though it were just created by constructor\n\t    constructor.apply(object, args);\n\t  },\n\t\n\t  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {\n\t    if (isDeprecated && options[loser]) {\n\t      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n\t    }\n\t\n\t    if (options[winner] && options[loser]) {\n\t      logger.warn(winner + ' overriding ' + loser);\n\t    }\n\t\n\t    options[winner] = options[winner] || options[loser] || defaultValue;\n\t  },\n\t\n\t  str_utf8_length: function(string) {\n\t    return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n\t  },\n\t\n\t  generateFakeSDP: function(body) {\n\t    if (!body) {\n\t      return;\n\t    }\n\t\n\t    var start = body.indexOf('o=');\n\t    var end = body.indexOf('\\r\\n', start);\n\t\n\t    return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n\t  },\n\t\n\t  isFunction: function(fn) {\n\t    if (fn !== undefined) {\n\t      return Object.prototype.toString.call(fn) === '[object Function]';\n\t    } else {\n\t      return false;\n\t    }\n\t  },\n\t\n\t  isDecimal: function (num) {\n\t    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));\n\t  },\n\t\n\t  createRandomToken: function(size, base) {\n\t    var i, r,\n\t      token = '';\n\t\n\t    base = base || 32;\n\t\n\t    for( i=0; i < size; i++ ) {\n\t      r = Math.random() * base|0;\n\t      token += r.toString(base);\n\t    }\n\t\n\t    return token;\n\t  },\n\t\n\t  newTag: function() {\n\t    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n\t  },\n\t\n\t  // http://stackoverflow.com/users/109538/broofa\n\t  newUUID: function() {\n\t    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n\t      return v.toString(16);\n\t    });\n\t\n\t    return UUID;\n\t  },\n\t\n\t  hostType: function(host) {\n\t    if (!host) {\n\t      return;\n\t    } else {\n\t      host = SIP.Grammar.parse(host,'host');\n\t      if (host !== -1) {\n\t        return host.host_type;\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Normalize SIP URI.\n\t  * NOTE: It does not allow a SIP URI without username.\n\t  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n\t  * Detects the domain part (if given) and properly hex-escapes the user portion.\n\t  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n\t  * @private\n\t  * @param {String} target\n\t  * @param {String} [domain]\n\t  */\n\t  normalizeTarget: function(target, domain) {\n\t    var uri, target_array, target_user, target_domain;\n\t\n\t    // If no target is given then raise an error.\n\t    if (!target) {\n\t      return;\n\t    // If a SIP.URI instance is given then return it.\n\t    } else if (target instanceof SIP.URI) {\n\t      return target;\n\t\n\t    // If a string is given split it by '@':\n\t    // - Last fragment is the desired domain.\n\t    // - Otherwise append the given domain argument.\n\t    } else if (typeof target === 'string') {\n\t      target_array = target.split('@');\n\t\n\t      switch(target_array.length) {\n\t        case 1:\n\t          if (!domain) {\n\t            return;\n\t          }\n\t          target_user = target;\n\t          target_domain = domain;\n\t          break;\n\t        case 2:\n\t          target_user = target_array[0];\n\t          target_domain = target_array[1];\n\t          break;\n\t        default:\n\t          target_user = target_array.slice(0, target_array.length-1).join('@');\n\t          target_domain = target_array[target_array.length-1];\n\t      }\n\t\n\t      // Remove the URI scheme (if present).\n\t      target_user = target_user.replace(/^(sips?|tel):/i, '');\n\t\n\t      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n\t      if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n\t        target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n\t      }\n\t\n\t      // Build the complete SIP URI.\n\t      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;\n\t\n\t      // Finally parse the resulting URI.\n\t      if (uri = SIP.URI.parse(target)) {\n\t        return uri;\n\t      } else {\n\t        return;\n\t      }\n\t    } else {\n\t      return;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Hex-escape a SIP URI user.\n\t  * @private\n\t  * @param {String} user\n\t  */\n\t  escapeUser: function(user) {\n\t    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n\t    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n\t  },\n\t\n\t  headerize: function(string) {\n\t    var exceptions = {\n\t      'Call-Id': 'Call-ID',\n\t      'Cseq': 'CSeq',\n\t      'Min-Se': 'Min-SE',\n\t      'Rack': 'RAck',\n\t      'Rseq': 'RSeq',\n\t      'Www-Authenticate': 'WWW-Authenticate'\n\t      },\n\t      name = string.toLowerCase().replace(/_/g,'-').split('-'),\n\t      hname = '',\n\t      parts = name.length, part;\n\t\n\t    for (part = 0; part < parts; part++) {\n\t      if (part !== 0) {\n\t        hname +='-';\n\t      }\n\t      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);\n\t    }\n\t    if (exceptions[hname]) {\n\t      hname = exceptions[hname];\n\t    }\n\t    return hname;\n\t  },\n\t\n\t  sipErrorCause: function(status_code) {\n\t    var cause;\n\t\n\t    for (cause in SIP.C.SIP_ERROR_CAUSES) {\n\t      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n\t        return SIP.C.causes[cause];\n\t      }\n\t    }\n\t\n\t    return SIP.C.causes.SIP_FAILURE_CODE;\n\t  },\n\t\n\t  getReasonPhrase: function getReasonPhrase (code, specific) {\n\t    return specific || SIP.C.REASON_PHRASE[code] || '';\n\t  },\n\t\n\t  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {\n\t    reason = SIP.Utils.getReasonPhrase(code, reason);\n\t    return 'SIP ;cause=' + code + ' ;text=\"' + reason + '\"';\n\t  },\n\t\n\t  getCancelReason: function getCancelReason (code, reason) {\n\t    if (code && code < 200 || code > 699) {\n\t      throw new TypeError('Invalid status_code: ' + code);\n\t    } else if (code) {\n\t      return SIP.Utils.getReasonHeaderValue(code, reason);\n\t    }\n\t  },\n\t\n\t  buildStatusLine: function buildStatusLine (code, reason) {\n\t    code = code || null;\n\t    reason = reason || null;\n\t\n\t    // Validate code and reason values\n\t    if (!code || (code < 100 || code > 699)) {\n\t      throw new TypeError('Invalid status_code: '+ code);\n\t    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n\t      throw new TypeError('Invalid reason_phrase: '+ reason);\n\t    }\n\t\n\t    reason = Utils.getReasonPhrase(code, reason);\n\t\n\t    return 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\t  },\n\t\n\t  /**\n\t  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n\t  * @private\n\t  */\n\t  getRandomTestNetIP: function() {\n\t    function getOctet(from,to) {\n\t      return Math.floor(Math.random()*(to-from+1)+from);\n\t    }\n\t    return '192.0.2.' + getOctet(1, 254);\n\t  },\n\t\n\t  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info\n\t  calculateMD5: function(string) {\n\t    function RotateLeft(lValue, iShiftBits) {\n\t      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n\t    }\n\t\n\t    function AddUnsigned(lX,lY) {\n\t      var lX4,lY4,lX8,lY8,lResult;\n\t      lX8 = (lX & 0x80000000);\n\t      lY8 = (lY & 0x80000000);\n\t      lX4 = (lX & 0x40000000);\n\t      lY4 = (lY & 0x40000000);\n\t      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n\t      if (lX4 & lY4) {\n\t        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n\t      }\n\t      if (lX4 | lY4) {\n\t        if (lResult & 0x40000000) {\n\t          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n\t        } else {\n\t          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n\t        }\n\t      } else {\n\t        return (lResult ^ lX8 ^ lY8);\n\t      }\n\t    }\n\t\n\t    function F(x,y,z) {\n\t      return (x & y) | ((~x) & z);\n\t    }\n\t\n\t    function G(x,y,z) {\n\t      return (x & z) | (y & (~z));\n\t    }\n\t\n\t    function H(x,y,z) {\n\t      return (x ^ y ^ z);\n\t    }\n\t\n\t    function I(x,y,z) {\n\t      return (y ^ (x | (~z)));\n\t    }\n\t\n\t    function FF(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function GG(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function HH(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function II(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function ConvertToWordArray(string) {\n\t      var lWordCount;\n\t      var lMessageLength = string.length;\n\t      var lNumberOfWords_temp1=lMessageLength + 8;\n\t      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n\t      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n\t      var lWordArray=Array(lNumberOfWords-1);\n\t      var lBytePosition = 0;\n\t      var lByteCount = 0;\n\t      while ( lByteCount < lMessageLength ) {\n\t        lWordCount = (lByteCount-(lByteCount % 4))/4;\n\t        lBytePosition = (lByteCount % 4)*8;\n\t        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n\t        lByteCount++;\n\t      }\n\t      lWordCount = (lByteCount-(lByteCount % 4))/4;\n\t      lBytePosition = (lByteCount % 4)*8;\n\t      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n\t      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n\t      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n\t      return lWordArray;\n\t    }\n\t\n\t    function WordToHex(lValue) {\n\t      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n\t      for (lCount = 0;lCount<=3;lCount++) {\n\t        lByte = (lValue>>>(lCount*8)) & 255;\n\t        WordToHexValue_temp = \"0\" + lByte.toString(16);\n\t        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n\t      }\n\t      return WordToHexValue;\n\t    }\n\t\n\t    function Utf8Encode(string) {\n\t      string = string.replace(/\\r\\n/g,\"\\n\");\n\t      var utftext = \"\";\n\t\n\t      for (var n = 0; n < string.length; n++) {\n\t        var c = string.charCodeAt(n);\n\t\n\t        if (c < 128) {\n\t          utftext += String.fromCharCode(c);\n\t        }\n\t        else if((c > 127) && (c < 2048)) {\n\t          utftext += String.fromCharCode((c >> 6) | 192);\n\t          utftext += String.fromCharCode((c & 63) | 128);\n\t        }\n\t        else {\n\t          utftext += String.fromCharCode((c >> 12) | 224);\n\t          utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t          utftext += String.fromCharCode((c & 63) | 128);\n\t        }\n\t      }\n\t      return utftext;\n\t    }\n\t\n\t    var x=[];\n\t    var k,AA,BB,CC,DD,a,b,c,d;\n\t    var S11=7, S12=12, S13=17, S14=22;\n\t    var S21=5, S22=9 , S23=14, S24=20;\n\t    var S31=4, S32=11, S33=16, S34=23;\n\t    var S41=6, S42=10, S43=15, S44=21;\n\t\n\t    string = Utf8Encode(string);\n\t\n\t    x = ConvertToWordArray(string);\n\t\n\t    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\t\n\t    for (k=0;k<x.length;k+=16) {\n\t      AA=a; BB=b; CC=c; DD=d;\n\t      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n\t      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n\t      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n\t      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n\t      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n\t      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n\t      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n\t      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n\t      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n\t      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n\t      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n\t      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n\t      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n\t      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n\t      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n\t      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n\t      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n\t      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n\t      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n\t      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n\t      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n\t      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n\t      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n\t      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n\t      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n\t      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n\t      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n\t      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n\t      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n\t      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n\t      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n\t      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n\t      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n\t      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n\t      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n\t      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n\t      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n\t      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n\t      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n\t      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n\t      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n\t      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n\t      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n\t      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n\t      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n\t      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n\t      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n\t      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n\t      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n\t      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n\t      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n\t      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n\t      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n\t      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n\t      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n\t      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n\t      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n\t      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n\t      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n\t      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n\t      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n\t      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n\t      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n\t      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n\t      a=AddUnsigned(a,AA);\n\t      b=AddUnsigned(b,BB);\n\t      c=AddUnsigned(c,CC);\n\t      d=AddUnsigned(d,DD);\n\t    }\n\t\n\t    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n\t\n\t    return temp.toLowerCase();\n\t  }\n\t};\n\t\n\tSIP.Utils = Utils;\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar levels = {\n\t  'error': 0,\n\t  'warn': 1,\n\t  'log': 2,\n\t  'debug': 3\n\t};\n\t\n\tmodule.exports = function (console) {\n\t\n\tvar LoggerFactory = function () {\n\t  var logger,\n\t    level = 2,\n\t    builtinEnabled = true,\n\t    connector = null;\n\t\n\t    this.loggers = {};\n\t\n\t    logger = this.getLogger('sip.loggerfactory');\n\t\n\t\n\t  Object.defineProperties(this, {\n\t    builtinEnabled: {\n\t      get: function(){ return builtinEnabled; },\n\t      set: function(value){\n\t        if (typeof value === 'boolean') {\n\t          builtinEnabled = value;\n\t        } else {\n\t          logger.error('invalid \"builtinEnabled\" parameter value: '+ JSON.stringify(value));\n\t        }\n\t      }\n\t    },\n\t\n\t    level: {\n\t      get: function() {return level; },\n\t      set: function(value) {\n\t        if (value >= 0 && value <=3) {\n\t          level = value;\n\t        } else if (value > 3) {\n\t          level = 3;\n\t        } else if (levels.hasOwnProperty(value)) {\n\t          level = levels[value];\n\t        } else {\n\t          logger.error('invalid \"level\" parameter value: '+ JSON.stringify(value));\n\t        }\n\t      }\n\t    },\n\t\n\t    connector: {\n\t      get: function() {return connector; },\n\t      set: function(value){\n\t        if(value === null || value === \"\" || value === undefined) {\n\t          connector = null;\n\t        } else if (typeof value === 'function') {\n\t          connector = value;\n\t        } else {\n\t          logger.error('invalid \"connector\" parameter value: '+ JSON.stringify(value));\n\t        }\n\t      }\n\t    }\n\t  });\n\t};\n\t\n\tLoggerFactory.prototype.print = function(target, category, label, content) {\n\t  if (typeof content === 'string') {\n\t    var prefix = [new Date(), category];\n\t    if (label) {\n\t      prefix.push(label);\n\t    }\n\t    content = prefix.concat(content).join(' | ');\n\t  }\n\t  target.call(console, content);\n\t};\n\t\n\tfunction Logger (logger, category, label) {\n\t  this.logger = logger;\n\t  this.category = category;\n\t  this.label = label;\n\t}\n\t\n\tObject.keys(levels).forEach(function (targetName) {\n\t  Logger.prototype[targetName] = function (content) {\n\t    this.logger[targetName](this.category, this.label, content);\n\t  };\n\t\n\t  LoggerFactory.prototype[targetName] = function (category, label, content) {\n\t    if (this.level >= levels[targetName]) {\n\t      if (this.builtinEnabled) {\n\t        this.print(console[targetName], category, label, content);\n\t      }\n\t\n\t      if (this.connector) {\n\t        this.connector(targetName, category, label, content);\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\tLoggerFactory.prototype.getLogger = function(category, label) {\n\t  var logger;\n\t\n\t  if (label && this.level === 3) {\n\t    return new Logger(this, category, label);\n\t  } else if (this.loggers[category]) {\n\t    return this.loggers[category];\n\t  } else {\n\t    logger = new Logger(this, category);\n\t    this.loggers[category] = logger;\n\t    return logger;\n\t  }\n\t};\n\t\n\treturn LoggerFactory;\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar NodeEventEmitter = __webpack_require__(21).EventEmitter;\n\t\n\tmodule.exports = function (console) {\n\t\n\t// Don't use `new SIP.EventEmitter()` for inheriting.\n\t// Use Object.create(SIP.EventEmitter.prototoype);\n\tfunction EventEmitter () {\n\t  NodeEventEmitter.call(this);\n\t}\n\t\n\tEventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {\n\t  constructor: {\n\t    value: EventEmitter,\n\t    enumerable: false,\n\t    writable: true,\n\t    configurable: true\n\t  }\n\t});\n\t\n\tEventEmitter.prototype.off = function off (eventName, listener) {\n\t  var warning = '';\n\t  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\\n';\n\t  warning += 'Please use removeListener or removeAllListeners instead.\\n';\n\t  warning += 'See here for more details:\\n';\n\t  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';\n\t  console.warn(warning);\n\t\n\t  if (arguments.length < 2) {\n\t    return this.removeAllListeners.apply(this, arguments);\n\t  } else {\n\t    return this.removeListener(eventName, listener);\n\t  }\n\t};\n\t\n\treturn EventEmitter;\n\t\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Constants\n\t */\n\t\n\t/**\n\t * SIP Constants.\n\t * @augments SIP\n\t */\n\t\n\tmodule.exports = function (name, version) {\n\treturn {\n\t  USER_AGENT: name +'/'+ version,\n\t\n\t  // SIP scheme\n\t  SIP:  'sip',\n\t  SIPS: 'sips',\n\t\n\t  // End and Failure causes\n\t  causes: {\n\t    // Generic error causes\n\t    CONNECTION_ERROR:         'Connection Error',\n\t    REQUEST_TIMEOUT:          'Request Timeout',\n\t    SIP_FAILURE_CODE:         'SIP Failure Code',\n\t    INTERNAL_ERROR:           'Internal Error',\n\t\n\t    // SIP error causes\n\t    BUSY:                     'Busy',\n\t    REJECTED:                 'Rejected',\n\t    REDIRECTED:               'Redirected',\n\t    UNAVAILABLE:              'Unavailable',\n\t    NOT_FOUND:                'Not Found',\n\t    ADDRESS_INCOMPLETE:       'Address Incomplete',\n\t    INCOMPATIBLE_SDP:         'Incompatible SDP',\n\t    AUTHENTICATION_ERROR:     'Authentication Error',\n\t    DIALOG_ERROR:             'Dialog Error',\n\t\n\t    // Session error causes\n\t    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',\n\t    WEBRTC_ERROR:             'WebRTC Error',\n\t    CANCELED:                 'Canceled',\n\t    NO_ANSWER:                'No Answer',\n\t    EXPIRES:                  'Expires',\n\t    NO_ACK:                   'No ACK',\n\t    NO_PRACK:                 'No PRACK',\n\t    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n\t    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',\n\t    RTP_TIMEOUT:              'RTP Timeout'\n\t  },\n\t\n\t  supported: {\n\t    UNSUPPORTED:        'none',\n\t    SUPPORTED:          'supported',\n\t    REQUIRED:           'required'\n\t  },\n\t\n\t  SIP_ERROR_CAUSES: {\n\t    REDIRECTED: [300,301,302,305,380],\n\t    BUSY: [486,600],\n\t    REJECTED: [403,603],\n\t    NOT_FOUND: [404,604],\n\t    UNAVAILABLE: [480,410,408,430],\n\t    ADDRESS_INCOMPLETE: [484],\n\t    INCOMPATIBLE_SDP: [488,606],\n\t    AUTHENTICATION_ERROR:[401,407]\n\t  },\n\t\n\t  // SIP Methods\n\t  ACK:        'ACK',\n\t  BYE:        'BYE',\n\t  CANCEL:     'CANCEL',\n\t  INFO:       'INFO',\n\t  INVITE:     'INVITE',\n\t  MESSAGE:    'MESSAGE',\n\t  NOTIFY:     'NOTIFY',\n\t  OPTIONS:    'OPTIONS',\n\t  REGISTER:   'REGISTER',\n\t  UPDATE:     'UPDATE',\n\t  SUBSCRIBE:  'SUBSCRIBE',\n\t  REFER:      'REFER',\n\t  PRACK:      'PRACK',\n\t\n\t  /* SIP Response Reasons\n\t   * DOC: http://www.iana.org/assignments/sip-parameters\n\t   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n\t   */\n\t  REASON_PHRASE: {\n\t    100: 'Trying',\n\t    180: 'Ringing',\n\t    181: 'Call Is Being Forwarded',\n\t    182: 'Queued',\n\t    183: 'Session Progress',\n\t    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199\n\t    200: 'OK',\n\t    202: 'Accepted',  // RFC 3265\n\t    204: 'No Notification',  //RFC 5839\n\t    300: 'Multiple Choices',\n\t    301: 'Moved Permanently',\n\t    302: 'Moved Temporarily',\n\t    305: 'Use Proxy',\n\t    380: 'Alternative Service',\n\t    400: 'Bad Request',\n\t    401: 'Unauthorized',\n\t    402: 'Payment Required',\n\t    403: 'Forbidden',\n\t    404: 'Not Found',\n\t    405: 'Method Not Allowed',\n\t    406: 'Not Acceptable',\n\t    407: 'Proxy Authentication Required',\n\t    408: 'Request Timeout',\n\t    410: 'Gone',\n\t    412: 'Conditional Request Failed',  // RFC 3903\n\t    413: 'Request Entity Too Large',\n\t    414: 'Request-URI Too Long',\n\t    415: 'Unsupported Media Type',\n\t    416: 'Unsupported URI Scheme',\n\t    417: 'Unknown Resource-Priority',  // RFC 4412\n\t    420: 'Bad Extension',\n\t    421: 'Extension Required',\n\t    422: 'Session Interval Too Small',  // RFC 4028\n\t    423: 'Interval Too Brief',\n\t    428: 'Use Identity Header',  // RFC 4474\n\t    429: 'Provide Referrer Identity',  // RFC 3892\n\t    430: 'Flow Failed',  // RFC 5626\n\t    433: 'Anonymity Disallowed',  // RFC 5079\n\t    436: 'Bad Identity-Info',  // RFC 4474\n\t    437: 'Unsupported Certificate',  // RFC 4744\n\t    438: 'Invalid Identity Header',  // RFC 4744\n\t    439: 'First Hop Lacks Outbound Support',  // RFC 5626\n\t    440: 'Max-Breadth Exceeded',  // RFC 5393\n\t    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events\n\t    470: 'Consent Needed',  // RFC 5360\n\t    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.\n\t    480: 'Temporarily Unavailable',\n\t    481: 'Call/Transaction Does Not Exist',\n\t    482: 'Loop Detected',\n\t    483: 'Too Many Hops',\n\t    484: 'Address Incomplete',\n\t    485: 'Ambiguous',\n\t    486: 'Busy Here',\n\t    487: 'Request Terminated',\n\t    488: 'Not Acceptable Here',\n\t    489: 'Bad Event',  // RFC 3265\n\t    491: 'Request Pending',\n\t    493: 'Undecipherable',\n\t    494: 'Security Agreement Required',  // RFC 3329\n\t    500: 'Internal Server Error',\n\t    501: 'Not Implemented',\n\t    502: 'Bad Gateway',\n\t    503: 'Service Unavailable',\n\t    504: 'Server Time-out',\n\t    505: 'Version Not Supported',\n\t    513: 'Message Too Large',\n\t    580: 'Precondition Failure',  // RFC 3312\n\t    600: 'Busy Everywhere',\n\t    603: 'Decline',\n\t    604: 'Does Not Exist Anywhere',\n\t    606: 'Not Acceptable'\n\t  },\n\t\n\t  /* SIP Option Tags\n\t   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4\n\t   */\n\t  OPTION_TAGS: {\n\t    '100rel':                   true,  // RFC 3262\n\t    199:                        true,  // RFC 6228\n\t    answermode:                 true,  // RFC 5373\n\t    'early-session':            true,  // RFC 3959\n\t    eventlist:                  true,  // RFC 4662\n\t    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n\t    'from-change':              true,  // RFC 4916\n\t    'geolocation-http':         true,  // RFC 6442\n\t    'geolocation-sip':          true,  // RFC 6442\n\t    gin:                        true,  // RFC 6140\n\t    gruu:                       true,  // RFC 5627\n\t    histinfo:                   true,  // RFC 7044\n\t    ice:                        true,  // RFC 5768\n\t    join:                       true,  // RFC 3911\n\t    'multiple-refer':           true,  // RFC 5368\n\t    norefersub:                 true,  // RFC 4488\n\t    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n\t    outbound:                   true,  // RFC 5626\n\t    path:                       true,  // RFC 3327\n\t    policy:                     true,  // RFC 6794\n\t    precondition:               true,  // RFC 3312\n\t    pref:                       true,  // RFC 3840\n\t    privacy:                    true,  // RFC 3323\n\t    'recipient-list-invite':    true,  // RFC 5366\n\t    'recipient-list-message':   true,  // RFC 5365\n\t    'recipient-list-subscribe': true,  // RFC 5367\n\t    replaces:                   true,  // RFC 3891\n\t    'resource-priority':        true,  // RFC 4412\n\t    'sdp-anat':                 true,  // RFC 4092\n\t    'sec-agree':                true,  // RFC 3329\n\t    tdialog:                    true,  // RFC 4538\n\t    timer:                      true,  // RFC 4028\n\t    uui:                        true   // RFC 7433\n\t  }\n\t};\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Exceptions\n\t */\n\t\n\t/**\n\t * SIP Exceptions.\n\t * @augments SIP\n\t */\n\tmodule.exports = {\n\t  ConfigurationError: (function(){\n\t    var exception = function(parameter, value) {\n\t      this.code = 1;\n\t      this.name = 'CONFIGURATION_ERROR';\n\t      this.parameter = parameter;\n\t      this.value = value;\n\t      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter \"'+ this.parameter +'\"';\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }()),\n\t\n\t  InvalidStateError: (function(){\n\t    var exception = function(status) {\n\t      this.code = 2;\n\t      this.name = 'INVALID_STATE_ERROR';\n\t      this.status = status;\n\t      this.message = 'Invalid status: ' + status;\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }()),\n\t\n\t  NotSupportedError: (function(){\n\t    var exception = function(message) {\n\t      this.code = 3;\n\t      this.name = 'NOT_SUPPORTED_ERROR';\n\t      this.message = message;\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }()),\n\t\n\t  GetDescriptionError: (function(){\n\t    var exception = function(message) {\n\t      this.code = 4;\n\t      this.name = 'GET_DESCRIPTION_ERROR';\n\t      this.message = message;\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }())\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP TIMERS\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t */\n\tvar\n\t  T1 = 500,\n\t  T2 = 4000,\n\t  T4 = 5000;\n\tmodule.exports = function (timers) {\n\t  var Timers = {\n\t    T1: T1,\n\t    T2: T2,\n\t    T4: T4,\n\t    TIMER_B: 64 * T1,\n\t    TIMER_D: 0  * T1,\n\t    TIMER_F: 64 * T1,\n\t    TIMER_H: 64 * T1,\n\t    TIMER_I: 0  * T1,\n\t    TIMER_J: 0  * T1,\n\t    TIMER_K: 0  * T4,\n\t    TIMER_L: 64 * T1,\n\t    TIMER_M: 64 * T1,\n\t    TIMER_N: 64 * T1,\n\t    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1\n\t  };\n\t\n\t  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']\n\t  .forEach(function (name) {\n\t    // can't just use timers[name].bind(timers) since it bypasses jasmine's\n\t    // clock-mocking\n\t    Timers[name] = function () {\n\t      return timers[name].apply(timers, arguments);\n\t    };\n\t  });\n\t\n\t  return Timers;\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Message Parser\n\t */\n\t\n\t/**\n\t * Extract and parse every header of a SIP message.\n\t * @augments SIP\n\t * @namespace\n\t */\n\tmodule.exports = function (SIP) {\n\tvar Parser;\n\t\n\tfunction getHeader(data, headerStart) {\n\t  var\n\t    // 'start' position of the header.\n\t    start = headerStart,\n\t    // 'end' position of the header.\n\t    end = 0,\n\t    // 'partial end' position of the header.\n\t    partialEnd = 0;\n\t\n\t  //End of message.\n\t  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n\t    return -2;\n\t  }\n\t\n\t  while(end === 0) {\n\t    // Partial End of Header.\n\t    partialEnd = data.indexOf('\\r\\n', start);\n\t\n\t    // 'indexOf' returns -1 if the value to be found never occurs.\n\t    if (partialEnd === -1) {\n\t      return partialEnd;\n\t    }\n\t\n\t    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n\t      // Not the end of the message. Continue from the next position.\n\t      start = partialEnd + 2;\n\t    } else {\n\t      end = partialEnd;\n\t    }\n\t  }\n\t\n\t  return end;\n\t}\n\t\n\tfunction parseHeader(message, data, headerStart, headerEnd) {\n\t  var header, idx, length, parsed,\n\t    hcolonIndex = data.indexOf(':', headerStart),\n\t    headerName = data.substring(headerStart, hcolonIndex).trim(),\n\t    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n\t\n\t  // If header-field is well-known, parse it.\n\t  switch(headerName.toLowerCase()) {\n\t    case 'via':\n\t    case 'v':\n\t      message.addHeader('via', headerValue);\n\t      if(message.getHeaders('via').length === 1) {\n\t        parsed = message.parseHeader('Via');\n\t        if(parsed) {\n\t          message.via = parsed;\n\t          message.via_branch = parsed.branch;\n\t        }\n\t      } else {\n\t        parsed = 0;\n\t      }\n\t      break;\n\t    case 'from':\n\t    case 'f':\n\t      message.setHeader('from', headerValue);\n\t      parsed = message.parseHeader('from');\n\t      if(parsed) {\n\t        message.from = parsed;\n\t        message.from_tag = parsed.getParam('tag');\n\t      }\n\t      break;\n\t    case 'to':\n\t    case 't':\n\t      message.setHeader('to', headerValue);\n\t      parsed = message.parseHeader('to');\n\t      if(parsed) {\n\t        message.to = parsed;\n\t        message.to_tag = parsed.getParam('tag');\n\t      }\n\t      break;\n\t    case 'record-route':\n\t      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n\t\n\t      if (parsed === -1) {\n\t        parsed = undefined;\n\t        break;\n\t      }\n\t\n\t      length = parsed.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = parsed[idx];\n\t        message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n\t        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n\t      }\n\t      break;\n\t    case 'call-id':\n\t    case 'i':\n\t      message.setHeader('call-id', headerValue);\n\t      parsed = message.parseHeader('call-id');\n\t      if(parsed) {\n\t        message.call_id = headerValue;\n\t      }\n\t      break;\n\t    case 'contact':\n\t    case 'm':\n\t      parsed = SIP.Grammar.parse(headerValue, 'Contact');\n\t\n\t      if (parsed === -1) {\n\t        parsed = undefined;\n\t        break;\n\t      }\n\t\n\t      length = parsed.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = parsed[idx];\n\t        message.addHeader('contact', headerValue.substring(header.position, header.offset));\n\t        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n\t      }\n\t      break;\n\t    case 'content-length':\n\t    case 'l':\n\t      message.setHeader('content-length', headerValue);\n\t      parsed = message.parseHeader('content-length');\n\t      break;\n\t    case 'content-type':\n\t    case 'c':\n\t      message.setHeader('content-type', headerValue);\n\t      parsed = message.parseHeader('content-type');\n\t      break;\n\t    case 'cseq':\n\t      message.setHeader('cseq', headerValue);\n\t      parsed = message.parseHeader('cseq');\n\t      if(parsed) {\n\t        message.cseq = parsed.value;\n\t      }\n\t      if(message instanceof SIP.IncomingResponse) {\n\t        message.method = parsed.method;\n\t      }\n\t      break;\n\t    case 'max-forwards':\n\t      message.setHeader('max-forwards', headerValue);\n\t      parsed = message.parseHeader('max-forwards');\n\t      break;\n\t    case 'www-authenticate':\n\t      message.setHeader('www-authenticate', headerValue);\n\t      parsed = message.parseHeader('www-authenticate');\n\t      break;\n\t    case 'proxy-authenticate':\n\t      message.setHeader('proxy-authenticate', headerValue);\n\t      parsed = message.parseHeader('proxy-authenticate');\n\t      break;\n\t    case 'refer-to':\n\t    case 'r':\n\t      message.setHeader('refer-to', headerValue);\n\t      parsed = message.parseHeader('refer-to');\n\t      if (parsed) {\n\t        message.refer_to = parsed;\n\t      }\n\t      break;\n\t    default:\n\t      // Do not parse this header.\n\t      message.setHeader(headerName, headerValue);\n\t      parsed = 0;\n\t  }\n\t\n\t  if (parsed === undefined) {\n\t    return {\n\t      error: 'error parsing header \"'+ headerName +'\"'\n\t    };\n\t  } else {\n\t    return true;\n\t  }\n\t}\n\t\n\t/** Parse SIP Message\n\t * @function\n\t * @param {String} message SIP message.\n\t * @param {Object} logger object.\n\t * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n\t */\n\tParser = {};\n\tParser.parseMessage = function(data, ua) {\n\t  var message, firstLine, contentLength, bodyStart, parsed,\n\t    headerStart = 0,\n\t    headerEnd = data.indexOf('\\r\\n'),\n\t    logger = ua.getLogger('sip.parser');\n\t\n\t  if(headerEnd === -1) {\n\t    logger.warn('no CRLF found, not a SIP message, discarded');\n\t    return;\n\t  }\n\t\n\t  // Parse first line. Check if it is a Request or a Reply.\n\t  firstLine = data.substring(0, headerEnd);\n\t  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n\t\n\t  if(parsed === -1) {\n\t    logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n\t    return;\n\t  } else if(!parsed.status_code) {\n\t    message = new SIP.IncomingRequest(ua);\n\t    message.method = parsed.method;\n\t    message.ruri = parsed.uri;\n\t  } else {\n\t    message = new SIP.IncomingResponse(ua);\n\t    message.status_code = parsed.status_code;\n\t    message.reason_phrase = parsed.reason_phrase;\n\t  }\n\t\n\t  message.data = data;\n\t  headerStart = headerEnd + 2;\n\t\n\t  /* Loop over every line in data. Detect the end of each header and parse\n\t  * it or simply add to the headers collection.\n\t  */\n\t  while(true) {\n\t    headerEnd = getHeader(data, headerStart);\n\t\n\t    // The SIP message has normally finished.\n\t    if(headerEnd === -2) {\n\t      bodyStart = headerStart + 2;\n\t      break;\n\t    }\n\t    // data.indexOf returned -1 due to a malformed message.\n\t    else if(headerEnd === -1) {\n\t      logger.error('malformed message');\n\t      return;\n\t    }\n\t\n\t    parsed = parseHeader(message, data, headerStart, headerEnd);\n\t\n\t    if(parsed !== true) {\n\t      logger.error(parsed.error);\n\t      return;\n\t    }\n\t\n\t    headerStart = headerEnd + 2;\n\t  }\n\t\n\t  /* RFC3261 18.3.\n\t   * If there are additional bytes in the transport packet\n\t   * beyond the end of the body, they MUST be discarded.\n\t   */\n\t  if(message.hasHeader('content-length')) {\n\t    contentLength = message.getHeader('content-length');\n\t    message.body = data.substr(bodyStart, contentLength);\n\t  } else {\n\t    message.body = data.substring(bodyStart);\n\t  }\n\t\n\t  return message;\n\t};\n\t\n\tSIP.Parser = Parser;\n\t};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Message\n\t */\n\t\n\tmodule.exports = function (SIP) {\n\tvar\n\t  OutgoingRequest,\n\t  IncomingMessage,\n\t  IncomingRequest,\n\t  IncomingResponse;\n\t\n\tfunction getSupportedHeader (request) {\n\t  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;\n\t  var optionTags = [];\n\t  var optionTagSet = {};\n\t\n\t  if (request.method === SIP.C.REGISTER) {\n\t    optionTags.push('path', 'gruu');\n\t  } else if (request.method === SIP.C.INVITE &&\n\t             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {\n\t    optionTags.push('gruu');\n\t  }\n\t\n\t  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n\t    optionTags.push('100rel');\n\t  }\n\t  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {\n\t    optionTags.push('replaces');\n\t  }\n\t\n\t  optionTags.push('outbound');\n\t\n\t  optionTags = optionTags.concat(request.ua.configuration.extraSupported);\n\t\n\t  optionTags = optionTags.filter(function(optionTag) {\n\t    var registered = SIP.C.OPTION_TAGS[optionTag];\n\t    var unique = !optionTagSet[optionTag];\n\t    optionTagSet[optionTag] = true;\n\t    return (registered || allowUnregistered) && unique;\n\t  });\n\t\n\t  return 'Supported: ' + optionTags.join(', ') + '\\r\\n';\n\t}\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class for outgoing SIP request.\n\t * @param {String} method request method\n\t * @param {String} ruri request uri\n\t * @param {SIP.UA} ua\n\t * @param {Object} params parameters that will have priority over ua.configuration parameters:\n\t * <br>\n\t *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set\n\t * @param {Object} [headers] extra headers\n\t * @param {String} [body]\n\t */\n\tOutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {\n\t  var\n\t    to,\n\t    from,\n\t    call_id,\n\t    cseq,\n\t    to_uri,\n\t    from_uri;\n\t\n\t  params = params || {};\n\t\n\t  // Mandatory parameters check\n\t  if(!method || !ruri || !ua) {\n\t    return null;\n\t  }\n\t\n\t  this.logger = ua.getLogger('sip.sipmessage');\n\t  this.ua = ua;\n\t  this.headers = {};\n\t  this.method = method;\n\t  this.ruri = ruri;\n\t  this.body = body;\n\t  this.extraHeaders = (extraHeaders || []).slice();\n\t  this.statusCode = params.status_code;\n\t  this.reasonPhrase = params.reason_phrase;\n\t\n\t  // Fill the Common SIP Request Headers\n\t\n\t  // Route\n\t  if (params.route_set) {\n\t    this.setHeader('route', params.route_set);\n\t  } else if (ua.configuration.usePreloadedRoute){\n\t    this.setHeader('route', ua.transport.server.sip_uri);\n\t  }\n\t\n\t  // Via\n\t  // Empty Via header. Will be filled by the client transaction.\n\t  this.setHeader('via', '');\n\t\n\t  // Max-Forwards\n\t  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);\n\t\n\t  // To\n\t  to_uri = params.to_uri || ruri;\n\t  to = (params.to_displayName || params.to_displayName === 0) ? '\"' + params.to_displayName + '\" ' : '';\n\t  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';\n\t  to += params.to_tag ? ';tag=' + params.to_tag : '';\n\t  this.to = new SIP.NameAddrHeader.parse(to);\n\t  this.setHeader('to', to);\n\t\n\t  // From\n\t  from_uri = params.from_uri || ua.configuration.uri;\n\t  if (params.from_displayName || params.from_displayName === 0) {\n\t    from = '\"' + params.from_displayName + '\" ';\n\t  } else if (ua.configuration.displayName) {\n\t    from = '\"' + ua.configuration.displayName + '\" ';\n\t  } else {\n\t    from = '';\n\t  }\n\t  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';\n\t  from += params.from_tag || SIP.Utils.newTag();\n\t  this.from = new SIP.NameAddrHeader.parse(from);\n\t  this.setHeader('from', from);\n\t\n\t  // Call-ID\n\t  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));\n\t  this.call_id = call_id;\n\t  this.setHeader('call-id', call_id);\n\t\n\t  // CSeq\n\t  cseq = params.cseq || Math.floor(Math.random() * 10000);\n\t  this.cseq = cseq;\n\t  this.setHeader('cseq', cseq + ' ' + method);\n\t};\n\t\n\tOutgoingRequest.prototype = {\n\t  /**\n\t   * Replace the the given header by the given value.\n\t   * @param {String} name header name\n\t   * @param {String | Array} value header value\n\t   */\n\t  setHeader: function(name, value) {\n\t    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n\t  },\n\t\n\t  /**\n\t   * Get the value of the given header name at the given position.\n\t   * @param {String} name header name\n\t   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.\n\t   */\n\t  getHeader: function(name) {\n\t    var regexp, idx,\n\t      length = this.extraHeaders.length,\n\t      header = this.headers[SIP.Utils.headerize(name)];\n\t\n\t    if(header) {\n\t      if(header[0]) {\n\t        return header[0];\n\t      }\n\t    } else {\n\t      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = this.extraHeaders[idx];\n\t        if (regexp.test(header)) {\n\t          return header.substring(header.indexOf(':')+1).trim();\n\t        }\n\t      }\n\t    }\n\t\n\t    return;\n\t  },\n\t\n\t  /**\n\t   * Get the header/s of the given name.\n\t   * @param {String} name header name\n\t   * @returns {Array} Array with all the headers of the specified name.\n\t   */\n\t  getHeaders: function(name) {\n\t    var idx, length, regexp,\n\t      header = this.headers[SIP.Utils.headerize(name)],\n\t      result = [];\n\t\n\t    if(header) {\n\t      length = header.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        result.push(header[idx]);\n\t      }\n\t      return result;\n\t    } else {\n\t      length = this.extraHeaders.length;\n\t      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = this.extraHeaders[idx];\n\t        if (regexp.test(header)) {\n\t          result.push(header.substring(header.indexOf(':')+1).trim());\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Verify the existence of the given header.\n\t   * @param {String} name header name\n\t   * @returns {boolean} true if header with given name exists, false otherwise\n\t   */\n\t  hasHeader: function(name) {\n\t    var regexp, idx,\n\t      length = this.extraHeaders.length;\n\t\n\t    if (this.headers[SIP.Utils.headerize(name)]) {\n\t      return true;\n\t    } else {\n\t      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n\t      for (idx = 0; idx < length; idx++) {\n\t        if (regexp.test(this.extraHeaders[idx])) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  toString: function() {\n\t    var msg = '', header, length, idx;\n\t\n\t    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\\r\\n';\n\t\n\t    for (header in this.headers) {\n\t      length = this.headers[header].length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        msg += header + ': ' + this.headers[header][idx] + '\\r\\n';\n\t      }\n\t    }\n\t\n\t    length = this.extraHeaders.length;\n\t    for (idx = 0; idx < length; idx++) {\n\t      msg += this.extraHeaders[idx].trim() +'\\r\\n';\n\t    }\n\t\n\t    msg += getSupportedHeader(this);\n\t    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\t\n\t    if(this.body) {\n\t      length = SIP.Utils.str_utf8_length(this.body);\n\t      msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n\t      msg += this.body;\n\t    } else {\n\t      msg += 'Content-Length: 0\\r\\n\\r\\n';\n\t    }\n\t\n\t    return msg;\n\t  }\n\t};\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class for incoming SIP message.\n\t */\n\tIncomingMessage = function(){\n\t  this.data = null;\n\t  this.headers = null;\n\t  this.method =  null;\n\t  this.via = null;\n\t  this.via_branch = null;\n\t  this.call_id = null;\n\t  this.cseq = null;\n\t  this.from = null;\n\t  this.from_tag = null;\n\t  this.to = null;\n\t  this.to_tag = null;\n\t  this.body = null;\n\t};\n\t\n\tIncomingMessage.prototype = {\n\t  /**\n\t  * Insert a header of the given name and value into the last position of the\n\t  * header array.\n\t  * @param {String} name header name\n\t  * @param {String} value header value\n\t  */\n\t  addHeader: function(name, value) {\n\t    var header = { raw: value };\n\t\n\t    name = SIP.Utils.headerize(name);\n\t\n\t    if(this.headers[name]) {\n\t      this.headers[name].push(header);\n\t    } else {\n\t      this.headers[name] = [header];\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get the value of the given header name at the given position.\n\t   * @param {String} name header name\n\t   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.\n\t   */\n\t  getHeader: function(name) {\n\t    var header = this.headers[SIP.Utils.headerize(name)];\n\t\n\t    if(header) {\n\t      if(header[0]) {\n\t        return header[0].raw;\n\t      }\n\t    } else {\n\t      return;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get the header/s of the given name.\n\t   * @param {String} name header name\n\t   * @returns {Array} Array with all the headers of the specified name.\n\t   */\n\t  getHeaders: function(name) {\n\t    var idx, length,\n\t      header = this.headers[SIP.Utils.headerize(name)],\n\t      result = [];\n\t\n\t    if(!header) {\n\t      return [];\n\t    }\n\t\n\t    length = header.length;\n\t    for (idx = 0; idx < length; idx++) {\n\t      result.push(header[idx].raw);\n\t    }\n\t\n\t    return result;\n\t  },\n\t\n\t  /**\n\t   * Verify the existence of the given header.\n\t   * @param {String} name header name\n\t   * @returns {boolean} true if header with given name exists, false otherwise\n\t   */\n\t  hasHeader: function(name) {\n\t    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;\n\t  },\n\t\n\t  /**\n\t  * Parse the given header on the given index.\n\t  * @param {String} name header name\n\t  * @param {Number} [idx=0] header index\n\t  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n\t  */\n\t  parseHeader: function(name, idx) {\n\t    var header, value, parsed;\n\t\n\t    name = SIP.Utils.headerize(name);\n\t\n\t    idx = idx || 0;\n\t\n\t    if(!this.headers[name]) {\n\t      this.logger.log('header \"' + name + '\" not present');\n\t      return;\n\t    } else if(idx >= this.headers[name].length) {\n\t      this.logger.log('not so many \"' + name + '\" headers present');\n\t      return;\n\t    }\n\t\n\t    header = this.headers[name][idx];\n\t    value = header.raw;\n\t\n\t    if(header.parsed) {\n\t      return header.parsed;\n\t    }\n\t\n\t    //substitute '-' by '_' for grammar rule matching.\n\t    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));\n\t\n\t    if(parsed === -1) {\n\t      this.headers[name].splice(idx, 1); //delete from headers\n\t      this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n\t      return;\n\t    } else {\n\t      header.parsed = parsed;\n\t      return parsed;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Message Header attribute selector. Alias of parseHeader.\n\t   * @param {String} name header name\n\t   * @param {Number} [idx=0] header index\n\t   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n\t   *\n\t   * @example\n\t   * message.s('via',3).port\n\t   */\n\t  s: function(name, idx) {\n\t    return this.parseHeader(name, idx);\n\t  },\n\t\n\t  /**\n\t  * Replace the value of the given header by the value.\n\t  * @param {String} name header name\n\t  * @param {String} value header value\n\t  */\n\t  setHeader: function(name, value) {\n\t    var header = { raw: value };\n\t    this.headers[SIP.Utils.headerize(name)] = [header];\n\t  },\n\t\n\t  toString: function() {\n\t    return this.data;\n\t  }\n\t};\n\t\n\t/**\n\t * @augments IncomingMessage\n\t * @class Class for incoming SIP request.\n\t */\n\tIncomingRequest = function(ua) {\n\t  this.logger = ua.getLogger('sip.sipmessage');\n\t  this.ua = ua;\n\t  this.headers = {};\n\t  this.ruri = null;\n\t  this.transport = null;\n\t  this.server_transaction = null;\n\t};\n\tIncomingRequest.prototype = new IncomingMessage();\n\t\n\t/**\n\t* Stateful reply.\n\t* @param {Number} code status code\n\t* @param {String} reason reason phrase\n\t* @param {Object} headers extra headers\n\t* @param {String} body body\n\t* @param {Function} [onSuccess] onSuccess callback\n\t* @param {Function} [onFailure] onFailure callback\n\t*/\n\tIncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {\n\t  var rr, vias, length, idx, response,\n\t    to = this.getHeader('To'),\n\t    r = 0,\n\t    v = 0;\n\t\n\t  response = SIP.Utils.buildStatusLine(code, reason);\n\t  extraHeaders = (extraHeaders || []).slice();\n\t\n\t  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {\n\t    rr = this.getHeaders('record-route');\n\t    length = rr.length;\n\t\n\t    for(r; r < length; r++) {\n\t      response += 'Record-Route: ' + rr[r] + '\\r\\n';\n\t    }\n\t  }\n\t\n\t  vias = this.getHeaders('via');\n\t  length = vias.length;\n\t\n\t  for(v; v < length; v++) {\n\t    response += 'Via: ' + vias[v] + '\\r\\n';\n\t  }\n\t\n\t  if(!this.to_tag && code > 100) {\n\t    to += ';tag=' + SIP.Utils.newTag();\n\t  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n\t    to += ';tag=' + this.to_tag;\n\t  }\n\t\n\t  response += 'To: ' + to + '\\r\\n';\n\t  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n\t  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n\t  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\t\n\t  length = extraHeaders.length;\n\t  for (idx = 0; idx < length; idx++) {\n\t    response += extraHeaders[idx].trim() +'\\r\\n';\n\t  }\n\t\n\t  response += getSupportedHeader(this);\n\t  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\t\n\t  if(body) {\n\t    length = SIP.Utils.str_utf8_length(body);\n\t    response += 'Content-Type: application/sdp\\r\\n';\n\t    response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n\t    response += body;\n\t  } else {\n\t    response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\t  }\n\t\n\t  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);\n\t\n\t  return response;\n\t};\n\t\n\t/**\n\t* Stateless reply.\n\t* @param {Number} code status code\n\t* @param {String} reason reason phrase\n\t*/\n\tIncomingRequest.prototype.reply_sl = function(code, reason) {\n\t  var to, response,\n\t    v = 0,\n\t    vias = this.getHeaders('via'),\n\t    length = vias.length;\n\t\n\t  response = SIP.Utils.buildStatusLine(code, reason);\n\t\n\t  for(v; v < length; v++) {\n\t    response += 'Via: ' + vias[v] + '\\r\\n';\n\t  }\n\t\n\t  to = this.getHeader('To');\n\t\n\t  if(!this.to_tag && code > 100) {\n\t    to += ';tag=' + SIP.Utils.newTag();\n\t  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n\t    to += ';tag=' + this.to_tag;\n\t  }\n\t\n\t  response += 'To: ' + to + '\\r\\n';\n\t  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n\t  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n\t  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\t  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\t  response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\t\n\t  this.transport.send(response);\n\t};\n\t\n\t\n\t/**\n\t * @augments IncomingMessage\n\t * @class Class for incoming SIP response.\n\t */\n\tIncomingResponse = function(ua) {\n\t  this.logger = ua.getLogger('sip.sipmessage');\n\t  this.headers = {};\n\t  this.status_code = null;\n\t  this.reason_phrase = null;\n\t};\n\tIncomingResponse.prototype = new IncomingMessage();\n\t\n\tSIP.OutgoingRequest = OutgoingRequest;\n\tSIP.IncomingRequest = IncomingRequest;\n\tSIP.IncomingResponse = IncomingResponse;\n\t};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP URI\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP URI.\n\t *\n\t * @param {String} [scheme]\n\t * @param {String} [user]\n\t * @param {String} host\n\t * @param {String} [port]\n\t * @param {Object} [parameters]\n\t * @param {Object} [headers]\n\t *\n\t */\n\tmodule.exports = function (SIP) {\n\tvar URI;\n\t\n\tURI = function(scheme, user, host, port, parameters, headers) {\n\t  var param, header, raw, normal;\n\t\n\t  // Checks\n\t  if(!host) {\n\t    throw new TypeError('missing or invalid \"host\" parameter');\n\t  }\n\t\n\t  // Initialize parameters\n\t  scheme = scheme || SIP.C.SIP;\n\t  this.parameters = {};\n\t  this.headers = {};\n\t\n\t  for (param in parameters) {\n\t    this.setParam(param, parameters[param]);\n\t  }\n\t\n\t  for (header in headers) {\n\t    this.setHeader(header, headers[header]);\n\t  }\n\t\n\t  // Raw URI\n\t  raw = {\n\t    scheme: scheme,\n\t    user: user,\n\t    host: host,\n\t    port: port\n\t  };\n\t\n\t  // Normalized URI\n\t  normal = {\n\t    scheme: scheme.toLowerCase(),\n\t    user: user,\n\t    host: host.toLowerCase(),\n\t    port: port\n\t  };\n\t\n\t  Object.defineProperties(this, {\n\t    _normal: {\n\t      get: function() { return normal; }\n\t    },\n\t\n\t    _raw: {\n\t      get: function() { return raw; }\n\t    },\n\t\n\t    scheme: {\n\t      get: function() { return normal.scheme; },\n\t      set: function(value) {\n\t        raw.scheme = value;\n\t        normal.scheme = value.toLowerCase();\n\t      }\n\t    },\n\t\n\t    user: {\n\t      get: function() { return normal.user; },\n\t      set: function(value) {\n\t        normal.user = raw.user = value;\n\t      }\n\t    },\n\t\n\t    host: {\n\t      get: function() { return normal.host; },\n\t      set: function(value) {\n\t        raw.host = value;\n\t        normal.host = value.toLowerCase();\n\t      }\n\t    },\n\t\n\t    aor: {\n\t      get: function() { return normal.user + '@' + normal.host; }\n\t    },\n\t\n\t    port: {\n\t      get: function() { return normal.port; },\n\t      set: function(value) {\n\t        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);\n\t      }\n\t    }\n\t  });\n\t};\n\t\n\tURI.prototype = {\n\t  setParam: function(key, value) {\n\t    if(key) {\n\t      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();\n\t    }\n\t  },\n\t\n\t  getParam: function(key) {\n\t    if(key) {\n\t      return this.parameters[key.toLowerCase()];\n\t    }\n\t  },\n\t\n\t  hasParam: function(key) {\n\t    if(key) {\n\t      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n\t    }\n\t  },\n\t\n\t  deleteParam: function(parameter) {\n\t    var value;\n\t    parameter = parameter.toLowerCase();\n\t    if (this.parameters.hasOwnProperty(parameter)) {\n\t      value = this.parameters[parameter];\n\t      delete this.parameters[parameter];\n\t      return value;\n\t    }\n\t  },\n\t\n\t  clearParams: function() {\n\t    this.parameters = {};\n\t  },\n\t\n\t  setHeader: function(name, value) {\n\t    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n\t  },\n\t\n\t  getHeader: function(name) {\n\t    if(name) {\n\t      return this.headers[SIP.Utils.headerize(name)];\n\t    }\n\t  },\n\t\n\t  hasHeader: function(name) {\n\t    if(name) {\n\t      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;\n\t    }\n\t  },\n\t\n\t  deleteHeader: function(header) {\n\t    var value;\n\t    header = SIP.Utils.headerize(header);\n\t    if(this.headers.hasOwnProperty(header)) {\n\t      value = this.headers[header];\n\t      delete this.headers[header];\n\t      return value;\n\t    }\n\t  },\n\t\n\t  clearHeaders: function() {\n\t    this.headers = {};\n\t  },\n\t\n\t  clone: function() {\n\t    return new URI(\n\t      this._raw.scheme,\n\t      this._raw.user,\n\t      this._raw.host,\n\t      this._raw.port,\n\t      JSON.parse(JSON.stringify(this.parameters)),\n\t      JSON.parse(JSON.stringify(this.headers)));\n\t  },\n\t\n\t  toRaw: function() {\n\t    return this._toString(this._raw);\n\t  },\n\t\n\t  toString: function() {\n\t    return this._toString(this._normal);\n\t  },\n\t\n\t  _toString: function(uri) {\n\t    var header, parameter, idx, uriString, headers = [];\n\t\n\t    uriString  = uri.scheme + ':';\n\t    // add slashes if it's not a sip(s) URI\n\t    if (!uri.scheme.toLowerCase().match(\"^sips?$\")) {\n\t      uriString += \"//\";\n\t    }\n\t    if (uri.user) {\n\t      uriString += SIP.Utils.escapeUser(uri.user) + '@';\n\t    }\n\t    uriString += uri.host;\n\t    if (uri.port || uri.port === 0) {\n\t      uriString += ':' + uri.port;\n\t    }\n\t\n\t    for (parameter in this.parameters) {\n\t      uriString += ';' + parameter;\n\t\n\t      if (this.parameters[parameter] !== null) {\n\t        uriString += '='+ this.parameters[parameter];\n\t      }\n\t    }\n\t\n\t    for(header in this.headers) {\n\t      for(idx in this.headers[header]) {\n\t        headers.push(header + '=' + this.headers[header][idx]);\n\t      }\n\t    }\n\t\n\t    if (headers.length > 0) {\n\t      uriString += '?' + headers.join('&');\n\t    }\n\t\n\t    return uriString;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t  * Parse the given string and returns a SIP.URI instance or undefined if\n\t  * it is an invalid URI.\n\t  * @public\n\t  * @param {String} uri\n\t  */\n\tURI.parse = function(uri) {\n\t  uri = SIP.Grammar.parse(uri,'SIP_URI');\n\t\n\t  if (uri !== -1) {\n\t    return uri;\n\t  } else {\n\t    return undefined;\n\t  }\n\t};\n\t\n\tSIP.URI = URI;\n\t};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP NameAddrHeader\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a Name Address SIP header.\n\t *\n\t * @param {SIP.URI} uri\n\t * @param {String} [displayName]\n\t * @param {Object} [parameters]\n\t *\n\t */\n\tmodule.exports = function (SIP) {\n\tvar NameAddrHeader;\n\t\n\tNameAddrHeader = function(uri, displayName, parameters) {\n\t  var param;\n\t\n\t  // Checks\n\t  if(!uri || !(uri instanceof SIP.URI)) {\n\t    throw new TypeError('missing or invalid \"uri\" parameter');\n\t  }\n\t\n\t  // Initialize parameters\n\t  this.uri = uri;\n\t  this.parameters = {};\n\t\n\t  for (param in parameters) {\n\t    this.setParam(param, parameters[param]);\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    friendlyName: {\n\t      get: function() { return this.displayName || uri.aor; }\n\t    },\n\t\n\t    displayName: {\n\t      get: function() { return displayName; },\n\t      set: function(value) {\n\t        displayName = (value === 0) ? '0' : value;\n\t      }\n\t    }\n\t  });\n\t};\n\tNameAddrHeader.prototype = {\n\t  setParam: function (key, value) {\n\t    if(key) {\n\t      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n\t    }\n\t  },\n\t  getParam: SIP.URI.prototype.getParam,\n\t  hasParam: SIP.URI.prototype.hasParam,\n\t  deleteParam: SIP.URI.prototype.deleteParam,\n\t  clearParams: SIP.URI.prototype.clearParams,\n\t\n\t  clone: function() {\n\t    return new NameAddrHeader(\n\t      this.uri.clone(),\n\t      this.displayName,\n\t      JSON.parse(JSON.stringify(this.parameters)));\n\t  },\n\t\n\t  toString: function() {\n\t    var body, parameter;\n\t\n\t    body  = (this.displayName || this.displayName === 0) ? '\"' + this.displayName + '\" ' : '';\n\t    body += '<' + this.uri.toString() + '>';\n\t\n\t    for (parameter in this.parameters) {\n\t      body += ';' + parameter;\n\t\n\t      if (this.parameters[parameter] !== null) {\n\t        body += '='+ this.parameters[parameter];\n\t      }\n\t    }\n\t\n\t    return body;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n\t  * it is an invalid NameAddrHeader.\n\t  * @public\n\t  * @param {String} name_addr_header\n\t  */\n\tNameAddrHeader.parse = function(name_addr_header) {\n\t  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');\n\t\n\t  if (name_addr_header !== -1) {\n\t    return name_addr_header;\n\t  } else {\n\t    return undefined;\n\t  }\n\t};\n\t\n\tSIP.NameAddrHeader = NameAddrHeader;\n\t};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Transactions\n\t */\n\t\n\t/**\n\t * SIP Transactions module.\n\t * @augments SIP\n\t */\n\tmodule.exports = function (SIP) {\n\tvar\n\t  C = {\n\t    // Transaction states\n\t    STATUS_TRYING:     1,\n\t    STATUS_PROCEEDING: 2,\n\t    STATUS_CALLING:    3,\n\t    STATUS_ACCEPTED:   4,\n\t    STATUS_COMPLETED:  5,\n\t    STATUS_TERMINATED: 6,\n\t    STATUS_CONFIRMED:  7,\n\t\n\t    // Transaction types\n\t    NON_INVITE_CLIENT: 'nict',\n\t    NON_INVITE_SERVER: 'nist',\n\t    INVITE_CLIENT: 'ict',\n\t    INVITE_SERVER: 'ist'\n\t  };\n\t\n\tfunction buildViaHeader (request_sender, transport, id) {\n\t  var via;\n\t  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n\t  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;\n\t  if (request_sender.ua.configuration.forceRport) {\n\t    via += ';rport';\n\t  }\n\t  return via;\n\t}\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Non Invite Client Transaction\n\t* @param {SIP.RequestSender} request_sender\n\t* @param {SIP.OutgoingRequest} request\n\t* @param {SIP.Transport} transport\n\t*/\n\tvar NonInviteClientTransaction = function(request_sender, request, transport) {\n\t  var via;\n\t\n\t  this.type = C.NON_INVITE_CLIENT;\n\t  this.transport = transport;\n\t  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n\t  this.request_sender = request_sender;\n\t  this.request = request;\n\t\n\t  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\t\n\t  via = buildViaHeader(request_sender, transport, this.id);\n\t  this.request.setHeader('via', via);\n\t\n\t  this.request_sender.ua.newTransaction(this);\n\t};\n\tNonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tNonInviteClientTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tNonInviteClientTransaction.prototype.send = function() {\n\t  var tr = this;\n\t\n\t  this.stateChanged(C.STATUS_TRYING);\n\t  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n\t\n\t  if(!this.transport.send(this.request)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\tNonInviteClientTransaction.prototype.onTransportError = function() {\n\t  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n\t  SIP.Timers.clearTimeout(this.F);\n\t  SIP.Timers.clearTimeout(this.K);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t  this.request_sender.onTransportError();\n\t};\n\t\n\tNonInviteClientTransaction.prototype.timer_F = function() {\n\t  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t  this.request_sender.onRequestTimeout();\n\t};\n\t\n\tNonInviteClientTransaction.prototype.timer_K = function() {\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t};\n\t\n\tNonInviteClientTransaction.prototype.receiveResponse = function(response) {\n\t  var\n\t    tr = this,\n\t    status_code = response.status_code;\n\t\n\t  if(status_code < 200) {\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_PROCEEDING);\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t    }\n\t  } else {\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_COMPLETED);\n\t        SIP.Timers.clearTimeout(this.F);\n\t\n\t        if(status_code === 408) {\n\t          this.request_sender.onRequestTimeout();\n\t        } else {\n\t          this.request_sender.receiveResponse(response);\n\t        }\n\t\n\t        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n\t        break;\n\t      case C.STATUS_COMPLETED:\n\t        break;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Invite Client Transaction\n\t* @param {SIP.RequestSender} request_sender\n\t* @param {SIP.OutgoingRequest} request\n\t* @param {SIP.Transport} transport\n\t*/\n\tvar InviteClientTransaction = function(request_sender, request, transport) {\n\t  var via,\n\t    tr = this;\n\t\n\t  this.type = C.INVITE_CLIENT;\n\t  this.transport = transport;\n\t  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n\t  this.request_sender = request_sender;\n\t  this.request = request;\n\t\n\t  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n\t\n\t  via = buildViaHeader(request_sender, transport, this.id);\n\t  this.request.setHeader('via', via);\n\t\n\t  this.request_sender.ua.newTransaction(this);\n\t\n\t  // Add the cancel property to the request.\n\t  //Will be called from the request instance, not the transaction itself.\n\t  this.request.cancel = function(reason) {\n\t    tr.cancel_request(tr, reason);\n\t  };\n\t};\n\tInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tInviteClientTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tInviteClientTransaction.prototype.send = function() {\n\t  var tr = this;\n\t  this.stateChanged(C.STATUS_CALLING);\n\t  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n\t\n\t  if(!this.transport.send(this.request)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\tInviteClientTransaction.prototype.onTransportError = function() {\n\t  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n\t  SIP.Timers.clearTimeout(this.B);\n\t  SIP.Timers.clearTimeout(this.D);\n\t  SIP.Timers.clearTimeout(this.M);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t\n\t  if (this.state !== C.STATUS_ACCEPTED) {\n\t    this.request_sender.onTransportError();\n\t  }\n\t};\n\t\n\t// RFC 6026 7.2\n\tInviteClientTransaction.prototype.timer_M = function() {\n\t  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);\n\t\n\t  if(this.state === C.STATUS_ACCEPTED) {\n\t    SIP.Timers.clearTimeout(this.B);\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.request_sender.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\t// RFC 3261 17.1.1\n\tInviteClientTransaction.prototype.timer_B = function() {\n\t  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);\n\t  if(this.state === C.STATUS_CALLING) {\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.request_sender.ua.destroyTransaction(this);\n\t    this.request_sender.onRequestTimeout();\n\t  }\n\t};\n\t\n\tInviteClientTransaction.prototype.timer_D = function() {\n\t  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);\n\t  SIP.Timers.clearTimeout(this.B);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t};\n\t\n\tInviteClientTransaction.prototype.sendACK = function(response) {\n\t  var tr = this;\n\t\n\t  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\\r\\n';\n\t  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\\r\\n';\n\t\n\t  if(this.request.headers['Route']) {\n\t    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\\r\\n';\n\t  }\n\t\n\t  this.ack += 'To: ' + response.getHeader('to') + '\\r\\n';\n\t  this.ack += 'From: ' + this.request.headers['From'].toString() + '\\r\\n';\n\t  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\\r\\n';\n\t  this.ack += 'Content-Length: 0\\r\\n';\n\t  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];\n\t  this.ack += ' ACK\\r\\n\\r\\n';\n\t\n\t  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);\n\t\n\t  this.transport.send(this.ack);\n\t};\n\t\n\tInviteClientTransaction.prototype.cancel_request = function(tr, reason) {\n\t  var request = tr.request;\n\t\n\t  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n\t  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n\t\n\t  if(this.request.headers['Route']) {\n\t    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n\t  }\n\t\n\t  this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n\t  this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n\t  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n\t  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +\n\t  ' CANCEL\\r\\n';\n\t\n\t  if(reason) {\n\t    this.cancel += 'Reason: ' + reason + '\\r\\n';\n\t  }\n\t\n\t  this.cancel += 'Content-Length: 0\\r\\n\\r\\n';\n\t\n\t  // Send only if a provisional response (>100) has been received.\n\t  if(this.state === C.STATUS_PROCEEDING) {\n\t    this.transport.send(this.cancel);\n\t  }\n\t};\n\t\n\tInviteClientTransaction.prototype.receiveResponse = function(response) {\n\t  var\n\t  tr = this,\n\t  status_code = response.status_code;\n\t\n\t  if(status_code >= 100 && status_code <= 199) {\n\t    switch(this.state) {\n\t      case C.STATUS_CALLING:\n\t        this.stateChanged(C.STATUS_PROCEEDING);\n\t        this.request_sender.receiveResponse(response);\n\t        if(this.cancel) {\n\t          this.transport.send(this.cancel);\n\t        }\n\t        break;\n\t      case C.STATUS_PROCEEDING:\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t    }\n\t  } else if(status_code >= 200 && status_code <= 299) {\n\t    switch(this.state) {\n\t      case C.STATUS_CALLING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_ACCEPTED);\n\t        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t      case C.STATUS_ACCEPTED:\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t    }\n\t  } else if(status_code >= 300 && status_code <= 699) {\n\t    switch(this.state) {\n\t      case C.STATUS_CALLING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_COMPLETED);\n\t        this.sendACK(response);\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t      case C.STATUS_COMPLETED:\n\t        this.sendACK(response);\n\t        break;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * @augments SIP.Transactions\n\t * @class ACK Client Transaction\n\t * @param {SIP.RequestSender} request_sender\n\t * @param {SIP.OutgoingRequest} request\n\t * @param {SIP.Transport} transport\n\t */\n\tvar AckClientTransaction = function(request_sender, request, transport) {\n\t  var via;\n\t\n\t  this.transport = transport;\n\t  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n\t  this.request_sender = request_sender;\n\t  this.request = request;\n\t\n\t  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\t\n\t  via = buildViaHeader(request_sender, transport, this.id);\n\t  this.request.setHeader('via', via);\n\t};\n\tAckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tAckClientTransaction.prototype.send = function() {\n\t  if(!this.transport.send(this.request)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\tAckClientTransaction.prototype.onTransportError = function() {\n\t  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n\t  this.request_sender.onTransportError();\n\t};\n\t\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Non Invite Server Transaction\n\t* @param {SIP.IncomingRequest} request\n\t* @param {SIP.UA} ua\n\t*/\n\tvar NonInviteServerTransaction = function(request, ua) {\n\t  this.type = C.NON_INVITE_SERVER;\n\t  this.id = request.via_branch;\n\t  this.request = request;\n\t  this.transport = request.transport;\n\t  this.ua = ua;\n\t  this.last_response = '';\n\t  request.server_transaction = this;\n\t\n\t  this.logger = ua.getLogger('sip.transaction.nist', this.id);\n\t\n\t  this.state = C.STATUS_TRYING;\n\t\n\t  ua.newTransaction(this);\n\t};\n\tNonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tNonInviteServerTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tNonInviteServerTransaction.prototype.timer_J = function() {\n\t  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.ua.destroyTransaction(this);\n\t};\n\t\n\tNonInviteServerTransaction.prototype.onTransportError = function() {\n\t  if (!this.transportError) {\n\t    this.transportError = true;\n\t\n\t    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n\t\n\t    SIP.Timers.clearTimeout(this.J);\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\tNonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n\t  var tr = this;\n\t  var deferred = SIP.Utils.defer();\n\t\n\t  if(status_code === 100) {\n\t    /* RFC 4320 4.1\n\t     * 'A SIP element MUST NOT\n\t     * send any provisional response with a\n\t     * Status-Code other than 100 to a non-INVITE request.'\n\t     */\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t        this.stateChanged(C.STATUS_PROCEEDING);\n\t        if(!this.transport.send(response))  {\n\t          this.onTransportError();\n\t        }\n\t        break;\n\t      case C.STATUS_PROCEEDING:\n\t        this.last_response = response;\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t          deferred.reject();\n\t        } else {\n\t          deferred.resolve();\n\t        }\n\t        break;\n\t    }\n\t  } else if(status_code >= 200 && status_code <= 699) {\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_COMPLETED);\n\t        this.last_response = response;\n\t        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t          deferred.reject();\n\t        } else {\n\t          deferred.resolve();\n\t        }\n\t        break;\n\t      case C.STATUS_COMPLETED:\n\t        break;\n\t    }\n\t  }\n\t\n\t  return deferred.promise;\n\t};\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Invite Server Transaction\n\t* @param {SIP.IncomingRequest} request\n\t* @param {SIP.UA} ua\n\t*/\n\tvar InviteServerTransaction = function(request, ua) {\n\t  this.type = C.INVITE_SERVER;\n\t  this.id = request.via_branch;\n\t  this.request = request;\n\t  this.transport = request.transport;\n\t  this.ua = ua;\n\t  this.last_response = '';\n\t  request.server_transaction = this;\n\t\n\t  this.logger = ua.getLogger('sip.transaction.ist', this.id);\n\t\n\t  this.state = C.STATUS_PROCEEDING;\n\t\n\t  ua.newTransaction(this);\n\t\n\t  this.resendProvisionalTimer = null;\n\t\n\t  request.reply(100);\n\t};\n\tInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tInviteServerTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tInviteServerTransaction.prototype.timer_H = function() {\n\t  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);\n\t\n\t  if(this.state === C.STATUS_COMPLETED) {\n\t    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n\t  }\n\t\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.ua.destroyTransaction(this);\n\t};\n\t\n\tInviteServerTransaction.prototype.timer_I = function() {\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.ua.destroyTransaction(this);\n\t};\n\t\n\t// RFC 6026 7.1\n\tInviteServerTransaction.prototype.timer_L = function() {\n\t  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);\n\t\n\t  if(this.state === C.STATUS_ACCEPTED) {\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\tInviteServerTransaction.prototype.onTransportError = function() {\n\t  if (!this.transportError) {\n\t    this.transportError = true;\n\t\n\t    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n\t\n\t    if (this.resendProvisionalTimer !== null) {\n\t      SIP.Timers.clearInterval(this.resendProvisionalTimer);\n\t      this.resendProvisionalTimer = null;\n\t    }\n\t\n\t    SIP.Timers.clearTimeout(this.L);\n\t    SIP.Timers.clearTimeout(this.H);\n\t    SIP.Timers.clearTimeout(this.I);\n\t\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\tInviteServerTransaction.prototype.resend_provisional = function() {\n\t  if(!this.transport.send(this.last_response)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\t// INVITE Server Transaction RFC 3261 17.2.1\n\tInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n\t  var tr = this;\n\t  var deferred = SIP.Utils.defer();\n\t\n\t  if(status_code >= 100 && status_code <= 199) {\n\t    switch(this.state) {\n\t      case C.STATUS_PROCEEDING:\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t        }\n\t        this.last_response = response;\n\t        break;\n\t    }\n\t  }\n\t\n\t  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n\t    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n\t    if(this.resendProvisionalTimer === null) {\n\t      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),\n\t        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n\t    }\n\t  } else if(status_code >= 200 && status_code <= 299) {\n\t    switch(this.state) {\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_ACCEPTED);\n\t        this.last_response = response;\n\t        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n\t\n\t        if (this.resendProvisionalTimer !== null) {\n\t          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n\t          this.resendProvisionalTimer = null;\n\t        }\n\t        /* falls through */\n\t        case C.STATUS_ACCEPTED:\n\t          // Note that this point will be reached for proceeding tr.state also.\n\t          if(!this.transport.send(response)) {\n\t            this.onTransportError();\n\t            deferred.reject();\n\t          } else {\n\t            deferred.resolve();\n\t          }\n\t          break;\n\t    }\n\t  } else if(status_code >= 300 && status_code <= 699) {\n\t    switch(this.state) {\n\t      case C.STATUS_PROCEEDING:\n\t        if (this.resendProvisionalTimer !== null) {\n\t          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n\t          this.resendProvisionalTimer = null;\n\t        }\n\t\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t          deferred.reject();\n\t        } else {\n\t          this.stateChanged(C.STATUS_COMPLETED);\n\t          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n\t          deferred.resolve();\n\t        }\n\t        break;\n\t    }\n\t  }\n\t\n\t  return deferred.promise;\n\t};\n\t\n\t/**\n\t * @function\n\t * @param {SIP.UA} ua\n\t * @param {SIP.IncomingRequest} request\n\t *\n\t * @return {boolean}\n\t * INVITE:\n\t *  _true_ if retransmission\n\t *  _false_ new request\n\t *\n\t * ACK:\n\t *  _true_  ACK to non2xx response\n\t *  _false_ ACK must be passed to TU (accepted state)\n\t *          ACK to 2xx response\n\t *\n\t * CANCEL:\n\t *  _true_  no matching invite transaction\n\t *  _false_ matching invite transaction and no final response sent\n\t *\n\t * OTHER:\n\t *  _true_  retransmission\n\t *  _false_ new request\n\t */\n\tvar checkTransaction = function(ua, request) {\n\t  var tr;\n\t\n\t  switch(request.method) {\n\t    case SIP.C.INVITE:\n\t      tr = ua.transactions.ist[request.via_branch];\n\t      if(tr) {\n\t        switch(tr.state) {\n\t          case C.STATUS_PROCEEDING:\n\t            tr.transport.send(tr.last_response);\n\t            break;\n\t\n\t            // RFC 6026 7.1 Invite retransmission\n\t            //received while in C.STATUS_ACCEPTED state. Absorb it.\n\t          case C.STATUS_ACCEPTED:\n\t            break;\n\t        }\n\t        return true;\n\t      }\n\t      break;\n\t    case SIP.C.ACK:\n\t      tr = ua.transactions.ist[request.via_branch];\n\t\n\t      // RFC 6026 7.1\n\t      if(tr) {\n\t        if(tr.state === C.STATUS_ACCEPTED) {\n\t          return false;\n\t        } else if(tr.state === C.STATUS_COMPLETED) {\n\t          tr.state = C.STATUS_CONFIRMED;\n\t          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n\t          return true;\n\t        }\n\t      }\n\t\n\t      // ACK to 2XX Response.\n\t      else {\n\t        return false;\n\t      }\n\t      break;\n\t    case SIP.C.CANCEL:\n\t      tr = ua.transactions.ist[request.via_branch];\n\t      if(tr) {\n\t        request.reply_sl(200);\n\t        if(tr.state === C.STATUS_PROCEEDING) {\n\t          return false;\n\t        } else {\n\t          return true;\n\t        }\n\t      } else {\n\t        request.reply_sl(481);\n\t        return true;\n\t      }\n\t      break;\n\t    default:\n\t\n\t      // Non-INVITE Server Transaction RFC 3261 17.2.2\n\t      tr = ua.transactions.nist[request.via_branch];\n\t      if(tr) {\n\t        switch(tr.state) {\n\t          case C.STATUS_TRYING:\n\t            break;\n\t          case C.STATUS_PROCEEDING:\n\t          case C.STATUS_COMPLETED:\n\t            tr.transport.send(tr.last_response);\n\t            break;\n\t        }\n\t        return true;\n\t      }\n\t      break;\n\t  }\n\t};\n\t\n\tSIP.Transactions = {\n\t  C: C,\n\t  checkTransaction: checkTransaction,\n\t  NonInviteClientTransaction: NonInviteClientTransaction,\n\t  InviteClientTransaction: InviteClientTransaction,\n\t  AckClientTransaction: AckClientTransaction,\n\t  NonInviteServerTransaction: NonInviteServerTransaction,\n\t  InviteServerTransaction: InviteServerTransaction\n\t};\n\t\n\t};\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Dialog\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP dialog.\n\t * @param {SIP.RTCSession} owner\n\t * @param {SIP.IncomingRequest|SIP.IncomingResponse} message\n\t * @param {Enum} type UAC / UAS\n\t * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED\n\t */\n\tmodule.exports = function (SIP) {\n\t\n\tvar RequestSender = __webpack_require__(31)(SIP);\n\t\n\tvar Dialog,\n\t  C = {\n\t    // Dialog states\n\t    STATUS_EARLY:       1,\n\t    STATUS_CONFIRMED:   2\n\t  };\n\t\n\t// RFC 3261 12.1\n\tDialog = function(owner, message, type, state) {\n\t  var contact;\n\t\n\t  this.uac_pending_reply = false;\n\t  this.uas_pending_reply = false;\n\t\n\t  if(!message.hasHeader('contact')) {\n\t    return {\n\t      error: 'unable to create a Dialog without Contact header field'\n\t    };\n\t  }\n\t\n\t  if(message instanceof SIP.IncomingResponse) {\n\t    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n\t  } else {\n\t    // Create confirmed dialog if state is not defined\n\t    state = state || C.STATUS_CONFIRMED;\n\t  }\n\t\n\t  contact = message.parseHeader('contact');\n\t\n\t  // RFC 3261 12.1.1\n\t  if(type === 'UAS') {\n\t    this.id = {\n\t      call_id: message.call_id,\n\t      local_tag: message.to_tag,\n\t      remote_tag: message.from_tag,\n\t      toString: function() {\n\t        return this.call_id + this.local_tag + this.remote_tag;\n\t      }\n\t    };\n\t    this.state = state;\n\t    this.remote_seqnum = message.cseq;\n\t    this.local_uri = message.parseHeader('to').uri;\n\t    this.remote_uri = message.parseHeader('from').uri;\n\t    this.remote_target = contact.uri;\n\t    this.route_set = message.getHeaders('record-route');\n\t    this.invite_seqnum = message.cseq;\n\t    this.local_seqnum = message.cseq;\n\t  }\n\t  // RFC 3261 12.1.2\n\t  else if(type === 'UAC') {\n\t    this.id = {\n\t      call_id: message.call_id,\n\t      local_tag: message.from_tag,\n\t      remote_tag: message.to_tag,\n\t      toString: function() {\n\t        return this.call_id + this.local_tag + this.remote_tag;\n\t      }\n\t    };\n\t    this.state = state;\n\t    this.invite_seqnum = message.cseq;\n\t    this.local_seqnum = message.cseq;\n\t    this.local_uri = message.parseHeader('from').uri;\n\t    this.pracked = [];\n\t    this.remote_uri = message.parseHeader('to').uri;\n\t    this.remote_target = contact.uri;\n\t    this.route_set = message.getHeaders('record-route').reverse();\n\t\n\t    //RENDERBODY\n\t    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {\n\t      this.mediaHandler = owner.mediaHandlerFactory(owner);\n\t    }\n\t  }\n\t\n\t  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());\n\t  this.owner = owner;\n\t  owner.ua.dialogs[this.id.toString()] = this;\n\t  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));\n\t  owner.emit('dialog', this);\n\t};\n\t\n\tDialog.prototype = {\n\t  /**\n\t   * @param {SIP.IncomingMessage} message\n\t   * @param {Enum} UAC/UAS\n\t   */\n\t  update: function(message, type) {\n\t    this.state = C.STATUS_CONFIRMED;\n\t\n\t    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');\n\t\n\t    if(type === 'UAC') {\n\t      // RFC 3261 13.2.2.4\n\t      this.route_set = message.getHeaders('record-route').reverse();\n\t    }\n\t  },\n\t\n\t  terminate: function() {\n\t    this.logger.log('dialog ' + this.id.toString() + ' deleted');\n\t    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {\n\t      this.mediaHandler.peerConnection.close();\n\t    }\n\t    delete this.owner.ua.dialogs[this.id.toString()];\n\t  },\n\t\n\t  /**\n\t  * @param {String} method request method\n\t  * @param {Object} extraHeaders extra headers\n\t  * @returns {SIP.OutgoingRequest}\n\t  */\n\t\n\t  // RFC 3261 12.2.1.1\n\t  createRequest: function(method, extraHeaders, body) {\n\t    var cseq, request;\n\t    extraHeaders = (extraHeaders || []).slice();\n\t\n\t    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }\n\t\n\t    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;\n\t\n\t    request = new SIP.OutgoingRequest(\n\t      method,\n\t      this.remote_target,\n\t      this.owner.ua, {\n\t        'cseq': cseq,\n\t        'call_id': this.id.call_id,\n\t        'from_uri': this.local_uri,\n\t        'from_tag': this.id.local_tag,\n\t        'to_uri': this.remote_uri,\n\t        'to_tag': this.id.remote_tag,\n\t        'route_set': this.route_set\n\t      }, extraHeaders, body);\n\t\n\t    request.dialog = this;\n\t\n\t    return request;\n\t  },\n\t\n\t  /**\n\t  * @param {SIP.IncomingRequest} request\n\t  * @returns {Boolean}\n\t  */\n\t\n\t  // RFC 3261 12.2.2\n\t  checkInDialogRequest: function(request) {\n\t    var self = this;\n\t\n\t    if(!this.remote_seqnum) {\n\t      this.remote_seqnum = request.cseq;\n\t    } else if(request.cseq < this.remote_seqnum) {\n\t        //Do not try to reply to an ACK request.\n\t        if (request.method !== SIP.C.ACK) {\n\t          request.reply(500);\n\t        }\n\t        if (request.cseq === this.invite_seqnum) {\n\t          return true;\n\t        }\n\t        return false;\n\t    } else if(request.cseq > this.remote_seqnum) {\n\t      this.remote_seqnum = request.cseq;\n\t    }\n\t\n\t    switch(request.method) {\n\t      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-\n\t      case SIP.C.INVITE:\n\t        if (this.uac_pending_reply === true) {\n\t          request.reply(491);\n\t        } else if (this.uas_pending_reply === true) {\n\t          var retryAfter = (Math.random() * 10 | 0) + 1;\n\t          request.reply(500, null, ['Retry-After:' + retryAfter]);\n\t          return false;\n\t        } else {\n\t          this.uas_pending_reply = true;\n\t          request.server_transaction.on('stateChanged', function stateChanged(){\n\t            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n\t                this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n\t                this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\t\n\t              this.removeListener('stateChanged', stateChanged);\n\t              self.uas_pending_reply = false;\n\t\n\t              if (self.uac_pending_reply === false) {\n\t                self.owner.onReadyToReinvite();\n\t              }\n\t            }\n\t          });\n\t        }\n\t\n\t        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted\n\t        if(request.hasHeader('contact')) {\n\t          request.server_transaction.on('stateChanged', function(){\n\t            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {\n\t              self.remote_target = request.parseHeader('contact').uri;\n\t            }\n\t          });\n\t        }\n\t        break;\n\t      case SIP.C.NOTIFY:\n\t        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted\n\t        if(request.hasHeader('contact')) {\n\t          request.server_transaction.on('stateChanged', function(){\n\t            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {\n\t              self.remote_target = request.parseHeader('contact').uri;\n\t            }\n\t          });\n\t        }\n\t        break;\n\t    }\n\t\n\t    return true;\n\t  },\n\t\n\t  sendRequest: function(applicant, method, options) {\n\t    options = options || {};\n\t\n\t    var\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t      body = options.body || null,\n\t      request = this.createRequest(method, extraHeaders, body),\n\t      request_sender = new RequestSender(this, applicant, request);\n\t\n\t    request_sender.send();\n\t\n\t    return request;\n\t  },\n\t\n\t  /**\n\t  * @param {SIP.IncomingRequest} request\n\t  */\n\t  receiveRequest: function(request) {\n\t    //Check in-dialog request\n\t    if(!this.checkInDialogRequest(request)) {\n\t      return;\n\t    }\n\t\n\t    this.owner.receiveRequest(request);\n\t  }\n\t};\n\t\n\tDialog.C = C;\n\tSIP.Dialog = Dialog;\n\t};\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview In-Dialog Request Sender\n\t */\n\t\n\t/**\n\t * @augments SIP.Dialog\n\t * @class Class creating an In-dialog request sender.\n\t * @param {SIP.Dialog} dialog\n\t * @param {Object} applicant\n\t * @param {SIP.OutgoingRequest} request\n\t */\n\t/**\n\t * @fileoverview in-Dialog Request Sender\n\t */\n\t\n\tmodule.exports = function (SIP) {\n\tvar RequestSender;\n\t\n\tRequestSender = function(dialog, applicant, request) {\n\t\n\t  this.dialog = dialog;\n\t  this.applicant = applicant;\n\t  this.request = request;\n\t\n\t  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n\t  this.reattempt = false;\n\t  this.reattemptTimer = null;\n\t};\n\t\n\tRequestSender.prototype = {\n\t  send: function() {\n\t    var self = this,\n\t      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);\n\t\n\t      request_sender.send();\n\t\n\t    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-\n\t    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n\t      this.dialog.uac_pending_reply = true;\n\t      request_sender.clientTransaction.on('stateChanged', function stateChanged(){\n\t        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n\t            this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n\t            this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\t\n\t          this.removeListener('stateChanged', stateChanged);\n\t          self.dialog.uac_pending_reply = false;\n\t\n\t          if (self.dialog.uas_pending_reply === false) {\n\t            self.dialog.owner.onReadyToReinvite();\n\t          }\n\t        }\n\t      });\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    this.applicant.onRequestTimeout();\n\t  },\n\t\n\t  onTransportError: function() {\n\t    this.applicant.onTransportError();\n\t  },\n\t\n\t  receiveResponse: function(response) {\n\t    var self = this;\n\t\n\t    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n\t    if (response.status_code === 408 || response.status_code === 481) {\n\t      this.applicant.onDialogError(response);\n\t    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {\n\t      if (this.reattempt) {\n\t        this.applicant.receiveResponse(response);\n\t      } else {\n\t        this.request.cseq.value = this.dialog.local_seqnum += 1;\n\t        this.reattemptTimer = SIP.Timers.setTimeout(\n\t          function() {\n\t            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {\n\t              self.reattempt = true;\n\t              self.request_sender.send();\n\t            }\n\t          },\n\t          this.getReattemptTimeout()\n\t        );\n\t      }\n\t    } else {\n\t      this.applicant.receiveResponse(response);\n\t    }\n\t  }\n\t};\n\t\n\treturn RequestSender;\n\t};\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview Request Sender\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a request sender.\n\t * @param {Object} applicant\n\t * @param {SIP.UA} ua\n\t */\n\tmodule.exports = function (SIP) {\n\tvar RequestSender;\n\t\n\tRequestSender = function(applicant, ua) {\n\t  this.logger = ua.getLogger('sip.requestsender');\n\t  this.ua = ua;\n\t  this.applicant = applicant;\n\t  this.method = applicant.request.method;\n\t  this.request = applicant.request;\n\t  this.credentials = null;\n\t  this.challenged = false;\n\t  this.staled = false;\n\t\n\t  // If ua is in closing process or even closed just allow sending Bye and ACK\n\t  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\t/**\n\t* Create the client transaction and send the message.\n\t*/\n\tRequestSender.prototype = {\n\t  send: function() {\n\t    switch(this.method) {\n\t      case \"INVITE\":\n\t        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n\t        break;\n\t      case \"ACK\":\n\t        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n\t        break;\n\t      default:\n\t        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n\t    }\n\t    this.clientTransaction.send();\n\t\n\t    return this.clientTransaction;\n\t  },\n\t\n\t  /**\n\t  * Callback fired when receiving a request timeout error from the client transaction.\n\t  * To be re-defined by the applicant.\n\t  * @event\n\t  */\n\t  onRequestTimeout: function() {\n\t    this.applicant.onRequestTimeout();\n\t  },\n\t\n\t  /**\n\t  * Callback fired when receiving a transport error from the client transaction.\n\t  * To be re-defined by the applicant.\n\t  * @event\n\t  */\n\t  onTransportError: function() {\n\t    this.applicant.onTransportError();\n\t  },\n\t\n\t  /**\n\t  * Called from client transaction when receiving a correct response to the request.\n\t  * Authenticate request if needed or pass the response back to the applicant.\n\t  * @param {SIP.IncomingResponse} response\n\t  */\n\t  receiveResponse: function(response) {\n\t    var cseq, challenge, authorization_header_name,\n\t      status_code = response.status_code;\n\t\n\t    /*\n\t    * Authentication\n\t    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n\t    */\n\t    if (status_code === 401 || status_code === 407) {\n\t\n\t      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n\t      if (response.status_code === 401) {\n\t        challenge = response.parseHeader('www-authenticate');\n\t        authorization_header_name = 'authorization';\n\t      } else {\n\t        challenge = response.parseHeader('proxy-authenticate');\n\t        authorization_header_name = 'proxy-authorization';\n\t      }\n\t\n\t      // Verify it seems a valid challenge.\n\t      if (! challenge) {\n\t        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n\t        this.applicant.receiveResponse(response);\n\t        return;\n\t      }\n\t\n\t      if (!this.challenged || (!this.staled && challenge.stale === true)) {\n\t        if (!this.credentials) {\n\t          this.credentials = this.ua.configuration.authenticationFactory(this.ua);\n\t        }\n\t\n\t        // Verify that the challenge is really valid.\n\t        if (!this.credentials.authenticate(this.request, challenge)) {\n\t          this.applicant.receiveResponse(response);\n\t          return;\n\t        }\n\t        this.challenged = true;\n\t\n\t        if (challenge.stale) {\n\t          this.staled = true;\n\t        }\n\t\n\t        if (response.method === SIP.C.REGISTER) {\n\t          cseq = this.applicant.cseq += 1;\n\t        } else if (this.request.dialog){\n\t          cseq = this.request.dialog.local_seqnum += 1;\n\t        } else {\n\t          cseq = this.request.cseq + 1;\n\t          this.request.cseq = cseq;\n\t        }\n\t        this.request.setHeader('cseq', cseq +' '+ this.method);\n\t\n\t        this.request.setHeader(authorization_header_name, this.credentials.toString());\n\t        this.send();\n\t      } else {\n\t        this.applicant.receiveResponse(response);\n\t      }\n\t    } else {\n\t      this.applicant.receiveResponse(response);\n\t    }\n\t  }\n\t};\n\t\n\tSIP.RequestSender = RequestSender;\n\t};\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP) {\n\t\n\tvar RegisterContext;\n\t\n\tRegisterContext = function (ua) {\n\t  var params = {},\n\t      regId = 1;\n\t\n\t  this.registrar = ua.configuration.registrarServer;\n\t  this.expires = ua.configuration.registerExpires;\n\t\n\t\n\t  // Contact header\n\t  this.contact = ua.contact.toString();\n\t\n\t  if(regId) {\n\t    this.contact += ';reg-id='+ regId;\n\t    this.contact += ';+sip.instance=\"<urn:uuid:'+ ua.configuration.instanceId+'>\"';\n\t  }\n\t\n\t  // Call-ID and CSeq values RFC3261 10.2\n\t  this.call_id = SIP.Utils.createRandomToken(22);\n\t  this.cseq = 80;\n\t\n\t  this.to_uri = ua.configuration.uri;\n\t\n\t  params.to_uri = this.to_uri;\n\t  params.to_displayName = ua.configuration.displayName;\n\t  params.call_id = this.call_id;\n\t  params.cseq = this.cseq;\n\t\n\t  // Extends ClientContext\n\t  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);\n\t\n\t  this.registrationTimer = null;\n\t  this.registrationExpiredTimer = null;\n\t\n\t  // Set status\n\t  this.registered = false;\n\t\n\t  this.logger = ua.getLogger('sip.registercontext');\n\t};\n\t\n\tRegisterContext.prototype = {\n\t  register: function (options) {\n\t    var self = this, extraHeaders;\n\t\n\t    // Handle Options\n\t    this.options = options || {};\n\t    extraHeaders = (this.options.extraHeaders || []).slice();\n\t    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n\t    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t    // Save original extraHeaders to be used in .close\n\t    this.closeHeaders = this.options.closeWithHeaders ?\n\t      (this.options.extraHeaders || []).slice() : [];\n\t\n\t    this.receiveResponse = function(response) {\n\t      var contact, expires,\n\t        contacts = response.getHeaders('contact').length,\n\t        cause;\n\t\n\t      // Discard responses to older REGISTER/un-REGISTER requests.\n\t      if(response.cseq !== this.cseq) {\n\t        return;\n\t      }\n\t\n\t      // Clear registration timer\n\t      if (this.registrationTimer !== null) {\n\t        SIP.Timers.clearTimeout(this.registrationTimer);\n\t        this.registrationTimer = null;\n\t      }\n\t\n\t      switch(true) {\n\t        case /^1[0-9]{2}$/.test(response.status_code):\n\t          this.emit('progress', response);\n\t          break;\n\t        case /^2[0-9]{2}$/.test(response.status_code):\n\t          this.emit('accepted', response);\n\t\n\t          if(response.hasHeader('expires')) {\n\t            expires = response.getHeader('expires');\n\t          }\n\t\n\t          if (this.registrationExpiredTimer !== null) {\n\t            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n\t            this.registrationExpiredTimer = null;\n\t          }\n\t\n\t          // Search the Contact pointing to us and update the expires value accordingly.\n\t          if (!contacts) {\n\t            this.logger.warn('no Contact header in response to REGISTER, response ignored');\n\t            break;\n\t          }\n\t\n\t          while(contacts--) {\n\t            contact = response.parseHeader('contact', contacts);\n\t            if(contact.uri.user === this.ua.contact.uri.user) {\n\t              expires = contact.getParam('expires');\n\t              break;\n\t            } else {\n\t              contact = null;\n\t            }\n\t          }\n\t\n\t          if (!contact) {\n\t            this.logger.warn('no Contact header pointing to us, response ignored');\n\t            break;\n\t          }\n\t\n\t          if(!expires) {\n\t            expires = this.expires;\n\t          }\n\t\n\t          // Re-Register before the expiration interval has elapsed.\n\t          // For that, decrease the expires value. ie: 3 seconds\n\t          this.registrationTimer = SIP.Timers.setTimeout(function() {\n\t            self.registrationTimer = null;\n\t            self.register(self.options);\n\t          }, (expires * 1000) - 3000);\n\t          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n\t            self.logger.warn('registration expired');\n\t            if (self.registered) {\n\t              self.unregistered(null, SIP.C.causes.EXPIRES);\n\t            }\n\t          }, expires * 1000);\n\t\n\t          //Save gruu values\n\t          if (contact.hasParam('temp-gruu')) {\n\t            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g,''));\n\t          }\n\t          if (contact.hasParam('pub-gruu')) {\n\t            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g,''));\n\t          }\n\t\n\t          this.registered = true;\n\t          this.emit('registered', response || null);\n\t          break;\n\t        // Interval too brief RFC3261 10.2.8\n\t        case /^423$/.test(response.status_code):\n\t          if(response.hasHeader('min-expires')) {\n\t            // Increase our registration interval to the suggested minimum\n\t            this.expires = response.getHeader('min-expires');\n\t            // Attempt the registration again immediately\n\t            this.register(this.options);\n\t          } else { //This response MUST contain a Min-Expires header field\n\t            this.logger.warn('423 response received for REGISTER without Min-Expires');\n\t            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n\t          }\n\t          break;\n\t        default:\n\t          cause = SIP.Utils.sipErrorCause(response.status_code);\n\t          this.registrationFailure(response, cause);\n\t      }\n\t    };\n\t\n\t    this.onRequestTimeout = function() {\n\t      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    };\n\t\n\t    this.onTransportError = function() {\n\t      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n\t    };\n\t\n\t    this.cseq++;\n\t    this.request.cseq = this.cseq;\n\t    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n\t    this.request.extraHeaders = extraHeaders;\n\t    this.send();\n\t  },\n\t\n\t  registrationFailure: function (response, cause) {\n\t    this.emit('failed', response || null, cause || null);\n\t  },\n\t\n\t  onTransportClosed: function() {\n\t    this.registered_before = this.registered;\n\t    if (this.registrationTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.registrationTimer);\n\t      this.registrationTimer = null;\n\t    }\n\t\n\t    if (this.registrationExpiredTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n\t      this.registrationExpiredTimer = null;\n\t    }\n\t\n\t    if(this.registered) {\n\t      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onTransportConnected: function() {\n\t    this.register(this.options);\n\t  },\n\t\n\t  close: function() {\n\t    var options = {\n\t      all: false,\n\t      extraHeaders: this.closeHeaders\n\t    };\n\t\n\t    this.registered_before = this.registered;\n\t    this.unregister(options);\n\t  },\n\t\n\t  unregister: function(options) {\n\t    var extraHeaders;\n\t\n\t    options = options || {};\n\t\n\t    if(!this.registered && !options.all) {\n\t      this.logger.warn('already unregistered');\n\t      return;\n\t    }\n\t\n\t    extraHeaders = (options.extraHeaders || []).slice();\n\t\n\t    this.registered = false;\n\t\n\t    // Clear the registration timer.\n\t    if (this.registrationTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.registrationTimer);\n\t      this.registrationTimer = null;\n\t    }\n\t\n\t    if(options.all) {\n\t      extraHeaders.push('Contact: *');\n\t      extraHeaders.push('Expires: 0');\n\t    } else {\n\t      extraHeaders.push('Contact: '+ this.contact + ';expires=0');\n\t    }\n\t\n\t\n\t    this.receiveResponse = function(response) {\n\t      var cause;\n\t\n\t      switch(true) {\n\t        case /^1[0-9]{2}$/.test(response.status_code):\n\t          this.emit('progress', response);\n\t          break;\n\t        case /^2[0-9]{2}$/.test(response.status_code):\n\t          this.emit('accepted', response);\n\t          if (this.registrationExpiredTimer !== null) {\n\t            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n\t            this.registrationExpiredTimer = null;\n\t          }\n\t          this.unregistered(response);\n\t          break;\n\t        default:\n\t          cause = SIP.Utils.sipErrorCause(response.status_code);\n\t          this.unregistered(response,cause);\n\t      }\n\t    };\n\t\n\t    this.onRequestTimeout = function() {\n\t      // Not actually unregistered...\n\t      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    };\n\t\n\t    this.onTransportError = function() {\n\t      // Not actually unregistered...\n\t      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n\t    };\n\t\n\t    this.cseq++;\n\t    this.request.cseq = this.cseq;\n\t    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n\t    this.request.extraHeaders = extraHeaders;\n\t\n\t    this.send();\n\t  },\n\t\n\t  unregistered: function(response, cause) {\n\t    this.registered = false;\n\t    this.emit('unregistered', response || null, cause || null);\n\t  }\n\t\n\t};\n\t\n\t\n\tSIP.RegisterContext = RegisterContext;\n\t};\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview MediaHandler\n\t */\n\t\n\t/* MediaHandler\n\t * @class PeerConnection helper Class.\n\t * @param {SIP.Session} session\n\t * @param {Object} [options]\n\t */\n\tmodule.exports = function (EventEmitter) {\n\tvar MediaHandler = function(session, options) {\n\t  // keep jshint happy\n\t  session = session;\n\t  options = options;\n\t};\n\t\n\tMediaHandler.prototype = Object.create(EventEmitter.prototype, {\n\t  isReady: {value: function isReady () {}},\n\t\n\t  close: {value: function close () {}},\n\t\n\t  /**\n\t   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.\n\t   */\n\t  getDescription: {value: function getDescription (mediaHint) {\n\t    // keep jshint happy\n\t    mediaHint = mediaHint;\n\t  }},\n\t\n\t  /**\n\t  * Message reception.\n\t  * @param {String} type\n\t  * @param {String} description\n\t  */\n\t  setDescription: {value: function setDescription (description) {\n\t    // keep jshint happy\n\t    description = description;\n\t  }}\n\t});\n\t\n\treturn MediaHandler;\n\t};\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP) {\n\tvar ClientContext;\n\t\n\tClientContext = function (ua, method, target, options) {\n\t  var originalTarget = target;\n\t\n\t  // Validate arguments\n\t  if (target === undefined) {\n\t    throw new TypeError('Not enough arguments');\n\t  }\n\t\n\t  this.ua = ua;\n\t  this.logger = ua.getLogger('sip.clientcontext');\n\t  this.method = method;\n\t  target = ua.normalizeTarget(target);\n\t  if (!target) {\n\t    throw new TypeError('Invalid target: ' + originalTarget);\n\t  }\n\t\n\t  /* Options\n\t   * - extraHeaders\n\t   * - params\n\t   * - contentType\n\t   * - body\n\t   */\n\t  options = Object.create(options || Object.prototype);\n\t  options.extraHeaders = (options.extraHeaders || []).slice();\n\t\n\t  if (options.contentType) {\n\t    this.contentType = options.contentType;\n\t    options.extraHeaders.push('Content-Type: ' + this.contentType);\n\t  }\n\t\n\t  // Build the request\n\t  this.request = new SIP.OutgoingRequest(this.method,\n\t                                         target,\n\t                                         this.ua,\n\t                                         options.params,\n\t                                         options.extraHeaders);\n\t  if (options.body) {\n\t    this.body = options.body;\n\t    this.request.body = this.body;\n\t  }\n\t\n\t  /* Set other properties from the request */\n\t  this.localIdentity = this.request.from;\n\t  this.remoteIdentity = this.request.to;\n\t\n\t  this.data = {};\n\t};\n\tClientContext.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tClientContext.prototype.send = function () {\n\t  (new SIP.RequestSender(this, this.ua)).send();\n\t  return this;\n\t};\n\t\n\tClientContext.prototype.cancel = function (options) {\n\t  options = options || {};\n\t\n\t  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n\t  this.request.cancel(cancel_reason);\n\t\n\t  this.emit('cancel');\n\t};\n\t\n\tClientContext.prototype.receiveResponse = function (response) {\n\t  var cause = SIP.Utils.getReasonPhrase(response.status_code);\n\t\n\t  switch(true) {\n\t    case /^1[0-9]{2}$/.test(response.status_code):\n\t      this.emit('progress', response, cause);\n\t      break;\n\t\n\t    case /^2[0-9]{2}$/.test(response.status_code):\n\t      if(this.ua.applicants[this]) {\n\t        delete this.ua.applicants[this];\n\t      }\n\t      this.emit('accepted', response, cause);\n\t      break;\n\t\n\t    default:\n\t      if(this.ua.applicants[this]) {\n\t        delete this.ua.applicants[this];\n\t      }\n\t      this.emit('rejected', response, cause);\n\t      this.emit('failed', response, cause);\n\t      break;\n\t  }\n\t\n\t};\n\t\n\tClientContext.prototype.onRequestTimeout = function () {\n\t  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n\t};\n\t\n\tClientContext.prototype.onTransportError = function () {\n\t  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n\t};\n\t\n\tSIP.ClientContext = ClientContext;\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP) {\n\tvar ServerContext;\n\t\n\tServerContext = function (ua, request) {\n\t  this.ua = ua;\n\t  this.logger = ua.getLogger('sip.servercontext');\n\t  this.request = request;\n\t  if (request.method === SIP.C.INVITE) {\n\t    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);\n\t  } else {\n\t    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);\n\t  }\n\t\n\t  if (request.body) {\n\t    this.body = request.body;\n\t  }\n\t  if (request.hasHeader('Content-Type')) {\n\t    this.contentType = request.getHeader('Content-Type');\n\t  }\n\t  this.method = request.method;\n\t\n\t  this.data = {};\n\t\n\t  this.localIdentity = request.to;\n\t  this.remoteIdentity = request.from;\n\t};\n\t\n\tServerContext.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tServerContext.prototype.progress = function (options) {\n\t  options = Object.create(options || Object.prototype);\n\t  options.statusCode || (options.statusCode = 180);\n\t  options.minCode = 100;\n\t  options.maxCode = 199;\n\t  options.events = ['progress'];\n\t  return this.reply(options);\n\t};\n\t\n\tServerContext.prototype.accept = function (options) {\n\t  options = Object.create(options || Object.prototype);\n\t  options.statusCode || (options.statusCode = 200);\n\t  options.minCode = 200;\n\t  options.maxCode = 299;\n\t  options.events = ['accepted'];\n\t  return this.reply(options);\n\t};\n\t\n\tServerContext.prototype.reject = function (options) {\n\t  options = Object.create(options || Object.prototype);\n\t  options.statusCode || (options.statusCode = 480);\n\t  options.minCode = 300;\n\t  options.maxCode = 699;\n\t  options.events = ['rejected', 'failed'];\n\t  return this.reply(options);\n\t};\n\t\n\tServerContext.prototype.reply = function (options) {\n\t  options = options || {}; // This is okay, so long as we treat options as read-only in this method\n\t  var\n\t    statusCode = options.statusCode || 100,\n\t    minCode = options.minCode || 100,\n\t    maxCode = options.maxCode || 699,\n\t    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),\n\t    extraHeaders = options.extraHeaders || [],\n\t    body = options.body,\n\t    events = options.events || [],\n\t    response;\n\t\n\t  if (statusCode < minCode || statusCode > maxCode) {\n\t    throw new TypeError('Invalid statusCode: ' + statusCode);\n\t  }\n\t  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\t  events.forEach(function (event) {\n\t    this.emit(event, response, reasonPhrase);\n\t  }, this);\n\t\n\t  return this;\n\t};\n\t\n\tServerContext.prototype.onRequestTimeout = function () {\n\t  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n\t};\n\t\n\tServerContext.prototype.onTransportError = function () {\n\t  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n\t};\n\t\n\tSIP.ServerContext = ServerContext;\n\t};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP, environment) {\n\t\n\tvar DTMF = __webpack_require__(38)(SIP);\n\t\n\tvar Session, InviteServerContext, InviteClientContext,\n\t C = {\n\t    //Session states\n\t    STATUS_NULL:                        0,\n\t    STATUS_INVITE_SENT:                 1,\n\t    STATUS_1XX_RECEIVED:                2,\n\t    STATUS_INVITE_RECEIVED:             3,\n\t    STATUS_WAITING_FOR_ANSWER:          4,\n\t    STATUS_ANSWERED:                    5,\n\t    STATUS_WAITING_FOR_PRACK:           6,\n\t    STATUS_WAITING_FOR_ACK:             7,\n\t    STATUS_CANCELED:                    8,\n\t    STATUS_TERMINATED:                  9,\n\t    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n\t    STATUS_EARLY_MEDIA:                11,\n\t    STATUS_CONFIRMED:                  12\n\t  };\n\t\n\t/*\n\t * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]\n\t *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)\n\t */\n\tSession = function (mediaHandlerFactory) {\n\t  this.status = C.STATUS_NULL;\n\t  this.dialog = null;\n\t  this.earlyDialogs = {};\n\t  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;\n\t  // this.mediaHandler gets set by ICC/ISC constructors\n\t  this.hasOffer = false;\n\t  this.hasAnswer = false;\n\t\n\t  // Session Timers\n\t  this.timers = {\n\t    ackTimer: null,\n\t    expiresTimer: null,\n\t    invite2xxTimer: null,\n\t    userNoAnswerTimer: null,\n\t    rel1xxTimer: null,\n\t    prackTimer: null\n\t  };\n\t\n\t  // Session info\n\t  this.startTime = null;\n\t  this.endTime = null;\n\t  this.tones = null;\n\t\n\t  // Mute/Hold state\n\t  this.local_hold = false;\n\t  this.remote_hold = false;\n\t\n\t  this.pending_actions = {\n\t    actions: [],\n\t\n\t    length: function() {\n\t      return this.actions.length;\n\t    },\n\t\n\t    isPending: function(name){\n\t      var\n\t      idx = 0,\n\t      length = this.actions.length;\n\t\n\t      for (idx; idx<length; idx++) {\n\t        if (this.actions[idx].name === name) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    },\n\t\n\t    shift: function() {\n\t      return this.actions.shift();\n\t    },\n\t\n\t    push: function(name) {\n\t      this.actions.push({\n\t        name: name\n\t      });\n\t    },\n\t\n\t    pop: function(name) {\n\t      var\n\t      idx = 0,\n\t      length = this.actions.length;\n\t\n\t      for (idx; idx<length; idx++) {\n\t        if (this.actions[idx].name === name) {\n\t          this.actions.splice(idx,1);\n\t          length --;\n\t          idx--;\n\t        }\n\t      }\n\t    }\n\t   };\n\t\n\t  this.early_sdp = null;\n\t  this.rel100 = SIP.C.supported.UNSUPPORTED;\n\t};\n\t\n\tSession.prototype = {\n\t  dtmf: function(tones, options) {\n\t    var tone, dtmfs = [],\n\t        self = this;\n\t\n\t    options = options || {};\n\t\n\t    if (tones === undefined) {\n\t      throw new TypeError('Not enough arguments');\n\t    }\n\t\n\t    // Check Session Status\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    // Check tones\n\t    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n\t      throw new TypeError('Invalid tones: '+ tones);\n\t    }\n\t\n\t    tones = tones.toString().split('');\n\t\n\t    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }\n\t\n\t    if (this.tones) {\n\t      // Tones are already queued, just add to the queue\n\t      this.tones =  this.tones.concat(dtmfs);\n\t      return this;\n\t    }\n\t\n\t    var sendDTMF = function () {\n\t      var dtmf, timeout;\n\t\n\t      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n\t        // Stop sending DTMF\n\t        self.tones = null;\n\t        return this;\n\t      }\n\t\n\t      dtmf = self.tones.shift();\n\t\n\t      if (tone === ',') {\n\t        timeout = 2000;\n\t      } else {\n\t        dtmf.on('failed', function(){self.tones = null;});\n\t        dtmf.send(options);\n\t        timeout = dtmf.duration + dtmf.interToneGap;\n\t      }\n\t\n\t      // Set timeout for the next tone\n\t      SIP.Timers.setTimeout(sendDTMF, timeout);\n\t    };\n\t\n\t    this.tones = dtmfs;\n\t    sendDTMF();\n\t    return this;\n\t  },\n\t\n\t  bye: function(options) {\n\t    options = Object.create(options || Object.prototype);\n\t    var statusCode = options.statusCode;\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      this.logger.error('Error: Attempted to send BYE in a terminated session.');\n\t      return this;\n\t    }\n\t\n\t    this.logger.log('terminating Session');\n\t\n\t    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n\t      throw new TypeError('Invalid statusCode: '+ statusCode);\n\t    }\n\t\n\t    options.receiveResponse = function () {};\n\t\n\t    return this.\n\t      sendRequest(SIP.C.BYE, options).\n\t      terminated();\n\t  },\n\t\n\t  refer: function(target, options) {\n\t    options = options || {};\n\t    var extraHeaders = (options.extraHeaders || []).slice(),\n\t        withReplaces =\n\t          target instanceof SIP.InviteServerContext ||\n\t          target instanceof SIP.InviteClientContext,\n\t        originalTarget = target;\n\t\n\t    if (target === undefined) {\n\t      throw new TypeError('Not enough arguments');\n\t    }\n\t\n\t    // Check Session Status\n\t    if (this.status !== C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    // transform `target` so that it can be a Refer-To header value\n\t    if (withReplaces) {\n\t      //Attended Transfer\n\t      // B.transfer(C)\n\t      target = '\"' + target.remoteIdentity.friendlyName + '\" ' +\n\t        '<' + target.dialog.remote_target.toString() +\n\t        '?Replaces=' + target.dialog.id.call_id +\n\t        '%3Bto-tag%3D' + target.dialog.id.remote_tag +\n\t        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';\n\t    } else {\n\t      //Blind Transfer\n\t      // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n\t      // so try to make one ahead of time\n\t      try {\n\t        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n\t      } catch (e) {\n\t        this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n\t        this.logger.debug(\"...falling through to normalizeTarget()\");\n\t      }\n\t\n\t      // Check target validity\n\t      target = this.ua.normalizeTarget(target);\n\t      if (!target) {\n\t        throw new TypeError('Invalid target: ' + originalTarget);\n\t      }\n\t    }\n\t\n\t    extraHeaders.push('Contact: '+ this.contact);\n\t    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t    extraHeaders.push('Refer-To: '+ target);\n\t\n\t    // Send the request\n\t    this.sendRequest(SIP.C.REFER, {\n\t      extraHeaders: extraHeaders,\n\t      body: options.body,\n\t      receiveResponse: function (response) {\n\t        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {\n\t          return;\n\t        }\n\t        // hang up only if we transferred to a SIP address\n\t        if (withReplaces || (target.scheme && target.scheme.match(\"^sips?$\"))) {\n\t          this.terminate();\n\t        }\n\t      }.bind(this)\n\t    });\n\t    return this;\n\t  },\n\t\n\t  followRefer: function followRefer (callback) {\n\t    return function referListener (callback, request) {\n\t      // open non-SIP URIs if possible and keep session open\n\t      var referTo = request.parseHeader('refer-to');\n\t      var target = referTo.uri;\n\t      if (!target.scheme.match(\"^sips?$\")) {\n\t        var targetString = target.toString();\n\t        if (typeof environment.open === \"function\") {\n\t          environment.open(targetString);\n\t        } else {\n\t          this.logger.warn(\"referred to non-SIP URI but `open` isn't in the environment: \" + targetString);\n\t        }\n\t        return;\n\t      }\n\t\n\t      var extraHeaders = [];\n\t\n\t      /* Copy the Replaces query into a Replaces header */\n\t      /* TODO - make sure we don't copy a poorly formatted header? */\n\t      var replaces = target.getHeader('Replaces');\n\t      if (replaces !== undefined) {\n\t        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));\n\t      }\n\t\n\t      // don't embed headers into Request-URI of INVITE\n\t      target.clearHeaders();\n\t\n\t      /*\n\t        Harmless race condition.  Both sides of REFER\n\t        may send a BYE, but in the end the dialogs are destroyed.\n\t      */\n\t      var getReferMedia = this.mediaHandler.getReferMedia;\n\t      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;\n\t\n\t      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);\n\t\n\t      var referSession = this.ua.invite(target, {\n\t        media: mediaHint,\n\t        params: {\n\t          to_displayName: referTo.friendlyName\n\t        },\n\t        extraHeaders: extraHeaders\n\t      });\n\t\n\t      callback.call(this, request, referSession);\n\t\n\t      this.terminate();\n\t    }.bind(this, callback);\n\t  },\n\t\n\t  sendRequest: function(method,options) {\n\t    options = options || {};\n\t    var self = this;\n\t\n\t    var request = new SIP.OutgoingRequest(\n\t      method,\n\t      this.dialog.remote_target,\n\t      this.ua,\n\t      {\n\t        cseq: options.cseq || (this.dialog.local_seqnum += 1),\n\t        call_id: this.dialog.id.call_id,\n\t        from_uri: this.dialog.local_uri,\n\t        from_tag: this.dialog.id.local_tag,\n\t        to_uri: this.dialog.remote_uri,\n\t        to_tag: this.dialog.id.remote_tag,\n\t        route_set: this.dialog.route_set,\n\t        statusCode: options.statusCode,\n\t        reasonPhrase: options.reasonPhrase\n\t      },\n\t      options.extraHeaders || [],\n\t      options.body\n\t    );\n\t\n\t    new SIP.RequestSender({\n\t      request: request,\n\t      onRequestTimeout: function() {\n\t        self.onRequestTimeout();\n\t      },\n\t      onTransportError: function() {\n\t        self.onTransportError();\n\t      },\n\t      receiveResponse: options.receiveResponse || function(response) {\n\t        self.receiveNonInviteResponse(response);\n\t      }\n\t    }, this.ua).send();\n\t\n\t    // Emit the request event\n\t    this.emit(method.toLowerCase(), request);\n\t\n\t    return this;\n\t  },\n\t\n\t  close: function() {\n\t    var idx;\n\t\n\t    if(this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    this.logger.log('closing INVITE session ' + this.id);\n\t\n\t    // 1st Step. Terminate media.\n\t    if (this.mediaHandler){\n\t      this.mediaHandler.close();\n\t    }\n\t\n\t    // 2nd Step. Terminate signaling.\n\t\n\t    // Clear session timers\n\t    for(idx in this.timers) {\n\t      SIP.Timers.clearTimeout(this.timers[idx]);\n\t    }\n\t\n\t    // Terminate dialogs\n\t\n\t    // Terminate confirmed dialog\n\t    if(this.dialog) {\n\t      this.dialog.terminate();\n\t      delete this.dialog;\n\t    }\n\t\n\t    // Terminate early dialogs\n\t    for(idx in this.earlyDialogs) {\n\t      this.earlyDialogs[idx].terminate();\n\t      delete this.earlyDialogs[idx];\n\t    }\n\t\n\t    this.status = C.STATUS_TERMINATED;\n\t\n\t    delete this.ua.sessions[this.id];\n\t    return this;\n\t  },\n\t\n\t  createDialog: function(message, type, early) {\n\t    var dialog, early_dialog,\n\t      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],\n\t      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],\n\t      id = message.call_id + local_tag + remote_tag;\n\t\n\t    early_dialog = this.earlyDialogs[id];\n\t\n\t    // Early Dialog\n\t    if (early) {\n\t      if (early_dialog) {\n\t        return true;\n\t      } else {\n\t        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);\n\t\n\t        // Dialog has been successfully created.\n\t        if(early_dialog.error) {\n\t          this.logger.error(early_dialog.error);\n\t          this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n\t          return false;\n\t        } else {\n\t          this.earlyDialogs[id] = early_dialog;\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t    // Confirmed Dialog\n\t    else {\n\t      // In case the dialog is in _early_ state, update it\n\t      if (early_dialog) {\n\t        early_dialog.update(message, type);\n\t        this.dialog = early_dialog;\n\t        delete this.earlyDialogs[id];\n\t        for (var dia in this.earlyDialogs) {\n\t          this.earlyDialogs[dia].terminate();\n\t          delete this.earlyDialogs[dia];\n\t        }\n\t        return true;\n\t      }\n\t\n\t      // Otherwise, create a _confirmed_ dialog\n\t      dialog = new SIP.Dialog(this, message, type);\n\t\n\t      if(dialog.error) {\n\t        this.logger.error(dialog.error);\n\t        this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n\t        return false;\n\t      } else {\n\t        this.to_tag = message.to_tag;\n\t        this.dialog = dialog;\n\t        return true;\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Check if Session is ready for a re-INVITE\n\t  *\n\t  * @returns {Boolean}\n\t  */\n\t  isReadyToReinvite: function() {\n\t    return this.mediaHandler.isReady() &&\n\t      !this.dialog.uac_pending_reply &&\n\t      !this.dialog.uas_pending_reply;\n\t  },\n\t\n\t  /**\n\t   * Mute\n\t   */\n\t  mute: function(options) {\n\t    var ret = this.mediaHandler.mute(options);\n\t    if (ret) {\n\t      this.onmute(ret);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Unmute\n\t   */\n\t  unmute: function(options) {\n\t    var ret = this.mediaHandler.unmute(options);\n\t    if (ret) {\n\t      this.onunmute(ret);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Hold\n\t   */\n\t  hold: function(options) {\n\t\n\t    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.mediaHandler.hold();\n\t\n\t    // Check if RTCSession is ready to send a reINVITE\n\t    if (!this.isReadyToReinvite()) {\n\t      /* If there is a pending 'unhold' action, cancel it and don't queue this one\n\t       * Else, if there isn't any 'hold' action, add this one to the queue\n\t       * Else, if there is already a 'hold' action, skip\n\t       */\n\t      if (this.pending_actions.isPending('unhold')) {\n\t        this.pending_actions.pop('unhold');\n\t      } else if (!this.pending_actions.isPending('hold')) {\n\t        this.pending_actions.push('hold');\n\t      }\n\t      return;\n\t    } else if (this.local_hold === true) {\n\t        return;\n\t    }\n\t\n\t    this.onhold('local');\n\t\n\t    options = options || {};\n\t    options.mangle = function(body){\n\t\n\t      // Don't receive media\n\t      // TODO - This will break for media streams with different directions.\n\t      if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {\n\t        body = body.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n\t      } else {\n\t        body = body.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n\t        body = body.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n\t      }\n\t\n\t      return body;\n\t    };\n\t\n\t    this.sendReinvite(options);\n\t  },\n\t\n\t  /**\n\t   * Unhold\n\t   */\n\t  unhold: function(options) {\n\t\n\t    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.mediaHandler.unhold();\n\t\n\t    if (!this.isReadyToReinvite()) {\n\t      /* If there is a pending 'hold' action, cancel it and don't queue this one\n\t       * Else, if there isn't any 'unhold' action, add this one to the queue\n\t       * Else, if there is already a 'unhold' action, skip\n\t       */\n\t      if (this.pending_actions.isPending('hold')) {\n\t        this.pending_actions.pop('hold');\n\t      } else if (!this.pending_actions.isPending('unhold')) {\n\t        this.pending_actions.push('unhold');\n\t      }\n\t      return;\n\t    } else if (this.local_hold === false) {\n\t      return;\n\t    }\n\t\n\t    this.onunhold('local');\n\t\n\t    this.sendReinvite(options);\n\t  },\n\t\n\t  /**\n\t   * isOnHold\n\t   */\n\t  isOnHold: function() {\n\t    return {\n\t      local: this.local_hold,\n\t      remote: this.remote_hold\n\t    };\n\t  },\n\t\n\t  /**\n\t   * In dialog INVITE Reception\n\t   * @private\n\t   */\n\t  receiveReinvite: function(request) {\n\t    var self = this;\n\t\n\t    if (!request.body) {\n\t      return;\n\t    }\n\t\n\t    if (request.getHeader('Content-Type') !== 'application/sdp') {\n\t      this.logger.warn('invalid Content-Type');\n\t      request.reply(415);\n\t      return;\n\t    }\n\t\n\t    this.mediaHandler.setDescription(request.body)\n\t    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n\t    .then(function(body) {\n\t      request.reply(200, null, ['Contact: ' + self.contact], body,\n\t        function() {\n\t          self.status = C.STATUS_WAITING_FOR_ACK;\n\t          self.setInvite2xxTimer(request, body);\n\t          self.setACKTimer();\n\t\n\t          // Are we holding?\n\t          var hold = (/a=(sendonly|inactive)/).test(request.body);\n\t\n\t          if (self.remote_hold && !hold) {\n\t            self.onunhold('remote');\n\t          } else if (!self.remote_hold && hold) {\n\t            self.onhold('remote');\n\t          }\n\t        });\n\t    })\n\t    .catch(function onFailure (e) {\n\t      var statusCode;\n\t      if (e instanceof SIP.Exceptions.GetDescriptionError) {\n\t        statusCode = 500;\n\t      } else {\n\t        self.logger.error(e);\n\t        statusCode = 488;\n\t      }\n\t      request.reply(statusCode);\n\t    });\n\t  },\n\t\n\t  sendReinvite: function(options) {\n\t    options = options || {};\n\t\n\t    var\n\t      self = this,\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t      eventHandlers = options.eventHandlers || {},\n\t      mangle = options.mangle || null,\n\t      succeeded;\n\t\n\t    if (eventHandlers.succeeded) {\n\t      succeeded = eventHandlers.succeeded;\n\t    }\n\t    this.reinviteSucceeded = function(){\n\t      SIP.Timers.clearTimeout(self.timers.ackTimer);\n\t      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n\t      self.status = C.STATUS_CONFIRMED;\n\t      succeeded && succeeded.apply(this, arguments);\n\t    };\n\t    if (eventHandlers.failed) {\n\t      this.reinviteFailed = eventHandlers.failed;\n\t    } else {\n\t      this.reinviteFailed = function(){};\n\t    }\n\t\n\t    extraHeaders.push('Contact: ' + this.contact);\n\t    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t    extraHeaders.push('Content-Type: application/sdp');\n\t\n\t    this.receiveResponse = this.receiveReinviteResponse;\n\t    //REVISIT\n\t    this.mediaHandler.getDescription(self.mediaHint)\n\t    .then(mangle)\n\t    .then(\n\t      function(body){\n\t        self.dialog.sendRequest(self, SIP.C.INVITE, {\n\t          extraHeaders: extraHeaders,\n\t          body: body\n\t        });\n\t      },\n\t      function() {\n\t        if (self.isReadyToReinvite()) {\n\t          self.onReadyToReinvite();\n\t        }\n\t        self.reinviteFailed();\n\t      }\n\t    );\n\t  },\n\t\n\t  receiveRequest: function (request) {\n\t    switch (request.method) {\n\t      case SIP.C.BYE:\n\t        request.reply(200);\n\t        if(this.status === C.STATUS_CONFIRMED) {\n\t          this.emit('bye', request);\n\t          this.terminated(request, SIP.C.causes.BYE);\n\t        }\n\t        break;\n\t      case SIP.C.INVITE:\n\t        if(this.status === C.STATUS_CONFIRMED) {\n\t          this.logger.log('re-INVITE received');\n\t          this.receiveReinvite(request);\n\t        }\n\t        break;\n\t      case SIP.C.INFO:\n\t        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {\n\t          var body, tone, duration,\n\t              contentType = request.getHeader('content-type'),\n\t              reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/,\n\t              reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\t\n\t          if (contentType) {\n\t            if (contentType.match(/^application\\/dtmf-relay/i)) {\n\t              if (request.body) {\n\t                body = request.body.split('\\r\\n', 2);\n\t                if (body.length === 2) {\n\t                  if (reg_tone.test(body[0])) {\n\t                    tone = body[0].replace(reg_tone,\"$2\");\n\t                  }\n\t                  if (reg_duration.test(body[1])) {\n\t                    duration = parseInt(body[1].replace(reg_duration,\"$2\"), 10);\n\t                  }\n\t                }\n\t              }\n\t\n\t              new DTMF(this, tone, {duration: duration}).init_incoming(request);\n\t            } else {\n\t              request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n\t            }\n\t          }\n\t        }\n\t        break;\n\t      case SIP.C.REFER:\n\t        if(this.status ===  C.STATUS_CONFIRMED) {\n\t          this.logger.log('REFER received');\n\t          var hasReferListener = this.listeners('refer').length,\n\t              notifyBody;\n\t\n\t          if (hasReferListener) {\n\t            request.reply(202, 'Accepted');\n\t            notifyBody = 'SIP/2.0 100 Trying';\n\t\n\t            this.sendRequest(SIP.C.NOTIFY, {\n\t              extraHeaders:[\n\t                'Event: refer',\n\t                'Subscription-State: terminated',\n\t                'Content-Type: message/sipfrag'\n\t              ],\n\t              body: notifyBody,\n\t              receiveResponse: function() {}\n\t            });\n\t\n\t            this.emit('refer', request);\n\t          } else {\n\t            // RFC 3515.2.4.2: 'the UA MAY decline the request.'\n\t            request.reply(603, 'Declined');\n\t          }\n\t        }\n\t        break;\n\t      case SIP.C.NOTIFY:\n\t        request.reply(200, 'OK');\n\t        this.emit('notify', request);\n\t        break;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Reception of Response for in-dialog INVITE\n\t   * @private\n\t   */\n\t  receiveReinviteResponse: function(response) {\n\t    var self = this,\n\t        contentType = response.getHeader('Content-Type');\n\t\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return;\n\t    }\n\t\n\t    switch(true) {\n\t      case /^1[0-9]{2}$/.test(response.status_code):\n\t        break;\n\t      case /^2[0-9]{2}$/.test(response.status_code):\n\t        this.status = C.STATUS_CONFIRMED;\n\t\n\t        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});\n\t\n\t        if(!response.body) {\n\t          this.reinviteFailed();\n\t          break;\n\t        } else if (contentType !== 'application/sdp') {\n\t          this.reinviteFailed();\n\t          break;\n\t        }\n\t\n\t        //REVISIT\n\t        this.mediaHandler.setDescription(response.body)\n\t        .then(\n\t          function onSuccess () {\n\t            self.reinviteSucceeded();\n\t          },\n\t          function onFailure () {\n\t            self.reinviteFailed();\n\t          }\n\t        );\n\t        break;\n\t      default:\n\t        this.reinviteFailed();\n\t    }\n\t  },\n\t\n\t  acceptAndTerminate: function(response, status_code, reason_phrase) {\n\t    var extraHeaders = [];\n\t\n\t    if (status_code) {\n\t      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));\n\t    }\n\t\n\t    // An error on dialog creation will fire 'failed' event\n\t    if (this.dialog || this.createDialog(response, 'UAC')) {\n\t      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n\t      this.sendRequest(SIP.C.BYE, {\n\t        extraHeaders: extraHeaders\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * RFC3261 13.3.1.4\n\t   * Response retransmissions cannot be accomplished by transaction layer\n\t   *  since it is destroyed when receiving the first 2xx answer\n\t   */\n\t  setInvite2xxTimer: function(request, body) {\n\t    var self = this,\n\t        timeout = SIP.Timers.T1;\n\t\n\t    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n\t      if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n\t        return;\n\t      }\n\t\n\t      self.logger.log('no ACK received, attempting to retransmit OK');\n\t\n\t      request.reply(200, null, ['Contact: ' + self.contact], body);\n\t\n\t      timeout = Math.min(timeout * 2, SIP.Timers.T2);\n\t\n\t      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n\t    }, timeout);\n\t  },\n\t\n\t  /**\n\t   * RFC3261 14.2\n\t   * If a UAS generates a 2xx response and never receives an ACK,\n\t   *  it SHOULD generate a BYE to terminate the dialog.\n\t   */\n\t  setACKTimer: function() {\n\t    var self = this;\n\t\n\t    this.timers.ackTimer = SIP.Timers.setTimeout(function() {\n\t      if(self.status === C.STATUS_WAITING_FOR_ACK) {\n\t        self.logger.log('no ACK received for an extended period of time, terminating the call');\n\t        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n\t        self.sendRequest(SIP.C.BYE);\n\t        self.terminated(null, SIP.C.causes.NO_ACK);\n\t      }\n\t    }, SIP.Timers.TIMER_H);\n\t  },\n\t\n\t  /*\n\t   * @private\n\t   */\n\t  onReadyToReinvite: function() {\n\t    var action = this.pending_actions.shift();\n\t\n\t    if (!action || !this[action.name]) {\n\t      return;\n\t    }\n\t\n\t    this[action.name]();\n\t  },\n\t\n\t  onTransportError: function() {\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    }\n\t  },\n\t\n\t  onDialogError: function(response) {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(response, SIP.C.causes.DIALOG_ERROR);\n\t      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   */\n\t  onhold: function(originator) {\n\t    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;\n\t    this.emit('hold', { originator: originator });\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   */\n\t  onunhold: function(originator) {\n\t    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;\n\t    this.emit('unhold', { originator: originator });\n\t  },\n\t\n\t  /*\n\t   * @private\n\t   */\n\t  onmute: function(options) {\n\t    this.emit('muted', {\n\t      audio: options.audio,\n\t      video: options.video\n\t    });\n\t  },\n\t\n\t  /*\n\t   * @private\n\t   */\n\t  onunmute: function(options) {\n\t    this.emit('unmuted', {\n\t      audio: options.audio,\n\t      video: options.video\n\t    });\n\t  },\n\t\n\t  failed: function(response, cause) {\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t    this.emit('failed', response || null, cause || null);\n\t    return this;\n\t  },\n\t\n\t  rejected: function(response, cause) {\n\t    this.emit('rejected',\n\t      response || null,\n\t      cause || null\n\t    );\n\t    return this;\n\t  },\n\t\n\t  canceled: function() {\n\t    this.emit('cancel');\n\t    return this;\n\t  },\n\t\n\t  accepted: function(response, cause) {\n\t    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);\n\t\n\t    this.startTime = new Date();\n\t\n\t    if (this.replacee) {\n\t      this.replacee.emit('replaced', this);\n\t      this.replacee.terminate();\n\t    }\n\t    this.emit('accepted', response, cause);\n\t    return this;\n\t  },\n\t\n\t  terminated: function(message, cause) {\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    this.endTime = new Date();\n\t\n\t    this.close();\n\t    this.emit('terminated',\n\t      message || null,\n\t      cause || null\n\t    );\n\t    return this;\n\t  },\n\t\n\t  connecting: function(request) {\n\t    this.emit('connecting', { request: request });\n\t    return this;\n\t  }\n\t};\n\t\n\tSession.desugar = function desugar(options) {\n\t  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {\n\t    options = {\n\t      media: {\n\t        constraints: {\n\t          audio: true,\n\t          video: options.tagName === 'VIDEO'\n\t        },\n\t        render: {\n\t          remote: options\n\t        }\n\t      }\n\t    };\n\t  }\n\t  return options || {};\n\t};\n\t\n\t\n\tSession.C = C;\n\tSIP.Session = Session;\n\t\n\t\n\tInviteServerContext = function(ua, request) {\n\t  var expires,\n\t    self = this,\n\t    contentType = request.getHeader('Content-Type'),\n\t    contentDisp = request.parseHeader('Content-Disposition');\n\t\n\t  // Check body and content type\n\t  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {\n\t    this.renderbody = request.body;\n\t    this.rendertype = contentType;\n\t  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {\n\t    request.reply(415);\n\t    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it\n\t    return;\n\t  }\n\t\n\t  //TODO: move this into media handler\n\t  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n\t  SIP.Hacks.AllBrowsers.maskDtls(request);\n\t\n\t  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n\t  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n\t\n\t  this.status = C.STATUS_INVITE_RECEIVED;\n\t  this.from_tag = request.from_tag;\n\t  this.id = request.call_id + this.from_tag;\n\t  this.request = request;\n\t  this.contact = this.ua.contact.toString();\n\t\n\t  this.receiveNonInviteResponse = function () {}; // intentional no-op\n\t\n\t  this.logger = ua.getLogger('sip.inviteservercontext', this.id);\n\t\n\t  //Save the session into the ua sessions collection.\n\t  this.ua.sessions[this.id] = this;\n\t\n\t  //Get the Expires header value if exists\n\t  if(request.hasHeader('expires')) {\n\t    expires = request.getHeader('expires') * 1000;\n\t  }\n\t\n\t  //Set 100rel if necessary\n\t  function set100rel(h,c) {\n\t    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n\t      self.rel100 = c;\n\t    }\n\t  }\n\t  set100rel('require', SIP.C.supported.REQUIRED);\n\t  set100rel('supported', SIP.C.supported.SUPPORTED);\n\t\n\t  /* Set the to_tag before\n\t   * replying a response code that will create a dialog.\n\t   */\n\t  request.to_tag = SIP.Utils.newTag();\n\t\n\t  // An error on dialog creation will fire 'failed' event\n\t  if(!this.createDialog(request, 'UAS', true)) {\n\t    request.reply(500, 'Missing Contact header field');\n\t    return;\n\t  }\n\t\n\t  //Initialize Media Session\n\t  this.mediaHandler = this.mediaHandlerFactory(this, {\n\t    RTCConstraints: {\"optional\": [{'DtlsSrtpKeyAgreement': 'true'}]}\n\t  });\n\t\n\t  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n\t    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n\t    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n\t  }\n\t\n\t  function fireNewSession() {\n\t    var options = {extraHeaders: ['Contact: ' + self.contact]};\n\t\n\t    if (self.rel100 !== SIP.C.supported.REQUIRED) {\n\t      self.progress(options);\n\t    }\n\t    self.status = C.STATUS_WAITING_FOR_ANSWER;\n\t\n\t    // Set userNoAnswerTimer\n\t    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {\n\t      request.reply(408);\n\t      self.failed(request, SIP.C.causes.NO_ANSWER);\n\t      self.terminated(request, SIP.C.causes.NO_ANSWER);\n\t    }, self.ua.configuration.noAnswerTimeout);\n\t\n\t    /* Set expiresTimer\n\t     * RFC3261 13.3.1\n\t     */\n\t    if (expires) {\n\t      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {\n\t        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {\n\t          request.reply(487);\n\t          self.failed(request, SIP.C.causes.EXPIRES);\n\t          self.terminated(request, SIP.C.causes.EXPIRES);\n\t        }\n\t      }, expires);\n\t    }\n\t\n\t    self.emit('invite',request);\n\t  }\n\t\n\t  if (!request.body || this.renderbody) {\n\t    SIP.Timers.setTimeout(fireNewSession, 0);\n\t  } else {\n\t    this.hasOffer = true;\n\t    this.mediaHandler.setDescription(request.body)\n\t    .then(\n\t      fireNewSession,\n\t      function onFailure (e) {\n\t        self.logger.warn('invalid SDP');\n\t        self.logger.warn(e);\n\t        request.reply(488);\n\t      }\n\t    );\n\t  }\n\t};\n\t\n\tInviteServerContext.prototype = {\n\t  reject: function(options) {\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.logger.log('rejecting RTCSession');\n\t\n\t    SIP.ServerContext.prototype.reject.call(this, options);\n\t    return this.terminated();\n\t  },\n\t\n\t  terminate: function(options) {\n\t    options = options || {};\n\t\n\t    var\n\t    extraHeaders = (options.extraHeaders || []).slice(),\n\t    body = options.body,\n\t    dialog,\n\t    self = this;\n\t\n\t    if (this.status === C.STATUS_WAITING_FOR_ACK &&\n\t       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n\t      dialog = this.dialog;\n\t\n\t      this.receiveRequest = function(request) {\n\t        if (request.method === SIP.C.ACK) {\n\t          this.request(SIP.C.BYE, {\n\t            extraHeaders: extraHeaders,\n\t            body: body\n\t          });\n\t          dialog.terminate();\n\t        }\n\t      };\n\t\n\t      this.request.server_transaction.on('stateChanged', function(){\n\t        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\t          this.request = new SIP.OutgoingRequest(\n\t            SIP.C.BYE,\n\t            this.dialog.remote_target,\n\t            this.ua,\n\t            {\n\t              'cseq': this.dialog.local_seqnum+=1,\n\t              'call_id': this.dialog.id.call_id,\n\t              'from_uri': this.dialog.local_uri,\n\t              'from_tag': this.dialog.id.local_tag,\n\t              'to_uri': this.dialog.remote_uri,\n\t              'to_tag': this.dialog.id.remote_tag,\n\t              'route_set': this.dialog.route_set\n\t            },\n\t            extraHeaders,\n\t            body\n\t          );\n\t\n\t          new SIP.RequestSender(\n\t            {\n\t              request: this.request,\n\t              onRequestTimeout: function() {\n\t                self.onRequestTimeout();\n\t              },\n\t              onTransportError: function() {\n\t                self.onTransportError();\n\t              },\n\t              receiveResponse: function() {\n\t                return;\n\t              }\n\t            },\n\t            this.ua\n\t          ).send();\n\t          dialog.terminate();\n\t        }\n\t      });\n\t\n\t      this.emit('bye', this.request);\n\t      this.terminated();\n\t\n\t      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n\t      this.dialog = dialog;\n\t\n\t      // Restore the dialog into 'ua' so the ACK can reach 'this' session\n\t      this.ua.dialogs[dialog.id.toString()] = dialog;\n\t\n\t    } else if (this.status === C.STATUS_CONFIRMED) {\n\t      this.bye(options);\n\t    } else {\n\t      this.reject(options);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /*\n\t   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t   */\n\t  progress: function (options) {\n\t    options = options || {};\n\t    var\n\t      statusCode = options.statusCode || 180,\n\t      reasonPhrase = options.reasonPhrase,\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t      iceServers,\n\t      stunServers = options.stunServers || null,\n\t      turnServers = options.turnServers || null,\n\t      body = options.body,\n\t      response;\n\t\n\t    if (statusCode < 100 || statusCode > 199) {\n\t      throw new TypeError('Invalid statusCode: ' + statusCode);\n\t    }\n\t\n\t    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    if (stunServers || turnServers) {\n\t      if (stunServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid stunServers: '+ stunServers);\n\t        } else {\n\t          this.stunServers = iceServers;\n\t        }\n\t      }\n\t\n\t      if (turnServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid turnServers: '+ turnServers);\n\t        } else {\n\t          this.turnServers = iceServers;\n\t        }\n\t      }\n\t\n\t      this.mediaHandler.updateIceServers({\n\t        stunServers: this.stunServers,\n\t        turnServers: this.turnServers\n\t      });\n\t    }\n\t\n\t    function do100rel() {\n\t      /* jshint validthis: true */\n\t      statusCode = options.statusCode || 183;\n\t\n\t      // Set status and add extra headers\n\t      this.status = C.STATUS_WAITING_FOR_PRACK;\n\t      extraHeaders.push('Contact: '+ this.contact);\n\t      extraHeaders.push('Require: 100rel');\n\t      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));\n\t\n\t      // Save media hint for later (referred sessions)\n\t      this.mediaHint = options.media;\n\t\n\t      // Get the session description to add to preaccept with\n\t      this.mediaHandler.getDescription(options.media)\n\t      .then(\n\t        function onSuccess (body) {\n\t          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n\t            return;\n\t          }\n\t\n\t          this.early_sdp = body;\n\t          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;\n\t\n\t          // Retransmit until we get a response or we time out (see prackTimer below)\n\t          var timeout = SIP.Timers.T1;\n\t          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n\t            this.request.reply(statusCode, null, extraHeaders, body);\n\t            timeout *= 2;\n\t            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n\t          }.bind(this), timeout);\n\t\n\t          // Timeout and reject INVITE if no response\n\t          this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n\t            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n\t              return;\n\t            }\n\t\n\t            this.logger.log('no PRACK received, rejecting the call');\n\t            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n\t            this.request.reply(504);\n\t            this.terminated(null, SIP.C.causes.NO_PRACK);\n\t          }.bind(this), SIP.Timers.T1 * 64);\n\t\n\t          // Send the initial response\n\t          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\t          this.emit('progress', response, reasonPhrase);\n\t        }.bind(this),\n\t\n\t        function onFailure () {\n\t          this.request.reply(480);\n\t          this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t        }.bind(this)\n\t      );\n\t    } // end do100rel\n\t\n\t    function normalReply() {\n\t      /* jshint validthis:true */\n\t      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\t      this.emit('progress', response, reasonPhrase);\n\t    }\n\t\n\t    if (options.statusCode !== 100 &&\n\t        (this.rel100 === SIP.C.supported.REQUIRED ||\n\t         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||\n\t         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {\n\t      do100rel.apply(this);\n\t    } else {\n\t      normalReply.apply(this);\n\t    }\n\t    return this;\n\t  },\n\t\n\t  /*\n\t   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t   */\n\t  accept: function(options) {\n\t    options = Object.create(Session.desugar(options));\n\t    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n\t    this.mediaHint = options.media;\n\t\n\t    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21\n\t    var\n\t      //idx, length, hasAudio, hasVideo,\n\t      self = this,\n\t      request = this.request,\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t    //mediaStream = options.mediaStream || null,\n\t      iceServers,\n\t      stunServers = options.stunServers || null,\n\t      turnServers = options.turnServers || null,\n\t      sdpCreationSucceeded = function(body) {\n\t        var\n\t          response,\n\t          // run for reply success callback\n\t          replySucceeded = function() {\n\t            self.status = C.STATUS_WAITING_FOR_ACK;\n\t\n\t            self.setInvite2xxTimer(request, body);\n\t            self.setACKTimer();\n\t          },\n\t\n\t          // run for reply failure callback\n\t          replyFailed = function() {\n\t            self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n\t          };\n\t\n\t        // Chrome might call onaddstream before accept() is called, which means\n\t        // mediaHandler.render() was called without a renderHint, so we need to\n\t        // re-render now that mediaHint.render has been set.\n\t        //\n\t        // Chrome seems to be in the right regarding this, see\n\t        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream\n\t        self.mediaHandler.render();\n\t\n\t        extraHeaders.push('Contact: ' + self.contact);\n\t        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t        if(!self.hasOffer) {\n\t          self.hasOffer = true;\n\t        } else {\n\t          self.hasAnswer = true;\n\t        }\n\t        response = request.reply(200, null, extraHeaders,\n\t                      body,\n\t                      replySucceeded,\n\t                      replyFailed\n\t                     );\n\t        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail\n\t          self.accepted(response, SIP.Utils.getReasonPhrase(200));\n\t        }\n\t      },\n\t\n\t      sdpCreationFailed = function() {\n\t        if (self.status === C.STATUS_TERMINATED) {\n\t          return;\n\t        }\n\t        // TODO - fail out on error\n\t        self.request.reply(480);\n\t        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n\t        self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t      };\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n\t      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n\t      return this;\n\t    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n\t      this.status = C.STATUS_ANSWERED;\n\t    } else if (this.status !== C.STATUS_EARLY_MEDIA) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    if ((stunServers || turnServers) &&\n\t        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {\n\t      if (stunServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid stunServers: '+ stunServers);\n\t        } else {\n\t          this.stunServers = iceServers;\n\t        }\n\t      }\n\t\n\t      if (turnServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid turnServers: '+ turnServers);\n\t        } else {\n\t          this.turnServers = iceServers;\n\t        }\n\t      }\n\t\n\t      this.mediaHandler.updateIceServers({\n\t        stunServers: this.stunServers,\n\t        turnServers: this.turnServers\n\t      });\n\t    }\n\t\n\t    // An error on dialog creation will fire 'failed' event\n\t    if(!this.createDialog(request, 'UAS')) {\n\t      request.reply(500, 'Missing Contact header field');\n\t      return this;\n\t    }\n\t\n\t    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);\n\t\n\t    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21\n\t    /*\n\t    length = this.getRemoteStreams().length;\n\t\n\t    for (idx = 0; idx < length; idx++) {\n\t      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {\n\t        hasVideo = true;\n\t      }\n\t      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {\n\t        hasAudio = true;\n\t      }\n\t    }\n\t\n\t    if (!hasAudio && this.mediaConstraints.audio === true) {\n\t      this.mediaConstraints.audio = false;\n\t      if (mediaStream) {\n\t        length = mediaStream.getAudioTracks().length;\n\t        for (idx = 0; idx < length; idx++) {\n\t          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (!hasVideo && this.mediaConstraints.video === true) {\n\t      this.mediaConstraints.video = false;\n\t      if (mediaStream) {\n\t        length = mediaStream.getVideoTracks().length;\n\t        for (idx = 0; idx < length; idx++) {\n\t          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);\n\t        }\n\t      }\n\t    }\n\t    */\n\t\n\t    if (this.status === C.STATUS_EARLY_MEDIA) {\n\t      sdpCreationSucceeded();\n\t    } else {\n\t      this.mediaHandler.getDescription(self.mediaHint)\n\t      .then(\n\t        sdpCreationSucceeded,\n\t        sdpCreationFailed\n\t      );\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  receiveRequest: function(request) {\n\t\n\t    // ISC RECEIVE REQUEST\n\t\n\t    function confirmSession() {\n\t      /* jshint validthis:true */\n\t      var contentType;\n\t\n\t      SIP.Timers.clearTimeout(this.timers.ackTimer);\n\t      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n\t      this.status = C.STATUS_CONFIRMED;\n\t      this.unmute();\n\t\n\t      // TODO - this logic assumes Content-Disposition defaults\n\t      contentType = request.getHeader('Content-Type');\n\t      if (contentType !== 'application/sdp') {\n\t        this.renderbody = request.body;\n\t        this.rendertype = contentType;\n\t      }\n\t    }\n\t\n\t    switch(request.method) {\n\t    case SIP.C.CANCEL:\n\t      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n\t       * was in progress and that the UAC MAY continue with the session established by\n\t       * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n\t       * established session. So the CANCEL is processed only if the session is not yet\n\t       * established.\n\t       */\n\t\n\t      /*\n\t       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n\t       *request opening the session.\n\t       */\n\t      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||\n\t         this.status === C.STATUS_WAITING_FOR_PRACK ||\n\t         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||\n\t         this.status === C.STATUS_EARLY_MEDIA ||\n\t         this.status === C.STATUS_ANSWERED) {\n\t\n\t        this.status = C.STATUS_CANCELED;\n\t        this.request.reply(487);\n\t        this.canceled(request);\n\t        this.rejected(request, SIP.C.causes.CANCELED);\n\t        this.failed(request, SIP.C.causes.CANCELED);\n\t        this.terminated(request, SIP.C.causes.CANCELED);\n\t      }\n\t      break;\n\t    case SIP.C.ACK:\n\t      if(this.status === C.STATUS_WAITING_FOR_ACK) {\n\t        if (!this.hasAnswer) {\n\t          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n\t            // ACK contains answer to an INVITE w/o SDP negotiation\n\t            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n\t            SIP.Hacks.AllBrowsers.maskDtls(request);\n\t\n\t            this.hasAnswer = true;\n\t            this.mediaHandler.setDescription(request.body)\n\t            .then(\n\t              confirmSession.bind(this),\n\t              function onFailure (e) {\n\t                this.logger.warn(e);\n\t                this.terminate({\n\t                  statusCode: '488',\n\t                  reasonPhrase: 'Bad Media Description'\n\t                });\n\t                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              }.bind(this)\n\t            );\n\t          } else if (this.early_sdp) {\n\t            confirmSession.apply(this);\n\t          } else {\n\t            //TODO: Pass to mediahandler\n\t            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t          }\n\t        } else {\n\t          confirmSession.apply(this);\n\t        }\n\t      }\n\t      break;\n\t    case SIP.C.PRACK:\n\t      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n\t        //localMedia = session.mediaHandler.localMedia;\n\t        if(!this.hasAnswer) {\n\t          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n\t            this.hasAnswer = true;\n\t            this.mediaHandler.setDescription(request.body)\n\t            .then(\n\t              function onSuccess () {\n\t                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n\t                SIP.Timers.clearTimeout(this.timers.prackTimer);\n\t                request.reply(200);\n\t                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n\t                  this.status = C.STATUS_EARLY_MEDIA;\n\t                  this.accept();\n\t                }\n\t                this.status = C.STATUS_EARLY_MEDIA;\n\t                //REVISIT\n\t                this.mute();\n\t              }.bind(this),\n\t              function onFailure (e) {\n\t                //TODO: Send to media handler\n\t                this.logger.warn(e);\n\t                this.terminate({\n\t                  statusCode: '488',\n\t                  reasonPhrase: 'Bad Media Description'\n\t                });\n\t                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              }.bind(this)\n\t            );\n\t          } else {\n\t            this.terminate({\n\t              statusCode: '488',\n\t              reasonPhrase: 'Bad Media Description'\n\t            });\n\t            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t          }\n\t        } else {\n\t          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n\t          SIP.Timers.clearTimeout(this.timers.prackTimer);\n\t          request.reply(200);\n\t\n\t          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n\t            this.status = C.STATUS_EARLY_MEDIA;\n\t            this.accept();\n\t          }\n\t          this.status = C.STATUS_EARLY_MEDIA;\n\t          //REVISIT\n\t          this.mute();\n\t        }\n\t      } else if(this.status === C.STATUS_EARLY_MEDIA) {\n\t        request.reply(200);\n\t      }\n\t      break;\n\t    default:\n\t      Session.prototype.receiveRequest.apply(this, [request]);\n\t      break;\n\t    }\n\t  },\n\t\n\t  onTransportError: function() {\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    }\n\t  }\n\t\n\t};\n\t\n\tSIP.InviteServerContext = InviteServerContext;\n\t\n\tInviteClientContext = function(ua, target, options) {\n\t  options = Object.create(Session.desugar(options));\n\t  options.params = Object.create(options.params || Object.prototype);\n\t\n\t  var iceServers,\n\t    extraHeaders = (options.extraHeaders || []).slice(),\n\t    stunServers = options.stunServers || null,\n\t    turnServers = options.turnServers || null,\n\t    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,\n\t    isMediaSupported = mediaHandlerFactory.isSupported;\n\t\n\t  // Check WebRTC support\n\t  if (isMediaSupported && !isMediaSupported()) {\n\t    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n\t  }\n\t\n\t  this.RTCConstraints = options.RTCConstraints || {};\n\t  this.inviteWithoutSdp = options.inviteWithoutSdp || false;\n\t\n\t  // Set anonymous property\n\t  this.anonymous = options.anonymous || false;\n\t\n\t  // Custom data to be sent either in INVITE or in ACK\n\t  this.renderbody = options.renderbody || null;\n\t  this.rendertype = options.rendertype || 'text/plain';\n\t\n\t  options.params.from_tag = this.from_tag;\n\t\n\t  /* Do not add ;ob in initial forming dialog requests if the registration over\n\t   *  the current connection got a GRUU URI.\n\t   */\n\t  this.contact = ua.contact.toString({\n\t    anonymous: this.anonymous,\n\t    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n\t  });\n\t\n\t  if (this.anonymous) {\n\t    options.params.from_displayName = 'Anonymous';\n\t    options.params.from_uri = 'sip:anonymous@anonymous.invalid';\n\t\n\t    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());\n\t    extraHeaders.push('Privacy: id');\n\t  }\n\t  extraHeaders.push('Contact: '+ this.contact);\n\t  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t  if (!this.inviteWithoutSdp) {\n\t    extraHeaders.push('Content-Type: application/sdp');\n\t  } else if (this.renderbody) {\n\t    extraHeaders.push('Content-Type: ' + this.rendertype);\n\t    extraHeaders.push('Content-Disposition: render;handling=optional');\n\t  }\n\t\n\t  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n\t    extraHeaders.push('Require: 100rel');\n\t  }\n\t  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {\n\t    extraHeaders.push('Require: replaces');\n\t  }\n\t\n\t  options.extraHeaders = extraHeaders;\n\t\n\t  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n\t  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);\n\t\n\t  // Check Session Status\n\t  if (this.status !== C.STATUS_NULL) {\n\t    throw new SIP.Exceptions.InvalidStateError(this.status);\n\t  }\n\t\n\t  // Session parameter initialization\n\t  this.from_tag = SIP.Utils.newTag();\n\t\n\t  // OutgoingSession specific parameters\n\t  this.isCanceled = false;\n\t  this.received_100 = false;\n\t\n\t  this.method = SIP.C.INVITE;\n\t\n\t  this.receiveNonInviteResponse = this.receiveResponse;\n\t  this.receiveResponse = this.receiveInviteResponse;\n\t\n\t  this.logger = ua.getLogger('sip.inviteclientcontext');\n\t\n\t  if (stunServers) {\n\t    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\t    if (!iceServers) {\n\t      throw new TypeError('Invalid stunServers: '+ stunServers);\n\t    } else {\n\t      this.stunServers = iceServers;\n\t    }\n\t  }\n\t\n\t  if (turnServers) {\n\t    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\t    if (!iceServers) {\n\t      throw new TypeError('Invalid turnServers: '+ turnServers);\n\t    } else {\n\t      this.turnServers = iceServers;\n\t    }\n\t  }\n\t\n\t  ua.applicants[this] = this;\n\t\n\t  this.id = this.request.call_id + this.from_tag;\n\t\n\t  //Initialize Media Session\n\t  this.mediaHandler = this.mediaHandlerFactory(this, {\n\t    RTCConstraints: this.RTCConstraints,\n\t    stunServers: this.stunServers,\n\t    turnServers: this.turnServers\n\t  });\n\t\n\t  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n\t    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n\t    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n\t  }\n\t\n\t  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n\t  this.mediaHint = options.media;\n\t};\n\t\n\tInviteClientContext.prototype = {\n\t  invite: function () {\n\t    var self = this;\n\t\n\t    //Save the session into the ua sessions collection.\n\t    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n\t    this.ua.sessions[this.id] = this;\n\t\n\t    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level\n\t    // and hand sip.js a stream as the mediaHint\n\t    if (this.inviteWithoutSdp) {\n\t      //just send an invite with no sdp...\n\t      this.request.body = self.renderbody;\n\t      this.status = C.STATUS_INVITE_SENT;\n\t      this.send();\n\t    } else {\n\t      this.mediaHandler.getDescription(self.mediaHint)\n\t      .then(\n\t        function onSuccess(offer) {\n\t          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n\t            return;\n\t          }\n\t          self.hasOffer = true;\n\t          self.request.body = offer;\n\t          self.status = C.STATUS_INVITE_SENT;\n\t          self.send();\n\t        },\n\t        function onFailure() {\n\t          if (self.status === C.STATUS_TERMINATED) {\n\t            return;\n\t          }\n\t          // TODO...fail out\n\t          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n\t          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t          self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t        }\n\t      );\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  receiveInviteResponse: function(response) {\n\t    var cause, //localMedia,\n\t      session = this,\n\t      id = response.call_id + response.from_tag + response.to_tag,\n\t      extraHeaders = [],\n\t      options = {};\n\t\n\t    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n\t      return;\n\t    }\n\t\n\t    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {\n\t      if (id !== this.dialog.id.toString() ) {\n\t        if (!this.createDialog(response, 'UAC', true)) {\n\t          return;\n\t        }\n\t        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,\n\t                                          {\n\t                                            body: SIP.Utils.generateFakeSDP(response.body)\n\t                                          });\n\t        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n\t\n\t        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n\t         * leg (due to peerConnection limitations) has been answered first. If your forking\n\t         * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n\t         */\n\t        if(this.status !== C.STATUS_CONFIRMED) {\n\t          this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n\t          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);\n\t        }\n\t        return;\n\t      } else if (this.status === C.STATUS_CONFIRMED) {\n\t        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n\t        return;\n\t      } else if (!this.hasAnswer) {\n\t        // invite w/o sdp is waiting for callback\n\t        //an invite with sdp must go on, and hasAnswer is true\n\t        return;\n\t      }\n\t    }\n\t\n\t    if (this.dialog && response.status_code < 200) {\n\t      /*\n\t        Early media has been set up with at least one other different branch,\n\t        but a final 2xx response hasn't been received\n\t      */\n\t      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n\t          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {\n\t        return;\n\t      }\n\t\n\t      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n\t        return;\n\t      }\n\t\n\t      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n\t          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n\t        return;\n\t      }\n\t\n\t      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n\t\n\t      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n\t        extraHeaders: extraHeaders,\n\t        body: SIP.Utils.generateFakeSDP(response.body)\n\t      });\n\t      return;\n\t    }\n\t\n\t    // Proceed to cancellation if the user requested.\n\t    if(this.isCanceled) {\n\t      if(response.status_code >= 100 && response.status_code < 200) {\n\t        this.request.cancel(this.cancelReason);\n\t        this.canceled(null);\n\t      } else if(response.status_code >= 200 && response.status_code < 299) {\n\t        this.acceptAndTerminate(response);\n\t        this.emit('bye', this.request);\n\t      } else if (response.status_code >= 300) {\n\t        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;\n\t        this.rejected(response, cause);\n\t        this.failed(response, cause);\n\t        this.terminated(response, cause);\n\t      }\n\t      return;\n\t    }\n\t\n\t    switch(true) {\n\t      case /^100$/.test(response.status_code):\n\t        this.received_100 = true;\n\t        this.emit('progress', response);\n\t        break;\n\t      case (/^1[0-9]{2}$/.test(response.status_code)):\n\t        // Do nothing with 1xx responses without To tag.\n\t        if(!response.to_tag) {\n\t          this.logger.warn('1xx response received without to tag');\n\t          break;\n\t        }\n\t\n\t        // Create Early Dialog if 1XX comes with contact\n\t        if(response.hasHeader('contact')) {\n\t          // An error on dialog creation will fire 'failed' event\n\t          if (!this.createDialog(response, 'UAC', true)) {\n\t            break;\n\t          }\n\t        }\n\t\n\t        this.status = C.STATUS_1XX_RECEIVED;\n\t\n\t        if(response.hasHeader('require') &&\n\t           response.getHeader('require').indexOf('100rel') !== -1) {\n\t\n\t          // Do nothing if this.dialog is already confirmed\n\t          if (this.dialog || !this.earlyDialogs[id]) {\n\t            break;\n\t          }\n\t\n\t          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n\t              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n\t            return;\n\t          }\n\t\n\t          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n\t          SIP.Hacks.AllBrowsers.maskDtls(response);\n\t\n\t          if (!response.body) {\n\t            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n\t            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n\t              extraHeaders: extraHeaders\n\t            });\n\t            this.emit('progress', response);\n\t\n\t          } else if (this.hasOffer) {\n\t            if (!this.createDialog(response, 'UAC')) {\n\t              break;\n\t            }\n\t            this.hasAnswer = true;\n\t            this.dialog.pracked.push(response.getHeader('rseq'));\n\t\n\t            this.mediaHandler.setDescription(response.body)\n\t            .then(\n\t              function onSuccess () {\n\t                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t\n\t                session.sendRequest(SIP.C.PRACK, {\n\t                  extraHeaders: extraHeaders,\n\t                  receiveResponse: function() {}\n\t                });\n\t                session.status = C.STATUS_EARLY_MEDIA;\n\t                session.mute();\n\t                session.emit('progress', response);\n\t                /*\n\t                if (session.status === C.STATUS_EARLY_MEDIA) {\n\t                  localMedia = session.mediaHandler.localMedia;\n\t                  if (localMedia.getAudioTracks().length > 0) {\n\t                    localMedia.getAudioTracks()[0].enabled = false;\n\t                  }\n\t                  if (localMedia.getVideoTracks().length > 0) {\n\t                    localMedia.getVideoTracks()[0].enabled = false;\n\t                  }\n\t                }*/\n\t              },\n\t              function onFailure (e) {\n\t                session.logger.warn(e);\n\t                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n\t                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              }\n\t            );\n\t          } else {\n\t            var earlyDialog = this.earlyDialogs[id];\n\t            var earlyMedia = earlyDialog.mediaHandler;\n\t\n\t            earlyDialog.pracked.push(response.getHeader('rseq'));\n\t\n\t            earlyMedia.setDescription(response.body)\n\t            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))\n\t            .then(function onSuccess(sdp) {\n\t              extraHeaders.push('Content-Type: application/sdp');\n\t              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t              earlyDialog.sendRequest(session, SIP.C.PRACK, {\n\t                extraHeaders: extraHeaders,\n\t                body: sdp\n\t              });\n\t              session.status = C.STATUS_EARLY_MEDIA;\n\t              session.emit('progress', response);\n\t            })\n\t            .catch(function onFailure(e) {\n\t              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n\t                earlyDialog.pracked.push(response.getHeader('rseq'));\n\t                if (session.status === C.STATUS_TERMINATED) {\n\t                  return;\n\t                }\n\t                // TODO - fail out on error\n\t                // session.failed(gum error);\n\t                session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t              } else {\n\t                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);\n\t                // Could not set remote description\n\t                session.logger.warn('invalid SDP');\n\t                session.logger.warn(e);\n\t              }\n\t            });\n\t          }\n\t        } else {\n\t          this.emit('progress', response);\n\t        }\n\t        break;\n\t      case /^2[0-9]{2}$/.test(response.status_code):\n\t        var cseq = this.request.cseq + ' ' + this.request.method;\n\t        if (cseq !== response.getHeader('cseq')) {\n\t          break;\n\t        }\n\t\n\t        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n\t          this.status = C.STATUS_CONFIRMED;\n\t          this.unmute();\n\t          /*localMedia = this.mediaHandler.localMedia;\n\t          if (localMedia.getAudioTracks().length > 0) {\n\t            localMedia.getAudioTracks()[0].enabled = true;\n\t          }\n\t          if (localMedia.getVideoTracks().length > 0) {\n\t            localMedia.getVideoTracks()[0].enabled = true;\n\t          }*/\n\t          options = {};\n\t          if (this.renderbody) {\n\t            extraHeaders.push('Content-Type: ' + this.rendertype);\n\t            options.extraHeaders = extraHeaders;\n\t            options.body = this.renderbody;\n\t          }\n\t          options.cseq = response.cseq;\n\t          this.sendRequest(SIP.C.ACK, options);\n\t          this.accepted(response);\n\t          break;\n\t        }\n\t        // Do nothing if this.dialog is already confirmed\n\t        if (this.dialog) {\n\t          break;\n\t        }\n\t\n\t        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n\t        SIP.Hacks.AllBrowsers.maskDtls(response);\n\t\n\t        // This is an invite without sdp\n\t        if (!this.hasOffer) {\n\t          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {\n\t            //REVISIT\n\t            this.hasOffer = true;\n\t            this.hasAnswer = true;\n\t            this.mediaHandler = this.earlyDialogs[id].mediaHandler;\n\t            if (!this.createDialog(response, 'UAC')) {\n\t              break;\n\t            }\n\t            this.status = C.STATUS_CONFIRMED;\n\t            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});\n\t\n\t            this.unmute();\n\t            /*\n\t            localMedia = session.mediaHandler.localMedia;\n\t            if (localMedia.getAudioTracks().length > 0) {\n\t              localMedia.getAudioTracks()[0].enabled = true;\n\t            }\n\t            if (localMedia.getVideoTracks().length > 0) {\n\t              localMedia.getVideoTracks()[0].enabled = true;\n\t            }*/\n\t            this.accepted(response);\n\t          } else {\n\t            if(!response.body) {\n\t              this.acceptAndTerminate(response, 400, 'Missing session description');\n\t              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              break;\n\t            }\n\t            if (!this.createDialog(response, 'UAC')) {\n\t              break;\n\t            }\n\t            this.hasOffer = true;\n\t            this.mediaHandler.setDescription(response.body)\n\t            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n\t            .then(function onSuccess(sdp) {\n\t              //var localMedia;\n\t              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {\n\t                return;\n\t              }\n\t\n\t              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);\n\t\n\t              session.status = C.STATUS_CONFIRMED;\n\t              session.hasAnswer = true;\n\t\n\t              session.unmute();\n\t              /*localMedia = session.mediaHandler.localMedia;\n\t              if (localMedia.getAudioTracks().length > 0) {\n\t                localMedia.getAudioTracks()[0].enabled = true;\n\t              }\n\t              if (localMedia.getVideoTracks().length > 0) {\n\t                localMedia.getVideoTracks()[0].enabled = true;\n\t              }*/\n\t              session.sendRequest(SIP.C.ACK,{\n\t                body: sdp,\n\t                extraHeaders:['Content-Type: application/sdp'],\n\t                cseq:response.cseq\n\t              });\n\t              session.accepted(response);\n\t            })\n\t            .catch(function onFailure(e) {\n\t              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n\t                // TODO do something here\n\t                session.logger.warn(\"there was a problem\");\n\t              } else {\n\t                session.logger.warn('invalid SDP');\n\t                session.logger.warn(e);\n\t                response.reply(488);\n\t              }\n\t            });\n\t          }\n\t        } else if (this.hasAnswer){\n\t          if (this.renderbody) {\n\t            extraHeaders.push('Content-Type: ' + session.rendertype);\n\t            options.extraHeaders = extraHeaders;\n\t            options.body = this.renderbody;\n\t          }\n\t          this.sendRequest(SIP.C.ACK, options);\n\t        } else {\n\t          if(!response.body) {\n\t            this.acceptAndTerminate(response, 400, 'Missing session description');\n\t            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            break;\n\t          }\n\t          if (!this.createDialog(response, 'UAC')) {\n\t            break;\n\t          }\n\t          this.hasAnswer = true;\n\t          this.mediaHandler.setDescription(response.body)\n\t          .then(\n\t            function onSuccess () {\n\t              var options = {};//,localMedia;\n\t              session.status = C.STATUS_CONFIRMED;\n\t              session.unmute();\n\t              /*localMedia = session.mediaHandler.localMedia;\n\t              if (localMedia.getAudioTracks().length > 0) {\n\t                localMedia.getAudioTracks()[0].enabled = true;\n\t              }\n\t              if (localMedia.getVideoTracks().length > 0) {\n\t                localMedia.getVideoTracks()[0].enabled = true;\n\t              }*/\n\t              if (session.renderbody) {\n\t                extraHeaders.push('Content-Type: ' + session.rendertype);\n\t                options.extraHeaders = extraHeaders;\n\t                options.body = session.renderbody;\n\t              }\n\t              options.cseq = response.cseq;\n\t              session.sendRequest(SIP.C.ACK, options);\n\t              session.accepted(response);\n\t            },\n\t            function onFailure (e) {\n\t              session.logger.warn(e);\n\t              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n\t              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            }\n\t          );\n\t        }\n\t        break;\n\t      default:\n\t        cause = SIP.Utils.sipErrorCause(response.status_code);\n\t        this.rejected(response, cause);\n\t        this.failed(response, cause);\n\t        this.terminated(response, cause);\n\t    }\n\t  },\n\t\n\t  cancel: function(options) {\n\t    options = options || {};\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.logger.log('canceling RTCSession');\n\t\n\t    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_NULL ||\n\t        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {\n\t      this.isCanceled = true;\n\t      this.cancelReason = cancel_reason;\n\t    } else if (this.status === C.STATUS_INVITE_SENT ||\n\t               this.status === C.STATUS_1XX_RECEIVED ||\n\t               this.status === C.STATUS_EARLY_MEDIA) {\n\t      this.request.cancel(cancel_reason);\n\t    }\n\t\n\t    return this.canceled();\n\t  },\n\t\n\t  terminate: function(options) {\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n\t      this.bye(options);\n\t    } else {\n\t      this.cancel(options);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  receiveRequest: function(request) {\n\t    // ICC RECEIVE REQUEST\n\t\n\t    // Reject CANCELs\n\t    if (request.method === SIP.C.CANCEL) {\n\t      // TODO; make this a switch when it gets added\n\t    }\n\t\n\t    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n\t      SIP.Timers.clearTimeout(this.timers.ackTimer);\n\t      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n\t      this.status = C.STATUS_CONFIRMED;\n\t      this.unmute();\n\t\n\t      this.accepted();\n\t    }\n\t\n\t    return Session.prototype.receiveRequest.apply(this, [request]);\n\t  },\n\t\n\t  onTransportError: function() {\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    }\n\t  }\n\t\n\t};\n\t\n\tSIP.InviteClientContext = InviteClientContext;\n\t\n\t};\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview DTMF\n\t */\n\t\n\t/**\n\t * @class DTMF\n\t * @param {SIP.Session} session\n\t */\n\tmodule.exports = function (SIP) {\n\t\n\tvar DTMF,\n\t  C = {\n\t    MIN_DURATION:            70,\n\t    MAX_DURATION:            6000,\n\t    DEFAULT_DURATION:        100,\n\t    MIN_INTER_TONE_GAP:      50,\n\t    DEFAULT_INTER_TONE_GAP:  500\n\t  };\n\t\n\tDTMF = function(session, tone, options) {\n\t  var duration, interToneGap;\n\t\n\t  if (tone === undefined) {\n\t    throw new TypeError('Not enough arguments');\n\t  }\n\t\n\t  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n\t  this.owner = session;\n\t  this.direction = null;\n\t\n\t  options = options || {};\n\t  duration = options.duration || null;\n\t  interToneGap = options.interToneGap || null;\n\t\n\t  // Check tone type\n\t  if (typeof tone === 'string' ) {\n\t    tone = tone.toUpperCase();\n\t  } else if (typeof tone === 'number') {\n\t    tone = tone.toString();\n\t  } else {\n\t    throw new TypeError('Invalid tone: '+ tone);\n\t  }\n\t\n\t  // Check tone value\n\t  if (!tone.match(/^[0-9A-D#*]$/)) {\n\t    throw new TypeError('Invalid tone: '+ tone);\n\t  } else {\n\t    this.tone = tone;\n\t  }\n\t\n\t  // Check duration\n\t  if (duration && !SIP.Utils.isDecimal(duration)) {\n\t    throw new TypeError('Invalid tone duration: '+ duration);\n\t  } else if (!duration) {\n\t    duration = DTMF.C.DEFAULT_DURATION;\n\t  } else if (duration < DTMF.C.MIN_DURATION) {\n\t    this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');\n\t    duration = DTMF.C.MIN_DURATION;\n\t  } else if (duration > DTMF.C.MAX_DURATION) {\n\t    this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');\n\t    duration = DTMF.C.MAX_DURATION;\n\t  } else {\n\t    duration = Math.abs(duration);\n\t  }\n\t  this.duration = duration;\n\t\n\t  // Check interToneGap\n\t  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n\t    throw new TypeError('Invalid interToneGap: '+ interToneGap);\n\t  } else if (!interToneGap) {\n\t    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;\n\t  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {\n\t    this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');\n\t    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;\n\t  } else {\n\t    interToneGap = Math.abs(interToneGap);\n\t  }\n\t  this.interToneGap = interToneGap;\n\t};\n\tDTMF.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\t\n\tDTMF.prototype.send = function(options) {\n\t  var extraHeaders, body;\n\t\n\t  this.direction = 'outgoing';\n\t\n\t  // Check RTCSession Status\n\t  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&\n\t    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n\t    throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n\t  }\n\t\n\t  // Get DTMF options\n\t  options = options || {};\n\t  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n\t\n\t  extraHeaders.push('Content-Type: application/dtmf-relay');\n\t\n\t  body = \"Signal= \" + this.tone + \"\\r\\n\";\n\t  body += \"Duration= \" + this.duration;\n\t\n\t  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n\t    extraHeaders: extraHeaders,\n\t    body: body\n\t  });\n\t\n\t  this.owner.emit('dtmf', this.request, this);\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.receiveResponse = function(response) {\n\t  var cause;\n\t\n\t  switch(true) {\n\t    case /^1[0-9]{2}$/.test(response.status_code):\n\t      // Ignore provisional responses.\n\t      break;\n\t\n\t    case /^2[0-9]{2}$/.test(response.status_code):\n\t      this.emit('succeeded', {\n\t        originator: 'remote',\n\t        response: response\n\t      });\n\t      break;\n\t\n\t    default:\n\t      cause = SIP.Utils.sipErrorCause(response.status_code);\n\t      this.emit('failed', response, cause);\n\t      break;\n\t  }\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.onRequestTimeout = function() {\n\t  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n\t  this.owner.onRequestTimeout();\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.onTransportError = function() {\n\t  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n\t  this.owner.onTransportError();\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.onDialogError = function(response) {\n\t  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n\t  this.owner.onDialogError(response);\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.init_incoming = function(request) {\n\t  this.direction = 'incoming';\n\t  this.request = request;\n\t\n\t  request.reply(200);\n\t\n\t  if (!this.tone || !this.duration) {\n\t    this.logger.warn('invalid INFO DTMF received, discarded');\n\t  } else {\n\t    this.owner.emit('dtmf', request, this);\n\t  }\n\t};\n\t\n\tDTMF.C = C;\n\treturn DTMF;\n\t};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP Subscription.\n\t */\n\tmodule.exports = function (SIP) {\n\tSIP.Subscription = function (ua, target, event, options) {\n\t  options = Object.create(options || Object.prototype);\n\t  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();\n\t\n\t  this.id = null;\n\t  this.state = 'init';\n\t\n\t  if (!event) {\n\t    throw new TypeError('Event necessary to create a subscription.');\n\t  } else {\n\t    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n\t    //The check may need to/should probably occur on the other side,\n\t    this.event = event;\n\t  }\n\t\n\t  if(typeof options.expires !== 'number'){\n\t    ua.logger.warn('expires must be a number. Using default of 3600.');\n\t    this.expires = 3600;\n\t  } else {\n\t    this.expires = options.expires;\n\t  }\n\t\n\t  options.extraHeaders.push('Event: ' + this.event);\n\t  options.extraHeaders.push('Expires: ' + this.expires);\n\t\n\t  if (options.body) {\n\t    this.body = options.body;\n\t  }\n\t\n\t  this.contact = ua.contact.toString();\n\t\n\t  options.extraHeaders.push('Contact: '+ this.contact);\n\t  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n\t\n\t  this.logger = ua.getLogger('sip.subscription');\n\t\n\t  this.dialog = null;\n\t  this.timers = {N: null, sub_duration: null};\n\t  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];\n\t};\n\t\n\tSIP.Subscription.prototype = {\n\t  subscribe: function() {\n\t    var sub = this;\n\t\n\t     //these states point to an existing subscription, no subscribe is necessary\n\t    if (this.state === 'active') {\n\t      this.refresh();\n\t      return this;\n\t    } else if (this.state === 'notify_wait') {\n\t      return this;\n\t    }\n\t\n\t    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t    SIP.Timers.clearTimeout(this.timers.N);\n\t    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\t\n\t    this.send();\n\t\n\t    this.state = 'notify_wait';\n\t\n\t    return this;\n\t  },\n\t\n\t  refresh: function () {\n\t    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {\n\t      return;\n\t    }\n\t\n\t    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {\n\t      extraHeaders: this.extraHeaders,\n\t      body: this.body\n\t    });\n\t  },\n\t\n\t  receiveResponse: function(response) {\n\t    var expires, sub = this,\n\t        cause = SIP.Utils.getReasonPhrase(response.status_code);\n\t\n\t    if ((this.state === 'notify_wait' && response.status_code >= 300) ||\n\t        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {\n\t      this.failed(response, null);\n\t    } else if (/^2[0-9]{2}$/.test(response.status_code)){\n\t      expires = response.getHeader('Expires');\n\t      SIP.Timers.clearTimeout(this.timers.N);\n\t\n\t      if (this.createConfirmedDialog(response,'UAC')) {\n\t        this.id = this.dialog.id.toString();\n\t        this.ua.subscriptions[this.id] = this;\n\t        this.emit('accepted', response, cause);\n\t        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n\t      }\n\t\n\t      if (expires && expires <= this.expires) {\n\t        // Preserve new expires value for subsequent requests\n\t        this.expires = expires;\n\t        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);\n\t      } else {\n\t        if (!expires) {\n\t          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n\t          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n\t        } else {\n\t          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n\t          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n\t        }\n\t      }\n\t    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx\n\t  },\n\t\n\t  unsubscribe: function() {\n\t    var extraHeaders = [], sub = this;\n\t\n\t    this.state = 'terminated';\n\t\n\t    extraHeaders.push('Event: ' + this.event);\n\t    extraHeaders.push('Expires: 0');\n\t\n\t    extraHeaders.push('Contact: '+ this.contact);\n\t    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t    //makes sure expires isn't set, and other typical resubscribe behavior\n\t    this.receiveResponse = function(){};\n\t\n\t    this.dialog.sendRequest(this, this.method, {\n\t      extraHeaders: extraHeaders,\n\t      body: this.body\n\t    });\n\t\n\t    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t    SIP.Timers.clearTimeout(this.timers.N);\n\t    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  timer_fire: function(){\n\t    if (this.state === 'terminated') {\n\t      this.terminateDialog();\n\t      SIP.Timers.clearTimeout(this.timers.N);\n\t      SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t\n\t      delete this.ua.subscriptions[this.id];\n\t    } else if (this.state === 'pending' || this.state === 'notify_wait') {\n\t      this.close();\n\t    } else {\n\t      this.refresh();\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  close: function() {\n\t    if(this.state !== 'notify_wait' && this.state !== 'terminated') {\n\t      this.unsubscribe();\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  createConfirmedDialog: function(message, type) {\n\t    var dialog;\n\t\n\t    this.terminateDialog();\n\t    dialog = new SIP.Dialog(this, message, type);\n\t\n\t    if(!dialog.error) {\n\t      this.dialog = dialog;\n\t      return true;\n\t    }\n\t    // Dialog not created due to an error\n\t    else {\n\t      return false;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  terminateDialog: function() {\n\t    if(this.dialog) {\n\t      delete this.ua.subscriptions[this.id];\n\t      this.dialog.terminate();\n\t      delete this.dialog;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  receiveRequest: function(request) {\n\t    var sub_state, sub = this;\n\t\n\t    function setExpiresTimeout() {\n\t      if (sub_state.expires) {\n\t        SIP.Timers.clearTimeout(sub.timers.sub_duration);\n\t        sub_state.expires = Math.min(sub.expires,\n\t                                     Math.max(sub_state.expires, 0));\n\t        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),\n\t                                                    sub_state.expires * 900);\n\t      }\n\t    }\n\t\n\t    if (!this.matchEvent(request)) { //checks event and subscription_state headers\n\t      request.reply(489);\n\t      return;\n\t    }\n\t\n\t    sub_state = request.parseHeader('Subscription-State');\n\t\n\t    request.reply(200, SIP.C.REASON_200);\n\t\n\t    SIP.Timers.clearTimeout(this.timers.N);\n\t\n\t    this.emit('notify', {request: request});\n\t\n\t    // if we've set state to terminated, no further processing should take place\n\t    // and we are only interested in cleaning up after the appropriate NOTIFY\n\t    if (this.state === 'terminated') {\n\t      if (sub_state.state === 'terminated') {\n\t        this.terminateDialog();\n\t        SIP.Timers.clearTimeout(this.timers.N);\n\t        SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t\n\t        delete this.ua.subscriptions[this.id];\n\t      }\n\t      return;\n\t    }\n\t\n\t    switch (sub_state.state) {\n\t      case 'active':\n\t        this.state = 'active';\n\t        setExpiresTimeout();\n\t        break;\n\t      case 'pending':\n\t        if (this.state === 'notify_wait') {\n\t          setExpiresTimeout();\n\t        }\n\t        this.state = 'pending';\n\t        break;\n\t      case 'terminated':\n\t        SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t        if (sub_state.reason) {\n\t          this.logger.log('terminating subscription with reason '+ sub_state.reason);\n\t          switch (sub_state.reason) {\n\t            case 'deactivated':\n\t            case 'timeout':\n\t              this.subscribe();\n\t              return;\n\t            case 'probation':\n\t            case 'giveup':\n\t              if(sub_state.params && sub_state.params['retry-after']) {\n\t                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n\t              } else {\n\t                this.subscribe();\n\t              }\n\t              return;\n\t            case 'rejected':\n\t            case 'noresource':\n\t            case 'invariant':\n\t              break;\n\t          }\n\t        }\n\t        this.close();\n\t        break;\n\t    }\n\t  },\n\t\n\t  failed: function(response, cause) {\n\t    this.close();\n\t    this.emit('failed', response, cause);\n\t    return this;\n\t  },\n\t\n\t  onDialogError: function(response) {\n\t    this.failed(response, SIP.C.causes.DIALOG_ERROR);\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  matchEvent: function(request) {\n\t    var event;\n\t\n\t    // Check mandatory header Event\n\t    if (!request.hasHeader('Event')) {\n\t      this.logger.warn('missing Event header');\n\t      return false;\n\t    }\n\t    // Check mandatory header Subscription-State\n\t    if (!request.hasHeader('Subscription-State')) {\n\t      this.logger.warn('missing Subscription-State header');\n\t      return false;\n\t    }\n\t\n\t    // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n\t    event = request.parseHeader('event').event;\n\t\n\t    if (this.event !== event) {\n\t      this.logger.warn('event match failed');\n\t      request.reply(481, 'Event Match Failed');\n\t      return false;\n\t    } else {\n\t      return true;\n\t    }\n\t  }\n\t};\n\t};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview WebRTC\n\t */\n\t\n\tmodule.exports = function (SIP, environment) {\n\tvar WebRTC;\n\t\n\tWebRTC = {};\n\t\n\tWebRTC.MediaHandler = __webpack_require__(41)(SIP);\n\tWebRTC.MediaStreamManager = __webpack_require__(42)(SIP, environment);\n\t\n\tvar _isSupported;\n\t\n\tWebRTC.isSupported = function () {\n\t  if (_isSupported !== undefined) {\n\t    return _isSupported;\n\t  }\n\t\n\t  WebRTC.MediaStream = environment.MediaStream;\n\t  WebRTC.getUserMedia = environment.getUserMedia;\n\t  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;\n\t  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;\n\t\n\t  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {\n\t    if (WebRTC.getUserMedia) {\n\t      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');\n\t    }\n\t    _isSupported = true;\n\t  }\n\t  else {\n\t    _isSupported = false;\n\t  }\n\t  return _isSupported;\n\t};\n\t\n\treturn WebRTC;\n\t};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview MediaHandler\n\t */\n\t\n\t/* MediaHandler\n\t * @class PeerConnection helper Class.\n\t * @param {SIP.Session} session\n\t * @param {Object} [options]\n\t * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]\n\t *        The MediaStreamManager to acquire/release streams from/to.\n\t *        If not provided, a default MediaStreamManager will be used.\n\t */\n\tmodule.exports = function (SIP) {\n\t\n\tvar MediaHandler = function(session, options) {\n\t  options = options || {};\n\t\n\t  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);\n\t  this.session = session;\n\t  this.localMedia = null;\n\t  this.ready = true;\n\t  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);\n\t  this.audioMuted = false;\n\t  this.videoMuted = false;\n\t\n\t  // old init() from here on\n\t  var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n\t  this.RTCConstraints = options.RTCConstraints || {};\n\t\n\t  this.initPeerConnection(servers, this.RTCConstraints);\n\t\n\t  function selfEmit(mh, event) {\n\t    if (mh.mediaStreamManager.on) {\n\t      mh.mediaStreamManager.on(event, function () {\n\t        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));\n\t      });\n\t    }\n\t  }\n\t\n\t  selfEmit(this, 'userMediaRequest');\n\t  selfEmit(this, 'userMedia');\n\t  selfEmit(this, 'userMediaFailed');\n\t};\n\t\n\tMediaHandler.defaultFactory = function defaultFactory (session, options) {\n\t  return new MediaHandler(session, options);\n\t};\n\tMediaHandler.defaultFactory.isSupported = function () {\n\t  return SIP.WebRTC.isSupported();\n\t};\n\t\n\tMediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {\n\t// Functions the session can use\n\t  isReady: {writable: true, value: function isReady () {\n\t    return this.ready;\n\t  }},\n\t\n\t  close: {writable: true, value: function close () {\n\t    this.logger.log('closing PeerConnection');\n\t    this._remoteStreams = [];\n\t    // have to check signalingState since this.close() gets called multiple times\n\t    // TODO figure out why that happens\n\t    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n\t      this.peerConnection.close();\n\t\n\t      if(this.localMedia) {\n\t        this.mediaStreamManager.release(this.localMedia);\n\t      }\n\t    }\n\t  }},\n\t\n\t  /**\n\t   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]\n\t   *        the MediaStream (or the constraints describing it) to be used for the session\n\t   */\n\t  getDescription: {writable: true, value: function getDescription (mediaHint) {\n\t    var self = this;\n\t    var acquire = self.mediaStreamManager.acquire;\n\t    if (acquire.length > 1) {\n\t      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);\n\t    }\n\t    mediaHint = mediaHint || {};\n\t    if (mediaHint.dataChannel === true) {\n\t      mediaHint.dataChannel = {};\n\t    }\n\t    this.mediaHint = mediaHint;\n\t\n\t    /*\n\t     * 1. acquire streams (skip if MediaStreams passed in)\n\t     * 2. addStreams\n\t     * 3. createOffer/createAnswer\n\t     */\n\t\n\t    var streamPromise;\n\t    if (self.localMedia) {\n\t      self.logger.log('already have local media');\n\t      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);\n\t    }\n\t    else {\n\t      self.logger.log('acquiring local media');\n\t      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)\n\t        .then(function acquireSucceeded(streams) {\n\t          self.logger.log('acquired local media streams');\n\t          self.localMedia = streams;\n\t          self.session.connecting();\n\t          return streams;\n\t        }, function acquireFailed(err) {\n\t          self.logger.error('unable to acquire streams');\n\t          self.logger.error(err);\n\t          self.session.connecting();\n\t          throw err;\n\t        })\n\t        .then(this.addStreams.bind(this))\n\t      ;\n\t    }\n\t\n\t    return streamPromise\n\t      .then(function streamAdditionSucceeded() {\n\t        if (self.hasOffer('remote')) {\n\t          self.peerConnection.ondatachannel = function (evt) {\n\t            self.dataChannel = evt.channel;\n\t            self.emit('dataChannel', self.dataChannel);\n\t          };\n\t        } else if (mediaHint.dataChannel &&\n\t                   self.peerConnection.createDataChannel) {\n\t          self.dataChannel = self.peerConnection.createDataChannel(\n\t            'sipjs',\n\t            mediaHint.dataChannel\n\t          );\n\t          self.emit('dataChannel', self.dataChannel);\n\t        }\n\t\n\t        self.render();\n\t        return self.createOfferOrAnswer(self.RTCConstraints);\n\t      })\n\t    ;\n\t  }},\n\t\n\t  /**\n\t  * Message reception.\n\t  * @param {String} type\n\t  * @param {String} sdp\n\t  */\n\t  setDescription: {writable: true, value: function setDescription (sdp) {\n\t    var rawDescription = {\n\t      type: this.hasOffer('local') ? 'answer' : 'offer',\n\t      sdp: sdp\n\t    };\n\t\n\t    this.emit('setDescription', rawDescription);\n\t\n\t    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);\n\t    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);\n\t  }},\n\t\n\t  /**\n\t   * If the Session associated with this MediaHandler were to be referred,\n\t   * what mediaHint should be provided to the UA's invite method?\n\t   */\n\t  getReferMedia: {writable: true, value: function getReferMedia () {\n\t    function hasTracks (trackGetter, stream) {\n\t      return stream[trackGetter]().length > 0;\n\t    }\n\t\n\t    function bothHaveTracks (trackGetter) {\n\t      /* jshint validthis:true */\n\t      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&\n\t             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));\n\t    }\n\t\n\t    return {\n\t      constraints: {\n\t        audio: bothHaveTracks.call(this, 'getAudioTracks'),\n\t        video: bothHaveTracks.call(this, 'getVideoTracks')\n\t      }\n\t    };\n\t  }},\n\t\n\t  updateIceServers: {writeable:true, value: function (options) {\n\t    var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n\t    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;\n\t\n\t    this.initPeerConnection(servers, this.RTCConstraints);\n\t\n\t    /* once updateIce is implemented correctly, this is better than above\n\t    //no op if browser does not support this\n\t    if (!this.peerConnection.updateIce) {\n\t      return;\n\t    }\n\t\n\t    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);\n\t    */\n\t  }},\n\t\n\t// Functions the session can use, but only because it's convenient for the application\n\t  isMuted: {writable: true, value: function isMuted () {\n\t    return {\n\t      audio: this.audioMuted,\n\t      video: this.videoMuted\n\t    };\n\t  }},\n\t\n\t  mute: {writable: true, value: function mute (options) {\n\t    if (this.getLocalStreams().length === 0) {\n\t      return;\n\t    }\n\t\n\t    options = options || {\n\t      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n\t      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n\t    };\n\t\n\t    var audioMuted = false,\n\t        videoMuted = false;\n\t\n\t    if (options.audio && !this.audioMuted) {\n\t      audioMuted = true;\n\t      this.audioMuted = true;\n\t      this.toggleMuteAudio(true);\n\t    }\n\t\n\t    if (options.video && !this.videoMuted) {\n\t      videoMuted = true;\n\t      this.videoMuted = true;\n\t      this.toggleMuteVideo(true);\n\t    }\n\t\n\t    //REVISIT\n\t    if (audioMuted || videoMuted) {\n\t      return {\n\t        audio: audioMuted,\n\t        video: videoMuted\n\t      };\n\t      /*this.session.onmute({\n\t        audio: audioMuted,\n\t        video: videoMuted\n\t      });*/\n\t    }\n\t  }},\n\t\n\t  unmute: {writable: true, value: function unmute (options) {\n\t    if (this.getLocalStreams().length === 0) {\n\t      return;\n\t    }\n\t\n\t    options = options || {\n\t      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n\t      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n\t    };\n\t\n\t    var audioUnMuted = false,\n\t        videoUnMuted = false;\n\t\n\t    if (options.audio && this.audioMuted) {\n\t      audioUnMuted = true;\n\t      this.audioMuted = false;\n\t      this.toggleMuteAudio(false);\n\t    }\n\t\n\t    if (options.video && this.videoMuted) {\n\t      videoUnMuted = true;\n\t      this.videoMuted = false;\n\t      this.toggleMuteVideo(false);\n\t    }\n\t\n\t    //REVISIT\n\t    if (audioUnMuted || videoUnMuted) {\n\t      return {\n\t        audio: audioUnMuted,\n\t        video: videoUnMuted\n\t      };\n\t      /*this.session.onunmute({\n\t        audio: audioUnMuted,\n\t        video: videoUnMuted\n\t      });*/\n\t    }\n\t  }},\n\t\n\t  hold: {writable: true, value: function hold () {\n\t    this.toggleMuteAudio(true);\n\t    this.toggleMuteVideo(true);\n\t  }},\n\t\n\t  unhold: {writable: true, value: function unhold () {\n\t    if (!this.audioMuted) {\n\t      this.toggleMuteAudio(false);\n\t    }\n\t\n\t    if (!this.videoMuted) {\n\t      this.toggleMuteVideo(false);\n\t    }\n\t  }},\n\t\n\t// Functions the application can use, but not the session\n\t  getLocalStreams: {writable: true, value: function getLocalStreams () {\n\t    var pc = this.peerConnection;\n\t    if (pc && pc.signalingState === 'closed') {\n\t      this.logger.warn('peerConnection is closed, getLocalStreams returning []');\n\t      return [];\n\t    }\n\t    return (pc.getLocalStreams && pc.getLocalStreams()) ||\n\t      pc.localStreams || [];\n\t  }},\n\t\n\t  getRemoteStreams: {writable: true, value: function getRemoteStreams () {\n\t    var pc = this.peerConnection;\n\t    if (pc && pc.signalingState === 'closed') {\n\t      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');\n\t      return this._remoteStreams;\n\t    }\n\t    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||\n\t      pc.remoteStreams || [];\n\t  }},\n\t\n\t  render: {writable: true, value: function render (renderHint) {\n\t    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);\n\t    if (!renderHint) {\n\t      return false;\n\t    }\n\t    var streamGetters = {\n\t      local: 'getLocalStreams',\n\t      remote: 'getRemoteStreams'\n\t    };\n\t    Object.keys(streamGetters).forEach(function (loc) {\n\t      var streamGetter = streamGetters[loc];\n\t      var streams = this[streamGetter]();\n\t      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);\n\t    }.bind(this));\n\t  }},\n\t\n\t// Internal functions\n\t  hasOffer: {writable: true, value: function hasOffer (where) {\n\t    var offerState = 'have-' + where + '-offer';\n\t    return this.peerConnection.signalingState === offerState;\n\t    // TODO consider signalingStates with 'pranswer'?\n\t  }},\n\t\n\t  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {\n\t    var servers = [],\n\t      config = this.session.ua.configuration;\n\t\n\t    stunServers = stunServers || config.stunServers;\n\t    turnServers = turnServers || config.turnServers;\n\t\n\t    [].concat(stunServers).forEach(function (server) {\n\t      servers.push({'urls': server});\n\t    });\n\t\n\t    [].concat(turnServers).forEach(function (server) {\n\t      servers.push({\n\t        'urls': server.urls,\n\t        'username': server.username,\n\t        'credential': server.password\n\t      });\n\t    });\n\t\n\t    return servers;\n\t  }},\n\t\n\t  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {\n\t    var self = this,\n\t      config = this.session.ua.configuration;\n\t\n\t    this.onIceCompleted = SIP.Utils.defer();\n\t    this.onIceCompleted.promise.then(function(pc) {\n\t      self.emit('iceGatheringComplete', pc);\n\t      if (self.iceCheckingTimer) {\n\t        SIP.Timers.clearTimeout(self.iceCheckingTimer);\n\t        self.iceCheckingTimer = null;\n\t      }\n\t    });\n\t\n\t    if (this.peerConnection) {\n\t      this.peerConnection.close();\n\t    }\n\t\n\t    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);\n\t\n\t    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams\n\t    // even if peerConnection.onaddstream was just called. In order to make\n\t    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually\n\t    this._remoteStreams = [];\n\t\n\t    this.peerConnection.onaddstream = function(e) {\n\t      self.logger.log('stream added: '+ e.stream.id);\n\t      self._remoteStreams.push(e.stream);\n\t      self.render();\n\t      self.emit('addStream', e);\n\t    };\n\t\n\t    this.peerConnection.onremovestream = function(e) {\n\t      self.logger.log('stream removed: '+ e.stream.id);\n\t    };\n\t\n\t    this.startIceCheckingTimer = function () {\n\t      if (!self.iceCheckingTimer) {\n\t        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {\n\t          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');\n\t          self.onIceCompleted.resolve(this);\n\t        }.bind(this.peerConnection), config.iceCheckingTimeout);\n\t      }\n\t    };\n\t\n\t    this.peerConnection.onicecandidate = function(e) {\n\t      self.emit('iceCandidate', e);\n\t      if (e.candidate) {\n\t        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n\t        self.startIceCheckingTimer();\n\t      } else {\n\t        self.onIceCompleted.resolve(this);\n\t      }\n\t    };\n\t\n\t    this.peerConnection.onicegatheringstatechange = function () {\n\t      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n\t      if (this.iceGatheringState === 'gathering') {\n\t        self.emit('iceGathering', this);\n\t      }\n\t      if (this.iceGatheringState === 'complete') {\n\t        self.onIceCompleted.resolve(this);\n\t      }\n\t    };\n\t\n\t    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case\n\t      var stateEvent;\n\t\n\t      if (this.iceConnectionState === 'checking') {\n\t        self.startIceCheckingTimer();\n\t      }\n\t\n\t      switch (this.iceConnectionState) {\n\t      case 'new':\n\t        stateEvent = 'iceConnection';\n\t        break;\n\t      case 'checking':\n\t        stateEvent = 'iceConnectionChecking';\n\t        break;\n\t      case 'connected':\n\t        stateEvent = 'iceConnectionConnected';\n\t        break;\n\t      case 'completed':\n\t        stateEvent = 'iceConnectionCompleted';\n\t        break;\n\t      case 'failed':\n\t        stateEvent = 'iceConnectionFailed';\n\t        break;\n\t      case 'disconnected':\n\t        stateEvent = 'iceConnectionDisconnected';\n\t        break;\n\t      case 'closed':\n\t        stateEvent = 'iceConnectionClosed';\n\t        break;\n\t      default:\n\t        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);\n\t        return;\n\t      }\n\t      self.emit(stateEvent, this);\n\t\n\t      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated\n\t      //normal calls switch from failed to connected in some cases, so checking for failed and terminated\n\t      /*if (this.iceConnectionState === 'failed') {\n\t        self.session.terminate({\n\t        cause: SIP.C.causes.RTP_TIMEOUT,\n\t        status_code: 200,\n\t        reason_phrase: SIP.C.causes.RTP_TIMEOUT\n\t      });\n\t      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {\n\t      self.onIceCompleted(this);\n\t      }*/\n\t    };\n\t\n\t    this.peerConnection.onstatechange = function() {\n\t      self.logger.log('PeerConnection state changed to \"'+ this.readyState +'\"');\n\t    };\n\t  }},\n\t\n\t  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {\n\t    var self = this;\n\t    var methodName;\n\t    var pc = self.peerConnection;\n\t\n\t    self.ready = false;\n\t    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n\t\n\t    return SIP.Utils.promisify(pc, methodName, true)(constraints)\n\t      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))\n\t      .then(function onSetLocalDescriptionSuccess() {\n\t        var deferred = SIP.Utils.defer();\n\t        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {\n\t          deferred.resolve();\n\t        } else {\n\t          self.onIceCompleted.promise.then(deferred.resolve);\n\t        }\n\t        return deferred.promise;\n\t      })\n\t      .then(function readySuccess () {\n\t        var sdp = pc.localDescription.sdp;\n\t\n\t        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);\n\t        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);\n\t\n\t        var sdpWrapper = {\n\t          type: methodName === 'createOffer' ? 'offer' : 'answer',\n\t          sdp: sdp\n\t        };\n\t\n\t        self.emit('getDescription', sdpWrapper);\n\t\n\t        self.ready = true;\n\t        return sdpWrapper.sdp;\n\t      })\n\t      .catch(function methodFailed (e) {\n\t        self.logger.error(e);\n\t        self.ready = true;\n\t        throw new SIP.Exceptions.GetDescriptionError(e);\n\t      })\n\t    ;\n\t  }},\n\t\n\t  addStreams: {writable: true, value: function addStreams (streams) {\n\t    try {\n\t      streams = [].concat(streams);\n\t      streams.forEach(function (stream) {\n\t        this.peerConnection.addStream(stream);\n\t      }, this);\n\t    } catch(e) {\n\t      this.logger.error('error adding stream');\n\t      this.logger.error(e);\n\t      return SIP.Utils.Promise.reject(e);\n\t    }\n\t\n\t    return SIP.Utils.Promise.resolve();\n\t  }},\n\t\n\t  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {\n\t    this.getLocalStreams().forEach(function (stream) {\n\t      stream[trackGetter]().forEach(function (track) {\n\t        track.enabled = !mute;\n\t      });\n\t    });\n\t  }},\n\t\n\t  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {\n\t    this.toggleMuteHelper('getAudioTracks', mute);\n\t  }},\n\t\n\t  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {\n\t    this.toggleMuteHelper('getVideoTracks', mute);\n\t  }}\n\t});\n\t\n\t// Return since it will be assigned to a variable.\n\treturn MediaHandler;\n\t};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview MediaStreamManager\n\t */\n\t\n\t/* MediaStreamManager\n\t * @class Manages the acquisition and release of MediaStreams.\n\t * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()\n\t */\n\tmodule.exports = function (SIP, environment) {\n\t\n\t// Default MediaStreamManager provides single-use streams created with getUserMedia\n\tvar MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {\n\t  if (!SIP.WebRTC.isSupported()) {\n\t    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n\t  }\n\t\n\t  this.mediaHint = defaultMediaHint || {\n\t    constraints: {audio: true, video: true}\n\t  };\n\t\n\t  // map of streams to acquisition manner:\n\t  // true -> passed in as mediaHint.stream\n\t  // false -> getUserMedia\n\t  this.acquisitions = {};\n\t};\n\tMediaStreamManager.streamId = function (stream) {\n\t  return stream.getAudioTracks().concat(stream.getVideoTracks())\n\t    .map(function trackId (track) {\n\t      return track.id;\n\t    })\n\t    .join('');\n\t};\n\t\n\t/**\n\t * @param {(Array of) MediaStream} streams - The streams to render\n\t *\n\t * @param {(Array of) HTMLMediaElement} elements\n\t *        - The <audio>/<video> element(s) that should render the streams\n\t *\n\t * Each stream in streams renders to the corresponding element in elements,\n\t * wrapping around elements if needed.\n\t */\n\tMediaStreamManager.render = function render (streams, elements) {\n\t  if (!elements) {\n\t    return false;\n\t  }\n\t  if (Array.isArray(elements) && !elements.length) {\n\t    throw new TypeError('elements must not be empty');\n\t  }\n\t\n\t  function attachMediaStream(element, stream) {\n\t    if (typeof element.src !== 'undefined') {\n\t      environment.revokeObjectURL(element.src);\n\t      element.src = environment.createObjectURL(stream);\n\t    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {\n\t      element.srcObject = element.mozSrcObject = stream;\n\t    } else {\n\t      return false;\n\t    }\n\t\n\t    return true;\n\t  }\n\t\n\t  function ensureMediaPlaying (mediaElement) {\n\t    var interval = 100;\n\t    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {\n\t      if (mediaElement.paused) {\n\t        mediaElement.play();\n\t      }\n\t      else {\n\t        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);\n\t      }\n\t    }, interval);\n\t  }\n\t\n\t  function attachAndPlay (elements, stream, index) {\n\t    if (typeof elements === 'function') {\n\t      elements = elements();\n\t    }\n\t    var element = elements[index % elements.length];\n\t    (environment.attachMediaStream || attachMediaStream)(element, stream);\n\t    ensureMediaPlaying(element);\n\t  }\n\t\n\t  // [].concat \"casts\" `elements` into an array\n\t  // so forEach works even if `elements` was a single element\n\t  elements = [].concat(elements);\n\t  [].concat(streams).forEach(attachAndPlay.bind(null, elements));\n\t};\n\t\n\tMediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {\n\t  'acquire': {writable: true, value: function acquire (mediaHint) {\n\t    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;\n\t\n\t    var saveSuccess = function (isHintStream, streams) {\n\t      streams = [].concat(streams);\n\t      streams.forEach(function (stream) {\n\t        var streamId = MediaStreamManager.streamId(stream);\n\t        this.acquisitions[streamId] = !!isHintStream;\n\t      }, this);\n\t      return SIP.Utils.Promise.resolve(streams);\n\t    }.bind(this);\n\t\n\t    if (mediaHint.stream) {\n\t      return saveSuccess(true, mediaHint.stream);\n\t    } else {\n\t      // Fallback to audio/video enabled if no mediaHint can be found.\n\t      var constraints = mediaHint.constraints ||\n\t        (this.mediaHint && this.mediaHint.constraints) ||\n\t        {audio: true, video: true};\n\t\n\t      var deferred = SIP.Utils.defer();\n\t\n\t      /*\n\t       * Make the call asynchronous, so that ICCs have a chance\n\t       * to define callbacks to `userMediaRequest`\n\t       */\n\t      SIP.Timers.setTimeout(function () {\n\t        this.emit('userMediaRequest', constraints);\n\t\n\t        var emitThenCall = function (eventName, callback) {\n\t          var callbackArgs = Array.prototype.slice.call(arguments, 2);\n\t          // Emit with all of the arguments from the real callback.\n\t          var newArgs = [eventName].concat(callbackArgs);\n\t\n\t          this.emit.apply(this, newArgs);\n\t\n\t          return callback.apply(null, callbackArgs);\n\t        }.bind(this);\n\t\n\t        if (constraints.audio || constraints.video) {\n\t          deferred.resolve(\n\t            SIP.WebRTC.getUserMedia(constraints)\n\t            .then(\n\t              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),\n\t              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})\n\t            )\n\t          );\n\t        } else {\n\t          // Local streams were explicitly excluded.\n\t          deferred.resolve([]);\n\t        }\n\t      }.bind(this), 0);\n\t\n\t      return deferred.promise;\n\t    }\n\t  }},\n\t\n\t  'release': {writable: true, value: function release (streams) {\n\t    streams = [].concat(streams);\n\t    streams.forEach(function (stream) {\n\t      var streamId = MediaStreamManager.streamId(stream);\n\t      if (this.acquisitions[streamId] === false) {\n\t        stream.getTracks().forEach(function (track) {\n\t          track.stop();\n\t        });\n\t      }\n\t      delete this.acquisitions[streamId];\n\t    }, this);\n\t  }},\n\t});\n\t\n\t// Return since it will be assigned to a variable.\n\treturn MediaStreamManager;\n\t};\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP User Agent.\n\t * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]\n\t *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.\n\t *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.\n\t *\n\t * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t */\n\tmodule.exports = function (SIP, environment) {\n\tvar UA,\n\t  C = {\n\t    // UA status codes\n\t    STATUS_INIT:                0,\n\t    STATUS_STARTING:            1,\n\t    STATUS_READY:               2,\n\t    STATUS_USER_CLOSED:         3,\n\t    STATUS_NOT_READY:           4,\n\t\n\t    // UA error codes\n\t    CONFIGURATION_ERROR:  1,\n\t    NETWORK_ERROR:        2,\n\t\n\t    ALLOWED_METHODS: [\n\t      'ACK',\n\t      'CANCEL',\n\t      'INVITE',\n\t      'MESSAGE',\n\t      'BYE',\n\t      'OPTIONS',\n\t      'INFO',\n\t      'NOTIFY',\n\t      'REFER'\n\t    ],\n\t\n\t    ACCEPTED_BODY_TYPES: [\n\t      'application/sdp',\n\t      'application/dtmf-relay'\n\t    ],\n\t\n\t    MAX_FORWARDS: 70,\n\t    TAG_LENGTH: 10\n\t  };\n\t\n\tUA = function(configuration) {\n\t  var self = this;\n\t\n\t  // Helper function for forwarding events\n\t  function selfEmit(type) {\n\t    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n\t    return self.emit.bind(self, type);\n\t  }\n\t\n\t  // Set Accepted Body Types\n\t  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n\t\n\t  this.log = new SIP.LoggerFactory();\n\t  this.logger = this.getLogger('sip.ua');\n\t\n\t  this.cache = {\n\t    credentials: {}\n\t  };\n\t\n\t  this.configuration = {};\n\t  this.dialogs = {};\n\t\n\t  //User actions outside any session/dialog (MESSAGE)\n\t  this.applicants = {};\n\t\n\t  this.data = {};\n\t  this.sessions = {};\n\t  this.subscriptions = {};\n\t  this.transport = null;\n\t  this.contact = null;\n\t  this.status = C.STATUS_INIT;\n\t  this.error = null;\n\t  this.transactions = {\n\t    nist: {},\n\t    nict: {},\n\t    ist: {},\n\t    ict: {}\n\t  };\n\t\n\t  this.transportRecoverAttempts = 0;\n\t  this.transportRecoveryTimer = null;\n\t\n\t  Object.defineProperties(this, {\n\t    transactionsCount: {\n\t      get: function() {\n\t        var type,\n\t          transactions = ['nist','nict','ist','ict'],\n\t          count = 0;\n\t\n\t        for (type in transactions) {\n\t          count += Object.keys(this.transactions[transactions[type]]).length;\n\t        }\n\t\n\t        return count;\n\t      }\n\t    },\n\t\n\t    nictTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['nict']).length;\n\t      }\n\t    },\n\t\n\t    nistTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['nist']).length;\n\t      }\n\t    },\n\t\n\t    ictTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['ict']).length;\n\t      }\n\t    },\n\t\n\t    istTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['ist']).length;\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Load configuration\n\t   *\n\t   * @throws {SIP.Exceptions.ConfigurationError}\n\t   * @throws {TypeError}\n\t   */\n\t\n\t  if(configuration === undefined) {\n\t    configuration = {};\n\t  } else if (typeof configuration === 'string' || configuration instanceof String) {\n\t    configuration = {\n\t      uri: configuration\n\t    };\n\t  }\n\t\n\t  // Apply log configuration if present\n\t  if (configuration.log) {\n\t    if (configuration.log.hasOwnProperty('builtinEnabled')) {\n\t      this.log.builtinEnabled = configuration.log.builtinEnabled;\n\t    }\n\t\n\t    if (configuration.log.hasOwnProperty('level')) {\n\t      this.log.level = configuration.log.level;\n\t    }\n\t\n\t    if (configuration.log.hasOwnProperty('connector')) {\n\t      this.log.connector = configuration.log.connector;\n\t    }\n\t  }\n\t\n\t  try {\n\t    this.loadConfig(configuration);\n\t  } catch(e) {\n\t    this.status = C.STATUS_NOT_READY;\n\t    this.error = C.CONFIGURATION_ERROR;\n\t    throw e;\n\t  }\n\t\n\t  // Initialize registerContext\n\t  this.registerContext = new SIP.RegisterContext(this);\n\t  this.registerContext.on('failed', selfEmit('registrationFailed'));\n\t  this.registerContext.on('registered', selfEmit('registered'));\n\t  this.registerContext.on('unregistered', selfEmit('unregistered'));\n\t\n\t  if(this.configuration.autostart) {\n\t    this.start();\n\t  }\n\t\n\t  if (typeof environment.addEventListener === 'function') {\n\t    // Google Chrome Packaged Apps don't allow 'unload' listeners:\n\t    // unload is not available in packaged apps\n\t    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {\n\t      environment.addEventListener('unload', this.stop.bind(this));\n\t    }\n\t  }\n\t};\n\tUA.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\t//=================\n\t//  High Level API\n\t//=================\n\t\n\tUA.prototype.register = function(options) {\n\t  this.configuration.register = true;\n\t  this.registerContext.register(options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Unregister.\n\t *\n\t * @param {Boolean} [all] unregister all user bindings.\n\t *\n\t */\n\tUA.prototype.unregister = function(options) {\n\t  this.configuration.register = false;\n\t\n\t  var context = this.registerContext;\n\t  this.afterConnected(context.unregister.bind(context, options));\n\t\n\t  return this;\n\t};\n\t\n\tUA.prototype.isRegistered = function() {\n\t  return this.registerContext.registered;\n\t};\n\t\n\t/**\n\t * Connection state.\n\t * @param {Boolean}\n\t */\n\tUA.prototype.isConnected = function() {\n\t  return this.transport ? this.transport.connected : false;\n\t};\n\t\n\tUA.prototype.afterConnected = function afterConnected (callback) {\n\t  if (this.isConnected()) {\n\t    callback();\n\t  } else {\n\t    this.once('connected', callback);\n\t  }\n\t};\n\t\n\t/**\n\t * Make an outgoing call.\n\t *\n\t * @param {String} target\n\t * @param {Object} views\n\t * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t *\n\t * @throws {TypeError}\n\t *\n\t */\n\tUA.prototype.invite = function(target, options) {\n\t  var context = new SIP.InviteClientContext(this, target, options);\n\t\n\t  this.afterConnected(context.invite.bind(context));\n\t  return context;\n\t};\n\t\n\tUA.prototype.subscribe = function(target, event, options) {\n\t  var sub = new SIP.Subscription(this, target, event, options);\n\t\n\t  this.afterConnected(sub.subscribe.bind(sub));\n\t  return sub;\n\t};\n\t\n\t/**\n\t * Send a message.\n\t *\n\t * @param {String} target\n\t * @param {String} body\n\t * @param {Object} [options]\n\t *\n\t * @throws {TypeError}\n\t *\n\t */\n\tUA.prototype.message = function(target, body, options) {\n\t  if (body === undefined) {\n\t    throw new TypeError('Not enough arguments');\n\t  }\n\t\n\t  // There is no Message module, so it is okay that the UA handles defaults here.\n\t  options = Object.create(options || Object.prototype);\n\t  options.contentType || (options.contentType = 'text/plain');\n\t  options.body = body;\n\t\n\t  return this.request(SIP.C.MESSAGE, target, options);\n\t};\n\t\n\tUA.prototype.request = function (method, target, options) {\n\t  var req = new SIP.ClientContext(this, method, target, options);\n\t\n\t  this.afterConnected(req.send.bind(req));\n\t  return req;\n\t};\n\t\n\t/**\n\t * Gracefully close.\n\t *\n\t */\n\tUA.prototype.stop = function() {\n\t  var session, subscription, applicant,\n\t    ua = this;\n\t\n\t  function transactionsListener() {\n\t    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n\t        ua.removeListener('transactionDestroyed', transactionsListener);\n\t        ua.transport.disconnect();\n\t    }\n\t  }\n\t\n\t  this.logger.log('user requested closure...');\n\t\n\t  if(this.status === C.STATUS_USER_CLOSED) {\n\t    this.logger.warn('UA already closed');\n\t    return this;\n\t  }\n\t\n\t  // Clear transportRecoveryTimer\n\t  SIP.Timers.clearTimeout(this.transportRecoveryTimer);\n\t\n\t  // Close registerContext\n\t  this.logger.log('closing registerContext');\n\t  this.registerContext.close();\n\t\n\t  // Run  _terminate_ on every Session\n\t  for(session in this.sessions) {\n\t    this.logger.log('closing session ' + session);\n\t    this.sessions[session].terminate();\n\t  }\n\t\n\t  //Run _close_ on every Subscription\n\t  for(subscription in this.subscriptions) {\n\t    this.logger.log('unsubscribing from subscription ' + subscription);\n\t    this.subscriptions[subscription].close();\n\t  }\n\t\n\t  // Run  _close_ on every applicant\n\t  for(applicant in this.applicants) {\n\t    this.applicants[applicant].close();\n\t  }\n\t\n\t  this.status = C.STATUS_USER_CLOSED;\n\t\n\t  /*\n\t   * If the remaining transactions are all INVITE transactions, there is no need to\n\t   * wait anymore because every session has already been closed by this method.\n\t   * - locally originated sessions where terminated (CANCEL or BYE)\n\t   * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n\t   * Remaining INVITE transactions belong tho sessions that where answered. This are in\n\t   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n\t   */\n\t  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n\t    this.transport.disconnect();\n\t  } else {\n\t    this.on('transactionDestroyed', transactionsListener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Connect to the WS server if status = STATUS_INIT.\n\t * Resume UA after being closed.\n\t *\n\t */\n\tUA.prototype.start = function() {\n\t  var server;\n\t\n\t  this.logger.log('user requested startup...');\n\t  if (this.status === C.STATUS_INIT) {\n\t    server = this.getNextWsServer();\n\t    this.status = C.STATUS_STARTING;\n\t    new SIP.Transport(this, server);\n\t  } else if(this.status === C.STATUS_USER_CLOSED) {\n\t    this.logger.log('resuming');\n\t    this.status = C.STATUS_READY;\n\t    this.transport.connect();\n\t  } else if (this.status === C.STATUS_STARTING) {\n\t    this.logger.log('UA is in STARTING status, not opening new connection');\n\t  } else if (this.status === C.STATUS_READY) {\n\t    this.logger.log('UA is in READY status, not resuming');\n\t  } else {\n\t    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Normalize a string into a valid SIP request URI\n\t *\n\t * @param {String} target\n\t *\n\t * @returns {SIP.URI|undefined}\n\t */\n\tUA.prototype.normalizeTarget = function(target) {\n\t  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n\t};\n\t\n\t\n\t//===============================\n\t//  Private (For internal use)\n\t//===============================\n\t\n\tUA.prototype.saveCredentials = function(credentials) {\n\t  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n\t  this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n\t\n\t  return this;\n\t};\n\t\n\tUA.prototype.getCredentials = function(request) {\n\t  var realm, credentials;\n\t\n\t  realm = request.ruri.host;\n\t\n\t  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n\t    credentials = this.cache.credentials[realm][request.ruri];\n\t    credentials.method = request.method;\n\t  }\n\t\n\t  return credentials;\n\t};\n\t\n\tUA.prototype.getLogger = function(category, label) {\n\t  return this.log.getLogger(category, label);\n\t};\n\t\n\t\n\t//==============================\n\t// Event Handlers\n\t//==============================\n\t\n\t/**\n\t * Transport Close event\n\t * @private\n\t * @event\n\t * @param {SIP.Transport} transport.\n\t */\n\tUA.prototype.onTransportClosed = function(transport) {\n\t  // Run _onTransportError_ callback on every client transaction using _transport_\n\t  var type, idx, length,\n\t    client_transactions = ['nict', 'ict', 'nist', 'ist'];\n\t\n\t  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;\n\t  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);\n\t\n\t  length = client_transactions.length;\n\t  for (type = 0; type < length; type++) {\n\t    for(idx in this.transactions[client_transactions[type]]) {\n\t      this.transactions[client_transactions[type]][idx].onTransportError();\n\t    }\n\t  }\n\t\n\t  // Close sessions if GRUU is not being used\n\t  if (!this.contact.pub_gruu) {\n\t    this.closeSessionsOnTransportError();\n\t  }\n\t\n\t};\n\t\n\t/**\n\t * Unrecoverable transport event.\n\t * Connection reattempt logic has been done and didn't success.\n\t * @private\n\t * @event\n\t * @param {SIP.Transport} transport.\n\t */\n\tUA.prototype.onTransportError = function(transport) {\n\t  var server;\n\t\n\t  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);\n\t\n\t  // Close sessions.\n\t  //Mark this transport as 'down'\n\t  transport.server.status = SIP.Transport.C.STATUS_ERROR;\n\t\n\t  this.emit('disconnected', {\n\t    transport: transport\n\t  });\n\t\n\t  // try the next transport if the UA isn't closed\n\t  if(this.status === C.STATUS_USER_CLOSED) {\n\t    return;\n\t  }\n\t\n\t  server = this.getNextWsServer();\n\t\n\t  if(server) {\n\t    new SIP.Transport(this, server);\n\t  }else {\n\t    this.closeSessionsOnTransportError();\n\t    if (!this.error || this.error !== C.NETWORK_ERROR) {\n\t      this.status = C.STATUS_NOT_READY;\n\t      this.error = C.NETWORK_ERROR;\n\t    }\n\t    // Transport Recovery process\n\t    this.recoverTransport();\n\t  }\n\t};\n\t\n\t/**\n\t * Transport connection event.\n\t * @private\n\t * @event\n\t * @param {SIP.Transport} transport.\n\t */\n\tUA.prototype.onTransportConnected = function(transport) {\n\t  this.transport = transport;\n\t\n\t  // Reset transport recovery counter\n\t  this.transportRecoverAttempts = 0;\n\t\n\t  transport.server.status = SIP.Transport.C.STATUS_READY;\n\t  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);\n\t\n\t  if(this.status === C.STATUS_USER_CLOSED) {\n\t    return;\n\t  }\n\t\n\t  this.status = C.STATUS_READY;\n\t  this.error = null;\n\t\n\t  if(this.configuration.register) {\n\t    this.configuration.authenticationFactory.initialize().then(function () {\n\t      this.registerContext.onTransportConnected();\n\t    }.bind(this));\n\t  }\n\t\n\t  this.emit('connected', {\n\t    transport: transport\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Transport connecting event\n\t * @private\n\t * @param {SIP.Transport} transport.\n\t * #param {Integer} attempts.\n\t */\n\t  UA.prototype.onTransportConnecting = function(transport, attempts) {\n\t    this.emit('connecting', {\n\t      transport: transport,\n\t      attempts: attempts\n\t    });\n\t  };\n\t\n\t\n\t/**\n\t * new Transaction\n\t * @private\n\t * @param {SIP.Transaction} transaction.\n\t */\n\tUA.prototype.newTransaction = function(transaction) {\n\t  this.transactions[transaction.type][transaction.id] = transaction;\n\t  this.emit('newTransaction', {transaction: transaction});\n\t};\n\t\n\t\n\t/**\n\t * destroy Transaction\n\t * @private\n\t * @param {SIP.Transaction} transaction.\n\t */\n\tUA.prototype.destroyTransaction = function(transaction) {\n\t  delete this.transactions[transaction.type][transaction.id];\n\t  this.emit('transactionDestroyed', {\n\t    transaction: transaction\n\t  });\n\t};\n\t\n\t\n\t//=========================\n\t// receiveRequest\n\t//=========================\n\t\n\t/**\n\t * Request reception\n\t * @private\n\t * @param {SIP.IncomingRequest} request.\n\t */\n\tUA.prototype.receiveRequest = function(request) {\n\t  var dialog, session, message,\n\t    method = request.method,\n\t    transaction,\n\t    replaces,\n\t    replacedDialog,\n\t    self = this;\n\t\n\t  function ruriMatches (uri) {\n\t    return uri && uri.user === request.ruri.user;\n\t  }\n\t\n\t  // Check that request URI points to us\n\t  if(!(ruriMatches(this.configuration.uri) ||\n\t       ruriMatches(this.contact.uri) ||\n\t       ruriMatches(this.contact.pub_gruu) ||\n\t       ruriMatches(this.contact.temp_gruu))) {\n\t    this.logger.warn('Request-URI does not point to us');\n\t    if (request.method !== SIP.C.ACK) {\n\t      request.reply_sl(404);\n\t    }\n\t    return;\n\t  }\n\t\n\t  // Check request URI scheme\n\t  if(request.ruri.scheme === SIP.C.SIPS) {\n\t    request.reply_sl(416);\n\t    return;\n\t  }\n\t\n\t  // Check transaction\n\t  if(SIP.Transactions.checkTransaction(this, request)) {\n\t    return;\n\t  }\n\t\n\t  /* RFC3261 12.2.2\n\t   * Requests that do not change in any way the state of a dialog may be\n\t   * received within a dialog (for example, an OPTIONS request).\n\t   * They are processed as if they had been received outside the dialog.\n\t   */\n\t  if(method === SIP.C.OPTIONS) {\n\t    new SIP.Transactions.NonInviteServerTransaction(request, this);\n\t    request.reply(200, null, [\n\t      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),\n\t      'Accept: '+ C.ACCEPTED_BODY_TYPES\n\t    ]);\n\t  } else if (method === SIP.C.MESSAGE) {\n\t    message = new SIP.ServerContext(this, request);\n\t    message.body = request.body;\n\t    message.content_type = request.getHeader('Content-Type') || 'text/plain';\n\t\n\t    request.reply(200, null);\n\t    this.emit('message', message);\n\t  } else if (method !== SIP.C.INVITE &&\n\t             method !== SIP.C.ACK) {\n\t    // Let those methods pass through to normal processing for now.\n\t    transaction = new SIP.ServerContext(this, request);\n\t  }\n\t\n\t  // Initial Request\n\t  if(!request.to_tag) {\n\t    switch(method) {\n\t      case SIP.C.INVITE:\n\t        replaces =\n\t          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&\n\t          request.parseHeader('replaces');\n\t\n\t        if (replaces) {\n\t          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];\n\t\n\t          if (!replacedDialog) {\n\t            //Replaced header without a matching dialog, reject\n\t            request.reply_sl(481, null);\n\t            return;\n\t          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {\n\t            request.reply_sl(603, null);\n\t            return;\n\t          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {\n\t            request.reply_sl(486, null);\n\t            return;\n\t          }\n\t        }\n\t\n\t        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;\n\t        if(!isMediaSupported || isMediaSupported()) {\n\t          session = new SIP.InviteServerContext(this, request);\n\t          session.replacee = replacedDialog && replacedDialog.owner;\n\t          session.on('invite', function() {\n\t            self.emit('invite', this);\n\t          });\n\t        } else {\n\t          this.logger.warn('INVITE received but WebRTC is not supported');\n\t          request.reply(488);\n\t        }\n\t        break;\n\t      case SIP.C.BYE:\n\t        // Out of dialog BYE received\n\t        request.reply(481);\n\t        break;\n\t      case SIP.C.CANCEL:\n\t        session = this.findSession(request);\n\t        if(session) {\n\t          session.receiveRequest(request);\n\t        } else {\n\t          this.logger.warn('received CANCEL request for a non existent session');\n\t        }\n\t        break;\n\t      case SIP.C.ACK:\n\t        /* Absorb it.\n\t         * ACK request without a corresponding Invite Transaction\n\t         * and without To tag.\n\t         */\n\t        break;\n\t      default:\n\t        request.reply(405);\n\t        break;\n\t    }\n\t  }\n\t  // In-dialog request\n\t  else {\n\t    dialog = this.findDialog(request);\n\t\n\t    if(dialog) {\n\t      if (method === SIP.C.INVITE) {\n\t        new SIP.Transactions.InviteServerTransaction(request, this);\n\t      }\n\t      dialog.receiveRequest(request);\n\t    } else if (method === SIP.C.NOTIFY) {\n\t      session = this.findSession(request);\n\t      if(session) {\n\t        session.receiveRequest(request);\n\t      } else {\n\t        this.logger.warn('received NOTIFY request for a non existent session');\n\t        request.reply(481, 'Subscription does not exist');\n\t      }\n\t    }\n\t    /* RFC3261 12.2.2\n\t     * Request with to tag, but no matching dialog found.\n\t     * Exception: ACK for an Invite request for which a dialog has not\n\t     * been created.\n\t     */\n\t    else {\n\t      if(method !== SIP.C.ACK) {\n\t        request.reply(481);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t//=================\n\t// Utils\n\t//=================\n\t\n\t/**\n\t * Get the session to which the request belongs to, if any.\n\t * @private\n\t * @param {SIP.IncomingRequest} request.\n\t * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n\t */\n\tUA.prototype.findSession = function(request) {\n\t  return this.sessions[request.call_id + request.from_tag] ||\n\t          this.sessions[request.call_id + request.to_tag] ||\n\t          null;\n\t};\n\t\n\t/**\n\t * Get the dialog to which the request belongs to, if any.\n\t * @private\n\t * @param {SIP.IncomingRequest}\n\t * @returns {SIP.Dialog|null}\n\t */\n\tUA.prototype.findDialog = function(request) {\n\t  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||\n\t          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||\n\t          null;\n\t};\n\t\n\t/**\n\t * Retrieve the next server to which connect.\n\t * @private\n\t * @returns {Object} ws_server\n\t */\n\tUA.prototype.getNextWsServer = function() {\n\t  // Order servers by weight\n\t  var idx, length, ws_server,\n\t    candidates = [];\n\t\n\t  length = this.configuration.wsServers.length;\n\t  for (idx = 0; idx < length; idx++) {\n\t    ws_server = this.configuration.wsServers[idx];\n\t\n\t    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {\n\t      continue;\n\t    } else if (candidates.length === 0) {\n\t      candidates.push(ws_server);\n\t    } else if (ws_server.weight > candidates[0].weight) {\n\t      candidates = [ws_server];\n\t    } else if (ws_server.weight === candidates[0].weight) {\n\t      candidates.push(ws_server);\n\t    }\n\t  }\n\t\n\t  idx = Math.floor(Math.random() * candidates.length);\n\t\n\t  return candidates[idx];\n\t};\n\t\n\t/**\n\t * Close all sessions on transport error.\n\t * @private\n\t */\n\tUA.prototype.closeSessionsOnTransportError = function() {\n\t  var idx;\n\t\n\t  // Run _transportError_ for every Session\n\t  for(idx in this.sessions) {\n\t    this.sessions[idx].onTransportError();\n\t  }\n\t  // Call registerContext _onTransportClosed_\n\t  this.registerContext.onTransportClosed();\n\t};\n\t\n\tUA.prototype.recoverTransport = function(ua) {\n\t  var idx, length, k, nextRetry, count, server;\n\t\n\t  ua = ua || this;\n\t  count = ua.transportRecoverAttempts;\n\t\n\t  length = ua.configuration.wsServers.length;\n\t  for (idx = 0; idx < length; idx++) {\n\t    ua.configuration.wsServers[idx].status = 0;\n\t  }\n\t\n\t  server = ua.getNextWsServer();\n\t\n\t  k = Math.floor((Math.random() * Math.pow(2,count)) +1);\n\t  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;\n\t\n\t  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {\n\t    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');\n\t    nextRetry = ua.configuration.connectionRecoveryMinInterval;\n\t    count = 0;\n\t  }\n\t\n\t  this.logger.log('next connection attempt in '+ nextRetry +' seconds');\n\t\n\t  this.transportRecoveryTimer = SIP.Timers.setTimeout(\n\t    function(){\n\t      ua.transportRecoverAttempts = count + 1;\n\t      new SIP.Transport(ua, server);\n\t    }, nextRetry * 1000);\n\t};\n\t\n\tfunction checkAuthenticationFactory (authenticationFactory) {\n\t  if (!(authenticationFactory instanceof Function)) {\n\t    return;\n\t  }\n\t  if (!authenticationFactory.initialize) {\n\t    authenticationFactory.initialize = function initialize () {\n\t      return SIP.Utils.Promise.resolve();\n\t    };\n\t  }\n\t  return authenticationFactory;\n\t}\n\t\n\t/**\n\t * Configuration load.\n\t * @private\n\t * returns {Boolean}\n\t */\n\tUA.prototype.loadConfig = function(configuration) {\n\t  // Settings and default values\n\t  var parameter, value, checked_value, hostportParams, registrarServer,\n\t    settings = {\n\t      /* Host address\n\t      * Value to be set in Via sent_by and host part of Contact FQDN\n\t      */\n\t      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n\t\n\t      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n\t      wsServers: [{\n\t        scheme: 'WSS',\n\t        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n\t        status: 0,\n\t        weight: 0,\n\t        ws_uri: 'wss://edge.sip.onsip.com'\n\t      }],\n\t\n\t      // Password\n\t      password: null,\n\t\n\t      // Registration parameters\n\t      registerExpires: 600,\n\t      register: true,\n\t      registrarServer: null,\n\t\n\t      // Transport related parameters\n\t      wsServerMaxReconnection: 3,\n\t      wsServerReconnectionTimeout: 4,\n\t\n\t      connectionRecoveryMinInterval: 2,\n\t      connectionRecoveryMaxInterval: 30,\n\t\n\t      keepAliveInterval: 0,\n\t\n\t      extraSupported: [],\n\t\n\t      usePreloadedRoute: false,\n\t\n\t      //string to be inserted into User-Agent request header\n\t      userAgentString: SIP.C.USER_AGENT,\n\t\n\t      // Session parameters\n\t      iceCheckingTimeout: 5000,\n\t      noAnswerTimeout: 60,\n\t      stunServers: ['stun:stun.l.google.com:19302'],\n\t      turnServers: [],\n\t\n\t      // Logging parameters\n\t      traceSip: false,\n\t\n\t      // Hacks\n\t      hackViaTcp: false,\n\t      hackIpInContact: false,\n\t      hackWssInTransport: false,\n\t      hackAllowUnregisteredOptionTags: false,\n\t\n\t      contactTransport: 'ws',\n\t      forceRport: false,\n\t\n\t      //autostarting\n\t      autostart: true,\n\t\n\t      //Reliable Provisional Responses\n\t      rel100: SIP.C.supported.UNSUPPORTED,\n\t\n\t      // Replaces header (RFC 3891)\n\t      // http://tools.ietf.org/html/rfc3891\n\t      replaces: SIP.C.supported.UNSUPPORTED,\n\t\n\t      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,\n\t\n\t      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {\n\t        return new SIP.DigestAuthentication(ua);\n\t      })\n\t    };\n\t\n\t  // Pre-Configuration\n\t  function aliasUnderscored (parameter, logger) {\n\t    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n\t      return m[0] + '_' + m[1].toLowerCase();\n\t    });\n\t\n\t    if (parameter === underscored) {\n\t      return;\n\t    }\n\t\n\t    var hasParameter = configuration.hasOwnProperty(parameter);\n\t    if (configuration.hasOwnProperty(underscored)) {\n\t      logger.warn(underscored + ' is deprecated, please use ' + parameter);\n\t      if (hasParameter) {\n\t        logger.warn(parameter + ' overriding ' + underscored);\n\t      }\n\t    }\n\t\n\t    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n\t  }\n\t\n\t  // Check Mandatory parameters\n\t  for(parameter in UA.configuration_check.mandatory) {\n\t    aliasUnderscored(parameter, this.logger);\n\t    if(!configuration.hasOwnProperty(parameter)) {\n\t      throw new SIP.Exceptions.ConfigurationError(parameter);\n\t    } else {\n\t      value = configuration[parameter];\n\t      checked_value = UA.configuration_check.mandatory[parameter](value);\n\t      if (checked_value !== undefined) {\n\t        settings[parameter] = checked_value;\n\t      } else {\n\t        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n\t      }\n\t    }\n\t  }\n\t\n\t  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);\n\t\n\t  var emptyArraysAllowed = ['stunServers', 'turnServers'];\n\t\n\t  // Check Optional parameters\n\t  for(parameter in UA.configuration_check.optional) {\n\t    aliasUnderscored(parameter, this.logger);\n\t    if(configuration.hasOwnProperty(parameter)) {\n\t      value = configuration[parameter];\n\t\n\t      // If the parameter value is an empty array, but shouldn't be, apply its default value.\n\t      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }\n\t\n\t      // If the parameter value is null, empty string, or undefined then apply its default value.\n\t      if(value === null || value === \"\" || value === undefined) { continue; }\n\t      // If it's a number with NaN value then also apply its default value.\n\t      // NOTE: JS does not allow \"value === NaN\", the following does the work:\n\t      else if(typeof(value) === 'number' && isNaN(value)) { continue; }\n\t\n\t      checked_value = UA.configuration_check.optional[parameter](value);\n\t      if (checked_value !== undefined) {\n\t        settings[parameter] = checked_value;\n\t      } else {\n\t        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Sanity Checks\n\t\n\t  // Connection recovery intervals\n\t  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {\n\t    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);\n\t  }\n\t\n\t  // Post Configuration Process\n\t\n\t  // Allow passing 0 number as displayName.\n\t  if (settings.displayName === 0) {\n\t    settings.displayName = '0';\n\t  }\n\t\n\t  // Instance-id for GRUU\n\t  if (!settings.instanceId) {\n\t    settings.instanceId = SIP.Utils.newUUID();\n\t  }\n\t\n\t  // sipjsId instance parameter. Static random tag of length 5\n\t  settings.sipjsId = SIP.Utils.createRandomToken(5);\n\t\n\t  // String containing settings.uri without scheme and user.\n\t  hostportParams = settings.uri.clone();\n\t  hostportParams.user = null;\n\t  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');\n\t\n\t  /* Check whether authorizationUser is explicitly defined.\n\t   * Take 'settings.uri.user' value if not.\n\t   */\n\t  if (!settings.authorizationUser) {\n\t    settings.authorizationUser = settings.uri.user;\n\t  }\n\t\n\t  /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n\t  if (!settings.registrarServer) {\n\t    registrarServer = settings.uri.clone();\n\t    registrarServer.user = null;\n\t    settings.registrarServer = registrarServer;\n\t  }\n\t\n\t  // User noAnswerTimeout\n\t  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;\n\t\n\t  // Via Host\n\t  if (settings.hackIpInContact) {\n\t    if (typeof settings.hackIpInContact === 'boolean') {\n\t      settings.viaHost = SIP.Utils.getRandomTestNetIP();\n\t    }\n\t    else if (typeof settings.hackIpInContact === 'string') {\n\t      settings.viaHost = settings.hackIpInContact;\n\t    }\n\t  }\n\t\n\t  // Contact transport parameter\n\t  if (settings.hackWssInTransport) {\n\t    settings.contactTransport = 'wss';\n\t  }\n\t\n\t  this.contact = {\n\t    pub_gruu: null,\n\t    temp_gruu: null,\n\t    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),\n\t    toString: function(options){\n\t      options = options || {};\n\t\n\t      var\n\t        anonymous = options.anonymous || null,\n\t        outbound = options.outbound || null,\n\t        contact = '<';\n\t\n\t      if (anonymous) {\n\t        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();\n\t      } else {\n\t        contact += (this.pub_gruu || this.uri).toString();\n\t      }\n\t\n\t      if (outbound) {\n\t        contact += ';ob';\n\t      }\n\t\n\t      contact += '>';\n\t\n\t      return contact;\n\t    }\n\t  };\n\t\n\t  // media overrides mediaConstraints\n\t  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);\n\t\n\t  // Fill the value of the configuration_skeleton\n\t  for(parameter in settings) {\n\t    UA.configuration_skeleton[parameter].value = settings[parameter];\n\t  }\n\t\n\t  Object.defineProperties(this.configuration, UA.configuration_skeleton);\n\t\n\t  // Clean UA.configuration_skeleton\n\t  for(parameter in settings) {\n\t    UA.configuration_skeleton[parameter].value = '';\n\t  }\n\t\n\t  this.logger.log('configuration parameters after validation:');\n\t  for(parameter in settings) {\n\t    switch(parameter) {\n\t      case 'uri':\n\t      case 'registrarServer':\n\t      case 'mediaHandlerFactory':\n\t        this.logger.log(' ' + parameter + ': ' + settings[parameter]);\n\t        break;\n\t      case 'password':\n\t        this.logger.log(' ' + parameter + ': ' + 'NOT SHOWN');\n\t        break;\n\t      default:\n\t        this.logger.log(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n\t    }\n\t  }\n\t\n\t  return;\n\t};\n\t\n\t/**\n\t * Configuration Object skeleton.\n\t * @private\n\t */\n\tUA.configuration_skeleton = (function() {\n\t  var idx,  parameter,\n\t    skeleton = {},\n\t    parameters = [\n\t      // Internal parameters\n\t      \"sipjsId\",\n\t      \"hostportParams\",\n\t\n\t      // Optional user configurable parameters\n\t      \"uri\",\n\t      \"wsServers\",\n\t      \"authorizationUser\",\n\t      \"connectionRecoveryMaxInterval\",\n\t      \"connectionRecoveryMinInterval\",\n\t      \"keepAliveInterval\",\n\t      \"extraSupported\",\n\t      \"displayName\",\n\t      \"hackViaTcp\", // false.\n\t      \"hackIpInContact\", //false\n\t      \"hackWssInTransport\", //false\n\t      \"hackAllowUnregisteredOptionTags\", //false\n\t      \"contactTransport\", // 'ws'\n\t      \"forceRport\", // false\n\t      \"iceCheckingTimeout\",\n\t      \"instanceId\",\n\t      \"noAnswerTimeout\", // 30 seconds.\n\t      \"password\",\n\t      \"registerExpires\", // 600 seconds.\n\t      \"registrarServer\",\n\t      \"reliable\",\n\t      \"rel100\",\n\t      \"replaces\",\n\t      \"userAgentString\", //SIP.C.USER_AGENT\n\t      \"autostart\",\n\t      \"stunServers\",\n\t      \"traceSip\",\n\t      \"turnServers\",\n\t      \"usePreloadedRoute\",\n\t      \"wsServerMaxReconnection\",\n\t      \"wsServerReconnectionTimeout\",\n\t      \"mediaHandlerFactory\",\n\t      \"media\",\n\t      \"mediaConstraints\",\n\t      \"authenticationFactory\",\n\t\n\t      // Post-configuration generated parameters\n\t      \"via_core_value\",\n\t      \"viaHost\"\n\t    ];\n\t\n\t  for(idx in parameters) {\n\t    parameter = parameters[idx];\n\t    skeleton[parameter] = {\n\t      value: '',\n\t      writable: false,\n\t      configurable: false\n\t    };\n\t  }\n\t\n\t  skeleton['register'] = {\n\t    value: '',\n\t    writable: true,\n\t    configurable: false\n\t  };\n\t\n\t  return skeleton;\n\t}());\n\t\n\t/**\n\t * Configuration checker.\n\t * @private\n\t * @return {Boolean}\n\t */\n\tUA.configuration_check = {\n\t  mandatory: {\n\t  },\n\t\n\t  optional: {\n\t\n\t    uri: function(uri) {\n\t      var parsed;\n\t\n\t      if (!(/^sip:/i).test(uri)) {\n\t        uri = SIP.C.SIP + ':' + uri;\n\t      }\n\t      parsed = SIP.URI.parse(uri);\n\t\n\t      if(!parsed) {\n\t        return;\n\t      } else if(!parsed.user) {\n\t        return;\n\t      } else {\n\t        return parsed;\n\t      }\n\t    },\n\t\n\t    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n\t    wsServers: function(wsServers) {\n\t      var idx, length, url;\n\t\n\t      /* Allow defining wsServers parameter as:\n\t       *  String: \"host\"\n\t       *  Array of Strings: [\"host1\", \"host2\"]\n\t       *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n\t       *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n\t       */\n\t      if (typeof wsServers === 'string') {\n\t        wsServers = [{ws_uri: wsServers}];\n\t      } else if (wsServers instanceof Array) {\n\t        length = wsServers.length;\n\t        for (idx = 0; idx < length; idx++) {\n\t          if (typeof wsServers[idx] === 'string'){\n\t            wsServers[idx] = {ws_uri: wsServers[idx]};\n\t          }\n\t        }\n\t      } else {\n\t        return;\n\t      }\n\t\n\t      if (wsServers.length === 0) {\n\t        return false;\n\t      }\n\t\n\t      length = wsServers.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        if (!wsServers[idx].ws_uri) {\n\t          return;\n\t        }\n\t        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {\n\t          return;\n\t        }\n\t\n\t        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');\n\t\n\t        if(url === -1) {\n\t          return;\n\t        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {\n\t          return;\n\t        } else {\n\t          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';\n\t\n\t          if (!wsServers[idx].weight) {\n\t            wsServers[idx].weight = 0;\n\t          }\n\t\n\t          wsServers[idx].status = 0;\n\t          wsServers[idx].scheme = url.scheme.toUpperCase();\n\t        }\n\t      }\n\t      return wsServers;\n\t    },\n\t\n\t    authorizationUser: function(authorizationUser) {\n\t      if(SIP.Grammar.parse('\"'+ authorizationUser +'\"', 'quoted_string') === -1) {\n\t        return;\n\t      } else {\n\t        return authorizationUser;\n\t      }\n\t    },\n\t\n\t    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {\n\t      var value;\n\t      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {\n\t        value = Number(connectionRecoveryMaxInterval);\n\t        if(value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {\n\t      var value;\n\t      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {\n\t        value = Number(connectionRecoveryMinInterval);\n\t        if(value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    displayName: function(displayName) {\n\t      if(SIP.Grammar.parse('\"' + displayName + '\"', 'displayName') === -1) {\n\t        return;\n\t      } else {\n\t        return displayName;\n\t      }\n\t    },\n\t\n\t    hackViaTcp: function(hackViaTcp) {\n\t      if (typeof hackViaTcp === 'boolean') {\n\t        return hackViaTcp;\n\t      }\n\t    },\n\t\n\t    hackIpInContact: function(hackIpInContact) {\n\t      if (typeof hackIpInContact === 'boolean') {\n\t        return hackIpInContact;\n\t      }\n\t      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {\n\t        return hackIpInContact;\n\t      }\n\t    },\n\t\n\t    iceCheckingTimeout: function(iceCheckingTimeout) {\n\t      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {\n\t        return Math.max(500, iceCheckingTimeout);\n\t      }\n\t    },\n\t\n\t    hackWssInTransport: function(hackWssInTransport) {\n\t      if (typeof hackWssInTransport === 'boolean') {\n\t        return hackWssInTransport;\n\t      }\n\t    },\n\t\n\t    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {\n\t      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {\n\t        return hackAllowUnregisteredOptionTags;\n\t      }\n\t    },\n\t\n\t    contactTransport: function(contactTransport) {\n\t      if (typeof contactTransport === 'string') {\n\t        return contactTransport;\n\t      }\n\t    },\n\t\n\t    forceRport: function(forceRport) {\n\t      if (typeof forceRport === 'boolean') {\n\t        return forceRport;\n\t      }\n\t    },\n\t\n\t    instanceId: function(instanceId) {\n\t      if(typeof instanceId !== 'string') {\n\t        return;\n\t      }\n\t\n\t      if ((/^uuid:/i.test(instanceId))) {\n\t        instanceId = instanceId.substr(5);\n\t      }\n\t\n\t      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {\n\t        return;\n\t      } else {\n\t        return instanceId;\n\t      }\n\t    },\n\t\n\t    keepAliveInterval: function(keepAliveInterval) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(keepAliveInterval)) {\n\t        value = Number(keepAliveInterval);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    extraSupported: function(optionTags) {\n\t      var idx, length;\n\t\n\t      if (!(optionTags instanceof Array)) {\n\t        return;\n\t      }\n\t\n\t      length = optionTags.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        if (typeof optionTags[idx] !== 'string') {\n\t          return;\n\t        }\n\t      }\n\t\n\t      return optionTags;\n\t    },\n\t\n\t    noAnswerTimeout: function(noAnswerTimeout) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(noAnswerTimeout)) {\n\t        value = Number(noAnswerTimeout);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    password: function(password) {\n\t      return String(password);\n\t    },\n\t\n\t    rel100: function(rel100) {\n\t      if(rel100 === SIP.C.supported.REQUIRED) {\n\t        return SIP.C.supported.REQUIRED;\n\t      } else if (rel100 === SIP.C.supported.SUPPORTED) {\n\t        return SIP.C.supported.SUPPORTED;\n\t      } else  {\n\t        return SIP.C.supported.UNSUPPORTED;\n\t      }\n\t    },\n\t\n\t    replaces: function(replaces) {\n\t      if(replaces === SIP.C.supported.REQUIRED) {\n\t        return SIP.C.supported.REQUIRED;\n\t      } else if (replaces === SIP.C.supported.SUPPORTED) {\n\t        return SIP.C.supported.SUPPORTED;\n\t      } else  {\n\t        return SIP.C.supported.UNSUPPORTED;\n\t      }\n\t    },\n\t\n\t    register: function(register) {\n\t      if (typeof register === 'boolean') {\n\t        return register;\n\t      }\n\t    },\n\t\n\t    registerExpires: function(registerExpires) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(registerExpires)) {\n\t        value = Number(registerExpires);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    registrarServer: function(registrarServer) {\n\t      var parsed;\n\t\n\t      if(typeof registrarServer !== 'string') {\n\t        return;\n\t      }\n\t\n\t      if (!/^sip:/i.test(registrarServer)) {\n\t        registrarServer = SIP.C.SIP + ':' + registrarServer;\n\t      }\n\t      parsed = SIP.URI.parse(registrarServer);\n\t\n\t      if(!parsed) {\n\t        return;\n\t      } else if(parsed.user) {\n\t        return;\n\t      } else {\n\t        return parsed;\n\t      }\n\t    },\n\t\n\t    stunServers: function(stunServers) {\n\t      var idx, length, stun_server;\n\t\n\t      if (typeof stunServers === 'string') {\n\t        stunServers = [stunServers];\n\t      } else if (!(stunServers instanceof Array)) {\n\t        return;\n\t      }\n\t\n\t      length = stunServers.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        stun_server = stunServers[idx];\n\t        if (!(/^stuns?:/.test(stun_server))) {\n\t          stun_server = 'stun:' + stun_server;\n\t        }\n\t\n\t        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {\n\t          return;\n\t        } else {\n\t          stunServers[idx] = stun_server;\n\t        }\n\t      }\n\t      return stunServers;\n\t    },\n\t\n\t    traceSip: function(traceSip) {\n\t      if (typeof traceSip === 'boolean') {\n\t        return traceSip;\n\t      }\n\t    },\n\t\n\t    turnServers: function(turnServers) {\n\t      var idx, jdx, length, turn_server, num_turn_server_urls, url;\n\t\n\t      if (turnServers instanceof Array) {\n\t        // Do nothing\n\t      } else {\n\t        turnServers = [turnServers];\n\t      }\n\t\n\t      length = turnServers.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        turn_server = turnServers[idx];\n\t        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.\n\t        if (turn_server.server) {\n\t          turn_server.urls = [turn_server.server];\n\t        }\n\t\n\t        if (!turn_server.urls || !turn_server.username || !turn_server.password) {\n\t          return;\n\t        }\n\t\n\t        if (turn_server.urls instanceof Array) {\n\t          num_turn_server_urls = turn_server.urls.length;\n\t        } else {\n\t          turn_server.urls = [turn_server.urls];\n\t          num_turn_server_urls = 1;\n\t        }\n\t\n\t        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {\n\t          url = turn_server.urls[jdx];\n\t\n\t          if (!(/^turns?:/.test(url))) {\n\t            url = 'turn:' + url;\n\t          }\n\t\n\t          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {\n\t            return;\n\t          }\n\t        }\n\t      }\n\t      return turnServers;\n\t    },\n\t\n\t    userAgentString: function(userAgentString) {\n\t      if (typeof userAgentString === 'string') {\n\t        return userAgentString;\n\t      }\n\t    },\n\t\n\t    usePreloadedRoute: function(usePreloadedRoute) {\n\t      if (typeof usePreloadedRoute === 'boolean') {\n\t        return usePreloadedRoute;\n\t      }\n\t    },\n\t\n\t    wsServerMaxReconnection: function(wsServerMaxReconnection) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {\n\t        value = Number(wsServerMaxReconnection);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {\n\t        value = Number(wsServerReconnectionTimeout);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    autostart: function(autostart) {\n\t      if (typeof autostart === 'boolean') {\n\t        return autostart;\n\t      }\n\t    },\n\t\n\t    mediaHandlerFactory: function(mediaHandlerFactory) {\n\t      if (mediaHandlerFactory instanceof Function) {\n\t        var promisifiedFactory = function promisifiedFactory () {\n\t          var mediaHandler = mediaHandlerFactory.apply(this, arguments);\n\t\n\t          function patchMethod (methodName) {\n\t            var method = mediaHandler[methodName];\n\t            if (method.length > 1) {\n\t              var callbacksFirst = methodName === 'getDescription';\n\t              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);\n\t            }\n\t          }\n\t\n\t          patchMethod('getDescription');\n\t          patchMethod('setDescription');\n\t\n\t          return mediaHandler;\n\t        };\n\t\n\t        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;\n\t        return promisifiedFactory;\n\t      }\n\t    },\n\t\n\t    authenticationFactory: checkAuthenticationFactory\n\t  }\n\t};\n\t\n\tUA.C = C;\n\tSIP.UA = UA;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Hacks - This file contains all of the things we\n\t * wish we didn't have to do, just for interop.  It is similar to\n\t * Utils, which provides actually useful and relevant functions for\n\t * a SIP library. Methods in this file are grouped by vendor, so\n\t * as to most easily track when particular hacks may not be necessary anymore.\n\t */\n\t\n\tmodule.exports = function (SIP) {\n\t\n\t//keep to quiet jshint, and remain consistent with other files\n\tSIP = SIP;\n\t\n\tvar Hacks = {\n\t  AllBrowsers: {\n\t    maskDtls: function (message) {\n\t      if (message.body) {\n\t        message.body = message.body.replace(/ UDP\\/TLS\\/RTP\\/SAVP/gmi, \" RTP/SAVP\");\n\t      }\n\t    },\n\t    unmaskDtls: function (sdp) {\n\t      /**\n\t       * Chrome does not handle DTLS correctly (Canaray does, but not production)\n\t       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)\n\t       *\n\t       * UPDATE: May 21, 2014\n\t       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES\n\t       *\n\t       * UPDATE: 2014-09-24\n\t       * Opera now supports DTLS by default as well.\n\t       *\n\t       **/\n\t      return sdp.replace(/ RTP\\/SAVP/gmi, \" UDP/TLS/RTP/SAVP\");\n\t    }\n\t  },\n\t  Firefox: {\n\t    /* Condition to detect if hacks are applicable */\n\t    isFirefox: function () {\n\t      return typeof mozRTCPeerConnection !== 'undefined';\n\t    },\n\t\n\t    cannotHandleExtraWhitespace: function (message) {\n\t      if (this.isFirefox() && message.body) {\n\t        message.body = message.body.replace(/ \\r\\n/g, \"\\r\\n\");\n\t      }\n\t    },\n\t\n\t    hasMissingCLineInSDP: function (sdp) {\n\t      /*\n\t       * This is a Firefox hack to insert valid sdp when getDescription is\n\t       * called with the constraint offerToReceiveVideo = false.\n\t       * We search for either a c-line at the top of the sdp above all\n\t       * m-lines. If that does not exist then we search for a c-line\n\t       * beneath each m-line. If it is missing a c-line, we insert\n\t       * a fake c-line with the ip address 0.0.0.0. This is then valid\n\t       * sdp and no media will be sent for that m-line.\n\t       *\n\t       * Valid SDP is:\n\t       * m=\n\t       * i=\n\t       * c=\n\t       */\n\t      var insertAt, mlines;\n\t      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {\n\t\n\t        // Find all m= lines\n\t        mlines = sdp.match(/m=.*\\r\\n.*/g);\n\t        for (var i=0; i<mlines.length; i++) {\n\t\n\t          // If it has an i= line, check if the next line is the c= line\n\t          if (mlines[i].toString().search(/i=.*/) >= 0) {\n\t            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;\n\t            if (sdp.substr(insertAt,2)!=='c=') {\n\t              sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n\t            }\n\t\n\t          // else add the C line if it's missing\n\t          } else if (mlines[i].toString().search(/c=.*/) < 0) {\n\t            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;\n\t            sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n\t          }\n\t        }\n\t      }\n\t      return sdp;\n\t    },\n\t  },\n\t\n\t  Chrome: {\n\t    needsExplicitlyInactiveSDP: function (sdp) {\n\t      var sub, index;\n\t\n\t      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending\n\t        index = sdp.indexOf('m=video 0');\n\t        if (index !== -1) {\n\t          sub = sdp.substr(index);\n\t          sub = sub.replace(/\\r\\nc=IN IP4.*\\r\\n$/,\n\t                            '\\r\\nc=IN IP4 0.0.0.0\\r\\na=inactive\\r\\n');\n\t          return sdp.substr(0, index) + sub;\n\t        }\n\t      }\n\t      return sdp;\n\t    },\n\t\n\t    getsConfusedAboutGUM: function (session) {\n\t      if (session.mediaHandler) {\n\t        session.mediaHandler.close();\n\t      }\n\t    }\n\t  }\n\t};\n\treturn Hacks;\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Incoming SIP Message Sanity Check\n\t */\n\t\n\t/**\n\t * SIP message sanity check.\n\t * @augments SIP\n\t * @function\n\t * @param {SIP.IncomingMessage} message\n\t * @param {SIP.UA} ua\n\t * @param {SIP.Transport} transport\n\t * @returns {Boolean}\n\t */\n\tmodule.exports = function (SIP) {\n\tvar sanityCheck,\n\t logger,\n\t message, ua, transport,\n\t requests = [],\n\t responses = [],\n\t all = [];\n\t\n\t// Reply\n\tfunction reply(status_code) {\n\t  var to,\n\t    response = SIP.Utils.buildStatusLine(status_code),\n\t    vias = message.getHeaders('via'),\n\t    length = vias.length,\n\t    idx = 0;\n\t\n\t  for(idx; idx < length; idx++) {\n\t    response += \"Via: \" + vias[idx] + \"\\r\\n\";\n\t  }\n\t\n\t  to = message.getHeader('To');\n\t\n\t  if(!message.to_tag) {\n\t    to += ';tag=' + SIP.Utils.newTag();\n\t  }\n\t\n\t  response += \"To: \" + to + \"\\r\\n\";\n\t  response += \"From: \" + message.getHeader('From') + \"\\r\\n\";\n\t  response += \"Call-ID: \" + message.call_id + \"\\r\\n\";\n\t  response += \"CSeq: \" + message.cseq + \" \" + message.method + \"\\r\\n\";\n\t  response += \"\\r\\n\";\n\t\n\t  transport.send(response);\n\t}\n\t\n\t/*\n\t * Sanity Check for incoming Messages\n\t *\n\t * Requests:\n\t *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n\t *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n\t *   Does not look at via sent-by but at sipjsId, which is inserted as\n\t *   a prefix in all initial requests generated by the ua\n\t *  - _rfc3261_18_3_request_ Body Content-Length\n\t *  - _rfc3261_8_2_2_2_ Merged Requests\n\t *\n\t * Responses:\n\t *  - _rfc3261_8_1_3_3_ Multiple Via headers\n\t *  - _rfc3261_18_1_2_ sent-by mismatch\n\t *  - _rfc3261_18_3_response_ Body Content-Length\n\t *\n\t * All:\n\t *  - Minimum headers in a SIP message\n\t */\n\t\n\t// Sanity Check functions for requests\n\tfunction rfc3261_8_2_2_1() {\n\t  if(!message.ruri || message.ruri.scheme !== 'sip') {\n\t    reply(416);\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_16_3_4() {\n\t  if(!message.to_tag) {\n\t    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {\n\t      reply(482);\n\t      return false;\n\t    }\n\t  }\n\t}\n\t\n\tfunction rfc3261_18_3_request() {\n\t  var len = SIP.Utils.str_utf8_length(message.body),\n\t  contentLength = message.getHeader('content-length');\n\t\n\t  if(len < contentLength) {\n\t    reply(400);\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_8_2_2_2() {\n\t  var tr, idx,\n\t    fromTag = message.from_tag,\n\t    call_id = message.call_id,\n\t    cseq = message.cseq;\n\t\n\t  if(!message.to_tag) {\n\t    if(message.method === SIP.C.INVITE) {\n\t      tr = ua.transactions.ist[message.via_branch];\n\t      if(tr) {\n\t        return;\n\t      } else {\n\t        for(idx in ua.transactions.ist) {\n\t          tr = ua.transactions.ist[idx];\n\t          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n\t            reply(482);\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t    } else {\n\t      tr = ua.transactions.nist[message.via_branch];\n\t      if(tr) {\n\t        return;\n\t      } else {\n\t        for(idx in ua.transactions.nist) {\n\t          tr = ua.transactions.nist[idx];\n\t          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n\t            reply(482);\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// Sanity Check functions for responses\n\tfunction rfc3261_8_1_3_3() {\n\t  if(message.getHeaders('via').length > 1) {\n\t    logger.warn('More than one Via header field present in the response. Dropping the response');\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_18_1_2() {\n\t  var viaHost = ua.configuration.viaHost;\n\t  if(message.via.host !== viaHost || message.via.port !== undefined) {\n\t    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_18_3_response() {\n\t  var\n\t    len = SIP.Utils.str_utf8_length(message.body),\n\t    contentLength = message.getHeader('content-length');\n\t\n\t    if(len < contentLength) {\n\t      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');\n\t      return false;\n\t    }\n\t}\n\t\n\t// Sanity Check functions for requests and responses\n\tfunction minimumHeaders() {\n\t  var\n\t    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],\n\t    idx = mandatoryHeaders.length;\n\t\n\t  while(idx--) {\n\t    if(!message.hasHeader(mandatoryHeaders[idx])) {\n\t      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');\n\t      return false;\n\t    }\n\t  }\n\t}\n\t\n\trequests.push(rfc3261_8_2_2_1);\n\trequests.push(rfc3261_16_3_4);\n\trequests.push(rfc3261_18_3_request);\n\trequests.push(rfc3261_8_2_2_2);\n\t\n\tresponses.push(rfc3261_8_1_3_3);\n\tresponses.push(rfc3261_18_1_2);\n\tresponses.push(rfc3261_18_3_response);\n\t\n\tall.push(minimumHeaders);\n\t\n\tsanityCheck = function(m, u, t) {\n\t  var len, pass;\n\t\n\t  message = m;\n\t  ua = u;\n\t  transport = t;\n\t\n\t  logger = ua.getLogger('sip.sanitycheck');\n\t\n\t  len = all.length;\n\t  while(len--) {\n\t    pass = all[len](message);\n\t    if(pass === false) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  if(message instanceof SIP.IncomingRequest) {\n\t    len = requests.length;\n\t    while(len--) {\n\t      pass = requests[len](message);\n\t      if(pass === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  else if(message instanceof SIP.IncomingResponse) {\n\t    len = responses.length;\n\t    while(len--) {\n\t      pass = responses[len](message);\n\t      if(pass === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  //Everything is OK\n\t  return true;\n\t};\n\t\n\tSIP.sanityCheck = sanityCheck;\n\t};\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview SIP Digest Authentication\n\t */\n\t\n\t/**\n\t * SIP Digest Authentication.\n\t * @augments SIP.\n\t * @function Digest Authentication\n\t * @param {SIP.UA} ua\n\t */\n\tmodule.exports = function (Utils) {\n\tvar DigestAuthentication;\n\t\n\tDigestAuthentication = function(ua) {\n\t  this.logger = ua.getLogger('sipjs.digestauthentication');\n\t  this.username = ua.configuration.authorizationUser;\n\t  this.password = ua.configuration.password;\n\t  this.cnonce = null;\n\t  this.nc = 0;\n\t  this.ncHex = '00000000';\n\t  this.response = null;\n\t};\n\t\n\t\n\t/**\n\t* Performs Digest authentication given a SIP request and the challenge\n\t* received in a response to that request.\n\t* Returns true if credentials were successfully generated, false otherwise.\n\t*\n\t* @param {SIP.OutgoingRequest} request\n\t* @param {Object} challenge\n\t*/\n\tDigestAuthentication.prototype.authenticate = function(request, challenge) {\n\t  // Inspect and validate the challenge.\n\t\n\t  this.algorithm = challenge.algorithm;\n\t  this.realm = challenge.realm;\n\t  this.nonce = challenge.nonce;\n\t  this.opaque = challenge.opaque;\n\t  this.stale = challenge.stale;\n\t\n\t  if (this.algorithm) {\n\t    if (this.algorithm !== 'MD5') {\n\t      this.logger.warn('challenge with Digest algorithm different than \"MD5\", authentication aborted');\n\t      return false;\n\t    }\n\t  } else {\n\t    this.algorithm = 'MD5';\n\t  }\n\t\n\t  if (! this.realm) {\n\t    this.logger.warn('challenge without Digest realm, authentication aborted');\n\t    return false;\n\t  }\n\t\n\t  if (! this.nonce) {\n\t    this.logger.warn('challenge without Digest nonce, authentication aborted');\n\t    return false;\n\t  }\n\t\n\t  // 'qop' can contain a list of values (Array). Let's choose just one.\n\t  if (challenge.qop) {\n\t    if (challenge.qop.indexOf('auth') > -1) {\n\t      this.qop = 'auth';\n\t    } else if (challenge.qop.indexOf('auth-int') > -1) {\n\t      this.qop = 'auth-int';\n\t    } else {\n\t      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n\t      this.logger.warn('challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n\t      return false;\n\t    }\n\t  } else {\n\t    this.qop = null;\n\t  }\n\t\n\t  // Fill other attributes.\n\t\n\t  this.method = request.method;\n\t  this.uri = request.ruri;\n\t  this.cnonce = Utils.createRandomToken(12);\n\t  this.nc += 1;\n\t  this.updateNcHex();\n\t\n\t  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n\t  if (this.nc === 4294967296) {\n\t    this.nc = 1;\n\t    this.ncHex = '00000001';\n\t  }\n\t\n\t  // Calculate the Digest \"response\" value.\n\t  this.calculateResponse();\n\t\n\t  return true;\n\t};\n\t\n\t\n\t/**\n\t* Generate Digest 'response' value.\n\t* @private\n\t*/\n\tDigestAuthentication.prototype.calculateResponse = function() {\n\t  var ha1, ha2;\n\t\n\t  // HA1 = MD5(A1) = MD5(username:realm:password)\n\t  ha1 = Utils.calculateMD5(this.username + \":\" + this.realm + \":\" + this.password);\n\t\n\t  if (this.qop === 'auth') {\n\t    // HA2 = MD5(A2) = MD5(method:digestURI)\n\t    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n\t    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n\t    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n\t\n\t  } else if (this.qop === 'auth-int') {\n\t    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n\t    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri + \":\" + Utils.calculateMD5(this.body ? this.body : \"\"));\n\t    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n\t    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n\t\n\t  } else if (this.qop === null) {\n\t    // HA2 = MD5(A2) = MD5(method:digestURI)\n\t    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n\t    // response = MD5(HA1:nonce:HA2)\n\t    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t* Return the Proxy-Authorization or WWW-Authorization header value.\n\t*/\n\tDigestAuthentication.prototype.toString = function() {\n\t  var auth_params = [];\n\t\n\t  if (! this.response) {\n\t    throw new Error('response field does not exist, cannot generate Authorization header');\n\t  }\n\t\n\t  auth_params.push('algorithm=' + this.algorithm);\n\t  auth_params.push('username=\"' + this.username + '\"');\n\t  auth_params.push('realm=\"' + this.realm + '\"');\n\t  auth_params.push('nonce=\"' + this.nonce + '\"');\n\t  auth_params.push('uri=\"' + this.uri + '\"');\n\t  auth_params.push('response=\"' + this.response + '\"');\n\t  if (this.opaque) {\n\t    auth_params.push('opaque=\"' + this.opaque + '\"');\n\t  }\n\t  if (this.qop) {\n\t    auth_params.push('qop=' + this.qop);\n\t    auth_params.push('cnonce=\"' + this.cnonce + '\"');\n\t    auth_params.push('nc=' + this.ncHex);\n\t  }\n\t\n\t  return 'Digest ' + auth_params.join(', ');\n\t};\n\t\n\t\n\t/**\n\t* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n\t* @private\n\t*/\n\tDigestAuthentication.prototype.updateNcHex = function() {\n\t  var hex = Number(this.nc).toString(16);\n\t  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;\n\t};\n\t\n\treturn DigestAuthentication;\n\t};\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Grammar = __webpack_require__(48);\n\t\n\tmodule.exports = function (SIP) {\n\t\n\treturn {\n\t  parse: function parseCustom (input, startRule) {\n\t    var options = {startRule: startRule, SIP: SIP};\n\t    try {\n\t      Grammar.parse(input, options);\n\t    } catch (e) {\n\t      options.data = -1;\n\t    }\n\t    return options.data;\n\t  }\n\t};\n\t\n\t};\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\tmodule.exports = (function() {\n\t  /*\n\t   * Generated by PEG.js 0.8.0.\n\t   *\n\t   * http://pegjs.majda.cz/\n\t   */\n\t\n\t  function peg$subclass(child, parent) {\n\t    function ctor() { this.constructor = child; }\n\t    ctor.prototype = parent.prototype;\n\t    child.prototype = new ctor();\n\t  }\n\t\n\t  function SyntaxError(message, expected, found, offset, line, column) {\n\t    this.message  = message;\n\t    this.expected = expected;\n\t    this.found    = found;\n\t    this.offset   = offset;\n\t    this.line     = line;\n\t    this.column   = column;\n\t\n\t    this.name     = \"SyntaxError\";\n\t  }\n\t\n\t  peg$subclass(SyntaxError, Error);\n\t\n\t  function parse(input) {\n\t    var options = arguments.length > 1 ? arguments[1] : {},\n\t\n\t        peg$FAILED = {},\n\t\n\t        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },\n\t        peg$startRuleIndex   = 118,\n\t\n\t        peg$consts = [\n\t          \"\\r\\n\",\n\t          { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n\t          /^[0-9]/,\n\t          { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n\t          /^[a-zA-Z]/,\n\t          { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n\t          /^[0-9a-fA-F]/,\n\t          { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n\t          /^[\\0-\\xFF]/,\n\t          { type: \"class\", value: \"[\\\\0-\\\\xFF]\", description: \"[\\\\0-\\\\xFF]\" },\n\t          /^[\"]/,\n\t          { type: \"class\", value: \"[\\\"]\", description: \"[\\\"]\" },\n\t          \" \",\n\t          { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n\t          \"\\t\",\n\t          { type: \"literal\", value: \"\\t\", description: \"\\\"\\\\t\\\"\" },\n\t          /^[a-zA-Z0-9]/,\n\t          { type: \"class\", value: \"[a-zA-Z0-9]\", description: \"[a-zA-Z0-9]\" },\n\t          \";\",\n\t          { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n\t          \"/\",\n\t          { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n\t          \"?\",\n\t          { type: \"literal\", value: \"?\", description: \"\\\"?\\\"\" },\n\t          \":\",\n\t          { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n\t          \"@\",\n\t          { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n\t          \"&\",\n\t          { type: \"literal\", value: \"&\", description: \"\\\"&\\\"\" },\n\t          \"=\",\n\t          { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n\t          \"+\",\n\t          { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n\t          \"$\",\n\t          { type: \"literal\", value: \"$\", description: \"\\\"$\\\"\" },\n\t          \",\",\n\t          { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n\t          \"-\",\n\t          { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n\t          \"_\",\n\t          { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n\t          \".\",\n\t          { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n\t          \"!\",\n\t          { type: \"literal\", value: \"!\", description: \"\\\"!\\\"\" },\n\t          \"~\",\n\t          { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n\t          \"*\",\n\t          { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n\t          \"'\",\n\t          { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\n\t          \"(\",\n\t          { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n\t          \")\",\n\t          { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n\t          peg$FAILED,\n\t          \"%\",\n\t          { type: \"literal\", value: \"%\", description: \"\\\"%\\\"\" },\n\t          null,\n\t          [],\n\t          function() {return \" \"; },\n\t          function() {return ':'; },\n\t          /^[!-~]/,\n\t          { type: \"class\", value: \"[!-~]\", description: \"[!-~]\" },\n\t          /^[\\x80-\\uFFFF]/,\n\t          { type: \"class\", value: \"[\\\\x80-\\\\uFFFF]\", description: \"[\\\\x80-\\\\uFFFF]\" },\n\t          /^[\\x80-\\xBF]/,\n\t          { type: \"class\", value: \"[\\\\x80-\\\\xBF]\", description: \"[\\\\x80-\\\\xBF]\" },\n\t          /^[a-f]/,\n\t          { type: \"class\", value: \"[a-f]\", description: \"[a-f]\" },\n\t          \"`\",\n\t          { type: \"literal\", value: \"`\", description: \"\\\"`\\\"\" },\n\t          \"<\",\n\t          { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n\t          \">\",\n\t          { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n\t          \"\\\\\",\n\t          { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n\t          \"[\",\n\t          { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n\t          \"]\",\n\t          { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n\t          \"{\",\n\t          { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n\t          \"}\",\n\t          { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n\t          function() {return \"*\"; },\n\t          function() {return \"/\"; },\n\t          function() {return \"=\"; },\n\t          function() {return \"(\"; },\n\t          function() {return \")\"; },\n\t          function() {return \">\"; },\n\t          function() {return \"<\"; },\n\t          function() {return \",\"; },\n\t          function() {return \";\"; },\n\t          function() {return \":\"; },\n\t          function() {return \"\\\"\"; },\n\t          /^[!-']/,\n\t          { type: \"class\", value: \"[!-']\", description: \"[!-']\" },\n\t          /^[*-[]/,\n\t          { type: \"class\", value: \"[*-[]\", description: \"[*-[]\" },\n\t          /^[\\]-~]/,\n\t          { type: \"class\", value: \"[\\\\]-~]\", description: \"[\\\\]-~]\" },\n\t          function(contents) {\n\t                                  return contents; },\n\t          /^[#-[]/,\n\t          { type: \"class\", value: \"[#-[]\", description: \"[#-[]\" },\n\t          /^[\\0-\\t]/,\n\t          { type: \"class\", value: \"[\\\\0-\\\\t]\", description: \"[\\\\0-\\\\t]\" },\n\t          /^[\\x0B-\\f]/,\n\t          { type: \"class\", value: \"[\\\\x0B-\\\\f]\", description: \"[\\\\x0B-\\\\f]\" },\n\t          /^[\\x0E-]/,\n\t          { type: \"class\", value: \"[\\\\x0E-]\", description: \"[\\\\x0E-]\" },\n\t          function() {\n\t                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);\n\t                                  delete options.data.scheme;\n\t                                  delete options.data.user;\n\t                                  delete options.data.host;\n\t                                  delete options.data.host_type;\n\t                                  delete options.data.port;\n\t                                },\n\t          function() {\n\t                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n\t                                  delete options.data.scheme;\n\t                                  delete options.data.user;\n\t                                  delete options.data.host;\n\t                                  delete options.data.host_type;\n\t                                  delete options.data.port;\n\t                                  delete options.data.uri_params;\n\t\n\t                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}\n\t                                },\n\t          \"sips\",\n\t          { type: \"literal\", value: \"sips\", description: \"\\\"sips\\\"\" },\n\t          \"sip\",\n\t          { type: \"literal\", value: \"sip\", description: \"\\\"sip\\\"\" },\n\t          function(uri_scheme) {\n\t                              options.data.scheme = uri_scheme; },\n\t          function() {\n\t                              options.data.user = decodeURIComponent(text().slice(0, -1));},\n\t          function() {\n\t                              options.data.password = text(); },\n\t          function() {\n\t                              options.data.host = text();\n\t                              return options.data.host; },\n\t          function() {\n\t                            options.data.host_type = 'domain';\n\t                            return text(); },\n\t          /^[a-zA-Z0-9_\\-]/,\n\t          { type: \"class\", value: \"[a-zA-Z0-9_\\\\-]\", description: \"[a-zA-Z0-9_\\\\-]\" },\n\t          /^[a-zA-Z0-9\\-]/,\n\t          { type: \"class\", value: \"[a-zA-Z0-9\\\\-]\", description: \"[a-zA-Z0-9\\\\-]\" },\n\t          function() {\n\t                              options.data.host_type = 'IPv6';\n\t                              return text(); },\n\t          \"::\",\n\t          { type: \"literal\", value: \"::\", description: \"\\\"::\\\"\" },\n\t          function() {\n\t                            options.data.host_type = 'IPv6';\n\t                            return text(); },\n\t          function() {\n\t                              options.data.host_type = 'IPv4';\n\t                              return text(); },\n\t          \"25\",\n\t          { type: \"literal\", value: \"25\", description: \"\\\"25\\\"\" },\n\t          /^[0-5]/,\n\t          { type: \"class\", value: \"[0-5]\", description: \"[0-5]\" },\n\t          \"2\",\n\t          { type: \"literal\", value: \"2\", description: \"\\\"2\\\"\" },\n\t          /^[0-4]/,\n\t          { type: \"class\", value: \"[0-4]\", description: \"[0-4]\" },\n\t          \"1\",\n\t          { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n\t          /^[1-9]/,\n\t          { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n\t          function(port) {\n\t                              port = parseInt(port.join(''));\n\t                              options.data.port = port;\n\t                              return port; },\n\t          \"transport=\",\n\t          { type: \"literal\", value: \"transport=\", description: \"\\\"transport=\\\"\" },\n\t          \"udp\",\n\t          { type: \"literal\", value: \"udp\", description: \"\\\"udp\\\"\" },\n\t          \"tcp\",\n\t          { type: \"literal\", value: \"tcp\", description: \"\\\"tcp\\\"\" },\n\t          \"sctp\",\n\t          { type: \"literal\", value: \"sctp\", description: \"\\\"sctp\\\"\" },\n\t          \"tls\",\n\t          { type: \"literal\", value: \"tls\", description: \"\\\"tls\\\"\" },\n\t          function(transport) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['transport'] = transport.toLowerCase(); },\n\t          \"user=\",\n\t          { type: \"literal\", value: \"user=\", description: \"\\\"user=\\\"\" },\n\t          \"phone\",\n\t          { type: \"literal\", value: \"phone\", description: \"\\\"phone\\\"\" },\n\t          \"ip\",\n\t          { type: \"literal\", value: \"ip\", description: \"\\\"ip\\\"\" },\n\t          function(user) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['user'] = user.toLowerCase(); },\n\t          \"method=\",\n\t          { type: \"literal\", value: \"method=\", description: \"\\\"method=\\\"\" },\n\t          function(method) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['method'] = method; },\n\t          \"ttl=\",\n\t          { type: \"literal\", value: \"ttl=\", description: \"\\\"ttl=\\\"\" },\n\t          function(ttl) {\n\t                                if(!options.data.params) options.data.params={};\n\t                                options.data.params['ttl'] = ttl; },\n\t          \"maddr=\",\n\t          { type: \"literal\", value: \"maddr=\", description: \"\\\"maddr=\\\"\" },\n\t          function(maddr) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['maddr'] = maddr; },\n\t          \"lr\",\n\t          { type: \"literal\", value: \"lr\", description: \"\\\"lr\\\"\" },\n\t          function() {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['lr'] = undefined; },\n\t          function(param, value) {\n\t                                if(!options.data.uri_params) options.data.uri_params = {};\n\t                                if (value === null){\n\t                                  value = undefined;\n\t                                }\n\t                                else {\n\t                                  value = value[1];\n\t                                }\n\t                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},\n\t          function(hname, hvalue) {\n\t                                hname = hname.join('').toLowerCase();\n\t                                hvalue = hvalue.join('');\n\t                                if(!options.data.uri_headers) options.data.uri_headers = {};\n\t                                if (!options.data.uri_headers[hname]) {\n\t                                  options.data.uri_headers[hname] = [hvalue];\n\t                                } else {\n\t                                  options.data.uri_headers[hname].push(hvalue);\n\t                                }},\n\t          function() {\n\t                                // lots of tests fail if this isn't guarded...\n\t                                if (options.startRule === 'Refer_To') {\n\t                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n\t                                  delete options.data.scheme;\n\t                                  delete options.data.user;\n\t                                  delete options.data.host;\n\t                                  delete options.data.host_type;\n\t                                  delete options.data.port;\n\t                                  delete options.data.uri_params;\n\t                                }\n\t                              },\n\t          \"//\",\n\t          { type: \"literal\", value: \"//\", description: \"\\\"//\\\"\" },\n\t          function() {\n\t                              options.data.scheme= text(); },\n\t          { type: \"literal\", value: \"SIP\", description: \"\\\"SIP\\\"\" },\n\t          function() {\n\t                              options.data.sip_version = text(); },\n\t          \"INVITE\",\n\t          { type: \"literal\", value: \"INVITE\", description: \"\\\"INVITE\\\"\" },\n\t          \"ACK\",\n\t          { type: \"literal\", value: \"ACK\", description: \"\\\"ACK\\\"\" },\n\t          \"VXACH\",\n\t          { type: \"literal\", value: \"VXACH\", description: \"\\\"VXACH\\\"\" },\n\t          \"OPTIONS\",\n\t          { type: \"literal\", value: \"OPTIONS\", description: \"\\\"OPTIONS\\\"\" },\n\t          \"BYE\",\n\t          { type: \"literal\", value: \"BYE\", description: \"\\\"BYE\\\"\" },\n\t          \"CANCEL\",\n\t          { type: \"literal\", value: \"CANCEL\", description: \"\\\"CANCEL\\\"\" },\n\t          \"REGISTER\",\n\t          { type: \"literal\", value: \"REGISTER\", description: \"\\\"REGISTER\\\"\" },\n\t          \"SUBSCRIBE\",\n\t          { type: \"literal\", value: \"SUBSCRIBE\", description: \"\\\"SUBSCRIBE\\\"\" },\n\t          \"NOTIFY\",\n\t          { type: \"literal\", value: \"NOTIFY\", description: \"\\\"NOTIFY\\\"\" },\n\t          \"REFER\",\n\t          { type: \"literal\", value: \"REFER\", description: \"\\\"REFER\\\"\" },\n\t          function() {\n\t\n\t                              options.data.method = text();\n\t                              return options.data.method; },\n\t          function(status_code) {\n\t                            options.data.status_code = parseInt(status_code.join('')); },\n\t          function() {\n\t                            options.data.reason_phrase = text(); },\n\t          function() {\n\t                        options.data = text(); },\n\t          function() {\n\t                                  var idx, length;\n\t                                  length = options.data.multi_header.length;\n\t                                  for (idx = 0; idx < length; idx++) {\n\t                                    if (options.data.multi_header[idx].parsed === null) {\n\t                                      options.data = null;\n\t                                      break;\n\t                                    }\n\t                                  }\n\t                                  if (options.data !== null) {\n\t                                    options.data = options.data.multi_header;\n\t                                  } else {\n\t                                    options.data = -1;\n\t                                  }},\n\t          function() {\n\t                                  var header;\n\t                                  if(!options.data.multi_header) options.data.multi_header = [];\n\t                                  try {\n\t                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                                    delete options.data.uri;\n\t                                    delete options.data.displayName;\n\t                                    delete options.data.params;\n\t                                  } catch(e) {\n\t                                    header = null;\n\t                                  }\n\t                                  options.data.multi_header.push( { 'position': peg$currPos,\n\t                                                            'offset': offset(),\n\t                                                            'parsed': header\n\t                                                          });},\n\t          function(displayName) {\n\t                                  displayName = text().trim();\n\t                                  if (displayName[0] === '\\\"') {\n\t                                    displayName = displayName.substring(1, displayName.length-1);\n\t                                  }\n\t                                  options.data.displayName = displayName; },\n\t          \"q\",\n\t          { type: \"literal\", value: \"q\", description: \"\\\"q\\\"\" },\n\t          function(q) {\n\t                                  if(!options.data.params) options.data.params = {};\n\t                                  options.data.params['q'] = q; },\n\t          \"expires\",\n\t          { type: \"literal\", value: \"expires\", description: \"\\\"expires\\\"\" },\n\t          function(expires) {\n\t                                  if(!options.data.params) options.data.params = {};\n\t                                  options.data.params['expires'] = expires; },\n\t          function(delta_seconds) {\n\t                                  return parseInt(delta_seconds.join('')); },\n\t          \"0\",\n\t          { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n\t          function() {\n\t                                  return parseFloat(text()); },\n\t          function(param, value) {\n\t                                  if(!options.data.params) options.data.params = {};\n\t                                  if (value === null){\n\t                                    value = undefined;\n\t                                  }\n\t                                  else {\n\t                                    value = value[1];\n\t                                  }\n\t                                  options.data.params[param.toLowerCase()] = value;},\n\t          \"render\",\n\t          { type: \"literal\", value: \"render\", description: \"\\\"render\\\"\" },\n\t          \"session\",\n\t          { type: \"literal\", value: \"session\", description: \"\\\"session\\\"\" },\n\t          \"icon\",\n\t          { type: \"literal\", value: \"icon\", description: \"\\\"icon\\\"\" },\n\t          \"alert\",\n\t          { type: \"literal\", value: \"alert\", description: \"\\\"alert\\\"\" },\n\t          function() {\n\t                                      if (options.startRule === 'Content_Disposition') {\n\t                                        options.data.type = text().toLowerCase();\n\t                                      }\n\t                                    },\n\t          \"handling\",\n\t          { type: \"literal\", value: \"handling\", description: \"\\\"handling\\\"\" },\n\t          \"optional\",\n\t          { type: \"literal\", value: \"optional\", description: \"\\\"optional\\\"\" },\n\t          \"required\",\n\t          { type: \"literal\", value: \"required\", description: \"\\\"required\\\"\" },\n\t          function(length) {\n\t                                  options.data = parseInt(length.join('')); },\n\t          function() {\n\t                                  options.data = text(); },\n\t          \"text\",\n\t          { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n\t          \"image\",\n\t          { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n\t          \"audio\",\n\t          { type: \"literal\", value: \"audio\", description: \"\\\"audio\\\"\" },\n\t          \"video\",\n\t          { type: \"literal\", value: \"video\", description: \"\\\"video\\\"\" },\n\t          \"application\",\n\t          { type: \"literal\", value: \"application\", description: \"\\\"application\\\"\" },\n\t          \"message\",\n\t          { type: \"literal\", value: \"message\", description: \"\\\"message\\\"\" },\n\t          \"multipart\",\n\t          { type: \"literal\", value: \"multipart\", description: \"\\\"multipart\\\"\" },\n\t          \"x-\",\n\t          { type: \"literal\", value: \"x-\", description: \"\\\"x-\\\"\" },\n\t          function(cseq_value) {\n\t                            options.data.value=parseInt(cseq_value.join('')); },\n\t          function(expires) {options.data = expires; },\n\t          function(event_type) {\n\t                                 options.data.event = event_type.toLowerCase(); },\n\t          function() {\n\t                          var tag = options.data.tag;\n\t                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                            if (tag) {options.data.setParam('tag',tag)}\n\t                          },\n\t          \"tag\",\n\t          { type: \"literal\", value: \"tag\", description: \"\\\"tag\\\"\" },\n\t          function(tag) {options.data.tag = tag; },\n\t          function(forwards) {\n\t                            options.data = parseInt(forwards.join('')); },\n\t          function(min_expires) {options.data = min_expires; },\n\t          function() {\n\t                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                                },\n\t          \"digest\",\n\t          { type: \"literal\", value: \"Digest\", description: \"\\\"Digest\\\"\" },\n\t          \"realm\",\n\t          { type: \"literal\", value: \"realm\", description: \"\\\"realm\\\"\" },\n\t          function(realm) { options.data.realm = realm; },\n\t          \"domain\",\n\t          { type: \"literal\", value: \"domain\", description: \"\\\"domain\\\"\" },\n\t          \"nonce\",\n\t          { type: \"literal\", value: \"nonce\", description: \"\\\"nonce\\\"\" },\n\t          function(nonce) { options.data.nonce=nonce; },\n\t          \"opaque\",\n\t          { type: \"literal\", value: \"opaque\", description: \"\\\"opaque\\\"\" },\n\t          function(opaque) { options.data.opaque=opaque; },\n\t          \"stale\",\n\t          { type: \"literal\", value: \"stale\", description: \"\\\"stale\\\"\" },\n\t          \"true\",\n\t          { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\n\t          function() { options.data.stale=true; },\n\t          \"false\",\n\t          { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\n\t          function() { options.data.stale=false; },\n\t          \"algorithm\",\n\t          { type: \"literal\", value: \"algorithm\", description: \"\\\"algorithm\\\"\" },\n\t          \"md5\",\n\t          { type: \"literal\", value: \"MD5\", description: \"\\\"MD5\\\"\" },\n\t          \"md5-sess\",\n\t          { type: \"literal\", value: \"MD5-sess\", description: \"\\\"MD5-sess\\\"\" },\n\t          function(algorithm) {\n\t                                options.data.algorithm=algorithm.toUpperCase(); },\n\t          \"qop\",\n\t          { type: \"literal\", value: \"qop\", description: \"\\\"qop\\\"\" },\n\t          \"auth-int\",\n\t          { type: \"literal\", value: \"auth-int\", description: \"\\\"auth-int\\\"\" },\n\t          \"auth\",\n\t          { type: \"literal\", value: \"auth\", description: \"\\\"auth\\\"\" },\n\t          function(qop_value) {\n\t                                  options.data.qop || (options.data.qop=[]);\n\t                                  options.data.qop.push(qop_value.toLowerCase()); },\n\t          function(rack_value) {\n\t                            options.data.value=parseInt(rack_value.join('')); },\n\t          function() {\n\t                            var idx, length;\n\t                            length = options.data.multi_header.length;\n\t                            for (idx = 0; idx < length; idx++) {\n\t                              if (options.data.multi_header[idx].parsed === null) {\n\t                                options.data = null;\n\t                                break;\n\t                              }\n\t                            }\n\t                            if (options.data !== null) {\n\t                              options.data = options.data.multi_header;\n\t                            } else {\n\t                              options.data = -1;\n\t                            }},\n\t          function() {\n\t                            var header;\n\t                            if(!options.data.multi_header) options.data.multi_header = [];\n\t                            try {\n\t                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                              delete options.data.uri;\n\t                              delete options.data.displayName;\n\t                              delete options.data.params;\n\t                            } catch(e) {\n\t                              header = null;\n\t                            }\n\t                            options.data.multi_header.push( { 'position': peg$currPos,\n\t                                                      'offset': offset(),\n\t                                                      'parsed': header\n\t                                                    });},\n\t          function() {\n\t                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                      },\n\t          function() {\n\t                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {\n\t                                  options.data = -1;\n\t                                }\n\t                              },\n\t          function() {\n\t                                options.data = {\n\t                                  call_id: options.data\n\t                                };\n\t                              },\n\t          \"from-tag\",\n\t          { type: \"literal\", value: \"from-tag\", description: \"\\\"from-tag\\\"\" },\n\t          function(from_tag) {\n\t                                options.data.replaces_from_tag = from_tag;\n\t                              },\n\t          \"to-tag\",\n\t          { type: \"literal\", value: \"to-tag\", description: \"\\\"to-tag\\\"\" },\n\t          function(to_tag) {\n\t                                options.data.replaces_to_tag = to_tag;\n\t                              },\n\t          \"early-only\",\n\t          { type: \"literal\", value: \"early-only\", description: \"\\\"early-only\\\"\" },\n\t          function() {\n\t                                options.data.early_only = true;\n\t                              },\n\t          function(r) {return r;},\n\t          function(first, rest) { return list(first, rest); },\n\t          function(value) {\n\t                          if (options.startRule === 'Require') {\n\t                            options.data = value || [];\n\t                          }\n\t                        },\n\t          function(rseq_value) {\n\t                            options.data.value=parseInt(rseq_value.join('')); },\n\t          \"active\",\n\t          { type: \"literal\", value: \"active\", description: \"\\\"active\\\"\" },\n\t          \"pending\",\n\t          { type: \"literal\", value: \"pending\", description: \"\\\"pending\\\"\" },\n\t          \"terminated\",\n\t          { type: \"literal\", value: \"terminated\", description: \"\\\"terminated\\\"\" },\n\t          function() {\n\t                                  options.data.state = text(); },\n\t          \"reason\",\n\t          { type: \"literal\", value: \"reason\", description: \"\\\"reason\\\"\" },\n\t          function(reason) {\n\t                                  if (typeof reason !== 'undefined') options.data.reason = reason; },\n\t          function(expires) {\n\t                                  if (typeof expires !== 'undefined') options.data.expires = expires; },\n\t          \"retry_after\",\n\t          { type: \"literal\", value: \"retry_after\", description: \"\\\"retry_after\\\"\" },\n\t          function(retry_after) {\n\t                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },\n\t          \"deactivated\",\n\t          { type: \"literal\", value: \"deactivated\", description: \"\\\"deactivated\\\"\" },\n\t          \"probation\",\n\t          { type: \"literal\", value: \"probation\", description: \"\\\"probation\\\"\" },\n\t          \"rejected\",\n\t          { type: \"literal\", value: \"rejected\", description: \"\\\"rejected\\\"\" },\n\t          \"timeout\",\n\t          { type: \"literal\", value: \"timeout\", description: \"\\\"timeout\\\"\" },\n\t          \"giveup\",\n\t          { type: \"literal\", value: \"giveup\", description: \"\\\"giveup\\\"\" },\n\t          \"noresource\",\n\t          { type: \"literal\", value: \"noresource\", description: \"\\\"noresource\\\"\" },\n\t          \"invariant\",\n\t          { type: \"literal\", value: \"invariant\", description: \"\\\"invariant\\\"\" },\n\t          function(value) {\n\t                          if (options.startRule === 'Supported') {\n\t                            options.data = value || [];\n\t                          }\n\t                        },\n\t          function() {\n\t                        var tag = options.data.tag;\n\t                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                          if (tag) {options.data.setParam('tag',tag)}\n\t                        },\n\t          \"ttl\",\n\t          { type: \"literal\", value: \"ttl\", description: \"\\\"ttl\\\"\" },\n\t          function(via_ttl_value) {\n\t                                options.data.ttl = via_ttl_value; },\n\t          \"maddr\",\n\t          { type: \"literal\", value: \"maddr\", description: \"\\\"maddr\\\"\" },\n\t          function(via_maddr) {\n\t                                options.data.maddr = via_maddr; },\n\t          \"received\",\n\t          { type: \"literal\", value: \"received\", description: \"\\\"received\\\"\" },\n\t          function(via_received) {\n\t                                options.data.received = via_received; },\n\t          \"branch\",\n\t          { type: \"literal\", value: \"branch\", description: \"\\\"branch\\\"\" },\n\t          function(via_branch) {\n\t                                options.data.branch = via_branch; },\n\t          \"rport\",\n\t          { type: \"literal\", value: \"rport\", description: \"\\\"rport\\\"\" },\n\t          function() {\n\t                                if(typeof response_port !== 'undefined')\n\t                                  options.data.rport = response_port.join(''); },\n\t          function(via_protocol) {\n\t                                options.data.protocol = via_protocol; },\n\t          { type: \"literal\", value: \"UDP\", description: \"\\\"UDP\\\"\" },\n\t          { type: \"literal\", value: \"TCP\", description: \"\\\"TCP\\\"\" },\n\t          { type: \"literal\", value: \"TLS\", description: \"\\\"TLS\\\"\" },\n\t          { type: \"literal\", value: \"SCTP\", description: \"\\\"SCTP\\\"\" },\n\t          function(via_transport) {\n\t                                options.data.transport = via_transport; },\n\t          function() {\n\t                                options.data.host = text(); },\n\t          function(via_sent_by_port) {\n\t                                options.data.port = parseInt(via_sent_by_port.join('')); },\n\t          function(ttl) {\n\t                                return parseInt(ttl.join('')); },\n\t          function(deltaSeconds) {\n\t                                if (options.startRule === 'Session_Expires') {\n\t                                  options.data.deltaSeconds = deltaSeconds;\n\t                                }\n\t                              },\n\t          \"refresher\",\n\t          { type: \"literal\", value: \"refresher\", description: \"\\\"refresher\\\"\" },\n\t          \"uas\",\n\t          { type: \"literal\", value: \"uas\", description: \"\\\"uas\\\"\" },\n\t          \"uac\",\n\t          { type: \"literal\", value: \"uac\", description: \"\\\"uac\\\"\" },\n\t          function(endpoint) {\n\t                                if (options.startRule === 'Session_Expires') {\n\t                                  options.data.refresher = endpoint;\n\t                                }\n\t                              },\n\t          function(deltaSeconds) {\n\t                                if (options.startRule === 'Min_SE') {\n\t                                  options.data = deltaSeconds;\n\t                                }\n\t                              },\n\t          \"stuns\",\n\t          { type: \"literal\", value: \"stuns\", description: \"\\\"stuns\\\"\" },\n\t          \"stun\",\n\t          { type: \"literal\", value: \"stun\", description: \"\\\"stun\\\"\" },\n\t          function(scheme) {\n\t                                options.data.scheme = scheme; },\n\t          function(host) {\n\t                                options.data.host = host; },\n\t          \"?transport=\",\n\t          { type: \"literal\", value: \"?transport=\", description: \"\\\"?transport=\\\"\" },\n\t          \"turns\",\n\t          { type: \"literal\", value: \"turns\", description: \"\\\"turns\\\"\" },\n\t          \"turn\",\n\t          { type: \"literal\", value: \"turn\", description: \"\\\"turn\\\"\" },\n\t          function() {\n\t                                options.data.transport = transport; },\n\t          function() {\n\t                            options.data = text(); }\n\t        ],\n\t\n\t        peg$bytecode = [\n\t          peg$decode(\". \\\"\\\"2 3!\"),\n\t          peg$decode(\"0\\\"\\\"\\\"1!3#\"),\n\t          peg$decode(\"0$\\\"\\\"1!3%\"),\n\t          peg$decode(\"0&\\\"\\\"1!3'\"),\n\t          peg$decode(\"7'*# \\\"7(\"),\n\t          peg$decode(\"0(\\\"\\\"1!3)\"),\n\t          peg$decode(\"0*\\\"\\\"1!3+\"),\n\t          peg$decode(\".,\\\"\\\"2,3-\"),\n\t          peg$decode(\"..\\\"\\\"2.3/\"),\n\t          peg$decode(\"00\\\"\\\"1!31\"),\n\t          peg$decode(\".2\\\"\\\"2233*\\x89 \\\".4\\\"\\\"2435*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n\t          peg$decode(\"7)*# \\\"7,\"),\n\t          peg$decode(\".F\\\"\\\"2F3G*} \\\".H\\\"\\\"2H3I*q \\\".J\\\"\\\"2J3K*e \\\".L\\\"\\\"2L3M*Y \\\".N\\\"\\\"2N3O*M \\\".P\\\"\\\"2P3Q*A \\\".R\\\"\\\"2R3S*5 \\\".T\\\"\\\"2T3U*) \\\".V\\\"\\\"2V3W\"),\n\t          peg$decode(\"!!.Y\\\"\\\"2Y3Z+7$7#+-%7#+#%'#%$## X$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"!! \\\\7$,#&7$\\\"+-$7 +#%'\\\"%$\\\"# X\\\"# X*# \\\" [+@$ \\\\7$+&$,#&7$\\\"\\\"\\\" X+'%4\\\"6]\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7.*# \\\" [\"),\n\t          peg$decode(\"! \\\\7'*# \\\"7(,)&7'*# \\\"7(\\\"+A$.8\\\"\\\"2839+1%7/+'%4#6^# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!! \\\\72+&$,#&72\\\"\\\"\\\" X+o$ \\\\! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X,@&! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"0_\\\"\\\"1!3`*# \\\"73\"),\n\t          peg$decode(\"0a\\\"\\\"1!3b\"),\n\t          peg$decode(\"0c\\\"\\\"1!3d\"),\n\t          peg$decode(\"7!*) \\\"0e\\\"\\\"1!3f\"),\n\t          peg$decode(\"! \\\\7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x9E$,\\x9B&7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"! \\\\7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x92$,\\x8F&7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\".T\\\"\\\"2T3U*\\xE3 \\\".V\\\"\\\"2V3W*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".k\\\"\\\"2k3l*\\xBF \\\".:\\\"\\\"2:3;*\\xB3 \\\".D\\\"\\\"2D3E*\\xA7 \\\".2\\\"\\\"2233*\\x9B \\\".8\\\"\\\"2839*\\x8F \\\".m\\\"\\\"2m3n*\\x83 \\\"7&*} \\\".4\\\"\\\"2435*q \\\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".6\\\"\\\"2637*M \\\".>\\\"\\\"2>3?*A \\\".s\\\"\\\"2s3t*5 \\\".u\\\"\\\"2u3v*) \\\"7'*# \\\"7(\"),\n\t          peg$decode(\"! \\\\7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v+\\u0134$,\\u0131&7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"!7/+A$.P\\\"\\\"2P3Q+1%7/+'%4#6w# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.4\\\"\\\"2435+1%7/+'%4#6x# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.>\\\"\\\"2>3?+1%7/+'%4#6y# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.T\\\"\\\"2T3U+1%7/+'%4#6z# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.V\\\"\\\"2V3W+1%7/+'%4#6{# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.k\\\"\\\"2k3l+1$7/+'%4\\\"6|\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+7$.i\\\"\\\"2i3j+'%4\\\"6}\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.D\\\"\\\"2D3E+1%7/+'%4#6~# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.2\\\"\\\"2233+1%7/+'%4#6# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.8\\\"\\\"2839+1%7/+'%4#6\\x80# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+1$7&+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7&+1$7/+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7=+W$ \\\\7G*) \\\"7K*# \\\"7F,/&7G*) \\\"7K*# \\\"7F\\\"+-%7>+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"0\\x82\\\"\\\"1!3\\x83*A \\\"0\\x84\\\"\\\"1!3\\x85*5 \\\"0\\x86\\\"\\\"1!3\\x87*) \\\"73*# \\\"7.\"),\n\t          peg$decode(\"!!7/+U$7&+K% \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+-%7&+#%'$%$$# X$## X$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"!7/+`$7&+V%! \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+! (%+2%7&+(%4$6\\x88$!!%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7.*G \\\".L\\\"\\\"2L3M*; \\\"0\\x89\\\"\\\"1!3\\x8A*/ \\\"0\\x86\\\"\\\"1!3\\x87*# \\\"73\"),\n\t          peg$decode(\"!.m\\\"\\\"2m3n+K$0\\x8B\\\"\\\"1!3\\x8C*5 \\\"0\\x8D\\\"\\\"1!3\\x8E*) \\\"0\\x8F\\\"\\\"1!3\\x90+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7N+Q$.8\\\"\\\"2839+A%7O*# \\\" [+1%7S+'%4$6\\x91$ %$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7N+k$.8\\\"\\\"2839+[%7O*# \\\" [+K%7S+A%7_+7%7l*# \\\" [+'%4&6\\x92& %$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\x93\\\"\\\"1$3\\x94*) \\\"/\\x95\\\"\\\"1#3\\x96+' 4!6\\x97!! %\"),\n\t          peg$decode(\"!7P+b$!.8\\\"\\\"2839+-$7R+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+7%.:\\\"\\\"2:3;+'%4#6\\x98# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\7+*) \\\"7-*# \\\"7Q+2$,/&7+*) \\\"7-*# \\\"7Q\\\"\\\"\\\" X\"),\n\t          peg$decode(\".<\\\"\\\"2<3=*q \\\".>\\\"\\\"2>3?*e \\\".@\\\"\\\"2@3A*Y \\\".B\\\"\\\"2B3C*M \\\".D\\\"\\\"2D3E*A \\\".2\\\"\\\"2233*5 \\\".6\\\"\\\"2637*) \\\".4\\\"\\\"2435\"),\n\t          peg$decode(\"! \\\\7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E,e&7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\\\"+& 4!6\\x99! %\"),\n\t          peg$decode(\"!7T+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\x9A! %\"),\n\t          peg$decode(\"! \\\\!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X,>&!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X\\\"+G$7W+=%.J\\\"\\\"2J3K*# \\\" [+'%4#6\\x9B# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\0\\x9C\\\"\\\"1!3\\x9D+,$,)&0\\x9C\\\"\\\"1!3\\x9D\\\"\\\"\\\" X\"),\n\t          peg$decode(\"!0$\\\"\\\"1!3%+A$ \\\\0\\x9E\\\"\\\"1!3\\x9F,)&0\\x9E\\\"\\\"1!3\\x9F\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.o\\\"\\\"2o3p+A$7Y+7%.q\\\"\\\"2q3r+'%4#6\\xA0# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!!7Z+\\xBF$.8\\\"\\\"2839+\\xAF%7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0838 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\xAF$7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0795 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95$7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u070C \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+{$7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u069D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+a$7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0648 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+G$7Z+=%.8\\\"\\\"2839+-%7[+#%'$%$$# X$## X$\\\"# X\\\"# X*\\u060D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7[+#%'\\\"%$\\\"# X\\\"# X*\\u05EC \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7Z+#%'\\\"%$\\\"# X\\\"# X*\\u05CB \\\"!7Z+\\xA5$.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0538 \\\"!7Z+\\xB6$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x8B%.\\xA1\\\"\\\"2\\xA13\\xA2+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0494 \\\"!7Z+\\xC7$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x9C%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+q%.\\xA1\\\"\\\"2\\xA13\\xA2+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u03DF \\\"!7Z+\\xD8$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xAD%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x82%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+W%.\\xA1\\\"\\\"2\\xA13\\xA2+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0319 \\\"!7Z+\\xE9$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0242 \\\"!7Z+\\u0114$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xE9%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0140 \\\"!7Z+\\u0135$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\u010A%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xDF%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xB4%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x89%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+^%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+3%.\\xA1\\\"\\\"2\\xA13\\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X+& 4!6\\xA3! %\"),\n\t          peg$decode(\"!7#+S$7#*# \\\" [+C%7#*# \\\" [+3%7#*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7Z+=$.8\\\"\\\"2839+-%7Z+#%'#%$## X$\\\"# X\\\"# X*# \\\"7\\\\\"),\n\t          peg$decode(\"!7]+u$.J\\\"\\\"2J3K+e%7]+[%.J\\\"\\\"2J3K+K%7]+A%.J\\\"\\\"2J3K+1%7]+'%4'6\\xA4' %$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.\\xA5\\\"\\\"2\\xA53\\xA6+3$0\\xA7\\\"\\\"1!3\\xA8+#%'\\\"%$\\\"# X\\\"# X*\\xA0 \\\"!.\\xA9\\\"\\\"2\\xA93\\xAA+=$0\\xAB\\\"\\\"1!3\\xAC+-%7!+#%'#%$## X$\\\"# X\\\"# X*o \\\"!.\\xAD\\\"\\\"2\\xAD3\\xAE+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X*D \\\"!0\\xAF\\\"\\\"1!3\\xB0+-$7!+#%'\\\"%$\\\"# X\\\"# X*# \\\"7!\"),\n\t          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\xB1!! %\"),\n\t          peg$decode(\" \\\\!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X\\\"\"),\n\t          peg$decode(\"7a*A \\\"7b*; \\\"7c*5 \\\"7d*/ \\\"7e*) \\\"7f*# \\\"7g\"),\n\t          peg$decode(\"!/\\xB2\\\"\\\"1*3\\xB3+b$/\\xB4\\\"\\\"1#3\\xB5*G \\\"/\\xB6\\\"\\\"1#3\\xB7*; \\\"/\\xB8\\\"\\\"1$3\\xB9*/ \\\"/\\xBA\\\"\\\"1#3\\xBB*# \\\"76+(%4\\\"6\\xBC\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xBD\\\"\\\"1%3\\xBE+J$/\\xBF\\\"\\\"1%3\\xC0*/ \\\"/\\xC1\\\"\\\"1\\\"3\\xC2*# \\\"76+(%4\\\"6\\xC3\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xC4\\\"\\\"1'3\\xC5+2$7\\x8F+(%4\\\"6\\xC6\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xC7\\\"\\\"1$3\\xC8+2$7\\xEF+(%4\\\"6\\xC9\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xCA\\\"\\\"1&3\\xCB+2$7T+(%4\\\"6\\xCC\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xCD\\\"\\\"1\\\"3\\xCE+R$!.>\\\"\\\"2>3?+-$76+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xCF\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7h+T$!.>\\\"\\\"2>3?+-$7i+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xD0\\\"\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"7k*) \\\"7+*# \\\"7-\"),\n\t          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".8\\\"\\\"2839*A \\\".<\\\"\\\"2<3=*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n\t          peg$decode(\"!.6\\\"\\\"2637+u$7m+k% \\\\!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X,>&!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7n+C$.>\\\"\\\"2>3?+3%7o+)%4#6\\xD1#\\\"\\\" %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-+2$,/&7p*) \\\"7+*# \\\"7-\\\"\\\"\\\" X\"),\n\t          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-,/&7p*) \\\"7+*# \\\"7-\\\"\"),\n\t          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".6\\\"\\\"2637*A \\\".8\\\"\\\"2839*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n\t          peg$decode(\"7\\x90*# \\\"7r\"),\n\t          peg$decode(\"!7\\x8F+K$7'+A%7s+7%7'+-%7\\x84+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7M*# \\\"7t\"),\n\t          peg$decode(\"!7+G$.8\\\"\\\"2839+7%7u*# \\\"7x+'%4#6\\xD2# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7v*# \\\"7w+N$!.6\\\"\\\"2637+-$7\\x83+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.\\xD3\\\"\\\"2\\xD33\\xD4+=$7\\x80+3%7w*# \\\" [+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.4\\\"\\\"2435+-$7{+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7z+5$ \\\\7y,#&7y\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7**) \\\"7+*# \\\"7-\"),\n\t          peg$decode(\"7+*\\x8F \\\"7-*\\x89 \\\".2\\\"\\\"2233*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n\t          peg$decode(\"!7|+k$ \\\\!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X,>&!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7~,#&7~\\\"+k$ \\\\!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\7~,#&7~\\\"\"),\n\t          peg$decode(\"7+*w \\\"7-*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n\t          peg$decode(\"!7\\\"+\\x8D$ \\\\7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K,M&7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K\\\"+'%4\\\"6\\xD5\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\x81*# \\\"7\\x82\"),\n\t          peg$decode(\"!!7O+3$.:\\\"\\\"2:3;+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+-$7S+#%'\\\"%$\\\"# X\\\"# X*# \\\" [\"),\n\t          peg$decode(\" \\\\7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A+\\x8C$,\\x89&7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A\\\"\\\"\\\" X\"),\n\t          peg$decode(\" \\\\7y,#&7y\\\"\"),\n\t          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6+y$.4\\\"\\\"2435+i% \\\\7!+&$,#&7!\\\"\\\"\\\" X+P%.J\\\"\\\"2J3K+@% \\\\7!+&$,#&7!\\\"\\\"\\\" X+'%4%6\\xD7% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\".\\xD8\\\"\\\"2\\xD83\\xD9\"),\n\t          peg$decode(\".\\xDA\\\"\\\"2\\xDA3\\xDB\"),\n\t          peg$decode(\".\\xDC\\\"\\\"2\\xDC3\\xDD\"),\n\t          peg$decode(\".\\xDE\\\"\\\"2\\xDE3\\xDF\"),\n\t          peg$decode(\".\\xE0\\\"\\\"2\\xE03\\xE1\"),\n\t          peg$decode(\".\\xE2\\\"\\\"2\\xE23\\xE3\"),\n\t          peg$decode(\".\\xE4\\\"\\\"2\\xE43\\xE5\"),\n\t          peg$decode(\".\\xE6\\\"\\\"2\\xE63\\xE7\"),\n\t          peg$decode(\".\\xE8\\\"\\\"2\\xE83\\xE9\"),\n\t          peg$decode(\".\\xEA\\\"\\\"2\\xEA3\\xEB\"),\n\t          peg$decode(\"!7\\x85*S \\\"7\\x86*M \\\"7\\x88*G \\\"7\\x89*A \\\"7\\x8A*; \\\"7\\x8B*5 \\\"7\\x8C*/ \\\"7\\x8D*) \\\"7\\x8E*# \\\"76+& 4!6\\xEC! %\"),\n\t          peg$decode(\"!7\\x84+K$7'+A%7\\x91+7%7'+-%7\\x93+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x92+' 4!6\\xED!! %\"),\n\t          peg$decode(\"!7!+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(,G&7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(\\\"+& 4!6\\xEE! %\"),\n\t          peg$decode(\"!7\\xB5+_$ \\\\!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!79+R$!.:\\\"\\\"2:3;+-$79+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xEF\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7:*j \\\"!7\\x97+_$ \\\\!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+& 4!6\\xF0! %\"),\n\t          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\xF1\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x99*# \\\" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!!76+_$ \\\\!7.+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7.+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\"7H+' 4!6\\xF2!! %\"),\n\t          peg$decode(\"7\\x9B*) \\\"7\\x9C*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\xF3\\\"\\\"1!3\\xF4+<$7<+2%7\\x9E+(%4#6\\xF5#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\xF8#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\xF9!! %\"),\n\t          peg$decode(\"!.\\xFA\\\"\\\"2\\xFA3\\xFB+x$!.J\\\"\\\"2J3K+S$7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xFC\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+N$!7<+-$7\\xA0+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xFD\\\"\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"76*) \\\"7T*# \\\"7H\"),\n\t          peg$decode(\"!7\\xA2+_$ \\\\!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xFE\\\"\\\"1&3\\xFF*G \\\"/\\u0100\\\"\\\"1'3\\u0101*; \\\"/\\u0102\\\"\\\"1$3\\u0103*/ \\\"/\\u0104\\\"\\\"1%3\\u0105*# \\\"76+& 4!6\\u0106! %\"),\n\t          peg$decode(\"7\\xA4*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\u0107\\\"\\\"1(3\\u0108+O$7<+E%/\\u0109\\\"\\\"1(3\\u010A*/ \\\"/\\u010B\\\"\\\"1(3\\u010C*# \\\"76+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u010D!! %\"),\n\t          peg$decode(\"!7\\xA8+& 4!6\\u010E! %\"),\n\t          peg$decode(\"!7\\xA9+s$7;+i%7\\xAE+_% \\\\!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xAA*# \\\"7\\xAB\"),\n\t          peg$decode(\"/\\u010F\\\"\\\"1$3\\u0110*S \\\"/\\u0111\\\"\\\"1%3\\u0112*G \\\"/\\u0113\\\"\\\"1%3\\u0114*; \\\"/\\u0115\\\"\\\"1%3\\u0116*/ \\\"/\\u0117\\\"\\\"1+3\\u0118*# \\\"7\\xAC\"),\n\t          peg$decode(\"/\\u0119\\\"\\\"1'3\\u011A*/ \\\"/\\u011B\\\"\\\"1)3\\u011C*# \\\"7\\xAC\"),\n\t          peg$decode(\"76*# \\\"7\\xAD\"),\n\t          peg$decode(\"!/\\u011D\\\"\\\"1\\\"3\\u011E+-$76+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xAC*# \\\"76\"),\n\t          peg$decode(\"!76+7$7<+-%7\\xB0+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"76*# \\\"7H\"),\n\t          peg$decode(\"!7\\xB2+7$7.+-%7\\x8F+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u011F!! %\"),\n\t          peg$decode(\"!7\\x9D+' 4!6\\u0120!! %\"),\n\t          peg$decode(\"!7\\xB5+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0121\\\"!!%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!!77+k$ \\\\!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X,>&!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0122\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\u0123\\\"\\\"1#3\\u0124+<$7<+2%76+(%4#6\\u0125#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0126!! %\"),\n\t          peg$decode(\"!7\\x9D+' 4!6\\u0127!! %\"),\n\t          peg$decode(\"! \\\\7\\x99,#&7\\x99\\\"+\\x81$7@+w%7M+m%7?+c% \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4%6\\u0128% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xBD\"),\n\t          peg$decode(\"!/\\u0129\\\"\\\"1&3\\u012A+s$7.+i%7\\xC0+_% \\\\!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\"7\\xBE\"),\n\t          peg$decode(\"!76+s$7.+i%7\\xBF+_% \\\\!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+=$7<+3%76*# \\\"7H+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xC1*G \\\"7\\xC3*A \\\"7\\xC5*; \\\"7\\xC7*5 \\\"7\\xC8*/ \\\"7\\xC9*) \\\"7\\xCA*# \\\"7\\xBF\"),\n\t          peg$decode(\"!/\\u012B\\\"\\\"1%3\\u012C+7$7<+-%7\\xC2+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7I+' 4!6\\u012D!! %\"),\n\t          peg$decode(\"!/\\u012E\\\"\\\"1&3\\u012F+\\xA5$7<+\\x9B%7D+\\x91%7\\xC4+\\x87% \\\\! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X,G&! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X\\\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7t*# \\\"7w\"),\n\t          peg$decode(\"!/\\u0130\\\"\\\"1%3\\u0131+7$7<+-%7\\xC6+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7I+' 4!6\\u0132!! %\"),\n\t          peg$decode(\"!/\\u0133\\\"\\\"1&3\\u0134+<$7<+2%7I+(%4#6\\u0135#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0136\\\"\\\"1%3\\u0137+_$7<+U%!/\\u0138\\\"\\\"1$3\\u0139+& 4!6\\u013A! %*4 \\\"!/\\u013B\\\"\\\"1%3\\u013C+& 4!6\\u013D! %+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u013E\\\"\\\"1)3\\u013F+T$7<+J%/\\u0140\\\"\\\"1#3\\u0141*/ \\\"/\\u0142\\\"\\\"1(3\\u0143*# \\\"76+(%4#6\\u0144#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0145\\\"\\\"1#3\\u0146+\\x9E$7<+\\x94%7D+\\x8A%!7\\xCB+k$ \\\\!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X,>&!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+-%7E+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0147\\\"\\\"1(3\\u0148*/ \\\"/\\u0149\\\"\\\"1$3\\u014A*# \\\"76+' 4!6\\u014B!! %\"),\n\t          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xCE+K$7.+A%7\\xCE+7%7.+-%7\\x8F+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u014C!! %\"),\n\t          peg$decode(\"!7\\xD0+c$ \\\\!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014D\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x98+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014E\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7L*T \\\"7\\x98*N \\\"!7@*# \\\" [+=$7t+3%7?*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014F\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xD3+c$ \\\\!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0150\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x95+& 4!6\\u0151! %\"),\n\t          peg$decode(\"!/\\u0152\\\"\\\"1(3\\u0153+<$7<+2%76+(%4#6\\u0154#! %$## X$\\\"# X\\\"# X*j \\\"!/\\u0155\\\"\\\"1&3\\u0156+<$7<+2%76+(%4#6\\u0157#! %$## X$\\\"# X\\\"# X*: \\\"!/\\u0158\\\"\\\"1*3\\u0159+& 4!6\\u015A! %*# \\\"7\\x9F\"),\n\t          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u015D!! %\"),\n\t          peg$decode(\"!7\\xD7+_$ \\\\!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x98+_$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u015E!! %\"),\n\t          peg$decode(\"!7\\xDA+_$ \\\\!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u015F\\\"\\\"1&3\\u0160*; \\\"/\\u0161\\\"\\\"1'3\\u0162*/ \\\"/\\u0163\\\"\\\"1*3\\u0164*# \\\"76+& 4!6\\u0165! %\"),\n\t          peg$decode(\"!/\\u0166\\\"\\\"1&3\\u0167+<$7<+2%7\\xDC+(%4#6\\u0168#! %$## X$\\\"# X\\\"# X*\\x83 \\\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\u0169#! %$## X$\\\"# X\\\"# X*S \\\"!/\\u016A\\\"\\\"1+3\\u016B+<$7<+2%7\\x9D+(%4#6\\u016C#! %$## X$\\\"# X\\\"# X*# \\\"7\\x9F\"),\n\t          peg$decode(\"/\\u016D\\\"\\\"1+3\\u016E*k \\\"/\\u016F\\\"\\\"1)3\\u0170*_ \\\"/\\u0171\\\"\\\"1(3\\u0172*S \\\"/\\u0173\\\"\\\"1'3\\u0174*G \\\"/\\u0175\\\"\\\"1&3\\u0176*; \\\"/\\u0177\\\"\\\"1*3\\u0178*/ \\\"/\\u0179\\\"\\\"1)3\\u017A*# \\\"76\"),\n\t          peg$decode(\"71*# \\\" [\"),\n\t          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u017B!! %\"),\n\t          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u017C\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n\t          peg$decode(\"!7\\xE2+_$ \\\\!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xE9+s$7.+i%7\\xEC+_% \\\\!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xE4*; \\\"7\\xE5*5 \\\"7\\xE6*/ \\\"7\\xE7*) \\\"7\\xE8*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\u017D\\\"\\\"1#3\\u017E+<$7<+2%7\\xEF+(%4#6\\u017F#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0180\\\"\\\"1%3\\u0181+<$7<+2%7T+(%4#6\\u0182#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0183\\\"\\\"1(3\\u0184+B$7<+8%7\\\\*# \\\"7Y+(%4#6\\u0185#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0186\\\"\\\"1&3\\u0187+<$7<+2%76+(%4#6\\u0188#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0189\\\"\\\"1%3\\u018A+T$!7<+5$ \\\\7!,#&7!\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\u018B\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xEA+K$7;+A%76+7%7;+-%7\\xEB+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6*# \\\"76+' 4!6\\u018C!! %\"),\n\t          peg$decode(\"!/\\xB4\\\"\\\"1#3\\u018D*G \\\"/\\xB6\\\"\\\"1#3\\u018E*; \\\"/\\xBA\\\"\\\"1#3\\u018F*/ \\\"/\\xB8\\\"\\\"1$3\\u0190*# \\\"76+' 4!6\\u0191!! %\"),\n\t          peg$decode(\"!7\\xED+H$!7C+-$7\\xEE+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\u0192! %\"),\n\t          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\u0193!! %\"),\n\t          peg$decode(\"!!7!+C$7!*# \\\" [+3%7!*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+' 4!6\\u0194!! %\"),\n\t          peg$decode(\"7\\xBD\"),\n\t          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0195\\\"!!%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xF3*# \\\"7\\x9F\"),\n\t          peg$decode(\"!.\\u0196\\\"\\\"2\\u01963\\u0197+N$7<+D%.\\u0198\\\"\\\"2\\u01983\\u0199*) \\\".\\u019A\\\"\\\"2\\u019A3\\u019B+(%4#6\\u019C#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u019D\\\"!!%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+7$70+-%7\\xF6+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\72*) \\\"74*# \\\"7.,/&72*) \\\"74*# \\\"7.\\\"\"),\n\t          peg$decode(\" \\\\7%,#&7%\\\"\"),\n\t          peg$decode(\"!7\\xF9+=$.8\\\"\\\"2839+-%7\\xFA+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u019E\\\"\\\"1%3\\u019F*) \\\"/\\u01A0\\\"\\\"1$3\\u01A1+' 4!6\\u01A2!! %\"),\n\t          peg$decode(\"!7\\xFB+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\\\*) \\\"7X*# \\\"7\\x82+' 4!6\\u01A3!! %\"),\n\t          peg$decode(\"! \\\\7\\xFD*) \\\"7-*# \\\"7\\xFE,/&7\\xFD*) \\\"7-*# \\\"7\\xFE\\\"+! (%\"),\n\t          peg$decode(\"7\\\"*S \\\"7!*M \\\".F\\\"\\\"2F3G*A \\\".J\\\"\\\"2J3K*5 \\\".H\\\"\\\"2H3I*) \\\".N\\\"\\\"2N3O\"),\n\t          peg$decode(\".L\\\"\\\"2L3M*\\x95 \\\".B\\\"\\\"2B3C*\\x89 \\\".<\\\"\\\"2<3=*} \\\".R\\\"\\\"2R3S*q \\\".T\\\"\\\"2T3U*e \\\".V\\\"\\\"2V3W*Y \\\".P\\\"\\\"2P3Q*M \\\".@\\\"\\\"2@3A*A \\\".D\\\"\\\"2D3E*5 \\\".2\\\"\\\"2233*) \\\".>\\\"\\\"2>3?\"),\n\t          peg$decode(\"!7\\u0100+h$.8\\\"\\\"2839+X%7\\xFA+N%!.\\u01A4\\\"\\\"2\\u01A43\\u01A5+-$7\\xEB+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u01A6\\\"\\\"1%3\\u01A7*) \\\"/\\u01A8\\\"\\\"1$3\\u01A9+' 4!6\\u01A2!! %\"),\n\t          peg$decode(\"!7\\xEB+Q$/\\xB4\\\"\\\"1#3\\xB5*7 \\\"/\\xB6\\\"\\\"1#3\\xB7*+ \\\" \\\\7+,#&7+\\\"+'%4\\\"6\\u01AA\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\u0104+\\x8F$.F\\\"\\\"2F3G+%7\\u0103+u%.F\\\"\\\"2F3G+e%7\\u0103+[%.F\\\"\\\"2F3G+K%7\\u0103+A%.F\\\"\\\"2F3G+1%7\\u0105+'%4)6\\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\u0103+-$7\\u0103+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\u0103+7$7\\u0103+-%7\\u0103+#%'#%$## X$\\\"# X\\\"# X\")\n\t        ],\n\t\n\t        peg$currPos          = 0,\n\t        peg$reportedPos      = 0,\n\t        peg$cachedPos        = 0,\n\t        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n\t        peg$maxFailPos       = 0,\n\t        peg$maxFailExpected  = [],\n\t        peg$silentFails      = 0,\n\t\n\t        peg$result;\n\t\n\t    if (\"startRule\" in options) {\n\t      if (!(options.startRule in peg$startRuleIndices)) {\n\t        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n\t      }\n\t\n\t      peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n\t    }\n\t\n\t    function text() {\n\t      return input.substring(peg$reportedPos, peg$currPos);\n\t    }\n\t\n\t    function offset() {\n\t      return peg$reportedPos;\n\t    }\n\t\n\t    function line() {\n\t      return peg$computePosDetails(peg$reportedPos).line;\n\t    }\n\t\n\t    function column() {\n\t      return peg$computePosDetails(peg$reportedPos).column;\n\t    }\n\t\n\t    function expected(description) {\n\t      throw peg$buildException(\n\t        null,\n\t        [{ type: \"other\", description: description }],\n\t        peg$reportedPos\n\t      );\n\t    }\n\t\n\t    function error(message) {\n\t      throw peg$buildException(message, null, peg$reportedPos);\n\t    }\n\t\n\t    function peg$computePosDetails(pos) {\n\t      function advance(details, startPos, endPos) {\n\t        var p, ch;\n\t\n\t        for (p = startPos; p < endPos; p++) {\n\t          ch = input.charAt(p);\n\t          if (ch === \"\\n\") {\n\t            if (!details.seenCR) { details.line++; }\n\t            details.column = 1;\n\t            details.seenCR = false;\n\t          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n\t            details.line++;\n\t            details.column = 1;\n\t            details.seenCR = true;\n\t          } else {\n\t            details.column++;\n\t            details.seenCR = false;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (peg$cachedPos !== pos) {\n\t        if (peg$cachedPos > pos) {\n\t          peg$cachedPos = 0;\n\t          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n\t        }\n\t        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n\t        peg$cachedPos = pos;\n\t      }\n\t\n\t      return peg$cachedPosDetails;\n\t    }\n\t\n\t    function peg$fail(expected) {\n\t      if (peg$currPos < peg$maxFailPos) { return; }\n\t\n\t      if (peg$currPos > peg$maxFailPos) {\n\t        peg$maxFailPos = peg$currPos;\n\t        peg$maxFailExpected = [];\n\t      }\n\t\n\t      peg$maxFailExpected.push(expected);\n\t    }\n\t\n\t    function peg$buildException(message, expected, pos) {\n\t      function cleanupExpected(expected) {\n\t        var i = 1;\n\t\n\t        expected.sort(function(a, b) {\n\t          if (a.description < b.description) {\n\t            return -1;\n\t          } else if (a.description > b.description) {\n\t            return 1;\n\t          } else {\n\t            return 0;\n\t          }\n\t        });\n\t\n\t        while (i < expected.length) {\n\t          if (expected[i - 1] === expected[i]) {\n\t            expected.splice(i, 1);\n\t          } else {\n\t            i++;\n\t          }\n\t        }\n\t      }\n\t\n\t      function buildMessage(expected, found) {\n\t        function stringEscape(s) {\n\t          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\t\n\t          return s\n\t            .replace(/\\\\/g,   '\\\\\\\\')\n\t            .replace(/\"/g,    '\\\\\"')\n\t            .replace(/\\x08/g, '\\\\b')\n\t            .replace(/\\t/g,   '\\\\t')\n\t            .replace(/\\n/g,   '\\\\n')\n\t            .replace(/\\f/g,   '\\\\f')\n\t            .replace(/\\r/g,   '\\\\r')\n\t            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n\t            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n\t            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n\t            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n\t        }\n\t\n\t        var expectedDescs = new Array(expected.length),\n\t            expectedDesc, foundDesc, i;\n\t\n\t        for (i = 0; i < expected.length; i++) {\n\t          expectedDescs[i] = expected[i].description;\n\t        }\n\t\n\t        expectedDesc = expected.length > 1\n\t          ? expectedDescs.slice(0, -1).join(\", \")\n\t              + \" or \"\n\t              + expectedDescs[expected.length - 1]\n\t          : expectedDescs[0];\n\t\n\t        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\t\n\t        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n\t      }\n\t\n\t      var posDetails = peg$computePosDetails(pos),\n\t          found      = pos < input.length ? input.charAt(pos) : null;\n\t\n\t      if (expected !== null) {\n\t        cleanupExpected(expected);\n\t      }\n\t\n\t      return new SyntaxError(\n\t        message !== null ? message : buildMessage(expected, found),\n\t        expected,\n\t        found,\n\t        pos,\n\t        posDetails.line,\n\t        posDetails.column\n\t      );\n\t    }\n\t\n\t    function peg$decode(s) {\n\t      var bc = new Array(s.length), i;\n\t\n\t      for (i = 0; i < s.length; i++) {\n\t        bc[i] = s.charCodeAt(i) - 32;\n\t      }\n\t\n\t      return bc;\n\t    }\n\t\n\t    function peg$parseRule(index) {\n\t      var bc    = peg$bytecode[index],\n\t          ip    = 0,\n\t          ips   = [],\n\t          end   = bc.length,\n\t          ends  = [],\n\t          stack = [],\n\t          params, i;\n\t\n\t      function protect(object) {\n\t        return Object.prototype.toString.apply(object) === \"[object Array]\" ? [] : object;\n\t      }\n\t\n\t      while (true) {\n\t        while (ip < end) {\n\t          switch (bc[ip]) {\n\t            case 0:\n\t              stack.push(protect(peg$consts[bc[ip + 1]]));\n\t              ip += 2;\n\t              break;\n\t\n\t            case 1:\n\t              stack.push(peg$currPos);\n\t              ip++;\n\t              break;\n\t\n\t            case 2:\n\t              stack.pop();\n\t              ip++;\n\t              break;\n\t\n\t            case 3:\n\t              peg$currPos = stack.pop();\n\t              ip++;\n\t              break;\n\t\n\t            case 4:\n\t              stack.length -= bc[ip + 1];\n\t              ip += 2;\n\t              break;\n\t\n\t            case 5:\n\t              stack.splice(-2, 1);\n\t              ip++;\n\t              break;\n\t\n\t            case 6:\n\t              stack[stack.length - 2].push(stack.pop());\n\t              ip++;\n\t              break;\n\t\n\t            case 7:\n\t              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n\t              ip += 2;\n\t              break;\n\t\n\t            case 8:\n\t              stack.pop();\n\t              stack.push(input.substring(stack[stack.length - 1], peg$currPos));\n\t              ip++;\n\t              break;\n\t\n\t            case 9:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (stack[stack.length - 1]) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 10:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (stack[stack.length - 1] === peg$FAILED) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 11:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (stack[stack.length - 1] !== peg$FAILED) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 12:\n\t              if (stack[stack.length - 1] !== peg$FAILED) {\n\t                ends.push(end);\n\t                ips.push(ip);\n\t\n\t                end = ip + 2 + bc[ip + 1];\n\t                ip += 2;\n\t              } else {\n\t                ip += 2 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 13:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (input.length > peg$currPos) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 14:\n\t              ends.push(end);\n\t              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\t\n\t              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n\t                end = ip + 4 + bc[ip + 2];\n\t                ip += 4;\n\t              } else {\n\t                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n\t                ip += 4 + bc[ip + 2];\n\t              }\n\t\n\t              break;\n\t\n\t            case 15:\n\t              ends.push(end);\n\t              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\t\n\t              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n\t                end = ip + 4 + bc[ip + 2];\n\t                ip += 4;\n\t              } else {\n\t                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n\t                ip += 4 + bc[ip + 2];\n\t              }\n\t\n\t              break;\n\t\n\t            case 16:\n\t              ends.push(end);\n\t              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\t\n\t              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n\t                end = ip + 4 + bc[ip + 2];\n\t                ip += 4;\n\t              } else {\n\t                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n\t                ip += 4 + bc[ip + 2];\n\t              }\n\t\n\t              break;\n\t\n\t            case 17:\n\t              stack.push(input.substr(peg$currPos, bc[ip + 1]));\n\t              peg$currPos += bc[ip + 1];\n\t              ip += 2;\n\t              break;\n\t\n\t            case 18:\n\t              stack.push(peg$consts[bc[ip + 1]]);\n\t              peg$currPos += peg$consts[bc[ip + 1]].length;\n\t              ip += 2;\n\t              break;\n\t\n\t            case 19:\n\t              stack.push(peg$FAILED);\n\t              if (peg$silentFails === 0) {\n\t                peg$fail(peg$consts[bc[ip + 1]]);\n\t              }\n\t              ip += 2;\n\t              break;\n\t\n\t            case 20:\n\t              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];\n\t              ip += 2;\n\t              break;\n\t\n\t            case 21:\n\t              peg$reportedPos = peg$currPos;\n\t              ip++;\n\t              break;\n\t\n\t            case 22:\n\t              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n\t              for (i = 0; i < bc[ip + 3]; i++) {\n\t                params[i] = stack[stack.length - 1 - params[i]];\n\t              }\n\t\n\t              stack.splice(\n\t                stack.length - bc[ip + 2],\n\t                bc[ip + 2],\n\t                peg$consts[bc[ip + 1]].apply(null, params)\n\t              );\n\t\n\t              ip += 4 + bc[ip + 3];\n\t              break;\n\t\n\t            case 23:\n\t              stack.push(peg$parseRule(bc[ip + 1]));\n\t              ip += 2;\n\t              break;\n\t\n\t            case 24:\n\t              peg$silentFails++;\n\t              ip++;\n\t              break;\n\t\n\t            case 25:\n\t              peg$silentFails--;\n\t              ip++;\n\t              break;\n\t\n\t            default:\n\t              throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n\t          }\n\t        }\n\t\n\t        if (ends.length > 0) {\n\t          end = ends.pop();\n\t          ip = ips.pop();\n\t        } else {\n\t          break;\n\t        }\n\t      }\n\t\n\t      return stack[0];\n\t    }\n\t\n\t\n\t      options.data = {}; // Object to which header attributes will be assigned during parsing\n\t\n\t      function list (first, rest) {\n\t        return [first].concat(rest);\n\t      }\n\t\n\t\n\t    peg$result = peg$parseRule(peg$startRuleIndex);\n\t\n\t    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n\t      return peg$result;\n\t    } else {\n\t      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n\t        peg$fail({ type: \"end\", description: \"end of input\" });\n\t      }\n\t\n\t      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n\t    }\n\t  }\n\t\n\t  return {\n\t    SyntaxError: SyntaxError,\n\t    parse:       parse\n\t  };\n\t})();\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\tvar toplevel = global.window || global;\n\t\n\tfunction getPrefixedProperty (object, name) {\n\t  if (object == null) {\n\t    return;\n\t  }\n\t  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n\t  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n\t  for (var i in prefixedNames) {\n\t    var property = object[prefixedNames[i]];\n\t    if (property) {\n\t      return property.bind(object);\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = {\n\t  WebSocket: toplevel.WebSocket,\n\t  Transport: __webpack_require__(50),\n\t  open: toplevel.open,\n\t  Promise: toplevel.Promise,\n\t  timers: toplevel,\n\t\n\t  // Console is not defined in ECMAScript, so just in case...\n\t  console: toplevel.console || {\n\t    debug: function () {},\n\t    log: function () {},\n\t    warn: function () {},\n\t    error: function () {}\n\t  },\n\t\n\t  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),\n\t  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),\n\t  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),\n\t  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),\n\t\n\t  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),\n\t  HTMLMediaElement: toplevel.HTMLMediaElement,\n\t\n\t  attachMediaStream: toplevel.attachMediaStream,\n\t  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,\n\t  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Transport\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Transport\n\t * @param {SIP.UA} ua\n\t * @param {Object} server ws_server Object\n\t */\n\tmodule.exports = function (SIP, WebSocket) {\n\tvar Transport,\n\t  C = {\n\t    // Transport status codes\n\t    STATUS_READY:        0,\n\t    STATUS_DISCONNECTED: 1,\n\t    STATUS_ERROR:        2\n\t  };\n\t\n\t/**\n\t * Compute an amount of time in seconds to wait before sending another\n\t * keep-alive.\n\t * @returns {Number}\n\t */\n\tfunction computeKeepAliveTimeout(upperBound) {\n\t  var lowerBound = upperBound * 0.8;\n\t  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n\t}\n\t\n\tTransport = function(ua, server) {\n\t\n\t  this.logger = ua.getLogger('sip.transport');\n\t  this.ua = ua;\n\t  this.ws = null;\n\t  this.server = server;\n\t  this.reconnection_attempts = 0;\n\t  this.closed = false;\n\t  this.connected = false;\n\t  this.reconnectTimer = null;\n\t  this.lastTransportError = {};\n\t\n\t  this.keepAliveInterval = ua.configuration.keepAliveInterval;\n\t  this.keepAliveTimeout = null;\n\t  this.keepAliveTimer = null;\n\t\n\t  this.ua.transport = this;\n\t\n\t  // Connect\n\t  this.connect();\n\t};\n\t\n\tTransport.prototype = {\n\t  /**\n\t   * Send a message.\n\t   * @param {SIP.OutgoingRequest|String} msg\n\t   * @returns {Boolean}\n\t   */\n\t  send: function(msg) {\n\t    var message = msg.toString();\n\t\n\t    if(this.ws && this.ws.readyState === WebSocket.OPEN) {\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n\t      }\n\t      this.ws.send(message);\n\t      return true;\n\t    } else {\n\t      this.logger.warn('unable to send message, WebSocket is not open');\n\t      return false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Send a keep-alive (a double-CRLF sequence).\n\t   * @private\n\t   * @returns {Boolean}\n\t   */\n\t  sendKeepAlive: function() {\n\t    if(this.keepAliveTimeout) { return; }\n\t\n\t    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {\n\t      this.ua.emit('keepAliveTimeout');\n\t    }.bind(this), 10000);\n\t\n\t    return this.send('\\r\\n\\r\\n');\n\t  },\n\t\n\t  /**\n\t   * Start sending keep-alives.\n\t   * @private\n\t   */\n\t  startSendingKeepAlives: function() {\n\t    if (this.keepAliveInterval && !this.keepAliveTimer) {\n\t      this.keepAliveTimer = SIP.Timers.setTimeout(function() {\n\t        this.sendKeepAlive();\n\t        this.keepAliveTimer = null;\n\t        this.startSendingKeepAlives();\n\t      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Stop sending keep-alives.\n\t   * @private\n\t   */\n\t  stopSendingKeepAlives: function() {\n\t    SIP.Timers.clearTimeout(this.keepAliveTimer);\n\t    SIP.Timers.clearTimeout(this.keepAliveTimeout);\n\t    this.keepAliveTimer = null;\n\t    this.keepAliveTimeout = null;\n\t  },\n\t\n\t  /**\n\t  * Disconnect socket.\n\t  */\n\t  disconnect: function() {\n\t    if(this.ws) {\n\t      // Clear reconnectTimer\n\t      SIP.Timers.clearTimeout(this.reconnectTimer);\n\t\n\t      this.stopSendingKeepAlives();\n\t\n\t      this.closed = true;\n\t      this.logger.log('closing WebSocket ' + this.server.ws_uri);\n\t      this.ws.close();\n\t    }\n\t\n\t    if (this.reconnectTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.reconnectTimer);\n\t      this.reconnectTimer = null;\n\t      this.ua.emit('disconnected', {\n\t        transport: this,\n\t        code: this.lastTransportError.code,\n\t        reason: this.lastTransportError.reason\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Connect socket.\n\t  */\n\t  connect: function() {\n\t    var transport = this;\n\t\n\t    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n\t      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');\n\t      return false;\n\t    }\n\t\n\t    if(this.ws) {\n\t      this.ws.close();\n\t    }\n\t\n\t    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n\t    this.ua.onTransportConnecting(this,\n\t      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);\n\t\n\t    try {\n\t      this.ws = new WebSocket(this.server.ws_uri, 'sip');\n\t    } catch(e) {\n\t      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);\n\t    }\n\t\n\t    this.ws.binaryType = 'arraybuffer';\n\t\n\t    this.ws.onopen = function() {\n\t      transport.onOpen();\n\t    };\n\t\n\t    this.ws.onclose = function(e) {\n\t      transport.onClose(e);\n\t    };\n\t\n\t    this.ws.onmessage = function(e) {\n\t      transport.onMessage(e);\n\t    };\n\t\n\t    this.ws.onerror = function(e) {\n\t      transport.onError(e);\n\t    };\n\t  },\n\t\n\t  // Transport Event Handlers\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onOpen: function() {\n\t    this.connected = true;\n\t\n\t    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');\n\t    // Clear reconnectTimer since we are not disconnected\n\t    if (this.reconnectTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.reconnectTimer);\n\t      this.reconnectTimer = null;\n\t    }\n\t    // Reset reconnection_attempts\n\t    this.reconnection_attempts = 0;\n\t    // Disable closed\n\t    this.closed = false;\n\t    // Trigger onTransportConnected callback\n\t    this.ua.onTransportConnected(this);\n\t    // Start sending keep-alives\n\t    this.startSendingKeepAlives();\n\t  },\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onClose: function(e) {\n\t    var connected_before = this.connected;\n\t\n\t    this.lastTransportError.code = e.code;\n\t    this.lastTransportError.reason = e.reason;\n\t\n\t    this.stopSendingKeepAlives();\n\t\n\t    if (this.reconnection_attempts > 0) {\n\t      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n\t      this.reconnect();\n\t    } else {\n\t      this.connected = false;\n\t      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n\t\n\t      if(e.wasClean === false) {\n\t        this.logger.warn('WebSocket abrupt disconnection');\n\t      }\n\t      // Transport was connected\n\t      if(connected_before === true) {\n\t        this.ua.onTransportClosed(this);\n\t        // Check whether the user requested to close.\n\t        if(!this.closed) {\n\t          this.reconnect();\n\t        } else {\n\t          this.ua.emit('disconnected', {\n\t            transport: this,\n\t            code: this.lastTransportError.code,\n\t            reason: this.lastTransportError.reason\n\t          });\n\t\n\t        }\n\t      } else {\n\t        // This is the first connection attempt\n\t        //Network error\n\t        this.ua.onTransportError(this);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onMessage: function(e) {\n\t    var message, transaction,\n\t      data = e.data;\n\t\n\t    // CRLF Keep Alive response from server. Ignore it.\n\t    if(data === '\\r\\n') {\n\t      SIP.Timers.clearTimeout(this.keepAliveTimeout);\n\t      this.keepAliveTimeout = null;\n\t\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('received WebSocket message with CRLF Keep Alive response');\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    // WebSocket binary message.\n\t    else if (typeof data !== 'string') {\n\t      try {\n\t        data = String.fromCharCode.apply(null, new Uint8Array(data));\n\t      } catch(evt) {\n\t        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n\t        return;\n\t      }\n\t\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n\t      }\n\t    }\n\t\n\t    // WebSocket text message.\n\t    else {\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n\t      }\n\t    }\n\t\n\t    message = SIP.Parser.parseMessage(data, this.ua);\n\t\n\t    if (!message) {\n\t      return;\n\t    }\n\t\n\t    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n\t      return;\n\t    }\n\t\n\t    // Do some sanity check\n\t    if(SIP.sanityCheck(message, this.ua, this)) {\n\t      if(message instanceof SIP.IncomingRequest) {\n\t        message.transport = this;\n\t        this.ua.receiveRequest(message);\n\t      } else if(message instanceof SIP.IncomingResponse) {\n\t        /* Unike stated in 18.1.2, if a response does not match\n\t        * any transaction, it is discarded here and no passed to the core\n\t        * in order to be discarded there.\n\t        */\n\t        switch(message.method) {\n\t          case SIP.C.INVITE:\n\t            transaction = this.ua.transactions.ict[message.via_branch];\n\t            if(transaction) {\n\t              transaction.receiveResponse(message);\n\t            }\n\t            break;\n\t          case SIP.C.ACK:\n\t            // Just in case ;-)\n\t            break;\n\t          default:\n\t            transaction = this.ua.transactions.nict[message.via_branch];\n\t            if(transaction) {\n\t              transaction.receiveResponse(message);\n\t            }\n\t            break;\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onError: function(e) {\n\t    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));\n\t  },\n\t\n\t  /**\n\t  * Reconnection attempt logic.\n\t  * @private\n\t  */\n\t  reconnect: function() {\n\t    var transport = this;\n\t\n\t    this.reconnection_attempts += 1;\n\t\n\t    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {\n\t      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n\t      this.ua.onTransportError(this);\n\t    } else if (this.reconnection_attempts === 1) {\n\t      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');\n\t      transport.connect();\n\t    } else {\n\t      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');\n\t\n\t      this.reconnectTimer = SIP.Timers.setTimeout(function() {\n\t        transport.connect();\n\t        transport.reconnectTimer = null;\n\t      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);\n\t    }\n\t  }\n\t};\n\t\n\tTransport.C = C;\n\treturn Transport;\n\t};\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar LoginService = function (sdk) {\n\t    var onLoginHandler = [];\n\t    return {\n\t        login: function login(username, extension, password) {\n\t            return _rcSdk.RC.sdk.platform().login({\n\t                'username': username,\n\t                'extension': extension,\n\t                'password': password\n\t            });\n\t        },\n\t        logout: function logout() {\n\t            return _rcSdk.RC.sdk.platform().logout();\n\t        },\n\t        checkLoginStatus: function checkLoginStatus() {\n\t            return _rcSdk.RC.sdk.platform().loggedIn().then(function (isLoggedIn) {\n\t                if (isLoggedIn) {\n\t                    onLoginHandler.forEach(function (handler) {\n\t                        return handler();\n\t                    });\n\t                }\n\t                return isLoggedIn;\n\t            });\n\t        },\n\t        oauth: function oauth() {\n\t            return new Promise(function (resolve, reject) {\n\t                var redirectUri = 'https://ringcentral.github.io/ringcentral-js-widget/page/redirect.html';\n\t                var url = _rcSdk.RC.sdk.platform().authUrl({\n\t                    redirectUri: redirectUri\n\t                });\n\t                var oauthWindow = window.open(url, 'rc-iframe-2', 'width=400, height=600');\n\t                var interval = setInterval(check, 500);\n\t                function check() {\n\t                    if (!oauthWindow) {\n\t                        return;\n\t                    }\n\t                    if (oauthWindow.closed) {\n\t                        reject(new Error(''));\n\t                        window.removeEventListener('message', oauthChannel);\n\t                        clearInterval(interval);\n\t                    }\n\t                }\n\t                window.addEventListener('message', oauthChannel);\n\t                function oauthChannel(e) {\n\t                    if (e.data.type === 'oauth') {\n\t                        var qs = _rcSdk.RC.sdk.platform().parseAuthRedirectUrl(e.data.value);\n\t                        qs.redirectUri = redirectUri;\n\t                        window.removeEventListener('message', oauthChannel);\n\t                        clearInterval(interval);\n\t                        resolve(_rcSdk.RC.sdk.platform().login(qs));\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    };\n\t}();\n\texports.default = LoginService;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _rcSubscriptionService = __webpack_require__(53);\n\t\n\tvar _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar CallLogService = function (sdk) {\n\t    var period = 7 * 24 * 3600 * 1000;\n\t    var dateFrom = new Date(Date.now() - period);\n\t    return {\n\t        getCallLogs: function getCallLogs() {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', { dateFrom: dateFrom.toISOString() }).then(function (response) {\n\t                return response.json().records;\n\t            });\n\t        },\n\t        getCallLogsByNumber: function getCallLogsByNumber(phoneNumber, hourFrom, hourTo) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', {\n\t                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n\t                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n\t                phoneNumber: phoneNumber\n\t            }).then(function (response) {\n\t                return response.json();\n\t            }).then(function (data) {\n\t                return data.records;\n\t            }).then(function (records) {\n\t                return records.reverse();\n\t            });\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = CallLogService;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar rcSubscription = function () {\n\t    var _init = false;\n\t    var cacheKey = 'ringcentral-subscription';\n\t    var subscription;\n\t    var handlers = {};\n\t    function init() {\n\t        _init = true;\n\t        subscription = _rcSdk.RC.sdk.createCachedSubscription(cacheKey).restore();\n\t        subscription.on(subscription.events.notification, function (msg) {\n\t            for (var key in handlers) {\n\t                if (handlers.hasOwnProperty(key)) {\n\t                    if (msg.event.indexOf(key) > -1) {\n\t                        handlers[key].forEach(function (h) {\n\t                            try {\n\t                                h(msg);\n\t                            } catch (e) {\n\t                                console.error('Error occurs when invoking subscription notification handler for \"' + msg.event + '\": ' + e);\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    return {\n\t        subscribe: function subscribe(suffix, event, handler) {\n\t            if (!_init) init();\n\t            if (event && suffix) {\n\t                if (!handlers[suffix]) {\n\t                    handlers[suffix] = [];\n\t                }\n\t                handlers[suffix].push(handler);\n\t                subscription.addEventFilters(event).register();\n\t            }\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcSubscription;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar accountService = function (RC) {\n\t    var info;\n\t    var numbers;\n\t    var fetchNumbers = null;\n\t\n\t    function getNumbersByType(numbers, type) {\n\t        if (!numbers) return Error('Need to fetch numbers first using accountService.getPhoneNumber');\n\t        return numbers.filter(function (number) {\n\t            return number.type === type;\n\t        });\n\t    }\n\t\n\t    function getNumbersByFeatures(numbers, features) {\n\t        if (!Array.isArray(features)) features = [features];\n\t        // if has duplicate features\n\t        return numbers.filter(function (number) {\n\t            return features.filter(function (f) {\n\t                return number.features.indexOf(f) > -1;\n\t            }).length > 0;\n\t        });\n\t    }\n\t\n\t    return {\n\t        getAccountInfo: function getAccountInfo() {\n\t            return RC.sdk.platform().get('/account/~/extension/~').then(function (response) {\n\t                info = response.json();\n\t                return info;\n\t            }).catch(function (e) {\n\t                return console.error('Recent Calls Error: ' + e.message);\n\t            });\n\t        },\n\t\n\t        getPhoneNumber: function getPhoneNumber() {\n\t            fetchNumbers = RC.sdk.platform().get('/account/~/extension/~/phone-number').then(function (response) {\n\t                var data = response.json();\n\t                numbers = data.records;\n\t                fetchNumbers = null;\n\t                return data.records;\n\t            }).catch(function (e) {\n\t                return console.error('Recent Calls Error: ' + e.message);\n\t            });\n\t            return fetchNumbers;\n\t        },\n\t\n\t        hasServiceFeature: function hasServiceFeature(name) {\n\t            if (!info) return Error('Need to fetch account info by accountService.getAccountInfo');\n\t            return info.serviceFeatures.filter(function (feature) {\n\t                return feature.featureName.toLowerCase() === name.toLowerCase();\n\t            }).length > 0;\n\t        },\n\t\n\t        listNumber: function listNumber(type) {\n\t            var features = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t            if (fetchNumbers) {\n\t                return fetchNumbers.then(function () {\n\t                    return getNumbersByFeatures(getNumbersByType(numbers, type), features).map(function (number) {\n\t                        return number.phoneNumber;\n\t                    });\n\t                });\n\t            } else {\n\t                return getNumbersByFeatures(getNumbersByType(numbers, type), features).sort(function (number1, number2) {\n\t                    if (number2.usageType === 'DirectNumber') return 1;\n\t                    return -1;\n\t                }).map(function (number) {\n\t                    return number.phoneNumber;\n\t                });\n\t            }\n\t        }\n\t    };\n\t}(_rcSdk.RC);\n\t\n\texports.default = accountService;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _lzString = __webpack_require__(56);\n\t\n\tvar _lzString2 = _interopRequireDefault(_lzString);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcContactService = function () {\n\t    var companyContacts = [];\n\t    var completeCompanyContacts = null;\n\t\n\t    var fetchingCompanyContacts = null;\n\t    var fetchingCompleteCompanyContacts = null;\n\t\n\t    function Contact() {\n\t        this.firstName = null;\n\t        this.lastName = null;\n\t        this.displayName = null;\n\t        this.extension = null;\n\t        this.email = null;\n\t        this.type = null;\n\t        this.id = null;\n\t        this.phoneNumber = [];\n\t    }\n\t\n\t    function createContact(extension) {\n\t        var contact = new Contact();\n\t        contact.extension = extension.extensionNumber;\n\t        contact.firstName = extension.contact.firstName;\n\t        contact.lastName = extension.contact.lastName;\n\t        contact.displayName = contact.firstName + ' ' + contact.lastName;\n\t        contact.email = extension.contact.email;\n\t        contact.type = 'rc';\n\t        contact.id = extension.id;\n\t        contact.profileImage = extension.profileImage.uri;\n\t        return contact;\n\t    }\n\t\n\t    function addToCompanyContact(response) {\n\t        var records = response.json().records.filter(function (extension) {\n\t            return extension.status === 'Enabled' && ['DigitalUser', 'User'].indexOf(extension.type) >= 0;\n\t        }).map(function (extension) {\n\t            return createContact(extension);\n\t        });\n\t        companyContacts.push.apply(companyContacts, records);\n\t    }\n\t\n\t    function fetchCompanyContactByPage(page) {\n\t        return _rcSdk.RC.sdk.platform().get('/account/~/extension/', { perPage: 250, page: page });\n\t    }\n\t\n\t    function fetchCompanyDirectNumbersByPage(page) {\n\t        return _rcSdk.RC.sdk.platform().get('/account/~/phone-number', { perPage: 250, page: page });\n\t    }\n\t\n\t    function fetchCompanyContacts() {\n\t        var page = 1;\n\t        fetchingCompanyContacts = fetchCompanyContactByPage(page).then(function (response) {\n\t            var respObj = response.json();\n\t            if (respObj.paging && respObj.paging.totalPages > page) {\n\t                var promises = [];\n\t                while (respObj.paging.totalPages > page) {\n\t                    page++;\n\t                    promises.push(fetchCompanyContactByPage(page));\n\t                }\n\t\n\t                return Promise.all(promises).then(function (responses) {\n\t                    responses.forEach(function (response) {\n\t                        addToCompanyContact(response);\n\t                    });\n\t                    fetchingCompanyContacts = null;\n\t                    return companyContacts;\n\t                });\n\t            } else {\n\t                addToCompanyContact(response);\n\t                return companyContacts;\n\t            }\n\t        }).catch(function (e) {\n\t            console.error(e);\n\t        });\n\t        return fetchingCompanyContacts;\n\t    }\n\t\n\t    function fetchCompanyDirectNumbers() {\n\t        var page = 1;\n\t        return fetchCompanyDirectNumbersByPage(page).then(function (response) {\n\t            var respObj = response.json();\n\t            if (respObj.paging && respObj.paging.totalPages > page) {\n\t                var promises = [];\n\t                while (respObj.paging.totalPages > page) {\n\t                    page++;\n\t                    promises.push(fetchCompanyDirectNumbersByPage(page));\n\t                }\n\t\n\t                return Promise.all(promises).then(function (responses) {\n\t                    var numbers = {};\n\t                    responses.forEach(function (response) {\n\t                        var resp = response.json();\n\t                        resp.records.forEach(function (el) {\n\t                            if (el.extension && el.extension.extensionNumber) {\n\t                                if (!numbers[el.extension.extensionNumber]) {\n\t                                    numbers[el.extension.extensionNumber] = [];\n\t                                }\n\t\n\t                                numbers[el.extension.extensionNumber].push(el);\n\t                            }\n\t                        });\n\t                    });\n\t                    companyContacts.forEach(function (contact) {\n\t                        var phones = numbers[contact.extension];\n\t                        if (phones) {\n\t                            phones.forEach(function (phone) {\n\t                                contact.phoneNumber.push(phone.phoneNumber);\n\t                            });\n\t                        }\n\t                    });\n\t                });\n\t            }\n\t        });\n\t    }\n\t\n\t    return {\n\t        get companyContacts() {\n\t            return companyContacts;\n\t        },\n\t        accessToken: function accessToken() {\n\t            return _rcSdk.RC.sdk.platform().auth().accessToken();\n\t        },\n\t        asyncGetCompanyContact: function asyncGetCompanyContact() {\n\t            if (fetchingCompanyContacts) {\n\t                return fetchingCompanyContacts;\n\t            } else {\n\t                return Promise.resolve(companyContacts);\n\t            }\n\t        },\n\t        syncCompanyContact: function syncCompanyContact() {\n\t            companyContacts.length = 0;\n\t            fetchCompanyContacts();\n\t            fetchCompanyDirectNumbers();\n\t        },\n\t        completeCompanyContact: function completeCompanyContact() {\n\t            if (completeCompanyContacts) return Promise.resolve(completeCompanyContacts);\n\t            if (fetchingCompleteCompanyContacts) return fetchingCompleteCompanyContacts;\n\t            fetchingCompleteCompanyContacts = fetchCompanyContacts().then(fetchCompanyDirectNumbers);\n\t            return fetchingCompleteCompanyContacts.then(function () {\n\t                completeCompanyContacts = companyContacts;\n\t                fetchingCompleteCompanyContacts = null;\n\t                return companyContacts;\n\t            });\n\t        },\n\t        cacheContacts: function () {\n\t            var contact = null;\n\t            var data = localStorage.getItem('rc-contacts');\n\t            return function () {\n\t                if (contact) {\n\t                    contact.then(function (value) {\n\t                        completeCompanyContacts = companyContacts = value;\n\t                    });\n\t                    return contact;\n\t                }\n\t                // For test\n\t                if (window.location.href.indexOf('127.0.0.11') === -1) {\n\t                    var fetch = new Promise(function (resolve, reject) {\n\t                        // Hack for delay the refreshing request\n\t                        setTimeout(function () {\n\t                            rcContactService.completeCompanyContact().then(function (data) {\n\t                                if (data) {\n\t                                    completeCompanyContacts = companyContacts = data;\n\t                                    localStorage.setItem('rc-contacts', _lzString2.default.compressToUTF16(JSON.stringify(data)));\n\t                                }\n\t                                return resolve(data);\n\t                            });\n\t                        }, 100);\n\t                    });\n\t                } else {\n\t                    var fetch;\n\t                }\n\t                if (data) {\n\t                    var fetchedContact = JSON.parse(_lzString2.default.decompressFromUTF16(data));\n\t                    completeCompanyContacts = companyContacts = fetchedContact;\n\t                    contact = Promise.resolve(fetchedContact);\n\t                } else {\n\t                    contact = fetch;\n\t                }\n\t                return contact;\n\t            };\n\t        }()\n\t    };\n\t}();\n\t\n\texports.default = rcContactService;\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n\t// This work is free. You can redistribute it and/or modify it\n\t// under the terms of the WTFPL, Version 2\n\t// For more information see LICENSE.txt or http://www.wtfpl.net/\n\t//\n\t// For more information, the home page:\n\t// http://pieroxy.net/blog/pages/lz-string/testing.html\n\t//\n\t// LZ-based compression algorithm, version 1.4.4\n\tvar LZString = (function() {\n\t\n\t// private property\n\tvar f = String.fromCharCode;\n\tvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\tvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n\tvar baseReverseDic = {};\n\t\n\tfunction getBaseValue(alphabet, character) {\n\t  if (!baseReverseDic[alphabet]) {\n\t    baseReverseDic[alphabet] = {};\n\t    for (var i=0 ; i<alphabet.length ; i++) {\n\t      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n\t    }\n\t  }\n\t  return baseReverseDic[alphabet][character];\n\t}\n\t\n\tvar LZString = {\n\t  compressToBase64 : function (input) {\n\t    if (input == null) return \"\";\n\t    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n\t    switch (res.length % 4) { // To produce valid Base64\n\t    default: // When could this happen ?\n\t    case 0 : return res;\n\t    case 1 : return res+\"===\";\n\t    case 2 : return res+\"==\";\n\t    case 3 : return res+\"=\";\n\t    }\n\t  },\n\t\n\t  decompressFromBase64 : function (input) {\n\t    if (input == null) return \"\";\n\t    if (input == \"\") return null;\n\t    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n\t  },\n\t\n\t  compressToUTF16 : function (input) {\n\t    if (input == null) return \"\";\n\t    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n\t  },\n\t\n\t  decompressFromUTF16: function (compressed) {\n\t    if (compressed == null) return \"\";\n\t    if (compressed == \"\") return null;\n\t    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n\t  },\n\t\n\t  //compress into uint8array (UCS-2 big endian format)\n\t  compressToUint8Array: function (uncompressed) {\n\t    var compressed = LZString.compress(uncompressed);\n\t    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\t\n\t    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n\t      var current_value = compressed.charCodeAt(i);\n\t      buf[i*2] = current_value >>> 8;\n\t      buf[i*2+1] = current_value % 256;\n\t    }\n\t    return buf;\n\t  },\n\t\n\t  //decompress from uint8array (UCS-2 big endian format)\n\t  decompressFromUint8Array:function (compressed) {\n\t    if (compressed===null || compressed===undefined){\n\t        return LZString.decompress(compressed);\n\t    } else {\n\t        var buf=new Array(compressed.length/2); // 2 bytes per character\n\t        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n\t          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n\t        }\n\t\n\t        var result = [];\n\t        buf.forEach(function (c) {\n\t          result.push(f(c));\n\t        });\n\t        return LZString.decompress(result.join(''));\n\t\n\t    }\n\t\n\t  },\n\t\n\t\n\t  //compress into a string that is already URI encoded\n\t  compressToEncodedURIComponent: function (input) {\n\t    if (input == null) return \"\";\n\t    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n\t  },\n\t\n\t  //decompress from an output of compressToEncodedURIComponent\n\t  decompressFromEncodedURIComponent:function (input) {\n\t    if (input == null) return \"\";\n\t    if (input == \"\") return null;\n\t    input = input.replace(/ /g, \"+\");\n\t    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n\t  },\n\t\n\t  compress: function (uncompressed) {\n\t    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n\t  },\n\t  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n\t    if (uncompressed == null) return \"\";\n\t    var i, value,\n\t        context_dictionary= {},\n\t        context_dictionaryToCreate= {},\n\t        context_c=\"\",\n\t        context_wc=\"\",\n\t        context_w=\"\",\n\t        context_enlargeIn= 2, // Compensate for the first entry which should not count\n\t        context_dictSize= 3,\n\t        context_numBits= 2,\n\t        context_data=[],\n\t        context_data_val=0,\n\t        context_data_position=0,\n\t        ii;\n\t\n\t    for (ii = 0; ii < uncompressed.length; ii += 1) {\n\t      context_c = uncompressed.charAt(ii);\n\t      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n\t        context_dictionary[context_c] = context_dictSize++;\n\t        context_dictionaryToCreate[context_c] = true;\n\t      }\n\t\n\t      context_wc = context_w + context_c;\n\t      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n\t        context_w = context_wc;\n\t      } else {\n\t        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n\t          if (context_w.charCodeAt(0)<256) {\n\t            for (i=0 ; i<context_numBits ; i++) {\n\t              context_data_val = (context_data_val << 1);\n\t              if (context_data_position == bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t            }\n\t            value = context_w.charCodeAt(0);\n\t            for (i=0 ; i<8 ; i++) {\n\t              context_data_val = (context_data_val << 1) | (value&1);\n\t              if (context_data_position == bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t              value = value >> 1;\n\t            }\n\t          } else {\n\t            value = 1;\n\t            for (i=0 ; i<context_numBits ; i++) {\n\t              context_data_val = (context_data_val << 1) | value;\n\t              if (context_data_position ==bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t              value = 0;\n\t            }\n\t            value = context_w.charCodeAt(0);\n\t            for (i=0 ; i<16 ; i++) {\n\t              context_data_val = (context_data_val << 1) | (value&1);\n\t              if (context_data_position == bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t              value = value >> 1;\n\t            }\n\t          }\n\t          context_enlargeIn--;\n\t          if (context_enlargeIn == 0) {\n\t            context_enlargeIn = Math.pow(2, context_numBits);\n\t            context_numBits++;\n\t          }\n\t          delete context_dictionaryToCreate[context_w];\n\t        } else {\n\t          value = context_dictionary[context_w];\n\t          for (i=0 ; i<context_numBits ; i++) {\n\t            context_data_val = (context_data_val << 1) | (value&1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = value >> 1;\n\t          }\n\t\n\t\n\t        }\n\t        context_enlargeIn--;\n\t        if (context_enlargeIn == 0) {\n\t          context_enlargeIn = Math.pow(2, context_numBits);\n\t          context_numBits++;\n\t        }\n\t        // Add wc to the dictionary.\n\t        context_dictionary[context_wc] = context_dictSize++;\n\t        context_w = String(context_c);\n\t      }\n\t    }\n\t\n\t    // Output the code for w.\n\t    if (context_w !== \"\") {\n\t      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n\t        if (context_w.charCodeAt(0)<256) {\n\t          for (i=0 ; i<context_numBits ; i++) {\n\t            context_data_val = (context_data_val << 1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t          }\n\t          value = context_w.charCodeAt(0);\n\t          for (i=0 ; i<8 ; i++) {\n\t            context_data_val = (context_data_val << 1) | (value&1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = value >> 1;\n\t          }\n\t        } else {\n\t          value = 1;\n\t          for (i=0 ; i<context_numBits ; i++) {\n\t            context_data_val = (context_data_val << 1) | value;\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = 0;\n\t          }\n\t          value = context_w.charCodeAt(0);\n\t          for (i=0 ; i<16 ; i++) {\n\t            context_data_val = (context_data_val << 1) | (value&1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = value >> 1;\n\t          }\n\t        }\n\t        context_enlargeIn--;\n\t        if (context_enlargeIn == 0) {\n\t          context_enlargeIn = Math.pow(2, context_numBits);\n\t          context_numBits++;\n\t        }\n\t        delete context_dictionaryToCreate[context_w];\n\t      } else {\n\t        value = context_dictionary[context_w];\n\t        for (i=0 ; i<context_numBits ; i++) {\n\t          context_data_val = (context_data_val << 1) | (value&1);\n\t          if (context_data_position == bitsPerChar-1) {\n\t            context_data_position = 0;\n\t            context_data.push(getCharFromInt(context_data_val));\n\t            context_data_val = 0;\n\t          } else {\n\t            context_data_position++;\n\t          }\n\t          value = value >> 1;\n\t        }\n\t\n\t\n\t      }\n\t      context_enlargeIn--;\n\t      if (context_enlargeIn == 0) {\n\t        context_enlargeIn = Math.pow(2, context_numBits);\n\t        context_numBits++;\n\t      }\n\t    }\n\t\n\t    // Mark the end of the stream\n\t    value = 2;\n\t    for (i=0 ; i<context_numBits ; i++) {\n\t      context_data_val = (context_data_val << 1) | (value&1);\n\t      if (context_data_position == bitsPerChar-1) {\n\t        context_data_position = 0;\n\t        context_data.push(getCharFromInt(context_data_val));\n\t        context_data_val = 0;\n\t      } else {\n\t        context_data_position++;\n\t      }\n\t      value = value >> 1;\n\t    }\n\t\n\t    // Flush the last char\n\t    while (true) {\n\t      context_data_val = (context_data_val << 1);\n\t      if (context_data_position == bitsPerChar-1) {\n\t        context_data.push(getCharFromInt(context_data_val));\n\t        break;\n\t      }\n\t      else context_data_position++;\n\t    }\n\t    return context_data.join('');\n\t  },\n\t\n\t  decompress: function (compressed) {\n\t    if (compressed == null) return \"\";\n\t    if (compressed == \"\") return null;\n\t    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n\t  },\n\t\n\t  _decompress: function (length, resetValue, getNextValue) {\n\t    var dictionary = [],\n\t        next,\n\t        enlargeIn = 4,\n\t        dictSize = 4,\n\t        numBits = 3,\n\t        entry = \"\",\n\t        result = [],\n\t        i,\n\t        w,\n\t        bits, resb, maxpower, power,\n\t        c,\n\t        data = {val:getNextValue(0), position:resetValue, index:1};\n\t\n\t    for (i = 0; i < 3; i += 1) {\n\t      dictionary[i] = i;\n\t    }\n\t\n\t    bits = 0;\n\t    maxpower = Math.pow(2,2);\n\t    power=1;\n\t    while (power!=maxpower) {\n\t      resb = data.val & data.position;\n\t      data.position >>= 1;\n\t      if (data.position == 0) {\n\t        data.position = resetValue;\n\t        data.val = getNextValue(data.index++);\n\t      }\n\t      bits |= (resb>0 ? 1 : 0) * power;\n\t      power <<= 1;\n\t    }\n\t\n\t    switch (next = bits) {\n\t      case 0:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,8);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t        c = f(bits);\n\t        break;\n\t      case 1:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,16);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t        c = f(bits);\n\t        break;\n\t      case 2:\n\t        return \"\";\n\t    }\n\t    dictionary[3] = c;\n\t    w = c;\n\t    result.push(c);\n\t    while (true) {\n\t      if (data.index > length) {\n\t        return \"\";\n\t      }\n\t\n\t      bits = 0;\n\t      maxpower = Math.pow(2,numBits);\n\t      power=1;\n\t      while (power!=maxpower) {\n\t        resb = data.val & data.position;\n\t        data.position >>= 1;\n\t        if (data.position == 0) {\n\t          data.position = resetValue;\n\t          data.val = getNextValue(data.index++);\n\t        }\n\t        bits |= (resb>0 ? 1 : 0) * power;\n\t        power <<= 1;\n\t      }\n\t\n\t      switch (c = bits) {\n\t        case 0:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,8);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t\n\t          dictionary[dictSize++] = f(bits);\n\t          c = dictSize-1;\n\t          enlargeIn--;\n\t          break;\n\t        case 1:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,16);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t          dictionary[dictSize++] = f(bits);\n\t          c = dictSize-1;\n\t          enlargeIn--;\n\t          break;\n\t        case 2:\n\t          return result.join('');\n\t      }\n\t\n\t      if (enlargeIn == 0) {\n\t        enlargeIn = Math.pow(2, numBits);\n\t        numBits++;\n\t      }\n\t\n\t      if (dictionary[c]) {\n\t        entry = dictionary[c];\n\t      } else {\n\t        if (c === dictSize) {\n\t          entry = w + w.charAt(0);\n\t        } else {\n\t          return null;\n\t        }\n\t      }\n\t      result.push(entry);\n\t\n\t      // Add w+entry[0] to the dictionary.\n\t      dictionary[dictSize++] = w + entry.charAt(0);\n\t      enlargeIn--;\n\t\n\t      w = entry;\n\t\n\t      if (enlargeIn == 0) {\n\t        enlargeIn = Math.pow(2, numBits);\n\t        numBits++;\n\t      }\n\t\n\t    }\n\t  }\n\t};\n\t  return LZString;\n\t})();\n\t\n\tif (true) {\n\t  !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return LZString; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if( typeof module !== 'undefined' && module != null ) {\n\t  module.exports = LZString\n\t}\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar contactSearchService = function () {\n\t    var searchProviders = [];\n\t    var queryCompletedHandlers = [];\n\t\n\t    function createResult(item) {\n\t        return {\n\t            name: item.name,\n\t            value: item.value,\n\t            type: item.type,\n\t            id: item.id\n\t        };\n\t    }\n\t    return {\n\t        query: function query(searchFunctions, filter) {\n\t            return Promise.all(searchFunctions).then(function (results) {\n\t                var searchResultsKeys = {};\n\t                var searchResults = [];\n\t                results.forEach(function (result) {\n\t                    result.forEach(function (item) {\n\t                        if (filter) {\n\t                            if (filter(item)) {\n\t                                var key = item.name + item.value;\n\t                                if (!searchResultsKeys[key]) {\n\t                                    var toAddItem = createResult(item);\n\t                                    searchResultsKeys[key] = toAddItem;\n\t                                    searchResults.push(toAddItem);\n\t                                }\n\t                            }\n\t                        } else {\n\t                            var key = item.name + item.value;\n\t                            if (!searchResultsKeys[key]) {\n\t                                var toAddItem = createResult(item);\n\t                                searchResultsKeys[key] = toAddItem;\n\t                                searchResults.push(toAddItem);\n\t                            }\n\t                        }\n\t                    });\n\t                });\n\t                return searchResults;\n\t            });\n\t        }\n\t    };\n\t}();\n\texports.default = contactSearchService;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcContactService = __webpack_require__(55);\n\t\n\tvar _rcContactService2 = _interopRequireDefault(_rcContactService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcContactSearchProvider = function () {\n\t    return {\n\t        search: function search(text) {\n\t            var results = [];\n\t            if (text) {\n\t                text = text.toLowerCase();\n\t                _rcContactService2.default.companyContacts.map(function (contact) {\n\t                    if (contact.displayName && contact.displayName.toLowerCase().indexOf(text) >= 0) {\n\t                        results.push({\n\t                            name: contact.displayName,\n\t                            value: contact.extension,\n\t                            type: 'rc',\n\t                            id: contact.id\n\t                        });\n\t                        contact.phoneNumber.forEach(function (phone) {\n\t                            results.push({\n\t                                name: contact.displayName,\n\t                                value: phone,\n\t                                type: 'rc',\n\t                                id: contact.id\n\t                            });\n\t                        });\n\t                    } else {\n\t                        if (contact.extension && contact.extension.indexOf(text) >= 0) {\n\t                            results.push({\n\t                                name: contact.displayName,\n\t                                value: contact.extension,\n\t                                type: 'rc',\n\t                                id: contact.id\n\t                            });\n\t                        }\n\t\n\t                        contact.phoneNumber.forEach(function (phone) {\n\t                            if (phone.indexOf(text) >= 0) {\n\t                                results.push({\n\t                                    name: contact.displayName,\n\t                                    value: phone,\n\t                                    type: 'rc',\n\t                                    id: contact.id\n\t                                });\n\t                            }\n\t                        });\n\t                    }\n\t                });\n\t            }\n\t\n\t            return results;\n\t        },\n\t        searchAll: function searchAll() {\n\t            return _rcContactService2.default.completeCompanyContact().then(function (companyContacts) {\n\t                return companyContacts.map(function (contact) {\n\t                    return {\n\t                        name: contact.displayName,\n\t                        type: 'rc',\n\t                        id: contact.id\n\t                    };\n\t                });\n\t            }).catch(function (e) {\n\t                return console.error(e);\n\t            });\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcContactSearchProvider;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _rcSubscriptionService = __webpack_require__(53);\n\t\n\tvar _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcMessageService = function () {\n\t    var messages = {};\n\t    var fetchingPromise = null;\n\t    var syncToken = null;\n\t    var messageUpdateHandlers = [];\n\t\n\t    function fullSyncMessages(hour) {\n\t        return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n\t            dateFrom: new Date(Date.now() - hour * 3600 * 1000).toISOString(),\n\t            syncType: 'FSync'\n\t        }).then(function (responses) {\n\t            var jsonResponse = responses.json();\n\t            syncToken = jsonResponse.syncInfo.syncToken;\n\t            var results = jsonResponse.records;\n\t            addMessageToList(results);\n\t            fetchingPromise = null;\n\t            return results;\n\t        });\n\t    }\n\t\n\t    function incrementalSyncMessages() {\n\t        if (syncToken) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n\t                syncType: 'ISync',\n\t                syncToken: syncToken\n\t            }).then(function (responses) {\n\t                var jsonResponse = responses.json();\n\t                var results = jsonResponse.records;\n\t                syncToken = jsonResponse.syncInfo.syncToken;\n\t                updateMessageList(results);\n\t                messageUpdateHandlers.forEach(function (h) {\n\t                    return h(results);\n\t                });\n\t            });\n\t        }\n\t    }\n\t\n\t    function concatMessages() {\n\t        var results = [];\n\t        for (var key in messages) {\n\t            if (messages.hasOwnProperty(key)) {\n\t                results = results.concat(messages[key]);\n\t            }\n\t        }\n\t        return results;\n\t    }\n\t\n\t    function addMessageToList(results) {\n\t        results.forEach(function (message) {\n\t            if (!messages[message.type]) {\n\t                messages[message.type] = [];\n\t            }\n\t            messages[message.type].push(message);\n\t        });\n\t    }\n\t\n\t    function updateMessageList(results) {\n\t        results.forEach(function (message) {\n\t            var messageList = messages[message.type];\n\t            if (!messageList) {\n\t                if (message.availability === 'Alive') {\n\t                    messages[message.type] = [];\n\t                    messages[message.type].splice(0, 0, message);\n\t                }\n\t            } else {\n\t                var index = 0;\n\t                for (; index < messageList.length; index++) {\n\t                    if (messageList[index].id === message.id) {\n\t                        if (message.availability === 'Alive') {\n\t                            messageList[index] = message;\n\t                        } else {\n\t                            messageList.splice(index, 1);\n\t                        }\n\t                        break;\n\t                    }\n\t                }\n\t                if (index === messageList.length) {\n\t                    if (message.availability === 'Alive') {\n\t                        messageList.splice(0, 0, message);\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    return {\n\t        syncMessages: function syncMessages(hour) {\n\t            fetchingPromise = fullSyncMessages(hour);\n\t            return fetchingPromise;\n\t        },\n\t        getMessagesByType: function getMessagesByType(type) {\n\t            if (!fetchingPromise) {\n\t                if (messages[type]) {\n\t                    return messages[type];\n\t                } else {\n\t                    return [];\n\t                }\n\t            } else {\n\t                return fetchingPromise.then(function () {\n\t                    return messages[type];\n\t                });\n\t            }\n\t        },\n\t        getAllMessages: function getAllMessages() {\n\t            return !fetchingPromise ? concatMessages() : fetchingPromise.then(concatMessages);\n\t        },\n\t        subscribeToMessageUpdate: function subscribeToMessageUpdate() {\n\t            _rcSubscriptionService2.default.subscribe('message-store', '/restapi/v1.0/account/~/extension/~/message-store', incrementalSyncMessages);\n\t        },\n\t        onMessageUpdated: function onMessageUpdated(handler) {\n\t            if (handler) {\n\t                messageUpdateHandlers.push(handler);\n\t            }\n\t        },\n\t        sendSMSMessage: function sendSMSMessage(text, fromNumber, toNumber) {\n\t            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/sms/', {\n\t                from: { phoneNumber: fromNumber },\n\t                to: [{ phoneNumber: toNumber }],\n\t                text: text\n\t            }).then(function (response) {\n\t                return response.json();\n\t            });\n\t        },\n\t        sendPagerMessage: function sendPagerMessage(text, fromNumber, toNumber) {\n\t            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/company-pager/', {\n\t                from: { extensionNumber: fromNumber },\n\t                to: [{ extensionNumber: toNumber }],\n\t                text: text\n\t            }).then(function (response) {\n\t                return response.json();\n\t            });\n\t        },\n\t        sendFax: function sendFax(files, toNumber) {\n\t            var body = {\n\t                to: [{ phoneNumber: toNumber }],\n\t                faxResolution: 'High'\n\t            };\n\t            var formData = new FormData();\n\t            formData.append('json', new File([JSON.stringify(body)], 'request.json', { type: 'application/json' }));\n\t            Array.from(files).forEach(function (file) {\n\t                formData.append('attachment', file);\n\t            });\n\t            // fax need have text thus can be sent\n\t            // formData.append(\n\t            //     'attachment',\n\t            //     new File(\n\t            //         [''],\n\t            //         'text.txt',\n\t            //         { type: 'application/octet-stream' })\n\t            // )\n\t            // Send the fax\n\t            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/fax', formData);\n\t        },\n\t        getConversation: function getConversation(conversationId, hourFrom, hourTo) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n\t                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n\t                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n\t                conversationId: conversationId\n\t            }).then(function (response) {\n\t                return response.json();\n\t            }).then(function (data) {\n\t                return data.records;\n\t            }).then(function (records) {\n\t                return records.reverse();\n\t            });\n\t        },\n\t        getMessagesByNumber: function getMessagesByNumber(phoneNumber, hourFrom, hourTo) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n\t                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n\t                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n\t                phoneNumber: phoneNumber\n\t            }).then(function (response) {\n\t                return response.json();\n\t            }).then(function (data) {\n\t                return data.records;\n\t            }).then(function (records) {\n\t                return records.reverse();\n\t            });\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcMessageService;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcMessageService = __webpack_require__(59);\n\t\n\tvar _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcMessageProvider = function () {\n\t    var messageUpdatedHandlers = [];\n\t    var conversations = {};\n\t    var cachedHour = 0;\n\t\n\t    _rcMessageService2.default.onMessageUpdated(function (results) {\n\t        messageUpdatedHandlers.forEach(function (h) {\n\t            try {\n\t                h(results.slice());\n\t            } catch (e) {\n\t                console.error(e);\n\t            }\n\t        });\n\t    });\n\t\n\t    function createResult(message) {\n\t        return {\n\t            id: message.id,\n\t            time: message.lastModifiedTime,\n\t            readStatus: message.readStatus,\n\t            type: getType(message),\n\t            contact: getNumber(message.type, getDirection(message, 'Outbound')),\n\t            subject: message.subject || null,\n\t            convId: message.conversation ? message.conversation.id : null,\n\t            author: getNumber(message, getDirection(message, 'Inbound'))\n\t        };\n\t\n\t        function getDirection(message, dir) {\n\t            return message.direction === dir ? message.to[0] : message.from;\n\t        }\n\t\n\t        function getNumber(message, info) {\n\t            return message.type === 'Pager' ? info.extensionNumber : info.phoneNumber;\n\t        }\n\t\n\t        function getType(message) {\n\t            return message.type === 'Fax' || message.type === 'VoiceMail' ? 'Text' : message.type;\n\t        }\n\t    }\n\t\n\t    return {\n\t        getTextMessages: function getTextMessages() {\n\t            return Promise.resolve(_rcMessageService2.default.getMessagesByType('SMS')).then(function (messages) {\n\t                var results = [];\n\t                messages.forEach(function (message) {\n\t                    results.push(createResult(message));\n\t                });\n\t                return results;\n\t            });\n\t        },\n\t\n\t        getLastMessagesOfAllType: function getLastMessagesOfAllType() {\n\t            var results = [];\n\t            return this.getMessagesOfAllType().then(function (msgs) {\n\t                for (var key in msgs) {\n\t                    if (msgs.hasOwnProperty(key)) {\n\t                        if (key === 'anonymous') results = results.concat(msgs.anonymous[0]);else results.push(msgs[key][0]);\n\t                    }\n\t                }\n\t                return results;\n\t            });\n\t        },\n\t        // Return all messages of type 'VoiceMail' and 'Fax'. For SMS and Pager, only last message in a conversation\n\t        // will be returned.\n\t        getMessagesOfAllType: function getMessagesOfAllType() {\n\t            return Promise.resolve(_rcMessageService2.default.getAllMessages()).then(function (messages) {\n\t                var results = [];\n\t                var target = {};\n\t                messages.forEach(function (message) {\n\t                    var result = createResult(message);\n\t                    //Combine SMS/Pager messages in conversation\n\t                    if (message.conversation && message.conversation.id) {\n\t                        target[message.conversation.id] = target[message.conversation.id] || [];\n\t                        target[message.conversation.id].push(result);\n\t                        conversations[message.conversation.id] = conversations[message.conversation.id] || [];\n\t                        conversations[message.conversation.id].push(message);\n\t                    } else {\n\t                        target['anonymous'] = target['anonymous'] || [];\n\t                        target['anonymous'].push(result);\n\t                    }\n\t                });\n\t                return target;\n\t            });\n\t        },\n\t\n\t        getConversation: function getConversation(convId, hourFrom) {\n\t            if (conversations[convId] && (!hourFrom || hourFrom < cachedHour)) {\n\t                return Promise.resolve(conversations[convId].reverse());\n\t            } else {\n\t                return _rcMessageService2.default.getConversation(convId, hourFrom, cachedHour).then(function (result) {\n\t                    cachedHour = hourFrom;\n\t                    return result;\n\t                });\n\t            }\n\t        },\n\t\n\t        onMessageUpdated: function onMessageUpdated(handler) {\n\t            messageUpdatedHandlers.push(handler);\n\t        }\n\t    };\n\t}();\n\texports.default = rcMessageProvider;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar rcConferenceSerivce = function () {\n\t    var fetchingConferenceInfo = null;\n\t\n\t    function fetchConferenceInfo() {\n\t        fetchingConferenceInfo = _rcSdk.RC.sdk.platform().get('/account/~/extension/~/conferencing').then(function (responses) {\n\t            var jsonResponse = responses.json();\n\t            var conferenceInfo = {};\n\t            conferenceInfo.hostCode = jsonResponse.hostCode;\n\t            conferenceInfo.phoneNumber = jsonResponse.phoneNumber;\n\t            conferenceInfo.participantCode = jsonResponse.participantCode;\n\t            fetchingConferenceInfo = null;\n\t            return conferenceInfo;\n\t        });\n\t        return fetchingConferenceInfo;\n\t    }\n\t\n\t    return {\n\t        getConferenceInfo: function getConferenceInfo() {\n\t            if (fetchingConferenceInfo) {\n\t                return fetchingConferenceInfo;\n\t            } else {\n\t                return fetchConferenceInfo();\n\t            }\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcConferenceSerivce;\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _callLogService = __webpack_require__(52);\n\t\n\tvar _callLogService2 = _interopRequireDefault(_callLogService);\n\t\n\tvar _rcMessageService = __webpack_require__(59);\n\t\n\tvar _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar conversationService = function () {\n\t    var cachedHour = 24 * 7;\n\t    function groupMessageToContact(msgs, contacts) {\n\t        var relatedContacts = contacts.filter(function (contact) {\n\t            var knownContactsIndex = [];\n\t            var contactNums = contact.phoneNumber.concat(contact.extension);\n\t            var contactMsgs = msgs.filter(function (msg, index) {\n\t                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t                var contain = contactNums.indexOf(msgNumber) > -1;\n\t                contact.msg = contact.msg || [];\n\t                var alreadyExist = contact.msg.find(function (contactMsg) {\n\t                    return contactMsg.id == msg.id;\n\t                });\n\t                if (contain && !alreadyExist) {\n\t\n\t                    contact.msg.push(msg);\n\t                    knownContactsIndex.push(index);\n\t                }\n\t                return contain;\n\t            });\n\t            knownContactsIndex.reverse().forEach(function (index) {\n\t                return msgs.splice(index, 1);\n\t            });\n\t            return contactMsgs.length > 0;\n\t        });\n\t        msgs.forEach(function (msg) {\n\t            var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t            var contact = relatedContacts.filter(function (contact) {\n\t                return contact.id === msgNumber;\n\t            })[0];\n\t            if (contact) {\n\t                contact.msg.push(msg);\n\t            } else {\n\t                relatedContacts.push(fakeContact(msg));\n\t            }\n\t        });\n\t        return relatedContacts;\n\t    }\n\t\n\t    function groupContactToMessage(msgs, contacts) {\n\t        return msgs.map(function (msg) {\n\t            var unknownContact = true;\n\t            contacts.forEach(function (contact) {\n\t                var contactNums = contact.phoneNumber.concat(contact.extension);\n\t                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t                var contain = contactNums.indexOf(msgNumber) > -1;\n\t                if (contain) {\n\t                    msg.contact = contact;\n\t                    unknownContact = false;\n\t                }\n\t            });\n\t            // if (unknownContact) {\n\t            //     console.log(msg);\n\t            //     var fake = fakeContact(msg)\n\t            //     msg.contact = fake\n\t            //     contacts.push(fake)\n\t            // }\n\t            return msg;\n\t        });\n\t    }\n\t\n\t    function combineAdjacentMessage(contents) {\n\t        // group related SMS message\n\t        var savedContent;\n\t        var result = [];\n\t        for (var i = contents.length - 1; i > 0; --i) {\n\t            var content = contents[i];\n\t            // if (content.type !== 'SMS') {\n\t            //     if (savedContent) {\n\t            //         result.push(savedContent)\n\t            //         savedContent = null\n\t            //     }\n\t            //     result.push(content)\n\t            //     continue\n\t            // }\n\t            if (savedContent && (content.type === 'SMS' || content.type === 'Pager') && savedContent.type === content.type && savedContent.contact.id === content.contact.id) {\n\t                savedContent.others.push(content);\n\t            } else {\n\t                savedContent && result.push(savedContent);\n\t                content.others = [];\n\t                savedContent = content;\n\t            }\n\t        }\n\t        savedContent && result.push(savedContent);\n\t        return result;\n\t    }\n\t\n\t    function combine() {\n\t        for (var _len = arguments.length, targets = Array(_len), _key = 0; _key < _len; _key++) {\n\t            targets[_key] = arguments[_key];\n\t        }\n\t\n\t        return targets.reduce(function (result, target) {\n\t            return result.concat(target);\n\t        }, []);\n\t    }\n\t\n\t    function sortTime(target) {\n\t        return target.slice().sort(function (a, b) {\n\t            return Date.parse(a.time) - Date.parse(b.time);\n\t        });\n\t    }\n\t    function containSameVal(array1, array2) {\n\t        return array1.filter(function (n) {\n\t            return array2.indexOf(n) != -1;\n\t        }).length > 0;\n\t    }\n\t    function uniqueArray(target) {\n\t        var seen = {};\n\t        return target.filter(function (item) {\n\t            return seen.hasOwnProperty(item) ? false : seen[item] = true;\n\t        });\n\t    }\n\t\n\t    function fakeContact(msg) {\n\t        var phoneNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t        return {\n\t            displayName: phoneNumber,\n\t            id: phoneNumber,\n\t            phoneNumber: [phoneNumber],\n\t            extension: null,\n\t            msg: [msg]\n\t        };\n\t    }\n\t\n\t    function adaptMessage(msg) {\n\t        return {\n\t            id: msg.id,\n\t            from: !msg.from && 'anonymous' || // For fax\n\t            msg.from.extensionNumber || msg.from.phoneNumber,\n\t            to: !msg.to && 'anonymous' || // For fax\n\t            msg.to.phoneNumber || msg.to.extensionNumber || msg.to[0].extensionNumber || msg.to[0].phoneNumber,\n\t            direction: msg.direction,\n\t            type: msg.type,\n\t            time: msg.creationTime || msg.startTime,\n\t            lastModifiedTime: msg.lastModifiedTime || msg.startTime,\n\t            subject: msg.recording || msg.subject || msg.action || msg.attachments[0],\n\t            status: {\n\t                sendConfirmed: false,\n\t                receiveConfirmed: false\n\t            }\n\t        };\n\t    }\n\t    function getMessagesByNumber(contact, offset) {\n\t        return Promise.all(contact.phoneNumber.map(function (number) {\n\t            return _rcMessageService2.default.getMessagesByNumber(\n\t            // FIXME\n\t            number, cachedHour + offset, cachedHour);\n\t        })).then(function (result) {\n\t            return combine.apply(undefined, _toConsumableArray(result));\n\t        });\n\t    }\n\t    function getCallLogsByNumber(contact, offset) {\n\t        return Promise.all(contact.phoneNumber.map(function (number) {\n\t            return _callLogService2.default.getCallLogsByNumber(number, cachedHour + offset, cachedHour);\n\t        })).then(function (result) {\n\t            return combine.apply(undefined, _toConsumableArray(result));\n\t        });\n\t    }\n\t    function uniqId(target) {\n\t        var seen = {};\n\t        return target.filter(function (item) {\n\t            return seen.hasOwnProperty(item.id) ? false : seen[item.id] = true;\n\t        });\n\t    }\n\t    function combineContent() {\n\t        for (var _len2 = arguments.length, sources = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t            sources[_key2] = arguments[_key2];\n\t        }\n\t\n\t        return sortTime(combine.apply(undefined, _toConsumableArray(sources.map(function (source) {\n\t            return source.map(adaptMessage);\n\t        }))));\n\t    }\n\t    return {\n\t        get cachedHour() {\n\t            return cachedHour;\n\t        },\n\t        syncContent: function syncContent(contacts) {\n\t            for (var _len3 = arguments.length, sources = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n\t                sources[_key3 - 1] = arguments[_key3];\n\t            }\n\t\n\t            var contents = combineContent.apply(undefined, sources);\n\t            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n\t            contents = groupContactToMessage(contents, relatedContacts);\n\t            return contents;\n\t        },\n\t        organizeContent: function organizeContent(contacts) {\n\t            for (var _len4 = arguments.length, sources = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t                sources[_key4 - 1] = arguments[_key4];\n\t            }\n\t\n\t            var contents = combineContent.apply(undefined, sources);\n\t            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n\t            contents = groupContactToMessage(contents, relatedContacts);\n\t            contents = combineAdjacentMessage(contents);\n\t            return contents;\n\t        },\n\t        getConversations: function getConversations(contacts) {\n\t            for (var _len5 = arguments.length, sources = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n\t                sources[_key5 - 1] = arguments[_key5];\n\t            }\n\t\n\t            var contents = combineContent.apply(undefined, sources);\n\t            var relatedContacts = groupMessageToContact(contents, contacts).map(function (contact) {\n\t                contact.syncHour = cachedHour;\n\t                return contact;\n\t            }).map(function (contact) {\n\t                contact.phoneNumber = uniqueArray(contact.phoneNumber.concat(contact.extension));\n\t                return contact;\n\t            }).reduce(function (map, contact) {\n\t                map[contact.id] = contact;\n\t                return map;\n\t            }, {});\n\t            return relatedContacts;\n\t        },\n\t        loadContent: function loadContent(contact, offset) {\n\t            return Promise.all([getCallLogsByNumber(contact, offset), getMessagesByNumber(contact, offset)]).then(function (result) {\n\t                return combineContent.apply(undefined, _toConsumableArray(result));\n\t            }).then(function (contents) {\n\t                contact.msg = contents.concat(contact.msg);\n\t                cachedHour += offset;\n\t                return contents;\n\t            });\n\t        },\n\t        onConversationUpdate: function onConversationUpdate(handler) {\n\t            _rcMessageService2.default.onMessageUpdated(function (msgs) {\n\t                try {\n\t                    var msgs = sortTime(msgs.map(adaptMessage));\n\t                    handler(msgs);\n\t                } catch (e) {\n\t                    console.error(e);\n\t                    throw e;\n\t                }\n\t            });\n\t        },\n\t        adaptMessage: adaptMessage\n\t    };\n\t}();\n\t\n\texports.default = conversationService;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*\n\t * JavaScript MD5\n\t * https://github.com/blueimp/JavaScript-MD5\n\t *\n\t * Copyright 2011, Sebastian Tschan\n\t * https://blueimp.net\n\t *\n\t * Licensed under the MIT license:\n\t * http://www.opensource.org/licenses/MIT\n\t *\n\t * Based on\n\t * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n\t * Digest Algorithm, as defined in RFC 1321.\n\t * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n\t * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n\t * Distributed under the BSD License\n\t * See http://pajhome.org.uk/crypt/md5 for more info.\n\t */\n\t\n\t/*global unescape, define, module */\n\t\n\t;(function ($) {\n\t  'use strict'\n\t\n\t  /*\n\t  * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n\t  * to work around bugs in some JS interpreters.\n\t  */\n\t  function safe_add (x, y) {\n\t    var lsw = (x & 0xFFFF) + (y & 0xFFFF)\n\t    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n\t    return (msw << 16) | (lsw & 0xFFFF)\n\t  }\n\t\n\t  /*\n\t  * Bitwise rotate a 32-bit number to the left.\n\t  */\n\t  function bit_rol (num, cnt) {\n\t    return (num << cnt) | (num >>> (32 - cnt))\n\t  }\n\t\n\t  /*\n\t  * These functions implement the four basic operations the algorithm uses.\n\t  */\n\t  function md5_cmn (q, a, b, x, s, t) {\n\t    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)\n\t  }\n\t  function md5_ff (a, b, c, d, x, s, t) {\n\t    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)\n\t  }\n\t  function md5_gg (a, b, c, d, x, s, t) {\n\t    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)\n\t  }\n\t  function md5_hh (a, b, c, d, x, s, t) {\n\t    return md5_cmn(b ^ c ^ d, a, b, x, s, t)\n\t  }\n\t  function md5_ii (a, b, c, d, x, s, t) {\n\t    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)\n\t  }\n\t\n\t  /*\n\t  * Calculate the MD5 of an array of little-endian words, and a bit length.\n\t  */\n\t  function binl_md5 (x, len) {\n\t    /* append padding */\n\t    x[len >> 5] |= 0x80 << (len % 32)\n\t    x[(((len + 64) >>> 9) << 4) + 14] = len\n\t\n\t    var i\n\t    var olda\n\t    var oldb\n\t    var oldc\n\t    var oldd\n\t    var a = 1732584193\n\t    var b = -271733879\n\t    var c = -1732584194\n\t    var d = 271733878\n\t\n\t    for (i = 0; i < x.length; i += 16) {\n\t      olda = a\n\t      oldb = b\n\t      oldc = c\n\t      oldd = d\n\t\n\t      a = md5_ff(a, b, c, d, x[i], 7, -680876936)\n\t      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)\n\t      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)\n\t      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)\n\t      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)\n\t      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)\n\t      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)\n\t      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)\n\t      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)\n\t      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)\n\t      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)\n\t      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)\n\t      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)\n\t      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)\n\t      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)\n\t      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\t\n\t      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)\n\t      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)\n\t      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)\n\t      b = md5_gg(b, c, d, a, x[i], 20, -373897302)\n\t      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)\n\t      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)\n\t      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)\n\t      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)\n\t      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)\n\t      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)\n\t      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)\n\t      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)\n\t      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)\n\t      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)\n\t      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)\n\t      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\t\n\t      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)\n\t      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)\n\t      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)\n\t      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)\n\t      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)\n\t      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)\n\t      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)\n\t      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)\n\t      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)\n\t      d = md5_hh(d, a, b, c, x[i], 11, -358537222)\n\t      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)\n\t      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)\n\t      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)\n\t      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)\n\t      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)\n\t      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)\n\t\n\t      a = md5_ii(a, b, c, d, x[i], 6, -198630844)\n\t      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)\n\t      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)\n\t      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)\n\t      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)\n\t      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)\n\t      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)\n\t      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)\n\t      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)\n\t      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)\n\t      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)\n\t      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)\n\t      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)\n\t      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)\n\t      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)\n\t      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)\n\t\n\t      a = safe_add(a, olda)\n\t      b = safe_add(b, oldb)\n\t      c = safe_add(c, oldc)\n\t      d = safe_add(d, oldd)\n\t    }\n\t    return [a, b, c, d]\n\t  }\n\t\n\t  /*\n\t  * Convert an array of little-endian words to a string\n\t  */\n\t  function binl2rstr (input) {\n\t    var i\n\t    var output = ''\n\t    for (i = 0; i < input.length * 32; i += 8) {\n\t      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)\n\t    }\n\t    return output\n\t  }\n\t\n\t  /*\n\t  * Convert a raw string to an array of little-endian words\n\t  * Characters >255 have their high-byte silently ignored.\n\t  */\n\t  function rstr2binl (input) {\n\t    var i\n\t    var output = []\n\t    output[(input.length >> 2) - 1] = undefined\n\t    for (i = 0; i < output.length; i += 1) {\n\t      output[i] = 0\n\t    }\n\t    for (i = 0; i < input.length * 8; i += 8) {\n\t      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)\n\t    }\n\t    return output\n\t  }\n\t\n\t  /*\n\t  * Calculate the MD5 of a raw string\n\t  */\n\t  function rstr_md5 (s) {\n\t    return binl2rstr(binl_md5(rstr2binl(s), s.length * 8))\n\t  }\n\t\n\t  /*\n\t  * Calculate the HMAC-MD5, of a key and some data (raw strings)\n\t  */\n\t  function rstr_hmac_md5 (key, data) {\n\t    var i\n\t    var bkey = rstr2binl(key)\n\t    var ipad = []\n\t    var opad = []\n\t    var hash\n\t    ipad[15] = opad[15] = undefined\n\t    if (bkey.length > 16) {\n\t      bkey = binl_md5(bkey, key.length * 8)\n\t    }\n\t    for (i = 0; i < 16; i += 1) {\n\t      ipad[i] = bkey[i] ^ 0x36363636\n\t      opad[i] = bkey[i] ^ 0x5C5C5C5C\n\t    }\n\t    hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n\t    return binl2rstr(binl_md5(opad.concat(hash), 512 + 128))\n\t  }\n\t\n\t  /*\n\t  * Convert a raw string to a hex string\n\t  */\n\t  function rstr2hex (input) {\n\t    var hex_tab = '0123456789abcdef'\n\t    var output = ''\n\t    var x\n\t    var i\n\t    for (i = 0; i < input.length; i += 1) {\n\t      x = input.charCodeAt(i)\n\t      output += hex_tab.charAt((x >>> 4) & 0x0F) +\n\t      hex_tab.charAt(x & 0x0F)\n\t    }\n\t    return output\n\t  }\n\t\n\t  /*\n\t  * Encode a string as utf-8\n\t  */\n\t  function str2rstr_utf8 (input) {\n\t    return unescape(encodeURIComponent(input))\n\t  }\n\t\n\t  /*\n\t  * Take string arguments and return either raw or hex encoded strings\n\t  */\n\t  function raw_md5 (s) {\n\t    return rstr_md5(str2rstr_utf8(s))\n\t  }\n\t  function hex_md5 (s) {\n\t    return rstr2hex(raw_md5(s))\n\t  }\n\t  function raw_hmac_md5 (k, d) {\n\t    return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))\n\t  }\n\t  function hex_hmac_md5 (k, d) {\n\t    return rstr2hex(raw_hmac_md5(k, d))\n\t  }\n\t\n\t  function md5 (string, key, raw) {\n\t    if (!key) {\n\t      if (!raw) {\n\t        return hex_md5(string)\n\t      }\n\t      return raw_md5(string)\n\t    }\n\t    if (!raw) {\n\t      return hex_hmac_md5(key, string)\n\t    }\n\t    return raw_hmac_md5(key, string)\n\t  }\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return md5\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    module.exports = md5\n\t  } else {\n\t    $.md5 = md5\n\t  }\n\t}(this))\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*!\n\t * EventEmitter v5.0.0 - git.io/ee\n\t * Unlicense - http://unlicense.org/\n\t * Oliver Caldwell - http://oli.me.uk/\n\t * @preserve\n\t */\n\t\n\t/**\n\t * Class for managing events.\n\t * Can be extended to provide event functionality in other classes.\n\t *\n\t * @class EventEmitter Manages event registering and emitting.\n\t */\n\tfunction EventEmitter() {}\n\t\n\t// Shortcuts to improve speed and size\n\tvar proto = EventEmitter.prototype;\n\t\n\t/**\n\t * Finds the index of the listener for the event in its storage array.\n\t *\n\t * @param {Function[]} listeners Array of listeners to search through.\n\t * @param {Function} listener Method to look for.\n\t * @return {Number} Index of the specified listener, -1 if not found\n\t * @api private\n\t */\n\tfunction indexOfListener(listeners, listener) {\n\t    var i = listeners.length;\n\t    while (i--) {\n\t        if (listeners[i].listener === listener) {\n\t            return i;\n\t        }\n\t    }\n\t\n\t    return -1;\n\t}\n\t\n\t/**\n\t * Alias a method while keeping the context correct, to allow for overwriting of target method.\n\t *\n\t * @param {String} name The name of the target method.\n\t * @return {Function} The aliased method\n\t * @api private\n\t */\n\tfunction alias(name) {\n\t    return function aliasClosure() {\n\t        return this[name].apply(this, arguments);\n\t    };\n\t}\n\t\n\t/**\n\t * Returns the listener array for the specified event.\n\t * Will initialise the event object and listener arrays if required.\n\t * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n\t * Each property in the object response is an array of listener functions.\n\t *\n\t * @param {String|RegExp} evt Name of the event to return the listeners from.\n\t * @return {Function[]|Object} All listener functions for the event.\n\t */\n\tproto.getListeners = function getListeners(evt) {\n\t    var events = this._getEvents();\n\t    var response;\n\t    var key;\n\t\n\t    // Return a concatenated array of all matching events if\n\t    // the selector is a regular expression.\n\t    if (evt instanceof RegExp) {\n\t        response = {};\n\t        for (key in events) {\n\t            if (events.hasOwnProperty(key) && evt.test(key)) {\n\t                response[key] = events[key];\n\t            }\n\t        }\n\t    } else {\n\t        response = events[evt] || (events[evt] = []);\n\t    }\n\t\n\t    return response;\n\t};\n\t\n\t/**\n\t * Takes a list of listener objects and flattens it into a list of listener functions.\n\t *\n\t * @param {Object[]} listeners Raw listener objects.\n\t * @return {Function[]} Just the listener functions.\n\t */\n\tproto.flattenListeners = function flattenListeners(listeners) {\n\t    var flatListeners = [];\n\t    var i;\n\t\n\t    for (i = 0; i < listeners.length; i += 1) {\n\t        flatListeners.push(listeners[i].listener);\n\t    }\n\t\n\t    return flatListeners;\n\t};\n\t\n\t/**\n\t * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n\t *\n\t * @param {String|RegExp} evt Name of the event to return the listeners from.\n\t * @return {Object} All listener functions for an event in an object.\n\t */\n\tproto.getListenersAsObject = function getListenersAsObject(evt) {\n\t    var listeners = this.getListeners(evt);\n\t    var response;\n\t\n\t    if (listeners instanceof Array) {\n\t        response = {};\n\t        response[evt] = listeners;\n\t    }\n\t\n\t    return response || listeners;\n\t};\n\t\n\t/**\n\t * Adds a listener function to the specified event.\n\t * The listener will not be added if it is a duplicate.\n\t * If the listener returns true then it will be removed after it is called.\n\t * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to attach the listener to.\n\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addListener = function addListener(evt, listener) {\n\t    var listeners = this.getListenersAsObject(evt);\n\t    var listenerIsWrapped = (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object';\n\t    var key;\n\t\n\t    for (key in listeners) {\n\t        if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n\t            listeners[key].push(listenerIsWrapped ? listener : {\n\t                listener: listener,\n\t                once: false\n\t            });\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of addListener\n\t */\n\tproto.on = alias('addListener');\n\t\n\t/**\n\t * Semi-alias of addListener. It will add a listener that will be\n\t * automatically removed after its first execution.\n\t *\n\t * @param {String|RegExp} evt Name of the event to attach the listener to.\n\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addOnceListener = function addOnceListener(evt, listener) {\n\t    return this.addListener(evt, {\n\t        listener: listener,\n\t        once: true\n\t    });\n\t};\n\t\n\t/**\n\t * Alias of addOnceListener.\n\t */\n\tproto.once = alias('addOnceListener');\n\t\n\t/**\n\t * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n\t * You need to tell it what event names should be matched by a regex.\n\t *\n\t * @param {String} evt Name of the event to create.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.defineEvent = function defineEvent(evt) {\n\t    this.getListeners(evt);\n\t    return this;\n\t};\n\t\n\t/**\n\t * Uses defineEvent to define multiple events.\n\t *\n\t * @param {String[]} evts An array of event names to define.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.defineEvents = function defineEvents(evts) {\n\t    for (var i = 0; i < evts.length; i += 1) {\n\t        this.defineEvent(evts[i]);\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a listener function from the specified event.\n\t * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to remove the listener from.\n\t * @param {Function} listener Method to remove from the event.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeListener = function removeListener(evt, listener) {\n\t    var listeners = this.getListenersAsObject(evt);\n\t    var index;\n\t    var key;\n\t\n\t    for (key in listeners) {\n\t        if (listeners.hasOwnProperty(key)) {\n\t            index = indexOfListener(listeners[key], listener);\n\t\n\t            if (index !== -1) {\n\t                listeners[key].splice(index, 1);\n\t            }\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of removeListener\n\t */\n\tproto.off = alias('removeListener');\n\t\n\t/**\n\t * Adds listeners in bulk using the manipulateListeners method.\n\t * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n\t * You can also pass it a regular expression to add the array of listeners to all events that match it.\n\t * Yeah, this function does quite a bit. That's probably a bad thing.\n\t *\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to add.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addListeners = function addListeners(evt, listeners) {\n\t    // Pass through to manipulateListeners\n\t    return this.manipulateListeners(false, evt, listeners);\n\t};\n\t\n\t/**\n\t * Removes listeners in bulk using the manipulateListeners method.\n\t * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n\t * You can also pass it an event name and an array of listeners to be removed.\n\t * You can also pass it a regular expression to remove the listeners from all events that match it.\n\t *\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to remove.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeListeners = function removeListeners(evt, listeners) {\n\t    // Pass through to manipulateListeners\n\t    return this.manipulateListeners(true, evt, listeners);\n\t};\n\t\n\t/**\n\t * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n\t * The first argument will determine if the listeners are removed (true) or added (false).\n\t * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n\t * You can also pass it an event name and an array of listeners to be added/removed.\n\t * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n\t *\n\t * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n\t    var i;\n\t    var value;\n\t    var single = remove ? this.removeListener : this.addListener;\n\t    var multiple = remove ? this.removeListeners : this.addListeners;\n\t\n\t    // If evt is an object then pass each of its properties to this method\n\t    if ((typeof evt === 'undefined' ? 'undefined' : _typeof(evt)) === 'object' && !(evt instanceof RegExp)) {\n\t        for (i in evt) {\n\t            if (evt.hasOwnProperty(i) && (value = evt[i])) {\n\t                // Pass the single listener straight through to the singular method\n\t                if (typeof value === 'function') {\n\t                    single.call(this, i, value);\n\t                } else {\n\t                    // Otherwise pass back to the multiple function\n\t                    multiple.call(this, i, value);\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        // So evt must be a string\n\t        // And listeners must be an array of listeners\n\t        // Loop over it and pass each one to the multiple method\n\t        i = listeners.length;\n\t        while (i--) {\n\t            single.call(this, evt, listeners[i]);\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes all listeners from a specified event.\n\t * If you do not specify an event then all listeners will be removed.\n\t * That means every event will be emptied.\n\t * You can also pass a regex to remove all events that match it.\n\t *\n\t * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeEvent = function removeEvent(evt) {\n\t    var type = typeof evt === 'undefined' ? 'undefined' : _typeof(evt);\n\t    var events = this._getEvents();\n\t    var key;\n\t\n\t    // Remove different things depending on the state of evt\n\t    if (type === 'string') {\n\t        // Remove all listeners for the specified event\n\t        delete events[evt];\n\t    } else if (evt instanceof RegExp) {\n\t        // Remove all events matching the regex.\n\t        for (key in events) {\n\t            if (events.hasOwnProperty(key) && evt.test(key)) {\n\t                delete events[key];\n\t            }\n\t        }\n\t    } else {\n\t        // Remove all listeners in all events\n\t        delete this._events;\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of removeEvent.\n\t *\n\t * Added to mirror the node API.\n\t */\n\tproto.removeAllListeners = alias('removeEvent');\n\t\n\t/**\n\t * Emits an event of your choice.\n\t * When emitted, every listener attached to that event will be executed.\n\t * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n\t * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n\t * So they will not arrive within the array on the other side, they will be separate.\n\t * You can also pass a regular expression to emit to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n\t * @param {Array} [args] Optional array of arguments to be passed to each listener.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.emitEvent = function emitEvent(evt, args) {\n\t    var listenersMap = this.getListenersAsObject(evt);\n\t    var listeners;\n\t    var listener;\n\t    var i;\n\t    var key;\n\t    var response;\n\t\n\t    for (key in listenersMap) {\n\t        if (listenersMap.hasOwnProperty(key)) {\n\t            listeners = listenersMap[key].slice(0);\n\t\n\t            for (i = 0; i < listeners.length; i++) {\n\t                // If the listener returns true then it shall be removed from the event\n\t                // The function is executed either with a basic call or an apply if there is an args array\n\t                listener = listeners[i];\n\t\n\t                if (listener.once === true) {\n\t                    this.removeListener(evt, listener.listener);\n\t                }\n\t\n\t                response = listener.listener.apply(this, args || []);\n\t\n\t                if (response === this._getOnceReturnValue()) {\n\t                    this.removeListener(evt, listener.listener);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of emitEvent\n\t */\n\tproto.trigger = alias('emitEvent');\n\t\n\t/**\n\t * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n\t * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n\t * @param {...*} Optional additional arguments to be passed to each listener.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.emit = function emit(evt) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return this.emitEvent(evt, args);\n\t};\n\t\n\t/**\n\t * Sets the current value to check against when executing listeners. If a\n\t * listeners return value matches the one set here then it will be removed\n\t * after execution. This value defaults to true.\n\t *\n\t * @param {*} value The new value to check for when executing listeners.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.setOnceReturnValue = function setOnceReturnValue(value) {\n\t    this._onceReturnValue = value;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Fetches the current value to check against when executing listeners. If\n\t * the listeners return value matches this one then it should be removed\n\t * automatically. It will return true by default.\n\t *\n\t * @return {*|Boolean} The current value to check for or the default, true.\n\t * @api private\n\t */\n\tproto._getOnceReturnValue = function _getOnceReturnValue() {\n\t    if (this.hasOwnProperty('_onceReturnValue')) {\n\t        return this._onceReturnValue;\n\t    } else {\n\t        return true;\n\t    }\n\t};\n\t\n\t/**\n\t * Fetches the events object and creates one if required.\n\t *\n\t * @return {Object} The events storage object.\n\t * @api private\n\t */\n\tproto._getEvents = function _getEvents() {\n\t    return this._events || (this._events = {});\n\t};\n\t\n\texports.default = EventEmitter;\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=incontact>\n    <div data-info=auth-panel class=auth-panel></div>\n    <div class=\"rc-panel main\" data-info=main-panel hidden>\n        <div class=rc-panel__header>\n            <img class=logo src=./ringcentral-logo.svg>\n        </div>\n        <div class=rc-panel__content>\n            <p data-info=waiting class=waiting hidden>\n                Ready to receive calls\n            </p>\n        </div>\n        <div id=call-panel class=overlap></div>\n        <div id=call-panel-incoming class=overlap></div>\n    </div>\n</div>","style":"\n    html, body {\n      height: 100%;\n      color: #333;\n    }\n    .incontact, .incontact .auth-panel {\n      height: 100%;\n    }\n    .incontact .main {\n        text-align: center;\n        background-color: #fafafa;\n    }\n    .incontact .logo {\n        margin-top: 10px;\n        width: 60%;\n    }\n    .incontact .waiting {\n        margin-top: 30px;\n        text-align: center;\n        font-size: 1.2em;\n    }\n    .incontact .overlap {\n        position: absolute;\n        top: 0;\n        height: 100%;\n    }\n    .auth-panel {}\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['rc-phone'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction _interopRequireDefault(t) {\n\t  return t && t.__esModule ? t : { default: t };\n\t}var _extends = Object.assign || function (t) {\n\t  for (var e = 1; e < arguments.length; e++) {\n\t    var o = arguments[e];for (var a in o) {\n\t      Object.prototype.hasOwnProperty.call(o, a) && (t[a] = o[a]);\n\t    }\n\t  }return t;\n\t},\n\t    _factory = __webpack_require__(2),\n\t    _factory2 = _interopRequireDefault(_factory),\n\t    _eventemitter = __webpack_require__(64),\n\t    _eventemitter2 = _interopRequireDefault(_eventemitter);w.register(function () {\n\t  function t(t, o) {\n\t    var a = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],\n\t        i = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];return w(\"conversation-advanced\", { data: _extends({}, a, { new: !0, contact: t }), actions: e.create(\"conversation-advanced\", _extends({}, i, { back: { after: function after() {\n\t            this.unmount(), o && \"function\" == typeof o && o();\n\t          } } })) });\n\t  }var e = new _factory2.default();this.data = { width: 250, originalHeight: 400 }, this.props = { panels: [], width: 250, originalHeight: 400, minimizedHeight: 100, height: 400, toolbarHeight: 40, key: null, secret: null, ee: new _eventemitter2.default() }, this.actions = e.create(\"rcPhone\", { on: { method: function method(t, e, o) {\n\t        this.props.ee.on(e, o);\n\t      } }, resize: { before: function before() {}, after: function after(t) {\n\t        var e;e = t ? t : this.props.height === this.props.minimizedHeight ? this.props.originalHeight : this.props.minimizedHeight, this.props.ee.trigger(\"resize\", [this.props.width, e]);\n\t      } }, setSize: { method: function method(t, e, o) {\n\t        this.props.width = e, this.props.height = o, this.dom.phone.style.width = this.props.width + \"px\", this.dom.phone.style.height = this.props.height + \"px\";\n\t      } }, init: { before: function before() {\n\t        this.props.cachedMessageHours = 168, this.props.originalHeight = this.data.originalHeight, this.props.width = this.data.width, this.props.key = this.data.key, this.props.secret = this.data.secret, this.props.sandbox = \"true\" === this.data.sandbox, this.setSize(this.props.width, this.props.originalHeight), this.dom.toolbar.style.height = this.props.toolbarHeight + \"px\", this.dom[\"auth-panel\"].style.width = this.props.width + \"px\", this.dom[\"auth-panel\"].style.height = this.props.height + \"px\", this.createWidgets();\n\t      } }, createWidgets: { method: function method() {\n\t        var o = this,\n\t            a = this,\n\t            i = this.props.height;if (this.props.conversation = void 0, this.props.contactDetail = void 0, this.props.notification = w(\"notification\", {}), this.data.firstLevel) {\n\t          var n = this.data.firstLevel.split(\",\");if (this.props.authPanel = w(\"auth-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { oauth: !0 }), actions: e.create(\"auth-panel\", { login: { after: function after() {\n\t                  this.unmount(), a.loadData(), n.length > 1 ? a.data.shadowRoot ? a.props.toolbar.mount(a.data.shadowRoot.querySelector(\"#toolbar\")) : a.props.toolbar.mount(\"#toolbar\") : (a.props.panels[0].mount(\"#first-level-0\"), a.dom.toolbar.parentNode.removeChild(a.dom.toolbar)), a.dom[\"auth-panel\"].style[\"z-index\"] = \"-1\";\n\t                } } }) }), console.log(n.length), console.log(i), n.length > 1) {\n\t            var s = this.props.toolbar = w(\"tool-bar\", { shadowRoot: a.data.shadowRoot, data: a.data, actions: { mount: { after: function after() {\n\t                    a.props.panels[0].mount(\"#first-level-0\");\n\t                  } } } });i = this.props.height - this.props.toolbarHeight;\n\t          } else 1 === n.length && (this.props.minimizedHeight = this.props.minimizedHeight - this.props.toolbarHeight);n.forEach(function (r, p) {\n\t            var l;if (\"call-log\" === r ? (l = o.props.callLog = w(\"call-log\", { shadowRoot: a.data.shadowRoot, actions: e.create(\"call-log\") }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uniC8\"></span><span class=\"icon-RC_shapes_2-30_pressed\"></span>'), a.switchWidgets(panel, \"#first-level\" + p, p))) : \"time-line\" === r ? (o.props.callPanel || (o.props.callPanel = w(\"call-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { target: \"#call-panel\", width: o.props.width, height: i }), actions: e.create(\"call-panel\") })), l = o.props.timeline = w(\"time-line\", { shadowRoot: a.data.shadowRoot, actions: e.create(\"time-line\", { search: { method: function method() {\n\t                    contacts.dom.searchText.value = this.dom.searchText.value, contacts.search();\n\t                  } }, enterItem: { after: function after() {\n\t                    var e = this,\n\t                        o = this.props.selectedContent.contact,\n\t                        n = o.phoneNumber[0];this.props.currentConv = t(o, function () {\n\t                      e.props.currentConv.unmount();\n\t                    }, { width: a.props.width, height: i, toNumber: n, toExt: o.extension, anchorContent: this.props.selectedContent, remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }, { callout: { after: function after() {\n\t                          a.props.callPanel.setName(this.props.toNumber || this.props.toExt), a.props.callPanel.mount(\"#call-panel\");\n\t                        } } }), this.props.currentConv.mount(\"#conversation\");\n\t                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uni2487\"></span></span><span class=\"icon-RC_shapes_1_30_pressed\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"contacts\" === r ? (l = o.props.contacts = w(\"contacts\", { shadowRoot: a.data.shadowRoot, data: {}, actions: e.create(\"contacts\", { selectContact: { method: function method() {\n\t                    var e = this.props.relateContacts && this.props.relateContacts[this.props.selectedContact.id] || this.props.contacts[this.props.selectedContact.id],\n\t                        o = a.props.timeline.props.currentConv = t(e, function () {\n\t                      a.props.timeline.mount(\"#contact-detail\");\n\t                    });o.mount(\"#contact-detail\");\n\t                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uni7D\"></span><span class=\"icon-contact_info_pressed\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"dial-pad\" === r ? (o.props.callPanel || (o.props.callPanel = w(\"call-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { target: \"#call-panel\", width: o.props.width, height: i }), actions: e.create(\"call-panel\") })), l = o.props.dialPad = w(\"dial-pad\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }), actions: e.create(\"dial-pad\", { mount: { after: function after() {\n\t                    var t = !1;[\"RTCPeerConnection\", \"webkitRTCPeerConnection\", \"mozRTCPeerConnection\", \"RTCIceGatherer\"].forEach(function (e) {\n\t                      t || (t = e in window);\n\t                    }), t || this.disable(\"This browser does not support WebRTC.\");\n\t                  } }, callout: { after: function after() {\n\t                    a.props.callPanel.setName(this.props.toNumber), a.props.callPanel.mount(\"#call-panel\");\n\t                  } }, numberChange: { after: function after() {\n\t                    a.props.ee.trigger(\"dialing\", [this.props.toNumber]);\n\t                  } } }) }), o.props.callPanelIncoming = w(\"call-panel-incoming\", { shadowRoot: a.data.shadowRoot, data: _extends({ target: \"#call-panel-incoming\" }, a.data, { width: o.props.width, height: i, remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }), actions: e.create(\"call-panel-incoming\", { mount: { after: function after() {\n\t                    a.props.height === a.props.minimizedHeight ? this.simplify(!0) : this.simplify(!1), a.resize(Math.max(280, a.props.height));\n\t                  } }, unmount: { after: function after() {\n\t                    a.props.height !== a.props.originalHeight && a.resize(a.props.minimizedHeight);\n\t                  } }, accept: { after: function after() {\n\t                    this.unmount(), a.props.callPanel.setName(this.props.name), a.props.callPanel.mount(\"#call-panel\"), a.props.callPanel.start(), a.resize(a.props.originalHeight);\n\t                  } }, ignore: { after: function after() {\n\t                    a.resize(a.props.minimizedHeight);\n\t                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uniA4\"></span><span class=\"icon-RC_shapes_1-40_pressed\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"conference\" === r ? (l = o.props.conference = w(\"conference\", { data: a.data, actions: e.create(\"conference\", { inviteWithText: { method: function method() {} }, joinAsHost: { method: function method() {\n\t                    a.dom.container.style.transform = \"translateX(0px)\", a.props.dialPad.mount(\"#dial-pad\"), a.props.dialPad.number(a.props.conference.props.dialInNumber);\n\t                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uniA3\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"call-panel-incoming\" === r && (o.props.callPanel = w(\"call-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { target: \"#call-panel\", width: o.props.width, height: i }), actions: e.create(\"call-panel\") }), o.props.callPanelIncoming = w(\"call-panel-incoming\", { shadowRoot: a.data.shadowRoot, data: _extends({ target: \"#call-panel-incoming\" }, a.data, { width: o.props.width, height: i, remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }), actions: e.create(\"call-panel-incoming\", { mount: { after: function after() {\n\t                    a.props.height === a.props.minimizedHeight ? this.simplify(!0) : this.simplify(!1), a.resize(Math.max(250, a.props.height));\n\t                  } }, unmount: { after: function after() {\n\t                    a.props.height != a.props.originalHeight && a.resize(a.props.minimizedHeight);\n\t                  } }, accept: { after: function after() {\n\t                    this.unmount(), a.props.callPanel.setName(this.props.name), a.props.callPanel.mount(\"#call-panel\"), a.props.callPanel.start(), a.resize(a.props.originalHeight);\n\t                  } }, ignore: { after: function after() {\n\t                    a.resize(a.props.minimizedHeight);\n\t                  } } }) })), l) {\n\t              o.props.panels.push(l);var h = document.createElement(\"div\");h.classList.add(\"panel\"), h.classList.add(\"float-left\"), h.style.width = o.props.width + \"px\", h.style.height = o.props.height + \"px\", n.length > 1 && (h.style.height = o.props.height - o.props.toolbarHeight + \"px\"), h.setAttribute(\"id\", \"first-level-\" + (o.props.panels.length - 1)), o.dom.container.appendChild(h);\n\t            }\n\t          });\n\t        }\n\t      } }, switchWidgets: { method: function method(t, e, o, a) {\n\t        var i = this;return function () {\n\t          if (i.props.conversation && (i.props.conversation.destroy(), i.props.conversation = null), i.props.contactDetail && (i.props.contactDetail.destroy(), i.props.contactDetail = null), i.props.callPanel && i.props.callPanel._mounted && i.props.callPanel.minimize(), i.props.currentIndex !== a && !i.props.isTranistioning) {\n\t            var t = function t(e) {\n\t              i.props.panels.filter(function (t, e) {\n\t                return e !== a;\n\t              }).forEach(function (t) {\n\t                return t.unmount();\n\t              }), i.dom.container.removeEventListener(\"transitionend\", t), i.props.isTranistioning = !1;\n\t            };i.props.isTranistioning = !0, i.props.currentIndex = a, i.dom.container.style.transform = \"translateX(\" + (0 - a * i.props.width) + \"px)\", i.dom.container.addEventListener(\"transitionend\", t), e.mount(\"#first-level-\" + a);\n\t          }\n\t        };\n\t      } }, mount: { after: function after() {\n\t        var t = this;this.props.authPanel.mount(\"#auth-panel\"), this.checkLogin().then(function (e) {\n\t          e ? (t.loadData(), 1 === t.props.panels.length ? (t.props.panels[0].mount(\"#first-level-0\"), t.dom.toolbar.parentNode.removeChild(t.dom.toolbar)) : 0 === t.props.panels.length ? t.dom.toolbar.parentNode.removeChild(t.dom.toolbar) : t.props.toolbar.mount(\"#toolbar\"), t.dom[\"auth-panel\"].style[\"z-index\"] = \"-1\") : t.props.authPanel.mount(\"#auth-panel\");\n\t        }), this.props.ee.trigger(\"ready\");\n\t      } }, logout: { after: function after() {\n\t        this.props.authPanel.mount(this.dom[\"auth-panel\"]), this.dom[\"auth-panel\"].style[\"z-index\"] = \"5\", this.props.toolbar.unmount(), this.props.panels.forEach(function (t) {\n\t          return t.unmount();\n\t        }), this.props.currentIndex = 0, this.dom.container.style.transform = \"translateX(0px)\";\n\t      } } }), this.on(\"click\", function (t) {\n\t    t.target === this.dom.resize && this.resize(), t.target === this.dom.remove ? (this.props.ee.trigger(\"unmount\"), this.unmount()) : t.target === this.dom.logout && this.logout();\n\t  });\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcServices = __webpack_require__(3);\n\t\n\tvar _rcServices2 = _interopRequireDefault(_rcServices);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction extend(base, mixin) {\n\t    // FIXME: avoid create function in for loop\n\t    Object.keys(mixin).forEach(function (action) {\n\t        if (base[action]) {\n\t            Object.keys(mixin[action]).forEach(function (hook) {\n\t                var origin = base[action][hook];\n\t                var mix = mixin[action][hook];\n\t                base[action][hook] = function () {\n\t                    var result;\n\t                    if (origin) {\n\t                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t                            args[_key] = arguments[_key];\n\t                        }\n\t\n\t                        result = origin.call.apply(origin, [this].concat(args));\n\t                    }\n\t                    mix.call(this);\n\t                    return result;\n\t                };\n\t            });\n\t        } else {\n\t            base[action] = mixin[action];\n\t        }\n\t    });\n\t    return base;\n\t} // TODO: use dependency injection\n\t\n\t\n\tvar Factory = function Factory() {};\n\t\n\tFactory.prototype.create = function (type) {\n\t    var mixin = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    return extend(_rcServices2.default[type], mixin);\n\t};\n\t\n\texports.default = Factory;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _phoneService = __webpack_require__(12);\n\t\n\tvar _phoneService2 = _interopRequireDefault(_phoneService);\n\t\n\tvar _loginService = __webpack_require__(51);\n\t\n\tvar _loginService2 = _interopRequireDefault(_loginService);\n\t\n\tvar _callLogService = __webpack_require__(52);\n\t\n\tvar _callLogService2 = _interopRequireDefault(_callLogService);\n\t\n\tvar _accountService = __webpack_require__(54);\n\t\n\tvar _accountService2 = _interopRequireDefault(_accountService);\n\t\n\tvar _rcContactService = __webpack_require__(55);\n\t\n\tvar _rcContactService2 = _interopRequireDefault(_rcContactService);\n\t\n\tvar _contactSearchService = __webpack_require__(57);\n\t\n\tvar _contactSearchService2 = _interopRequireDefault(_contactSearchService);\n\t\n\tvar _rcContactSearchProvider = __webpack_require__(58);\n\t\n\tvar _rcContactSearchProvider2 = _interopRequireDefault(_rcContactSearchProvider);\n\t\n\tvar _rcMessageService = __webpack_require__(59);\n\t\n\tvar _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n\t\n\tvar _rcMessageProvider = __webpack_require__(60);\n\t\n\tvar _rcMessageProvider2 = _interopRequireDefault(_rcMessageProvider);\n\t\n\tvar _rcConferenceService = __webpack_require__(61);\n\t\n\tvar _rcConferenceService2 = _interopRequireDefault(_rcConferenceService);\n\t\n\tvar _rcConversationService = __webpack_require__(62);\n\t\n\tvar _rcConversationService2 = _interopRequireDefault(_rcConversationService);\n\t\n\tvar _blueimpMd = __webpack_require__(63);\n\t\n\tvar _blueimpMd2 = _interopRequireDefault(_blueimpMd);\n\t\n\tvar _rcConfig = __webpack_require__(11);\n\t\n\tvar _rcConfig2 = _interopRequireDefault(_rcConfig);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar dialPadSearchProviders = [_rcContactSearchProvider2.default];\n\t\n\tvar services = {};\n\tservices['incontact'] = {\n\t    init: {\n\t        after: function after() {\n\t            /// critical, inject app key & secret into service\n\t            (0, _rcSdk.injectSDK)({\n\t                key: this.props.key,\n\t                secret: this.props.secret,\n\t                sandbox: this.props.sandbox\n\t            });\n\t        }\n\t    },\n\t    checkLogin: {\n\t        method: function method() {\n\t            return _loginService2.default.checkLoginStatus();\n\t        }\n\t    }\n\t};\n\tservices['rcPhone'] = {\n\t    init: {\n\t        after: function after() {\n\t            /// critical, inject app key & secret into service\n\t            (0, _rcSdk.injectSDK)({\n\t                key: this.props.key,\n\t                secret: this.props.secret,\n\t                sandbox: this.props.sandbox\n\t            });\n\t        }\n\t    },\n\t    loadData: {\n\t        method: function method() {\n\t            _rcMessageService2.default.subscribeToMessageUpdate();\n\t            // rcMessageService.syncMessages(this.props.cachedMessageHours);\n\t            _accountService2.default.getAccountInfo();\n\t            _accountService2.default.getPhoneNumber();\n\t            _rcContactService2.default.cacheContacts();\n\t            _phoneService2.default.init({\n\t                incomingAudio: _rcConfig2.default.incomingAudio,\n\t                outgoingAudio: _rcConfig2.default.outgoingAudio\n\t            });\n\t            _callLogService2.default.getCallLogs();\n\t        }\n\t    },\n\t    checkLogin: {\n\t        method: function method() {\n\t            return _loginService2.default.checkLoginStatus();\n\t        }\n\t    },\n\t    logout: {\n\t        method: function method() {\n\t            return _loginService2.default.logout();\n\t        }\n\t    }\n\t};\n\tservices['auth-panel'] = {\n\t    login: {\n\t        method: function method() {\n\t            // return loginService.login(\n\t            //     this.props.username,\n\t            //     this.props.extension,\n\t            //     this.props.password\n\t            // )\n\t            return _loginService2.default.oauth();\n\t        }\n\t    }\n\t};\n\tservices['dial-pad'] = {\n\t    mount: {\n\t        after: function after() {\n\t            if (!_accountService2.default.hasServiceFeature('VoipCalling')) this.disable();\n\t        }\n\t    },\n\t    callout: {\n\t        method: function method() {\n\t            console.log('real call');\n\t            return _phoneService2.default.call(this.props.fromNumber, this.props.toNumber, {\n\t                remoteVideo: this.props.remoteVideo,\n\t                localVideo: this.props.localVideo\n\t            });\n\t        }\n\t    },\n\t    queryContacts: {\n\t        method: function method() {\n\t            var _this = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this.props.toNumber);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    },\n\t    getOutboundCallerID: {\n\t        method: function method() {\n\t            return _accountService2.default.getPhoneNumber().then(function () {\n\t                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n\t            });\n\t        }\n\t    }\n\t};\n\t\n\tservices['conference'] = {\n\t    getConferenceInfo: {\n\t        method: function method() {\n\t            return _rcConferenceService2.default.getConferenceInfo();\n\t        }\n\t    }\n\t};\n\tservices['call-log'] = {\n\t    init: {\n\t        method: function method() {\n\t            return _callLogService2.default.getCallLogs();\n\t        }\n\t    }\n\t};\n\t\n\tservices['time-line'] = {\n\t    mount: {\n\t        after: function after() {\n\t            var _this2 = this;\n\t\n\t            _rcMessageService2.default.subscribeToMessageUpdate();\n\t            _rcMessageProvider2.default.onMessageUpdated(function (msg) {\n\t                _this2.updateTimeline(_rcConversationService2.default.syncContent(_this2.props.contacts, msg));\n\t                if (_this2.props.currentConv) {\n\t                    _this2.props.currentConv.confirmMessages();\n\t                    _this2.props.currentConv.addIncomingMessages();\n\t                }\n\t            });\n\t            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n\t                return _this2.props.contacts = contacts;\n\t            });\n\t        }\n\t    },\n\t    fetchData: {\n\t        method: function method() {\n\t            return Promise.all([_rcContactService2.default.cacheContacts(), // first one must be the contacts\n\t            _rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs()]).then(function (result) {\n\t                return _rcConversationService2.default.organizeContent.apply(_rcConversationService2.default, _toConsumableArray(result));\n\t            });\n\t        }\n\t    }\n\t};\n\t\n\tservices['contacts'] = {\n\t    mount: {\n\t        after: function after() {\n\t            this.fetchContacts();\n\t        }\n\t    },\n\t    fetchRelatedContact: {\n\t        method: function method() {\n\t            var _this3 = this;\n\t\n\t            return Promise.all([_rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs(), _rcContactService2.default.cacheContacts()]).then(function (result) {\n\t                var _result = _slicedToArray(result, 3);\n\t\n\t                var msgs = _result[0];\n\t                var logs = _result[1];\n\t                var contacts = _result[2];\n\t\n\t                _this3.props.contacts = contacts.reduce(function (result, contact) {\n\t                    result[contact.id] = contact;\n\t                    return result;\n\t                }, {});\n\t                return _rcConversationService2.default.getConversations(contacts, msgs, logs);\n\t            }).then(function (relateContacts) {\n\t                _this3.props.relateContacts = relateContacts;\n\t                return relateContacts;\n\t            }).then(function (relateContacts) {\n\t                return Object.keys(relateContacts).map(function (index) {\n\t                    // adapt to messages template format\n\t                    relateContacts[index].msg[0].contact = relateContacts[index].displayName;\n\t                    // for conversation-advance temaplate\n\t                    relateContacts[index].msg[0].contactId = index;\n\t                    return relateContacts[index].msg[0];\n\t                });\n\t            });\n\t        }\n\t    },\n\t    fetchContacts: {\n\t        method: function method() {\n\t            var _this4 = this;\n\t\n\t            // var dialPadSearchFunctions = dialPadSearchProviders.map(provider => {\n\t            //     return provider.searchAll();\n\t            // });\n\t            // return contactSearchService.query(dialPadSearchFunctions);\n\t            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n\t                _this4.props.contacts = contacts.reduce(function (result, contact) {\n\t                    result[contact.id] = contact;\n\t                    return result;\n\t                }, {});\n\t                return contacts.map(function (contact) {\n\t                    return {\n\t                        name: contact.displayName,\n\t                        type: 'rc',\n\t                        id: contact.id\n\t                    };\n\t                });\n\t            }).catch(function (e) {\n\t                return console.error(e);\n\t            });\n\t        }\n\t    }\n\t};\n\t\n\tservices['conversation-advanced'] = {\n\t    init: {\n\t        after: function after() {}\n\t    },\n\t    mount: {\n\t        after: function after() {\n\t            var _this5 = this;\n\t\n\t            return _accountService2.default.getAccountInfo()\n\t            // FIXME: set props from outside is a anti-pattern\n\t            .then(function (info) {\n\t                return _this5.props.fromExt = info.extensionNumber;\n\t            }).then(function () {\n\t                _this5.setOutboundCallerID();\n\t            });\n\t        }\n\t    },\n\t    send: {\n\t        method: function method() {\n\t            if (!this.props.toNumber || this.props.toNumber === this.props.toExt) {\n\t                return _rcMessageService2.default.sendPagerMessage(this.props.message, this.props.fromExt, this.props.toExt);\n\t            } else {\n\t                return _rcMessageService2.default.sendSMSMessage(this.props.message, this.props.fromNumber, this.props.toNumber);\n\t            }\n\t        }\n\t    },\n\t    sendFax: {\n\t        method: function method() {\n\t            _rcMessageService2.default.sendFax(this.props.files, this.props.toNumber || this.props.toExt);\n\t        }\n\t    },\n\t    callout: {\n\t        method: function method() {\n\t            return _phoneService2.default.call(this.props.fromNumber || this.props.fromExt, this.props.toNumber || this.props.toExt, {\n\t                remoteVideo: this.props.remoteVideo,\n\t                localVideo: this.props.localVideo\n\t            });\n\t        }\n\t    },\n\t    reachTop: {\n\t        method: function method() {\n\t            console.log('load content');\n\t            return _rcConversationService2.default.loadContent(this.props.contact, this.props.loadingPeriod);\n\t        }\n\t    },\n\t    getAvatar: {\n\t        method: function method() {\n\t            var _this6 = this;\n\t\n\t            if (!this.props.profileImage) return Promise.resolve('https://www.gravatar.com/avatar/' + (0, _blueimpMd2.default)(this.props.contact.id) + '?d=retro');\n\t            return _rcSdk.RC.sdk.platform().get(this.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken())).then(function (r) {\n\t                return r.response();\n\t            }).then(function (r) {\n\t                // Real contact, no avatar\n\t                if (r.status === 204 || r.status === 404) {\n\t                    var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n\t                    return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n\t                } else {\n\t                    // Real contact, has avatar\n\t                    return;\n\t                    _this6.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken());\n\t                }\n\t            }).catch(function (e) {\n\t                // Real contact, no avatar\n\t                var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n\t                return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n\t            });\n\t        }\n\t    },\n\t    transformURL: {\n\t        method: function method() {\n\t            return this.props.transformee + ('?access_token=' + _rcContactService2.default.accessToken());\n\t        }\n\t    },\n\t    getFileInfo: {\n\t        method: function method() {\n\t            console.log(this.props.fileURL);\n\t            return _rcSdk.RC.sdk.platform().get(this.props.fileURL).then(function (r) {\n\t                return r.json();\n\t            });\n\t        }\n\t    },\n\t    setOutboundCallerID: {\n\t        method: function method() {\n\t            return _accountService2.default.getPhoneNumber().then(function () {\n\t                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n\t            });\n\t        }\n\t    }\n\t};\n\tservices['call-panel'] = {\n\t    init: {\n\t        after: function after() {\n\t            var _this7 = this;\n\t\n\t            _phoneService2.default.init({\n\t                incomingAudio: _rcConfig2.default.incomingAudio,\n\t                outgoingAudio: _rcConfig2.default.outgoingAudio\n\t            });\n\t            _phoneService2.default.on('progress', function () {\n\t                if (!_this7._mounted) {\n\t                    _this7.mount(_this7.props.target);\n\t                }\n\t            });\n\t            _phoneService2.default.on('bye', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('terminated', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('rejected', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('failed', function () {\n\t                _this7.unmount();\n\t            });\n\t            _phoneService2.default.on('accepted', function () {\n\t                console.log('accept');\n\t                _this7.start();\n\t            });\n\t        }\n\t    },\n\t    mount: {\n\t        after: function after() {}\n\t    },\n\t    getContact: {\n\t        method: function method() {\n\t            var _this8 = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this8.props.name);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    },\n\t    hangup: {\n\t        method: function method() {\n\t            return _phoneService2.default.hangup();\n\t        }\n\t    },\n\t    hold: {\n\t        method: function method() {\n\t            return _phoneService2.default.hold(!this.props.isHold);\n\t        }\n\t    },\n\t    mute: {\n\t        method: function method() {\n\t            return _phoneService2.default.mute(!this.props.isMute);\n\t        }\n\t    },\n\t    flip: {\n\t        method: function method() {\n\t            return _phoneService2.default.flip(this.props.actionNumber);\n\t        }\n\t    },\n\t    transfer: {\n\t        method: function method() {\n\t            return _phoneService2.default.transfer(this.props.actionNumber);\n\t        }\n\t    },\n\t    record: {\n\t        method: function method() {\n\t            console.log(this.props.isRecord);\n\t            return _phoneService2.default.record(!this.props.isRecord);\n\t        }\n\t    },\n\t    park: {\n\t        method: function method() {\n\t            return _phoneService2.default.park();\n\t        }\n\t    },\n\t    dtmf: {\n\t        method: function method(number) {\n\t            return _phoneService2.default.dtmf(this.props.dtmfNumber);\n\t        }\n\t    },\n\t    queryContacts: {\n\t        method: function method() {\n\t            var _this9 = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this9.props.inputValue);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    },\n\t    getOutboundCallerID: {\n\t        method: function method() {\n\t            return _accountService2.default.getPhoneNumber().then(function () {\n\t                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n\t            });\n\t        }\n\t    }\n\t};\n\tservices['call-panel-incoming'] = {\n\t    init: {\n\t        method: function method() {\n\t            var _this10 = this;\n\t\n\t            _phoneService2.default.on('invite', function (session) {\n\t                _this10.props.session = session;\n\t                var name = session.request.from.displayName || session.request.from.friendlyName.split(\"@\")[0];\n\t                _this10.setName(name);\n\t                _this10.mount(_this10.props.target);\n\t                _phoneService2.default.on('terminated', function () {\n\t                    _this10.unmount();\n\t                });\n\t                _phoneService2.default.on('failed', function () {\n\t                    _this10.unmount();\n\t                });\n\t            });\n\t        }\n\t    },\n\t    accept: {\n\t        method: function method() {\n\t            return _phoneService2.default.accept({\n\t                remoteVideo: this.props.remoteVideo,\n\t                localVideo: this.props.localVideo\n\t            });\n\t        }\n\t    },\n\t    reject: {\n\t        method: function method() {\n\t            return _phoneService2.default.reject();\n\t        }\n\t    },\n\t    forward: {\n\t        method: function method() {\n\t            return _phoneService2.default.forward(this.props.actionNumber);\n\t        }\n\t    },\n\t    queryContacts: {\n\t        method: function method() {\n\t            var _this11 = this;\n\t\n\t            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n\t                return provider.search(_this11.props.inputValue);\n\t            });\n\t            return _contactSearchService2.default.query(dialPadSearchFunctions);\n\t        }\n\t    }\n\t};\n\texports.default = services;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.RC = exports.injectSDK = undefined;\n\t\n\tvar _ringcentralBundle = __webpack_require__(5);\n\t\n\tvar _ringcentralBundle2 = _interopRequireDefault(_ringcentralBundle);\n\t\n\tvar _rcConfig = __webpack_require__(11);\n\t\n\tvar _rcConfig2 = _interopRequireDefault(_rcConfig);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar holder = {};\n\t\n\t// for dependency injection\n\tvar sdk = function () {\n\t    return holder.sdk;\n\t}();\n\t\n\tvar injectSDK = function injectSDK(_ref) {\n\t    var key = _ref.key;\n\t    var secret = _ref.secret;\n\t    var sandbox = _ref.sandbox;\n\t\n\t    holder.sdk = new _ringcentralBundle2.default({\n\t        appKey: key,\n\t        appSecret: secret,\n\t        server: sandbox ? _ringcentralBundle2.default.server.sandbox : _ringcentralBundle2.default.server.production\n\t    });\n\t};\n\texports.injectSDK = injectSDK;\n\texports.RC = holder;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"SDK\"] = factory();\n\t\telse\n\t\t\troot[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"SDK\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"/build/\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(2);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Copyright (c) 2014, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n\t * additional grant of patent rights can be found in the PATENTS file in\n\t * the same directory.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var iteratorSymbol =\n\t    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    // If outerFn provided, then outerFn.prototype instanceof Generator.\n\t    var generator = Object.create((outerFn || Generator).prototype);\n\t    var context = new Context(tryLocsList || []);\n\t\n\t    // The ._invoke method unifies the implementations of the .next,\n\t    // .throw, and .return methods.\n\t    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\t\n\t    return generator;\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function Generator() {}\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  // Helper for defining the .next, .throw, and .return methods of the\n\t  // Iterator interface in terms of a single ._invoke method.\n\t  function defineIteratorMethods(prototype) {\n\t    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n\t      prototype[method] = function(arg) {\n\t        return this._invoke(method, arg);\n\t      };\n\t    });\n\t  }\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    if (Object.setPrototypeOf) {\n\t      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n\t    } else {\n\t      genFun.__proto__ = GeneratorFunctionPrototype;\n\t    }\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  // Within the body of any async function, `await x` is transformed to\n\t  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n\t  // `value instanceof AwaitArgument` to determine if the yielded value is\n\t  // meant to be awaited. Some may consider the name of this method too\n\t  // cutesy, but they are curmudgeons.\n\t  runtime.awrap = function(arg) {\n\t    return new AwaitArgument(arg);\n\t  };\n\t\n\t  function AwaitArgument(arg) {\n\t    this.arg = arg;\n\t  }\n\t\n\t  function AsyncIterator(generator) {\n\t    // This invoke function is written in a style that assumes some\n\t    // calling function (or Promise) will handle exceptions.\n\t    function invoke(method, arg) {\n\t      var result = generator[method](arg);\n\t      var value = result.value;\n\t      return value instanceof AwaitArgument\n\t        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)\n\t        : Promise.resolve(value).then(function(unwrapped) {\n\t            // When a yielded Promise is resolved, its final value becomes\n\t            // the .value of the Promise<{value,done}> result for the\n\t            // current iteration. If the Promise is rejected, however, the\n\t            // result for this iteration will be rejected with the same\n\t            // reason. Note that rejections of yielded Promises are not\n\t            // thrown back into the generator function, as is the case\n\t            // when an awaited Promise is rejected. This difference in\n\t            // behavior between yield and await is important, because it\n\t            // allows the consumer to decide what to do with the yielded\n\t            // rejection (swallow it and continue, manually .throw it back\n\t            // into the generator, abandon iteration, whatever). With\n\t            // await, by contrast, there is no opportunity to examine the\n\t            // rejection reason outside the generator function, so the\n\t            // only option is to throw it from the await expression, and\n\t            // let the generator function handle the exception.\n\t            result.value = unwrapped;\n\t            return result;\n\t          });\n\t    }\n\t\n\t    if (typeof process === \"object\" && process.domain) {\n\t      invoke = process.domain.bind(invoke);\n\t    }\n\t\n\t    var invokeNext = invoke.bind(generator, \"next\");\n\t    var invokeThrow = invoke.bind(generator, \"throw\");\n\t    var invokeReturn = invoke.bind(generator, \"return\");\n\t    var previousPromise;\n\t\n\t    function enqueue(method, arg) {\n\t      function callInvokeWithMethodAndArg() {\n\t        return invoke(method, arg);\n\t      }\n\t\n\t      return previousPromise =\n\t        // If enqueue has been called before, then we want to wait until\n\t        // all previous Promises have been resolved before calling invoke,\n\t        // so that results are always delivered in the correct order. If\n\t        // enqueue has not been called before, then it is important to\n\t        // call invoke immediately, without waiting on a callback to fire,\n\t        // so that the async generator function has the opportunity to do\n\t        // any necessary setup in a predictable way. This predictability\n\t        // is why the Promise constructor synchronously invokes its\n\t        // executor callback, and why async functions synchronously\n\t        // execute code before the first await. Since we implement simple\n\t        // async functions in terms of async generators, it is especially\n\t        // important to get this right, even though it requires care.\n\t        previousPromise ? previousPromise.then(\n\t          callInvokeWithMethodAndArg,\n\t          // Avoid propagating failures to Promises returned by later\n\t          // invocations of the iterator.\n\t          callInvokeWithMethodAndArg\n\t        ) : new Promise(function (resolve) {\n\t          resolve(callInvokeWithMethodAndArg());\n\t        });\n\t    }\n\t\n\t    // Define the unified helper method that is used to implement .next,\n\t    // .throw, and .return (see defineIteratorMethods).\n\t    this._invoke = enqueue;\n\t  }\n\t\n\t  defineIteratorMethods(AsyncIterator.prototype);\n\t\n\t  // Note that simple async functions are implemented on top of\n\t  // AsyncIterator objects; they just return a Promise for the value of\n\t  // the final result produced by the iterator.\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    var iter = new AsyncIterator(\n\t      wrap(innerFn, outerFn, self, tryLocsList)\n\t    );\n\t\n\t    return runtime.isGeneratorFunction(outerFn)\n\t      ? iter // If outerFn is a generator, return the full iterator.\n\t      : iter.next().then(function(result) {\n\t          return result.done ? result.value : iter.next();\n\t        });\n\t  };\n\t\n\t  function makeInvokeMethod(innerFn, self, context) {\n\t    var state = GenStateSuspendedStart;\n\t\n\t    return function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        if (method === \"throw\") {\n\t          throw arg;\n\t        }\n\t\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          if (method === \"return\" ||\n\t              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n\t            // A return or throw (when the delegate iterator has no throw\n\t            // method) always terminates the yield* loop.\n\t            context.delegate = null;\n\t\n\t            // If the delegate iterator has a return method, give it a\n\t            // chance to clean up.\n\t            var returnMethod = delegate.iterator[\"return\"];\n\t            if (returnMethod) {\n\t              var record = tryCatch(returnMethod, delegate.iterator, arg);\n\t              if (record.type === \"throw\") {\n\t                // If the return method threw an exception, let that\n\t                // exception prevail over the original return or throw.\n\t                method = \"throw\";\n\t                arg = record.arg;\n\t                continue;\n\t              }\n\t            }\n\t\n\t            if (method === \"return\") {\n\t              // Continue with the outer return, now that the delegate\n\t              // iterator has been terminated.\n\t              continue;\n\t            }\n\t          }\n\t\n\t          var record = tryCatch(\n\t            delegate.iterator[method],\n\t            delegate.iterator,\n\t            arg\n\t          );\n\t\n\t          if (record.type === \"throw\") {\n\t            context.delegate = null;\n\t\n\t            // Like returning generator.throw(uncaught), but without the\n\t            // overhead of an extra function call.\n\t            method = \"throw\";\n\t            arg = record.arg;\n\t            continue;\n\t          }\n\t\n\t          // Delegate generator ran and handled its own exceptions so\n\t          // regardless of what the method was, we continue as if it is\n\t          // \"next\" with an undefined arg.\n\t          method = \"next\";\n\t          arg = undefined;\n\t\n\t          var info = record.arg;\n\t          if (info.done) {\n\t            context[delegate.resultName] = info.value;\n\t            context.next = delegate.nextLoc;\n\t          } else {\n\t            state = GenStateSuspendedYield;\n\t            return info;\n\t          }\n\t\n\t          context.delegate = null;\n\t        }\n\t\n\t        if (method === \"next\") {\n\t          context._sent = arg;\n\t\n\t          if (state === GenStateSuspendedYield) {\n\t            context.sent = arg;\n\t          } else {\n\t            context.sent = undefined;\n\t          }\n\t        } else if (method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw arg;\n\t          }\n\t\n\t          if (context.dispatchException(arg)) {\n\t            // If the dispatched exception was caught by a catch block,\n\t            // then let that catch block handle the exception normally.\n\t            method = \"next\";\n\t            arg = undefined;\n\t          }\n\t\n\t        } else if (method === \"return\") {\n\t          context.abrupt(\"return\", arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          var info = {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            if (context.delegate && method === \"next\") {\n\t              // Deliberately forget the last sent value so that we don't\n\t              // accidentally pass it on to the delegate.\n\t              arg = undefined;\n\t            }\n\t          } else {\n\t            return info;\n\t          }\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t          // Dispatch the exception by looping back around to the\n\t          // context.dispatchException(arg) call above.\n\t          method = \"throw\";\n\t          arg = record.arg;\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  // Define Generator.prototype.{next,throw,return} in terms of the\n\t  // unified ._invoke helper method.\n\t  defineIteratorMethods(Gp);\n\t\n\t  Gp[iteratorSymbol] = function() {\n\t    return this;\n\t  };\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset(true);\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function(skipTempReset) {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      this.sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      if (!skipTempReset) {\n\t        for (var name in this) {\n\t          // Not sure about the optimal order of these conditions:\n\t          if (name.charAt(0) === \"t\" &&\n\t              hasOwn.call(this, name) &&\n\t              !isNaN(+name.slice(1))) {\n\t            this[name] = undefined;\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t        return !!caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") &&\n\t            this.prev < entry.finallyLoc) {\n\t          var finallyEntry = entry;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (finallyEntry &&\n\t          (type === \"break\" ||\n\t           type === \"continue\") &&\n\t          finallyEntry.tryLoc <= arg &&\n\t          arg <= finallyEntry.finallyLoc) {\n\t        // Ignore the finally entry if control is not jumping to a\n\t        // location outside the try/catch block.\n\t        finallyEntry = null;\n\t      }\n\t\n\t      var record = finallyEntry ? finallyEntry.completion : {};\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (finallyEntry) {\n\t        this.next = finallyEntry.finallyLoc;\n\t      } else {\n\t        this.complete(record);\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = record.arg;\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.finallyLoc === finallyLoc) {\n\t          this.complete(entry.completion, entry.afterLoc);\n\t          resetTryEntry(entry);\n\t          return ContinueSentinel;\n\t        }\n\t      }\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // Among the various tricks for obtaining a reference to the global\n\t  // object, this seems to be the most reliable technique that does not\n\t  // use indirect eval (which violates Content Security Policy).\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this\n\t);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tvar Utils = _interopRequireWildcard(_Utils);\n\t\n\tvar _Cache = __webpack_require__(12);\n\t\n\tvar _Cache2 = _interopRequireDefault(_Cache);\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar Externals = _interopRequireWildcard(_Externals);\n\t\n\tvar _Observable = __webpack_require__(13);\n\t\n\tvar _Observable2 = _interopRequireDefault(_Observable);\n\t\n\tvar _Queue = __webpack_require__(14);\n\t\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\t\n\tvar _Client = __webpack_require__(15);\n\t\n\tvar _Client2 = _interopRequireDefault(_Client);\n\t\n\tvar _ApiResponse = __webpack_require__(16);\n\t\n\tvar _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n\t\n\tvar _ClientMock = __webpack_require__(17);\n\t\n\tvar _ClientMock2 = _interopRequireDefault(_ClientMock);\n\t\n\tvar _Mock = __webpack_require__(19);\n\t\n\tvar _Mock2 = _interopRequireDefault(_Mock);\n\t\n\tvar _Registry = __webpack_require__(18);\n\t\n\tvar _Registry2 = _interopRequireDefault(_Registry);\n\t\n\tvar _Platform = __webpack_require__(20);\n\t\n\tvar _Platform2 = _interopRequireDefault(_Platform);\n\t\n\tvar _Auth = __webpack_require__(21);\n\t\n\tvar _Auth2 = _interopRequireDefault(_Auth);\n\t\n\tvar _PubnubFactory = __webpack_require__(22);\n\t\n\tvar _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);\n\t\n\tvar _Subscription = __webpack_require__(24);\n\t\n\tvar _Subscription2 = _interopRequireDefault(_Subscription);\n\t\n\tvar _CachedSubscription = __webpack_require__(25);\n\t\n\tvar _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar SDK = function () {\n\t\n\t    /**\n\t     * @namespace RingCentral\n\t     * @constructor\n\t     * @param {object} [options]\n\t     * @param {string} [options.server]\n\t     * @param {string} [options.cachePrefix]\n\t     * @param {string} [options.appSecret]\n\t     * @param {string} [options.appKey]\n\t     * @param {string} [options.appName]\n\t     * @param {string} [options.appVersion]\n\t     * @param {string} [options.pubnubFactory]\n\t     * @param {string} [options.client]\n\t     */\n\t\n\t    function SDK(options) {\n\t        _classCallCheck(this, SDK);\n\t\n\t        options = options || {};\n\t\n\t        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);\n\t\n\t        this._client = options.client || new _Client2.default();\n\t\n\t        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);\n\t\n\t        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;\n\t    }\n\t\n\t    /**\n\t     * @return {Platform}\n\t     */\n\t\n\t\n\t    SDK.prototype.platform = function platform() {\n\t        return this._platform;\n\t    };\n\t\n\t    /**\n\t     * @return {Subscription}\n\t     */\n\t\n\t\n\t    SDK.prototype.createSubscription = function createSubscription() {\n\t        return new _Subscription2.default(this._pubnubFactory, this._platform);\n\t    };\n\t\n\t    /**\n\t     * @return {CachedSubscription}\n\t     */\n\t\n\t\n\t    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {\n\t        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);\n\t    };\n\t\n\t    /**\n\t     * @return {Cache}\n\t     */\n\t\n\t\n\t    SDK.prototype.cache = function cache() {\n\t        return this._cache;\n\t    };\n\t\n\t    SDK.handleAuthRedirect = function handleAuthRedirect(origin) {\n\t        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);\n\t    };\n\t\n\t    return SDK;\n\t}();\n\t\n\tSDK.version = '2.0.6';\n\tSDK.server = {\n\t    sandbox: 'https://platform.devtest.ringcentral.com',\n\t    production: 'https://platform.ringcentral.com'\n\t};\n\tSDK.core = {\n\t    Cache: _Cache2.default,\n\t    Observable: _Observable2.default,\n\t    Utils: Utils,\n\t    Externals: Externals,\n\t    Queue: _Queue2.default\n\t};\n\tSDK.http = {\n\t    Client: _Client2.default,\n\t    ApiResponse: _ApiResponse2.default\n\t};\n\tSDK.platform = {\n\t    Auth: _Auth2.default,\n\t    Platform: _Platform2.default\n\t};\n\tSDK.subscription = {\n\t    Subscription: _Subscription2.default\n\t};\n\tSDK.mocks = {\n\t    Client: _ClientMock2.default,\n\t    Registry: _Registry2.default,\n\t    Mock: _Mock2.default\n\t};\n\tSDK.pubnub = {\n\t    PubnubMockFactory: _PubnubFactory2.default\n\t};\n\t\n\t\n\tmodule.exports = SDK;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\texports.queryStringify = queryStringify;\n\texports.parseQueryString = parseQueryString;\n\texports.isFunction = isFunction;\n\texports.isArray = isArray;\n\texports.isObject = isObject;\n\texports.isObjectObject = isObjectObject;\n\texports.isPlainObject = isPlainObject;\n\texports.poll = poll;\n\texports.stopPolling = stopPolling;\n\texports.isNodeJS = isNodeJS;\n\texports.isBrowser = isBrowser;\n\texports.delay = delay;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\t/**\n\t * TODO Replace with something better\n\t * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n\t * @param {object} parameters\n\t * @returns {string}\n\t */\n\tfunction queryStringify(parameters) {\n\t\n\t    var array = [];\n\t\n\t    parameters = parameters || {};\n\t\n\t    Object.keys(parameters).forEach(function (k) {\n\t\n\t        var v = parameters[k];\n\t\n\t        if (isArray(v)) {\n\t            v.forEach(function (vv) {\n\t                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));\n\t            });\n\t        } else {\n\t            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));\n\t        }\n\t    });\n\t\n\t    return array.join('&');\n\t}\n\t\n\t/**\n\t * TODO Replace with something better\n\t * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n\t * @param {string} queryString\n\t * @returns {object}\n\t */\n\tfunction parseQueryString(queryString) {\n\t\n\t    var argsParsed = {};\n\t\n\t    queryString.split('&').forEach(function (arg) {\n\t\n\t        arg = decodeURIComponent(arg);\n\t\n\t        if (arg.indexOf('=') == -1) {\n\t\n\t            argsParsed[arg.trim()] = true;\n\t        } else {\n\t\n\t            var pair = arg.split('='),\n\t                key = pair[0].trim(),\n\t                value = pair[1].trim();\n\t\n\t            if (key in argsParsed) {\n\t                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];\n\t                argsParsed[key].push(value);\n\t            } else {\n\t                argsParsed[key] = value;\n\t            }\n\t        }\n\t    });\n\t\n\t    return argsParsed;\n\t}\n\t\n\t/**\n\t * @param obj\n\t * @return {boolean}\n\t */\n\tfunction isFunction(obj) {\n\t    return typeof obj === \"function\";\n\t}\n\t\n\t/**\n\t * @param obj\n\t * @return {boolean}\n\t */\n\tfunction isArray(obj) {\n\t    return Array.isArray ? Array.isArray(obj) : typeof obj === \"array\";\n\t}\n\t\n\tfunction isObject(o) {\n\t    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);\n\t}\n\t\n\tfunction isObjectObject(o) {\n\t    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n\t}\n\t\n\tfunction isPlainObject(o) {\n\t    var ctor, prot;\n\t\n\t    if (isObjectObject(o) === false) return false;\n\t\n\t    // If has modified constructor\n\t    ctor = o.constructor;\n\t    if (typeof ctor !== 'function') return false;\n\t\n\t    // If has modified prototype\n\t    prot = ctor.prototype;\n\t    if (isObjectObject(prot) === false) return false;\n\t\n\t    // If constructor does not have an Object-specific method\n\t    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n\t        return false;\n\t    }\n\t\n\t    // Most likely a plain Object\n\t    return true;\n\t}\n\t\n\t/**\n\t * @param fn\n\t * @param interval\n\t * @param timeout\n\t */\n\tfunction poll(fn, interval, timeout) {\n\t    //NodeJS.Timer|number\n\t\n\t    module.exports.stopPolling(timeout);\n\t\n\t    interval = interval || 1000;\n\t\n\t    var next = function next(delay) {\n\t\n\t        delay = delay || interval;\n\t\n\t        interval = delay;\n\t\n\t        return setTimeout(function () {\n\t\n\t            fn(next, delay);\n\t        }, delay);\n\t    };\n\t\n\t    return next();\n\t}\n\t\n\tfunction stopPolling(timeout) {\n\t    if (timeout) clearTimeout(timeout);\n\t}\n\t\n\tfunction isNodeJS() {\n\t    return typeof process !== 'undefined';\n\t}\n\t\n\tfunction isBrowser() {\n\t    return typeof window !== 'undefined';\n\t}\n\t\n\tfunction delay(timeout) {\n\t    return new _Externals.Promise(function (resolve, reject) {\n\t        setTimeout(function () {\n\t            resolve(null);\n\t        }, timeout);\n\t    });\n\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;\n\t\n\tvar _es6Promise = __webpack_require__(5);\n\t\n\tvar _es6Promise2 = _interopRequireDefault(_es6Promise);\n\t\n\tvar _nodeFetch = __webpack_require__(10);\n\t\n\tvar _nodeFetch2 = _interopRequireDefault(_nodeFetch);\n\t\n\tvar _pubnub = __webpack_require__(11);\n\t\n\tvar _pubnub2 = _interopRequireDefault(_pubnub);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar root = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function(\"return this;\")();\n\t\n\tvar Promise = exports.Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;\n\t\n\tvar fetch = exports.fetch = root.fetch || _nodeFetch2.default;\n\tvar Request = exports.Request = root.Request || fetch.Request;\n\tvar Response = exports.Response = root.Response || fetch.Response;\n\tvar Headers = exports.Headers = root.Headers || fetch.Headers;\n\t\n\tvar PUBNUB = exports.PUBNUB = root.PUBNUB || _pubnub2.default;\n\t\n\tvar localStorage = exports.localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   2.2.0\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$toString = {}.toString;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    function lib$es6$promise$asap$$asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$default = lib$es6$promise$asap$$asap;\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      var nextTick = process.nextTick;\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // setImmediate should be used instead instead\n\t      var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n\t      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n\t        nextTick = setImmediate;\n\t      }\n\t      return function() {\n\t        nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertex() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"vertx\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFullfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$default(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n\t      if (maybeThenable.constructor === promise.constructor) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\t\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      var enumerator = this;\n\t\n\t      enumerator._instanceConstructor = Constructor;\n\t      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (enumerator._validateInput(input)) {\n\t        enumerator._input     = input;\n\t        enumerator.length     = input.length;\n\t        enumerator._remaining = input.length;\n\t\n\t        enumerator._init();\n\t\n\t        if (enumerator.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t        } else {\n\t          enumerator.length = enumerator.length || 0;\n\t          enumerator._enumerate();\n\t          if (enumerator._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n\t      return lib$es6$promise$utils$$isArray(input);\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n\t      this._result = new Array(this.length);\n\t    };\n\t\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var enumerator = this;\n\t\n\t      var length  = enumerator.length;\n\t      var promise = enumerator.promise;\n\t      var input   = enumerator._input;\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        enumerator._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var enumerator = this;\n\t      var c = enumerator._instanceConstructor;\n\t\n\t      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n\t        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          entry._onerror = null;\n\t          enumerator._settledAt(entry._state, i, entry._result);\n\t        } else {\n\t          enumerator._willSettleAt(c.resolve(entry), i);\n\t        }\n\t      } else {\n\t        enumerator._remaining--;\n\t        enumerator._result[i] = entry;\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var enumerator = this;\n\t      var promise = enumerator.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        enumerator._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          enumerator._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (enumerator._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$es6$promise$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t    var lib$es6$promise$promise$$counter = 0;\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promises eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this._id = lib$es6$promise$promise$$counter++;\n\t      this._state = undefined;\n\t      this._result = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n\t          lib$es6$promise$promise$$needsResolver();\n\t        }\n\t\n\t        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n\t          lib$es6$promise$promise$$needsNew();\n\t        }\n\t\n\t        lib$es6$promise$$internal$$initializePromise(this, resolver);\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$default;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: function(onFulfillment, onRejection) {\n\t        var parent = this;\n\t        var state = parent._state;\n\t\n\t        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n\t          return this;\n\t        }\n\t\n\t        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t        var result = parent._result;\n\t\n\t        if (state) {\n\t          var callback = arguments[state - 1];\n\t          lib$es6$promise$asap$$default(function(){\n\t            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n\t          });\n\t        } else {\n\t          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t        }\n\t\n\t        return child;\n\t      },\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(9)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, (function() { return this; }()), __webpack_require__(8)(module)))\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(7).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, __webpack_require__(6).clearImmediate))\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\t\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\t\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports) {\n\t\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\n\t\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports) {\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  var support = {\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob();\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this._initBody(bodyInit)\n\t    this.type = 'default'\n\t    this.url = null\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  self.Headers = Headers;\n\t  self.Request = Request;\n\t  self.Response = Response;\n\t\n\t  self.fetch = function(input, init) {\n\t    var request\n\t    if (Request.prototype.isPrototypeOf(input) && !init) {\n\t      request = input\n\t    } else {\n\t      request = new Request(input, init)\n\t    }\n\t\n\t    return new Promise(function(resolve, reject) {\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return;\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var status = (xhr.status === 1223) ? 204 : xhr.status\n\t        if (status < 100 || status > 599) {\n\t          reject(new TypeError('Network request failed'))\n\t          return\n\t        }\n\t        var options = {\n\t          status: status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})();\n\t\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(module) {// Version: 3.7.16\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t/* =-=========================     JSON     =============================-= */\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t\n\t(window['JSON'] && window['JSON']['stringify']) || (function () {\n\t    window['JSON'] || (window['JSON'] = {});\n\t\n\t    function toJSON(key) {\n\t        try      { return this.valueOf() }\n\t        catch(e) { return null }\n\t    }\n\t\n\t    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t        gap,\n\t        indent,\n\t        meta = {    // table of character substitutions\n\t            '\\b': '\\\\b',\n\t            '\\t': '\\\\t',\n\t            '\\n': '\\\\n',\n\t            '\\f': '\\\\f',\n\t            '\\r': '\\\\r',\n\t            '\"' : '\\\\\"',\n\t            '\\\\': '\\\\\\\\'\n\t        },\n\t        rep;\n\t\n\t    function quote(string) {\n\t        escapable.lastIndex = 0;\n\t        return escapable.test(string) ?\n\t            '\"' + string.replace(escapable, function (a) {\n\t                var c = meta[a];\n\t                return typeof c === 'string' ? c :\n\t                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t            }) + '\"' :\n\t            '\"' + string + '\"';\n\t    }\n\t\n\t    function str(key, holder) {\n\t        var i,          // The loop counter.\n\t            k,          // The member key.\n\t            v,          // The member value.\n\t            length,\n\t            partial,\n\t            mind  = gap,\n\t            value = holder[key];\n\t\n\t        if (value && typeof value === 'object') {\n\t            value = toJSON.call( value, key );\n\t        }\n\t\n\t        if (typeof rep === 'function') {\n\t            value = rep.call(holder, key, value);\n\t        }\n\t\n\t        switch (typeof value) {\n\t        case 'string':\n\t            return quote(value);\n\t\n\t        case 'number':\n\t            return isFinite(value) ? String(value) : 'null';\n\t\n\t        case 'boolean':\n\t        case 'null':\n\t            return String(value);\n\t\n\t        case 'object':\n\t\n\t            if (!value) {\n\t                return 'null';\n\t            }\n\t\n\t            gap += indent;\n\t            partial = [];\n\t\n\t            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\t\n\t                length = value.length;\n\t                for (i = 0; i < length; i += 1) {\n\t                    partial[i] = str(i, value) || 'null';\n\t                }\n\t\n\t                v = partial.length === 0 ? '[]' :\n\t                    gap ? '[\\n' + gap +\n\t                            partial.join(',\\n' + gap) + '\\n' +\n\t                                mind + ']' :\n\t                          '[' + partial.join(',') + ']';\n\t                gap = mind;\n\t                return v;\n\t            }\n\t            if (rep && typeof rep === 'object') {\n\t                length = rep.length;\n\t                for (i = 0; i < length; i += 1) {\n\t                    k = rep[i];\n\t                    if (typeof k === 'string') {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (k in value) {\n\t                    if (Object.hasOwnProperty.call(value, k)) {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t\n\t            v = partial.length === 0 ? '{}' :\n\t                gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n\t                        mind + '}' : '{' + partial.join(',') + '}';\n\t            gap = mind;\n\t            return v;\n\t        }\n\t    }\n\t\n\t    if (typeof JSON['stringify'] !== 'function') {\n\t        JSON['stringify'] = function (value, replacer, space) {\n\t            var i;\n\t            gap = '';\n\t            indent = '';\n\t\n\t            if (typeof space === 'number') {\n\t                for (i = 0; i < space; i += 1) {\n\t                    indent += ' ';\n\t                }\n\t            } else if (typeof space === 'string') {\n\t                indent = space;\n\t            }\n\t            rep = replacer;\n\t            if (replacer && typeof replacer !== 'function' &&\n\t                    (typeof replacer !== 'object' ||\n\t                     typeof replacer.length !== 'number')) {\n\t                throw new Error('JSON.stringify');\n\t            }\n\t            return str('', {'': value});\n\t        };\n\t    }\n\t\n\t    if (typeof JSON['parse'] !== 'function') {\n\t        // JSON is parsed on the server for security.\n\t        JSON['parse'] = function (text) {return eval('('+text+')')};\n\t    }\n\t}());\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t/* =-=========================     UTIL     =============================-= */\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t\n\twindow['PUBNUB'] || (function() {\n\tvar NOW             = 1\n\t,   READY           = false\n\t,   READY_BUFFER    = []\n\t,   PRESENCE_SUFFIX = '-pnpres'\n\t,   DEF_WINDOWING   = 10     // MILLISECONDS.\n\t,   DEF_TIMEOUT     = 10000  // MILLISECONDS.\n\t,   DEF_SUB_TIMEOUT = 310    // SECONDS.\n\t,   DEF_KEEPALIVE   = 60     // SECONDS (FOR TIMESYNC).\n\t,   SECOND          = 1000   // A THOUSAND MILLISECONDS.\n\t,   URLBIT          = '/'\n\t,   PARAMSBIT       = '&'\n\t,   PRESENCE_HB_THRESHOLD = 5\n\t,   PRESENCE_HB_DEFAULT  = 30\n\t,   SDK_VER         = '3.7.16'\n\t,   REPL            = /{([\\w\\-]+)}/g;\n\t\n\t/**\n\t * UTILITIES\n\t */\n\tfunction unique() { return'x'+ ++NOW+''+(+new Date) }\n\tfunction rnow()   { return+new Date }\n\t\n\t/**\n\t * NEXTORIGIN\n\t * ==========\n\t * var next_origin = nextorigin();\n\t */\n\tvar nextorigin = (function() {\n\t    var max = 20\n\t    ,   ori = Math.floor(Math.random() * max);\n\t    return function( origin, failover ) {\n\t        return origin.indexOf('pubsub.') > 0\n\t            && origin.replace(\n\t             'pubsub', 'ps' + (\n\t                failover ? generate_uuid().split('-')[0] :\n\t                (++ori < max? ori : ori=1)\n\t            ) ) || origin;\n\t    }\n\t})();\n\t\n\t\n\t/**\n\t * Build Url\n\t * =======\n\t *\n\t */\n\tfunction build_url( url_components, url_params ) {\n\t    var url    = url_components.join(URLBIT)\n\t    ,   params = [];\n\t\n\t    if (!url_params) return url;\n\t\n\t    each( url_params, function( key, value ) {\n\t        var value_str = (typeof value == 'object')?JSON['stringify'](value):value;\n\t        (typeof value != 'undefined' &&\n\t            value != null && encode(value_str).length > 0\n\t        ) && params.push(key + \"=\" + encode(value_str));\n\t    } );\n\t\n\t    url += \"?\" + params.join(PARAMSBIT);\n\t    return url;\n\t}\n\t\n\t/**\n\t * UPDATER\n\t * =======\n\t * var timestamp = unique();\n\t */\n\tfunction updater( fun, rate ) {\n\t    var timeout\n\t    ,   last   = 0\n\t    ,   runnit = function() {\n\t        if (last + rate > rnow()) {\n\t            clearTimeout(timeout);\n\t            timeout = setTimeout( runnit, rate );\n\t        }\n\t        else {\n\t            last = rnow();\n\t            fun();\n\t        }\n\t    };\n\t\n\t    return runnit;\n\t}\n\t\n\t/**\n\t * GREP\n\t * ====\n\t * var list = grep( [1,2,3], function(item) { return item % 2 } )\n\t */\n\tfunction grep( list, fun ) {\n\t    var fin = [];\n\t    each( list || [], function(l) { fun(l) && fin.push(l) } );\n\t    return fin\n\t}\n\t\n\t/**\n\t * SUPPLANT\n\t * ========\n\t * var text = supplant( 'Hello {name}!', { name : 'John' } )\n\t */\n\tfunction supplant( str, values ) {\n\t    return str.replace( REPL, function( _, match ) {\n\t        return values[match] || _\n\t    } );\n\t}\n\t\n\t/**\n\t * timeout\n\t * =======\n\t * timeout( function(){}, 100 );\n\t */\n\tfunction timeout( fun, wait ) {\n\t    return setTimeout( fun, wait );\n\t}\n\t\n\t/**\n\t * uuid\n\t * ====\n\t * var my_uuid = generate_uuid();\n\t */\n\tfunction generate_uuid(callback) {\n\t    var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,\n\t    function(c) {\n\t        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n\t        return v.toString(16);\n\t    });\n\t    if (callback) callback(u);\n\t    return u;\n\t}\n\t\n\tfunction isArray(arg) {\n\t  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n\t  //return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n\t}\n\t\n\t/**\n\t * EACH\n\t * ====\n\t * each( [1,2,3], function(item) { } )\n\t */\n\tfunction each( o, f) {\n\t    if ( !o || !f ) return;\n\t\n\t    if ( isArray(o) )\n\t        for ( var i = 0, l = o.length; i < l; )\n\t            f.call( o[i], o[i], i++ );\n\t    else\n\t        for ( var i in o )\n\t            o.hasOwnProperty    &&\n\t            o.hasOwnProperty(i) &&\n\t            f.call( o[i], i, o[i] );\n\t}\n\t\n\t/**\n\t * MAP\n\t * ===\n\t * var list = map( [1,2,3], function(item) { return item + 1 } )\n\t */\n\tfunction map( list, fun ) {\n\t    var fin = [];\n\t    each( list || [], function( k, v ) { fin.push(fun( k, v )) } );\n\t    return fin;\n\t}\n\t\n\t\n\tfunction pam_encode(str) {\n\t  return encodeURIComponent(str).replace(/[!'()*~]/g, function(c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t  });\n\t}\n\t\n\t/**\n\t * ENCODE\n\t * ======\n\t * var encoded_data = encode('path');\n\t */\n\tfunction encode(path) { return encodeURIComponent(path) }\n\t\n\t/**\n\t * Generate Subscription Channel List\n\t * ==================================\n\t * generate_channel_list(channels_object);\n\t */\n\tfunction generate_channel_list(channels, nopresence) {\n\t    var list = [];\n\t    each( channels, function( channel, status ) {\n\t        if (nopresence) {\n\t            if(channel.search('-pnpres') < 0) {\n\t                if (status.subscribed) list.push(channel);\n\t            }\n\t        } else {\n\t            if (status.subscribed) list.push(channel);\n\t        }\n\t    });\n\t    return list.sort();\n\t}\n\t\n\t/**\n\t * Generate Subscription Channel Groups List\n\t * ==================================\n\t * generate_channel_group_list(channels_groups object);\n\t */\n\tfunction generate_channel_group_list(channel_groups, nopresence) {\n\t    var list = [];\n\t    each(channel_groups, function( channel_group, status ) {\n\t        if (nopresence) {\n\t            if(channel_group.search('-pnpres') < 0) {\n\t                if (status.subscribed) list.push(channel_group);\n\t            }\n\t        } else {\n\t            if (status.subscribed) list.push(channel_group);\n\t        }\n\t    });\n\t    return list.sort();\n\t}\n\t\n\t// PUBNUB READY TO CONNECT\n\tfunction ready() { timeout( function() {\n\t    if (READY) return;\n\t    READY = 1;\n\t    each( READY_BUFFER, function(connect) { connect() } );\n\t}, SECOND ); }\n\t\n\tfunction PNmessage(args) {\n\t    msg = args || {'apns' : {}},\n\t    msg['getPubnubMessage'] = function() {\n\t        var m = {};\n\t\n\t        if (Object.keys(msg['apns']).length) {\n\t            m['pn_apns'] = {\n\t                    'aps' : {\n\t                        'alert' : msg['apns']['alert'] ,\n\t                        'badge' : msg['apns']['badge']\n\t                    }\n\t            }\n\t            for (var k in msg['apns']) {\n\t                m['pn_apns'][k] = msg['apns'][k];\n\t            }\n\t            var exclude1 = ['badge','alert'];\n\t            for (var k in exclude1) {\n\t                delete m['pn_apns'][exclude1[k]];\n\t            }\n\t        }\n\t\n\t\n\t\n\t        if (msg['gcm']) {\n\t            m['pn_gcm'] = {\n\t                'data' : msg['gcm']\n\t            }\n\t        }\n\t\n\t        for (var k in msg) {\n\t            m[k] = msg[k];\n\t        }\n\t        var exclude = ['apns','gcm','publish', 'channel','callback','error'];\n\t        for (var k in exclude) {\n\t            delete m[exclude[k]];\n\t        }\n\t\n\t        return m;\n\t    };\n\t    msg['publish'] = function() {\n\t\n\t        var m = msg.getPubnubMessage();\n\t\n\t        if (msg['pubnub'] && msg['channel']) {\n\t            msg['pubnub'].publish({\n\t                'message' : m,\n\t                'channel' : msg['channel'],\n\t                'callback' : msg['callback'],\n\t                'error' : msg['error']\n\t            })\n\t        }\n\t    };\n\t    return msg;\n\t}\n\t\n\tfunction PN_API(setup) {\n\t    var SUB_WINDOWING =  +setup['windowing']   || DEF_WINDOWING\n\t    ,   SUB_TIMEOUT   = (+setup['timeout']     || DEF_SUB_TIMEOUT) * SECOND\n\t    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n\t    ,   TIME_CHECK    = setup['timecheck']     || 0\n\t    ,   NOLEAVE       = setup['noleave']       || 0\n\t    ,   PUBLISH_KEY   = setup['publish_key']\n\t    ,   SUBSCRIBE_KEY = setup['subscribe_key']\n\t    ,   AUTH_KEY      = setup['auth_key']      || ''\n\t    ,   SECRET_KEY    = setup['secret_key']    || ''\n\t    ,   hmac_SHA256   = setup['hmac_SHA256']\n\t    ,   SSL           = setup['ssl']            ? 's' : ''\n\t    ,   ORIGIN        = 'http'+SSL+'://'+(setup['origin']||'pubsub.pubnub.com')\n\t    ,   STD_ORIGIN    = nextorigin(ORIGIN)\n\t    ,   SUB_ORIGIN    = nextorigin(ORIGIN)\n\t    ,   CONNECT       = function(){}\n\t    ,   PUB_QUEUE     = []\n\t    ,   CLOAK         = true\n\t    ,   TIME_DRIFT    = 0\n\t    ,   SUB_CALLBACK  = 0\n\t    ,   SUB_CHANNEL   = 0\n\t    ,   SUB_RECEIVER  = 0\n\t    ,   SUB_RESTORE   = setup['restore'] || 0\n\t    ,   SUB_BUFF_WAIT = 0\n\t    ,   TIMETOKEN     = 0\n\t    ,   RESUMED       = false\n\t    ,   CHANNELS      = {}\n\t    ,   CHANNEL_GROUPS       = {}\n\t    ,   SUB_ERROR     = function(){}\n\t    ,   STATE         = {}\n\t    ,   PRESENCE_HB_TIMEOUT  = null\n\t    ,   PRESENCE_HB          = validate_presence_heartbeat(\n\t        setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']\n\t    )\n\t    ,   PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) -1\n\t    ,   PRESENCE_HB_RUNNING  = false\n\t    ,   NO_WAIT_FOR_PENDING  = setup['no_wait_for_pending']\n\t    ,   COMPATIBLE_35 = setup['compatible_3.5']  || false\n\t    ,   xdr           = setup['xdr']\n\t    ,   params        = setup['params'] || {}\n\t    ,   error         = setup['error']      || function() {}\n\t    ,   _is_online    = setup['_is_online'] || function() { return 1 }\n\t    ,   jsonp_cb      = setup['jsonp_cb']   || function() { return 0 }\n\t    ,   db            = setup['db']         || {'get': function(){}, 'set': function(){}}\n\t    ,   CIPHER_KEY    = setup['cipher_key']\n\t    ,   UUID          = setup['uuid'] || ( !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY+'uuid') || '')\n\t    ,   USE_INSTANCEID = setup['instance_id'] || false\n\t    ,   INSTANCEID    = ''\n\t    ,   shutdown      = setup['shutdown']\n\t    ,   use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined')?setup['use_send_beacon']:true\n\t    ,   sendBeacon    = (use_send_beacon)?setup['sendBeacon']:null\n\t    ,   _poll_timer\n\t    ,   _poll_timer2;\n\t\n\t    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n\t\n\t    var crypto_obj    = setup['crypto_obj'] ||\n\t        {\n\t            'encrypt' : function(a,key){ return a},\n\t            'decrypt' : function(b,key){return b}\n\t        };\n\t\n\t    function _get_url_params(data) {\n\t        if (!data) data = {};\n\t        each( params , function( key, value ) {\n\t            if (!(key in data)) data[key] = value;\n\t        });\n\t        return data;\n\t    }\n\t\n\t    function _object_to_key_list(o) {\n\t        var l = []\n\t        each( o , function( key, value ) {\n\t            l.push(key);\n\t        });\n\t        return l;\n\t    }\n\t    function _object_to_key_list_sorted(o) {\n\t        return _object_to_key_list(o).sort();\n\t    }\n\t\n\t    function _get_pam_sign_input_from_params(params) {\n\t        var si = \"\";\n\t        var l = _object_to_key_list_sorted(params);\n\t\n\t        for (var i in l) {\n\t            var k = l[i]\n\t            si += k + \"=\" + pam_encode(params[k]) ;\n\t            if (i != l.length - 1) si += \"&\"\n\t        }\n\t        return si;\n\t    }\n\t\n\t    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n\t        var err = false;\n\t\n\t        if (typeof heartbeat === 'undefined') {\n\t            return cur_heartbeat;\n\t        }\n\t\n\t        if (typeof heartbeat === 'number') {\n\t            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0)\n\t                err = false;\n\t            else\n\t                err = true;\n\t        } else if(typeof heartbeat === 'boolean'){\n\t            if (!heartbeat) {\n\t                return 0;\n\t            } else {\n\t                return PRESENCE_HB_DEFAULT;\n\t            }\n\t        } else {\n\t            err = true;\n\t        }\n\t\n\t        if (err) {\n\t            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n\t            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n\t        } else return heartbeat;\n\t    }\n\t\n\t    function encrypt(input, key) {\n\t        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n\t    }\n\t    function decrypt(input, key) {\n\t        return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||\n\t               crypto_obj['decrypt'](input, CIPHER_KEY) ||\n\t               input;\n\t    }\n\t\n\t    function error_common(message, callback) {\n\t        callback && callback({ 'error' : message || \"error occurred\"});\n\t        error && error(message);\n\t    }\n\t    function _presence_heartbeat() {\n\t\n\t        clearTimeout(PRESENCE_HB_TIMEOUT);\n\t\n\t        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||\n\t            PRESENCE_HB_INTERVAL < 1 ||\n\t            (!generate_channel_list(CHANNELS,true).length  && !generate_channel_group_list(CHANNEL_GROUPS, true).length ) )\n\t        {\n\t            PRESENCE_HB_RUNNING = false;\n\t            return;\n\t        }\n\t\n\t        PRESENCE_HB_RUNNING = true;\n\t        SELF['presence_heartbeat']({\n\t            'callback' : function(r) {\n\t                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n\t            },\n\t            'error' : function(e) {\n\t                error && error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n\t                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n\t            }\n\t        });\n\t    }\n\t\n\t    function start_presence_heartbeat() {\n\t        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n\t    }\n\t\n\t    function publish(next) {\n\t\n\t        if (NO_WAIT_FOR_PENDING) {\n\t            if (!PUB_QUEUE.length) return;\n\t        } else {\n\t            if (next) PUB_QUEUE.sending = 0;\n\t            if ( PUB_QUEUE.sending || !PUB_QUEUE.length ) return;\n\t            PUB_QUEUE.sending = 1;\n\t        }\n\t\n\t        xdr(PUB_QUEUE.shift());\n\t    }\n\t    function each_channel_group(callback) {\n\t        var count = 0;\n\t\n\t        each( generate_channel_group_list(CHANNEL_GROUPS), function(channel_group) {\n\t            var chang = CHANNEL_GROUPS[channel_group];\n\t\n\t            if (!chang) return;\n\t\n\t            count++;\n\t            (callback||function(){})(chang);\n\t        } );\n\t\n\t        return count;\n\t    }\n\t\n\t    function each_channel(callback) {\n\t        var count = 0;\n\t\n\t        each( generate_channel_list(CHANNELS), function(channel) {\n\t            var chan = CHANNELS[channel];\n\t\n\t            if (!chan) return;\n\t\n\t            count++;\n\t            (callback||function(){})(chan);\n\t        } );\n\t\n\t        return count;\n\t    }\n\t    function _invoke_callback(response, callback, err) {\n\t        if (typeof response == 'object') {\n\t            if (response['error']) {\n\t                var callback_data = {};\n\t\n\t                if (response['message']) {\n\t                    callback_data['message'] = response['message'];\n\t                }\n\t\n\t                if (response['payload']) {\n\t                    callback_data['payload'] = response['payload'];\n\t                }\n\t\n\t                err && err(callback_data);\n\t                return;\n\t\n\t            }\n\t            if (response['payload']) {\n\t                if (response['next_page'])\n\t                    callback && callback(response['payload'], response['next_page']);\n\t                else\n\t                    callback && callback(response['payload']);\n\t                return;\n\t            }\n\t        }\n\t        callback && callback(response);\n\t    }\n\t\n\t    function _invoke_error(response,err) {\n\t\n\t        if (typeof response == 'object' && response['error']) {\n\t                var callback_data = {};\n\t\n\t                if (response['message']) {\n\t                    callback_data['message'] = response['message'];\n\t                }\n\t\n\t                if (response['payload']) {\n\t                    callback_data['payload'] = response['payload'];\n\t                }\n\t                \n\t                err && err(callback_data);\n\t                return;\n\t        } else {\n\t            err && err(response);\n\t        }\n\t    }\n\t    function CR(args, callback, url1, data) {\n\t            var callback        = args['callback']      || callback\n\t            ,   err             = args['error']         || error\n\t            ,   jsonp           = jsonp_cb();\n\t\n\t            data = data || {};\n\t            \n\t            if (!data['auth']) {\n\t                data['auth'] = args['auth_key'] || AUTH_KEY;\n\t            }\n\t            \n\t            var url = [\n\t                    STD_ORIGIN, 'v1', 'channel-registration',\n\t                    'sub-key', SUBSCRIBE_KEY\n\t                ];\n\t\n\t            url.push.apply(url,url1);\n\t            \n\t            if (jsonp) data['callback']              = jsonp;\n\t            \n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t\n\t    }\n\t\n\t    // Announce Leave Event\n\t    var SELF = {\n\t        'LEAVE' : function( channel, blocking, auth_key, callback, error ) {\n\t\n\t            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n\t            ,   origin = nextorigin(ORIGIN)\n\t            ,   callback = callback || function(){}\n\t            ,   err      = error    || function(){}\n\t            ,   url\n\t            ,   params\n\t            ,   jsonp  = jsonp_cb();\n\t\n\t            // Prevent Leaving a Presence Channel\n\t            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\t\n\t\n\t            if (COMPATIBLE_35) {\n\t                if (!SSL)         return false;\n\t                if (jsonp == '0') return false;\n\t            }\n\t\n\t            if (NOLEAVE)  return false;\n\t\n\t            if (jsonp != '0') data['callback'] = jsonp;\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            url = [\n\t                    origin, 'v2', 'presence', 'sub_key',\n\t                    SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'\n\t                ];\n\t\n\t            params = _get_url_params(data);\n\t\n\t\n\t            if (sendBeacon) {\n\t                url_string = build_url(url, params);\n\t                if (sendBeacon(url_string)) {\n\t                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n\t                    return true;\n\t                }\n\t            }\n\t\n\t\n\t            xdr({\n\t                blocking : blocking || SSL,\n\t                timeout  : 2000,\n\t                callback : jsonp,\n\t                data     : params,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t            return true;\n\t        },\n\t        'LEAVE_GROUP' : function( channel_group, blocking, auth_key, callback, error ) {\n\t\n\t            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n\t            ,   origin = nextorigin(ORIGIN)\n\t            ,   url\n\t            ,   params\n\t            ,   callback = callback || function(){}\n\t            ,   err      = error    || function(){}\n\t            ,   jsonp  = jsonp_cb();\n\t\n\t            // Prevent Leaving a Presence Channel Group\n\t            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\t\n\t            if (COMPATIBLE_35) {\n\t                if (!SSL)         return false;\n\t                if (jsonp == '0') return false;\n\t            }\n\t\n\t            if (NOLEAVE)  return false;\n\t\n\t            if (jsonp != '0') data['callback'] = jsonp;\n\t\n\t            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            url = [\n\t                    origin, 'v2', 'presence', 'sub_key',\n\t                    SUBSCRIBE_KEY, 'channel', encode(','), 'leave'\n\t            ];\n\t\n\t            params = _get_url_params(data);\n\t\n\t            if (sendBeacon) {\n\t                url_string = build_url(url, params);\n\t                if (sendBeacon(url_string)) {\n\t                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            xdr({\n\t                blocking : blocking || SSL,\n\t                timeout  : 5000,\n\t                callback : jsonp,\n\t                data     : params,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t            return true;\n\t        },\n\t        'set_resumed' : function(resumed) {\n\t                RESUMED = resumed;\n\t        },\n\t        'get_cipher_key' : function() {\n\t            return CIPHER_KEY;\n\t        },\n\t        'set_cipher_key' : function(key) {\n\t            CIPHER_KEY = key;\n\t        },\n\t        'raw_encrypt' : function(input, key) {\n\t            return encrypt(input, key);\n\t        },\n\t        'raw_decrypt' : function(input, key) {\n\t            return decrypt(input, key);\n\t        },\n\t        'get_heartbeat' : function() {\n\t            return PRESENCE_HB;\n\t        },\n\t        \n\t        'set_heartbeat' : function(heartbeat, heartbeat_interval) {\n\t            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);\n\t            PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;\n\t            if (PRESENCE_HB == 2) {\n\t                PRESENCE_HB_INTERVAL = 1;\n\t            }\n\t            CONNECT();\n\t            _presence_heartbeat();\n\t        },\n\t        \n\t        'get_heartbeat_interval' : function() {\n\t            return PRESENCE_HB_INTERVAL;\n\t        },\n\t        \n\t        'set_heartbeat_interval' : function(heartbeat_interval) {\n\t            PRESENCE_HB_INTERVAL = heartbeat_interval;\n\t            _presence_heartbeat();\n\t        },\n\t        \n\t        'get_version' : function() {\n\t            return SDK_VER;\n\t        },\n\t        'getGcmMessageObject' : function(obj) {\n\t            return {\n\t                'data' : obj\n\t            }\n\t        },\n\t        'getApnsMessageObject' : function(obj) {\n\t            var x =  {\n\t                'aps' : { 'badge' : 1, 'alert' : ''}\n\t            }\n\t            for (k in obj) {\n\t                k[x] = obj[k];\n\t            }\n\t            return x;\n\t        },\n\t        'newPnMessage' : function() {\n\t            var x = {};\n\t            if (gcm) x['pn_gcm'] = gcm;\n\t            if (apns) x['pn_apns'] = apns;\n\t            for ( k in n ) {\n\t                x[k] = n[k];\n\t            }\n\t            return x;\n\t        },\n\t\n\t        '_add_param' : function(key,val) {\n\t            params[key] = val;\n\t        },\n\t\n\t        'channel_group' : function(args, callback) {\n\t            var ns_ch       = args['channel_group']\n\t            ,   callback    = callback         || args['callback']\n\t            ,   channels    = args['channels'] || args['channel']\n\t            ,   cloak       = args['cloak']\n\t            ,   namespace\n\t            ,   channel_group\n\t            ,   url = []\n\t            ,   data = {}\n\t            ,   mode = args['mode'] || 'add';\n\t\n\t\n\t            if (ns_ch) {\n\t                var ns_ch_a = ns_ch.split(':');\n\t\n\t                if (ns_ch_a.length > 1) {\n\t                    namespace = (ns_ch_a[0] === '*')?null:ns_ch_a[0];\n\t\n\t                    channel_group = ns_ch_a[1];\n\t                } else {\n\t                    channel_group = ns_ch_a[0];\n\t                }\n\t            }\n\t\n\t            namespace && url.push('namespace') && url.push(encode(namespace));\n\t\n\t            url.push('channel-group');\n\t\n\t            if (channel_group && channel_group !== '*') {\n\t                url.push(channel_group);\n\t            }\n\t\n\t            if (channels ) {\n\t                if (isArray(channels)) {\n\t                    channels = channels.join(',');\n\t                }\n\t                data[mode] = channels;\n\t                data['cloak'] = (CLOAK)?'true':'false';\n\t            } else {\n\t                if (mode === 'remove') url.push('remove');\n\t            }\n\t\n\t            if (typeof cloak != 'undefined') data['cloak'] = (cloak)?'true':'false';\n\t\n\t            CR(args, callback, url, data);\n\t        },\n\t\n\t        'channel_group_list_groups' : function(args, callback) {\n\t            var namespace;\n\t\n\t            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n\t            if (namespace) {\n\t                args[\"channel_group\"] = namespace + \":*\";\n\t            }\n\t\n\t            SELF['channel_group'](args, callback);\n\t        },\n\t\n\t        'channel_group_list_channels' : function(args, callback) {\n\t            if (!args['channel_group']) return error('Missing Channel Group');\n\t            SELF['channel_group'](args, callback);\n\t        },\n\t\n\t        'channel_group_remove_channel' : function(args, callback) {\n\t            if (!args['channel_group']) return error('Missing Channel Group');\n\t            if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n\t\n\t            args['mode'] = 'remove';\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_remove_group' : function(args, callback) {\n\t            if (!args['channel_group']) return error('Missing Channel Group');\n\t            if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n\t\n\t            args['mode'] = 'remove';\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_add_channel' : function(args, callback) {\n\t           if (!args['channel_group']) return error('Missing Channel Group');\n\t           if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_cloak' : function(args, callback) {\n\t            if (typeof args['cloak'] == 'undefined') {\n\t                callback(CLOAK);\n\t                return;\n\t            }\n\t            CLOAK = args['cloak'];\n\t            SELF['channel_group'](args,callback);\n\t        },\n\t\n\t        'channel_group_list_namespaces' : function(args, callback) {\n\t            var url = ['namespace'];\n\t            CR(args, callback, url);\n\t        },\n\t        'channel_group_remove_namespace' : function(args, callback) {\n\t            var url = ['namespace',args['namespace'],'remove'];\n\t            CR(args, callback, url);\n\t        },\n\t\n\t        /*\n\t            PUBNUB.history({\n\t                channel  : 'my_chat_channel',\n\t                limit    : 100,\n\t                callback : function(history) { }\n\t            });\n\t        */\n\t        'history' : function( args, callback ) {\n\t            var callback         = args['callback'] || callback\n\t            ,   count            = args['count']    || args['limit'] || 100\n\t            ,   reverse          = args['reverse']  || \"false\"\n\t            ,   err              = args['error']    || function(){}\n\t            ,   auth_key         = args['auth_key'] || AUTH_KEY\n\t            ,   cipher_key       = args['cipher_key']\n\t            ,   channel          = args['channel']\n\t            ,   channel_group    = args['channel_group']\n\t            ,   start            = args['start']\n\t            ,   end              = args['end']\n\t            ,   include_token    = args['include_token']\n\t            ,   string_msg_token = args['string_message_token'] || false\n\t            ,   params           = {}\n\t            ,   jsonp            = jsonp_cb();\n\t\n\t            // Make sure we have a Channel\n\t            if (!channel && !channel_group) return error('Missing Channel');\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            params['stringtoken'] = 'true';\n\t            params['count']       = count;\n\t            params['reverse']     = reverse;\n\t            params['auth']        = auth_key;\n\t\n\t            if (channel_group) {\n\t                params['channel-group'] = channel_group;\n\t                if (!channel) {\n\t                    channel = ','; \n\t                }\n\t            }\n\t            if (jsonp) params['callback']              = jsonp;\n\t            if (start) params['start']                 = start;\n\t            if (end)   params['end']                   = end;\n\t            if (include_token) params['include_token'] = 'true';\n\t            if (string_msg_token) params['string_message_token'] = 'true';\n\t\n\t            // Send Message\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(params),\n\t                success  : function(response) {\n\t                    if (typeof response == 'object' && response['error']) {\n\t                        err({'message' : response['message'], 'payload' : response['payload']});\n\t                        return;\n\t                    }\n\t                    var messages = response[0];\n\t                    var decrypted_messages = [];\n\t                    for (var a = 0; a < messages.length; a++) {\n\t                        if (include_token) {\n\t                            var new_message = decrypt(messages[a]['message'],cipher_key);\n\t                            var timetoken = messages[a]['timetoken'];\n\t                            try {\n\t                                decrypted_messages['push']({\"message\" : JSON['parse'](new_message), \"timetoken\" : timetoken});\n\t                            } catch (e) {\n\t                                decrypted_messages['push'](({\"message\" : new_message, \"timetoken\" : timetoken}));\n\t                            }\n\t                        } else {\n\t                            var new_message = decrypt(messages[a],cipher_key);\n\t                            try {\n\t                                decrypted_messages['push'](JSON['parse'](new_message));\n\t                            } catch (e) {\n\t                                decrypted_messages['push']((new_message));\n\t                            }     \n\t                        }\n\t                    }\n\t                    callback([decrypted_messages, response[1], response[2]]);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v2', 'history', 'sub-key',\n\t                    SUBSCRIBE_KEY, 'channel', encode(channel)\n\t                ]\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.replay({\n\t                source      : 'my_channel',\n\t                destination : 'new_channel'\n\t            });\n\t        */\n\t        'replay' : function(args, callback) {\n\t            var callback    = callback || args['callback'] || function(){}\n\t            ,   auth_key    = args['auth_key'] || AUTH_KEY\n\t            ,   source      = args['source']\n\t            ,   destination = args['destination']\n\t            ,   stop        = args['stop']\n\t            ,   start       = args['start']\n\t            ,   end         = args['end']\n\t            ,   reverse     = args['reverse']\n\t            ,   limit       = args['limit']\n\t            ,   jsonp       = jsonp_cb()\n\t            ,   data        = {}\n\t            ,   url;\n\t\n\t            // Check User Input\n\t            if (!source)        return error('Missing Source Channel');\n\t            if (!destination)   return error('Missing Destination Channel');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            // Setup URL Params\n\t            if (jsonp != '0') data['callback'] = jsonp;\n\t            if (stop)         data['stop']     = 'all';\n\t            if (reverse)      data['reverse']  = 'true';\n\t            if (start)        data['start']    = start;\n\t            if (end)          data['end']      = end;\n\t            if (limit)        data['count']    = limit;\n\t\n\t            data['auth'] = auth_key;\n\t\n\t            // Compose URL Parts\n\t            url = [\n\t                STD_ORIGIN, 'v1', 'replay',\n\t                PUBLISH_KEY, SUBSCRIBE_KEY,\n\t                source, destination\n\t            ];\n\t\n\t            // Start (or Stop) Replay!\n\t            xdr({\n\t                callback : jsonp,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function() { callback([ 0, 'Disconnected' ]) },\n\t                url      : url,\n\t                data     : _get_url_params(data)\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.auth('AJFLKAJSDKLA');\n\t        */\n\t        'auth' : function(auth) {\n\t            AUTH_KEY = auth;\n\t            CONNECT();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.time(function(time){ });\n\t        */\n\t        'time' : function(callback) {\n\t            var jsonp = jsonp_cb();\n\t\n\t            var data = { 'uuid' : UUID, 'auth' : AUTH_KEY }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                timeout  : SECOND * 5,\n\t                url      : [STD_ORIGIN, 'time', jsonp],\n\t                success  : function(response) { callback(response[0]) },\n\t                fail     : function() { callback(0) }\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.publish({\n\t                channel : 'my_chat_channel',\n\t                message : 'hello!'\n\t            });\n\t        */\n\t        'publish' : function( args, callback ) {\n\t            var msg      = args['message'];\n\t            if (!msg) return error('Missing Message');\n\t\n\t            var callback = callback || args['callback'] || msg['callback'] || function(){}\n\t            ,   channel  = args['channel'] || msg['channel']\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   cipher_key = args['cipher_key']\n\t            ,   err      = args['error'] || msg['error'] || function() {}\n\t            ,   post     = args['post'] || false\n\t            ,   store    = ('store_in_history' in args) ? args['store_in_history']: true\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   add_msg  = 'push'\n\t            ,   params\n\t            ,   url;\n\t\n\t            if (args['prepend']) add_msg = 'unshift'\n\t\n\t            if (!channel)       return error('Missing Channel');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            if (msg['getPubnubMessage']) {\n\t                msg = msg['getPubnubMessage']();\n\t            }\n\t\n\t            // If trying to send Object\n\t            msg = JSON['stringify'](encrypt(msg, cipher_key));\n\t\n\t            // Create URL\n\t            url = [\n\t                STD_ORIGIN, 'publish',\n\t                PUBLISH_KEY, SUBSCRIBE_KEY,\n\t                0, encode(channel),\n\t                jsonp, encode(msg)\n\t            ];\n\t\n\t            params = { 'uuid' : UUID, 'auth' : auth_key }\n\t\n\t            if (!store) params['store'] =\"0\"\n\t\n\t            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n\t\n\t            // Queue Message Send\n\t            PUB_QUEUE[add_msg]({\n\t                callback : jsonp,\n\t                timeout  : SECOND * 5,\n\t                url      : url,\n\t                data     : _get_url_params(params),\n\t                fail     : function(response){\n\t                    _invoke_error(response, err);\n\t                    publish(1);\n\t                },\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                    publish(1);\n\t                },\n\t                mode     : (post)?'POST':'GET'\n\t            });\n\t\n\t            // Send Message\n\t            publish();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.unsubscribe({ channel : 'my_chat' });\n\t        */\n\t        'unsubscribe' : function(args, callback) {\n\t            var channel       = args['channel']\n\t            ,   channel_group = args['channel_group']\n\t            ,   auth_key      = args['auth_key']    || AUTH_KEY\n\t            ,   callback      = callback            || args['callback'] || function(){}\n\t            ,   err           = args['error']       || function(){};\n\t\n\t            TIMETOKEN   = 0;\n\t            SUB_RESTORE = 1;   // REVISIT !!!!\n\t\n\t            if (channel) {\n\t\n\t                // Prepare LeaveChannel(s)\n\t                var leave_c = map( (\n\t                    channel.join ? channel.join(',') : ''+channel\n\t                ).split(','), function(channel) {\n\t                    if (!CHANNELS[channel]) return;\n\t                    return channel;\n\t                } ).join(',');\n\t\n\t                // Prepare Channel(s)\n\t                channel = map( (\n\t                    channel.join ? channel.join(',') : ''+channel\n\t                ).split(','), function(channel) {\n\t                    if (!CHANNELS[channel]) return;\n\t                    return channel + ',' + channel + PRESENCE_SUFFIX;\n\t                } ).join(',');\n\t\n\t                // Iterate over Channels\n\t                each(channel.split(','), function(ch) {\n\t                    if (!ch) return;\n\t                    CHANNELS[ch] = 0;\n\t                    if (ch in STATE) delete STATE[ch];\n\t                } );\n\t\n\t                var CB_CALLED = true;\n\t                if (READY) {\n\t                    CB_CALLED = SELF['LEAVE'](leave_c, 0 , auth_key, callback, err);\n\t                }\n\t                if (!CB_CALLED) callback({action : \"leave\"});\n\t            }\n\t\n\t            if (channel_group) {\n\t\n\t                // Prepare channel group(s)\n\t                var leave_gc = map( (\n\t                    channel_group.join ? channel_group.join(',') : ''+channel_group\n\t                ).split(','), function(channel_group) {\n\t                    if (!CHANNEL_GROUPS[channel_group]) return;\n\t                    return channel_group;\n\t                } ).join(',');\n\t\n\t                // Prepare channel group(s)\n\t                channel_group = map( (\n\t                    channel_group.join ? channel_group.join(',') : ''+channel_group\n\t                ).split(','), function(channel_group) {\n\t                    if (!CHANNEL_GROUPS[channel_group]) return;\n\t                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n\t                } ).join(',');\n\t\n\t                // Iterate over channel groups\n\t                each( channel_group.split(','), function(chg) {\n\t                    if (!chg) return;\n\t                    CHANNEL_GROUPS[chg] = 0;\n\t                    if (chg in STATE) delete STATE[chg];\n\t                } );\n\t\n\t                var CB_CALLED = true;\n\t                if (READY) {\n\t                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0 , auth_key, callback, err);\n\t                }\n\t                if (!CB_CALLED) callback({action : \"leave\"});\n\t            }\n\t\n\t            // Reset Connection if Count Less\n\t            CONNECT();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.subscribe({\n\t                channel  : 'my_chat'\n\t                callback : function(message) { }\n\t            });\n\t        */\n\t        'subscribe' : function( args, callback ) {\n\t            var channel         = args['channel']\n\t            ,   channel_group   = args['channel_group']\n\t            ,   callback        = callback            || args['callback']\n\t            ,   callback        = callback            || args['message']\n\t            ,   connect         = args['connect']     || function(){}\n\t            ,   reconnect       = args['reconnect']   || function(){}\n\t            ,   disconnect      = args['disconnect']  || function(){}\n\t            ,   SUB_ERROR       = args['error']       || SUB_ERROR || function(){}\n\t            ,   idlecb          = args['idle']        || function(){}\n\t            ,   presence        = args['presence']    || 0\n\t            ,   noheresync      = args['noheresync']  || 0\n\t            ,   backfill        = args['backfill']    || 0\n\t            ,   timetoken       = args['timetoken']   || 0\n\t            ,   sub_timeout     = args['timeout']     || SUB_TIMEOUT\n\t            ,   windowing       = args['windowing']   || SUB_WINDOWING\n\t            ,   state           = args['state']\n\t            ,   heartbeat       = args['heartbeat'] || args['pnexpires']\n\t            ,   heartbeat_interval = args['heartbeat_interval']\n\t            ,   restore         = args['restore'] || SUB_RESTORE;\n\t\n\t            AUTH_KEY            = args['auth_key']    || AUTH_KEY;\n\t\n\t            // Restore Enabled?\n\t            SUB_RESTORE = restore;\n\t\n\t            // Always Reset the TT\n\t            TIMETOKEN = timetoken;\n\t\n\t            // Make sure we have a Channel\n\t            if (!channel && !channel_group) {\n\t                return error('Missing Channel');\n\t            }\n\t\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n\t                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n\t            }\n\t\n\t            // Setup Channel(s)\n\t            if (channel) {\n\t                each( (channel.join ? channel.join(',') : ''+channel).split(','),\n\t                function(channel) {\n\t                    var settings = CHANNELS[channel] || {};\n\t\n\t                    // Store Channel State\n\t                    CHANNELS[SUB_CHANNEL = channel] = {\n\t                        name         : channel,\n\t                        connected    : settings.connected,\n\t                        disconnected : settings.disconnected,\n\t                        subscribed   : 1,\n\t                        callback     : SUB_CALLBACK = callback,\n\t                        'cipher_key' : args['cipher_key'],\n\t                        connect      : connect,\n\t                        disconnect   : disconnect,\n\t                        reconnect    : reconnect\n\t                    };\n\t\n\t                    if (state) {\n\t                        if (channel in state) {\n\t                            STATE[channel] = state[channel];\n\t                        } else {\n\t                            STATE[channel] = state;\n\t                        }\n\t                    }\n\t\n\t                    // Presence Enabled?\n\t                    if (!presence) return;\n\t\n\t                    // Subscribe Presence Channel\n\t                    SELF['subscribe']({\n\t                        'channel'  : channel + PRESENCE_SUFFIX,\n\t                        'callback' : presence,\n\t                        'restore'  : restore\n\t                    });\n\t\n\t                    // Presence Subscribed?\n\t                    if (settings.subscribed) return;\n\t\n\t                    // See Who's Here Now?\n\t                    if (noheresync) return;\n\t                    SELF['here_now']({\n\t                        'channel'  : channel,\n\t                        'data'     : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n\t                        'callback' : function(here) {\n\t                            each( 'uuids' in here ? here['uuids'] : [],\n\t                            function(uid) { presence( {\n\t                                'action'    : 'join',\n\t                                'uuid'      : uid,\n\t                                'timestamp' : Math.floor(rnow() / 1000),\n\t                                'occupancy' : here['occupancy'] || 1\n\t                            }, here, channel ); } );\n\t                        }\n\t                    });\n\t                } );\n\t            }\n\t\n\t            // Setup Channel Groups\n\t            if (channel_group) {\n\t                each( (channel_group.join ? channel_group.join(',') : ''+channel_group).split(','),\n\t                function(channel_group) {\n\t                    var settings = CHANNEL_GROUPS[channel_group] || {};\n\t\n\t                    CHANNEL_GROUPS[channel_group] = {\n\t                        name         : channel_group,\n\t                        connected    : settings.connected,\n\t                        disconnected : settings.disconnected,\n\t                        subscribed   : 1,\n\t                        callback     : SUB_CALLBACK = callback,\n\t                        'cipher_key' : args['cipher_key'],\n\t                        connect      : connect,\n\t                        disconnect   : disconnect,\n\t                        reconnect    : reconnect\n\t                    };\n\t\n\t                    // Presence Enabled?\n\t                    if (!presence) return;\n\t\n\t                    // Subscribe Presence Channel\n\t                    SELF['subscribe']({\n\t                        'channel_group'  : channel_group + PRESENCE_SUFFIX,\n\t                        'callback' : presence,\n\t                        'restore'  : restore,\n\t                        'auth_key' : AUTH_KEY\n\t                    });\n\t\n\t                    // Presence Subscribed?\n\t                    if (settings.subscribed) return;\n\t\n\t                    // See Who's Here Now?\n\t                    if (noheresync) return;\n\t                    SELF['here_now']({\n\t                        'channel_group'  : channel_group,\n\t                        'data'           : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n\t                        'callback' : function(here) {\n\t                            each( 'uuids' in here ? here['uuids'] : [],\n\t                            function(uid) { presence( {\n\t                                'action'    : 'join',\n\t                                'uuid'      : uid,\n\t                                'timestamp' : Math.floor(rnow() / 1000),\n\t                                'occupancy' : here['occupancy'] || 1\n\t                            }, here, channel_group ); } );\n\t                        }\n\t                    });\n\t                } );\n\t            }\n\t\n\t\n\t            // Test Network Connection\n\t            function _test_connection(success) {\n\t                if (success) {\n\t                    // Begin Next Socket Connection\n\t                    timeout( CONNECT, windowing);\n\t                }\n\t                else {\n\t                    // New Origin on Failed Connection\n\t                    STD_ORIGIN = nextorigin( ORIGIN, 1 );\n\t                    SUB_ORIGIN = nextorigin( ORIGIN, 1 );\n\t\n\t                    // Re-test Connection\n\t                    timeout( function() {\n\t                        SELF['time'](_test_connection);\n\t                    }, SECOND );\n\t                }\n\t\n\t                // Disconnect & Reconnect\n\t                each_channel(function(channel){\n\t                    // Reconnect\n\t                    if (success && channel.disconnected) {\n\t                        channel.disconnected = 0;\n\t                        return channel.reconnect(channel.name);\n\t                    }\n\t\n\t                    // Disconnect\n\t                    if (!success && !channel.disconnected) {\n\t                        channel.disconnected = 1;\n\t                        channel.disconnect(channel.name);\n\t                    }\n\t                });\n\t                \n\t                // Disconnect & Reconnect for channel groups\n\t                each_channel_group(function(channel_group){\n\t                    // Reconnect\n\t                    if (success && channel_group.disconnected) {\n\t                        channel_group.disconnected = 0;\n\t                        return channel_group.reconnect(channel_group.name);\n\t                    }\n\t\n\t                    // Disconnect\n\t                    if (!success && !channel_group.disconnected) {\n\t                        channel_group.disconnected = 1;\n\t                        channel_group.disconnect(channel_group.name);\n\t                    }\n\t                });\n\t            }\n\t\n\t            // Evented Subscribe\n\t            function _connect() {\n\t                var jsonp           = jsonp_cb()\n\t                ,   channels        = generate_channel_list(CHANNELS).join(',')\n\t                ,   channel_groups  = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n\t\n\t                // Stop Connection\n\t                if (!channels && !channel_groups) return;\n\t\n\t                if (!channels) channels = ',';\n\t\n\t                // Connect to PubNub Subscribe Servers\n\t                _reset_offline();\n\t\n\t                var data = _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY });\n\t\n\t                if (channel_groups) {\n\t                    data['channel-group'] = channel_groups;\n\t                }\n\t\n\t\n\t                var st = JSON.stringify(STATE);\n\t                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n\t\n\t                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n\t\n\t                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t                start_presence_heartbeat();\n\t                SUB_RECEIVER = xdr({\n\t                    timeout  : sub_timeout,\n\t                    callback : jsonp,\n\t                    fail     : function(response) {\n\t                        if (response && response['error'] && response['service']) {\n\t                            _invoke_error(response, SUB_ERROR);\n\t                            _test_connection(1);\n\t                        } else {\n\t                            SELF['time'](function(success){\n\t                                !success && ( _invoke_error(response, SUB_ERROR));\n\t                                _test_connection(success);\n\t                            });\n\t                        }\n\t                    },\n\t                    data     : _get_url_params(data),\n\t                    url      : [\n\t                        SUB_ORIGIN, 'subscribe',\n\t                        SUBSCRIBE_KEY, encode(channels),\n\t                        jsonp, TIMETOKEN\n\t                    ],\n\t                    success : function(messages) {\n\t\n\t                        // Check for Errors\n\t                        if (!messages || (\n\t                            typeof messages == 'object' &&\n\t                            'error' in messages         &&\n\t                            messages['error']\n\t                        )) {\n\t                            SUB_ERROR(messages['error']);\n\t                            return timeout( CONNECT, SECOND );\n\t                        }\n\t\n\t                        // User Idle Callback\n\t                        idlecb(messages[1]);\n\t\n\t                        // Restore Previous Connection Point if Needed\n\t                        TIMETOKEN = !TIMETOKEN               &&\n\t                                    SUB_RESTORE              &&\n\t                                    db['get'](SUBSCRIBE_KEY) || messages[1];\n\t\n\t                        /*\n\t                        // Connect\n\t                        each_channel_registry(function(registry){\n\t                            if (registry.connected) return;\n\t                            registry.connected = 1;\n\t                            registry.connect(channel.name);\n\t                        });\n\t                        */\n\t\n\t                        // Connect\n\t                        each_channel(function(channel){\n\t                            if (channel.connected) return;\n\t                            channel.connected = 1;\n\t                            channel.connect(channel.name);\n\t                        });\n\t\n\t                        // Connect for channel groups\n\t                        each_channel_group(function(channel_group){\n\t                            if (channel_group.connected) return;\n\t                            channel_group.connected = 1;\n\t                            channel_group.connect(channel_group.name);\n\t                        });\n\t\n\t                        if (RESUMED && !SUB_RESTORE) {\n\t                                TIMETOKEN = 0;\n\t                                RESUMED = false;\n\t                                // Update Saved Timetoken\n\t                                db['set']( SUBSCRIBE_KEY, 0 );\n\t                                timeout( _connect, windowing );\n\t                                return;\n\t                        }\n\t\n\t                        // Invoke Memory Catchup and Receive Up to 100\n\t                        // Previous Messages from the Queue.\n\t                        if (backfill) {\n\t                            TIMETOKEN = 10000;\n\t                            backfill  = 0;\n\t                        }\n\t\n\t                        // Update Saved Timetoken\n\t                        db['set']( SUBSCRIBE_KEY, messages[1] );\n\t\n\t                        // Route Channel <---> Callback for Message\n\t                        var next_callback = (function() {\n\t                            var channels = '';\n\t                            var channels2 = '';\n\t\n\t                            if (messages.length > 3) {\n\t                                channels  = messages[3];\n\t                                channels2 = messages[2];\n\t                            } else if (messages.length > 2) {\n\t                                channels = messages[2];\n\t                            } else {\n\t                                channels =  map(\n\t                                    generate_channel_list(CHANNELS), function(chan) { return map(\n\t                                        Array(messages[0].length)\n\t                                        .join(',').split(','),\n\t                                        function() { return chan; }\n\t                                    ) }).join(',')\n\t                            }\n\t\n\t                            var list  = channels.split(',');\n\t                            var list2 = (channels2)?channels2.split(','):[];\n\t\n\t                            return function() {\n\t                                var channel  = list.shift()||SUB_CHANNEL;\n\t                                var channel2 = list2.shift();\n\t\n\t                                var chobj = {};\n\t\n\t                                if (channel2) {\n\t                                    if (channel && channel.indexOf('-pnpres') >= 0 \n\t                                        && channel2.indexOf('-pnpres') < 0) {\n\t                                        channel2 += '-pnpres';\n\t                                    }\n\t                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || {'callback' : function(){}};\n\t                                } else {\n\t                                    chobj = CHANNELS[channel];\n\t                                }\n\t\n\t                                var r = [\n\t                                    chobj\n\t                                    .callback||SUB_CALLBACK,\n\t                                    channel.split(PRESENCE_SUFFIX)[0]\n\t                                ];\n\t                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n\t                                return r;\n\t                            };\n\t                        })();\n\t\n\t                        var latency = detect_latency(+messages[1]);\n\t                        each( messages[0], function(msg) {\n\t                            var next = next_callback();\n\t                            var decrypted_msg = decrypt(msg,\n\t                                (CHANNELS[next[1]])?CHANNELS[next[1]]['cipher_key']:null);\n\t                            next[0] && next[0]( decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n\t                        });\n\t\n\t                        timeout( _connect, windowing );\n\t                    }\n\t                });\n\t            }\n\t\n\t            CONNECT = function() {\n\t                _reset_offline();\n\t                timeout( _connect, windowing );\n\t            };\n\t\n\t            // Reduce Status Flicker\n\t            if (!READY) return READY_BUFFER.push(CONNECT);\n\t\n\t            // Connect Now\n\t            CONNECT();\n\t        },\n\t\n\t        /*\n\t            PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n\t        */\n\t        'here_now' : function( args, callback ) {\n\t            var callback = args['callback'] || callback\n\t            ,   debug    = args['debug']\n\t            ,   err      = args['error']    || function(){}\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   channel  = args['channel']\n\t            ,   channel_group = args['channel_group']\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   uuids    = ('uuids' in args) ? args['uuids'] : true\n\t            ,   state    = args['state']\n\t            ,   data     = { 'uuid' : UUID, 'auth' : auth_key };\n\t\n\t            if (!uuids) data['disable_uuids'] = 1;\n\t            if (state) data['state'] = 1;\n\t\n\t            // Make sure we have a Channel\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            var url = [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub_key', SUBSCRIBE_KEY\n\t                ];\n\t\n\t            channel && url.push('channel') && url.push(encode(channel));\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            if (channel_group) {\n\t                data['channel-group'] = channel_group;\n\t                !channel && url.push('channel') && url.push(','); \n\t            }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                debug    : debug,\n\t                url      : url\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n\t        */\n\t        'where_now' : function( args, callback ) {\n\t            var callback = args['callback'] || callback\n\t            ,   err      = args['error']    || function(){}\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   uuid     = args['uuid']     || UUID\n\t            ,   data     = { 'auth' : auth_key };\n\t\n\t            // Make sure we have a Channel\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub_key', SUBSCRIBE_KEY,\n\t                    'uuid', encode(uuid)\n\t                ]\n\t            });\n\t        },\n\t\n\t        'state' : function(args, callback) {\n\t            var callback = args['callback'] || callback || function(r) {}\n\t            ,   err      = args['error']    || function(){}\n\t            ,   auth_key = args['auth_key'] || AUTH_KEY\n\t            ,   jsonp    = jsonp_cb()\n\t            ,   state    = args['state']\n\t            ,   uuid     = args['uuid'] || UUID\n\t            ,   channel  = args['channel']\n\t            ,   channel_group = args['channel_group']\n\t            ,   url\n\t            ,   data     = _get_url_params({ 'auth' : auth_key });\n\t\n\t            // Make sure we have a Channel\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t            if (!uuid) return error('Missing UUID');\n\t            if (!channel && !channel_group) return error('Missing Channel');\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            if (typeof channel != 'undefined'\n\t                && CHANNELS[channel] && CHANNELS[channel].subscribed ) {\n\t                if (state) STATE[channel] = state;\n\t            }\n\t\n\t            if (typeof channel_group != 'undefined'\n\t                && CHANNEL_GROUPS[channel_group]\n\t                && CHANNEL_GROUPS[channel_group].subscribed\n\t                ) {\n\t                if (state) STATE[channel_group] = state;\n\t                data['channel-group'] = channel_group;\n\t\n\t                if (!channel) {\n\t                    channel = ',';\n\t                }\n\t            }\n\t\n\t            data['state'] = JSON.stringify(state);\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            if (state) {\n\t                url      = [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub-key', SUBSCRIBE_KEY,\n\t                    'channel', channel,\n\t                    'uuid', uuid, 'data'\n\t                ]\n\t            } else {\n\t                url      = [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub-key', SUBSCRIBE_KEY,\n\t                    'channel', channel,\n\t                    'uuid', encode(uuid)\n\t                ]\n\t            }\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t\n\t            });\n\t\n\t        },\n\t\n\t        /*\n\t            PUBNUB.grant({\n\t                channel  : 'my_chat',\n\t                callback : fun,\n\t                error    : fun,\n\t                ttl      : 24 * 60, // Minutes\n\t                read     : true,\n\t                write    : true,\n\t                auth_key : '3y8uiajdklytowsj'\n\t            });\n\t        */\n\t        'grant' : function( args, callback ) {\n\t            var callback        = args['callback'] || callback\n\t            ,   err             = args['error']    || function(){}\n\t            ,   channel         = args['channel']  || args['channels']\n\t            ,   channel_group   = args['channel_group']\n\t            ,   jsonp           = jsonp_cb()\n\t            ,   ttl             = args['ttl']\n\t            ,   r               = (args['read'] )?\"1\":\"0\"\n\t            ,   w               = (args['write'])?\"1\":\"0\"\n\t            ,   m               = (args['manage'])?\"1\":\"0\"\n\t            ,   auth_key        = args['auth_key'] || args['auth_keys'];\n\t\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SECRET_KEY)    return error('Missing Secret Key');\n\t\n\t            var timestamp  = Math.floor(new Date().getTime() / 1000)\n\t            ,   sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\"\n\t                    + \"grant\" + \"\\n\";\n\t\n\t            var data = {\n\t                'w'         : w,\n\t                'r'         : r,\n\t                'timestamp' : timestamp\n\t            };\n\t            if (args['manage']) {\n\t                data['m'] = m;\n\t            }\n\t            if (isArray(channel)) {\n\t                channel = channel['join'](',');\n\t            }\n\t            if (isArray(auth_key)) {\n\t                auth_key = auth_key['join'](',');\n\t            }\n\t            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n\t            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n\t                data['channel-group'] = channel_group;\n\t            }\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t            if (ttl || ttl === 0) data['ttl'] = ttl;\n\t\n\t            if (auth_key) data['auth'] = auth_key;\n\t\n\t            data = _get_url_params(data)\n\t\n\t            if (!auth_key) delete data['auth'];\n\t\n\t            sign_input += _get_pam_sign_input_from_params(data);\n\t\n\t            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n\t\n\t            signature = signature.replace( /\\+/g, \"-\" );\n\t            signature = signature.replace( /\\//g, \"_\" );\n\t\n\t            data['signature'] = signature;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : data,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v1', 'auth', 'grant' ,\n\t                    'sub-key', SUBSCRIBE_KEY\n\t                ]\n\t            });\n\t        },\n\t\n\t        /*\n\t         PUBNUB.mobile_gw_provision ({\n\t         device_id: 'A655FBA9931AB',\n\t         op       : 'add' | 'remove',\n\t         gw_type  : 'apns' | 'gcm',\n\t         channel  : 'my_chat',\n\t         callback : fun,\n\t         error    : fun,\n\t         });\n\t         */\n\t\n\t        'mobile_gw_provision' : function( args ) {\n\t\n\t            var callback = args['callback'] || function(){}\n\t                ,   auth_key       = args['auth_key'] || AUTH_KEY\n\t                ,   err            = args['error'] || function() {}\n\t                ,   jsonp          = jsonp_cb()\n\t                ,   channel        = args['channel']\n\t                ,   op             = args['op']\n\t                ,   gw_type        = args['gw_type']\n\t                ,   device_id      = args['device_id']\n\t                ,   params\n\t                ,   url;\n\t\n\t            if (!device_id)     return error('Missing Device ID (device_id)');\n\t            if (!gw_type)       return error('Missing GW Type (gw_type: gcm or apns)');\n\t            if (!op)            return error('Missing GW Operation (op: add or remove)');\n\t            if (!channel)       return error('Missing gw destination Channel (channel)');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t\n\t            // Create URL\n\t            url = [\n\t                STD_ORIGIN, 'v1/push/sub-key',\n\t                SUBSCRIBE_KEY, 'devices', device_id\n\t            ];\n\t\n\t            params = { 'uuid' : UUID, 'auth' : auth_key, 'type': gw_type};\n\t\n\t            if (op == \"add\") {\n\t                params['add'] = channel;\n\t            } else if (op == \"remove\") {\n\t                params['remove'] = channel;\n\t            }\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : params,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : url\n\t            });\n\t\n\t        },\n\t\n\t        /*\n\t            PUBNUB.audit({\n\t                channel  : 'my_chat',\n\t                callback : fun,\n\t                error    : fun,\n\t                read     : true,\n\t                write    : true,\n\t                auth_key : '3y8uiajdklytowsj'\n\t            });\n\t        */\n\t        'audit' : function( args, callback ) {\n\t            var callback        = args['callback'] || callback\n\t            ,   err             = args['error']    || function(){}\n\t            ,   channel         = args['channel']\n\t            ,   channel_group   = args['channel_group']\n\t            ,   auth_key        = args['auth_key']\n\t            ,   jsonp           = jsonp_cb();\n\t\n\t            // Make sure we have a Channel\n\t            if (!callback)      return error('Missing Callback');\n\t            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n\t            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n\t            if (!SECRET_KEY)    return error('Missing Secret Key');\n\t\n\t            var timestamp  = Math.floor(new Date().getTime() / 1000)\n\t            ,   sign_input = SUBSCRIBE_KEY + \"\\n\"\n\t                + PUBLISH_KEY + \"\\n\"\n\t                + \"audit\" + \"\\n\";\n\t\n\t            var data = {'timestamp' : timestamp };\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n\t            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n\t                data['channel-group'] = channel_group;\n\t            }\n\t            if (auth_key) data['auth']    = auth_key;\n\t\n\t            data = _get_url_params(data);\n\t\n\t            if (!auth_key) delete data['auth'];\n\t\n\t            sign_input += _get_pam_sign_input_from_params(data);\n\t\n\t            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n\t\n\t            signature = signature.replace( /\\+/g, \"-\" );\n\t            signature = signature.replace( /\\//g, \"_\" );\n\t\n\t            data['signature'] = signature;\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : data,\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) {\n\t                    _invoke_error(response, err);\n\t                },\n\t                url      : [\n\t                    STD_ORIGIN, 'v1', 'auth', 'audit' ,\n\t                    'sub-key', SUBSCRIBE_KEY\n\t                ]\n\t            });\n\t        },\n\t\n\t        /*\n\t            PUBNUB.revoke({\n\t                channel  : 'my_chat',\n\t                callback : fun,\n\t                error    : fun,\n\t                auth_key : '3y8uiajdklytowsj'\n\t            });\n\t        */\n\t        'revoke' : function( args, callback ) {\n\t            args['read']  = false;\n\t            args['write'] = false;\n\t            SELF['grant']( args, callback );\n\t        },\n\t        'set_uuid' : function(uuid) {\n\t            UUID = uuid;\n\t            CONNECT();\n\t        },\n\t        'get_uuid' : function() {\n\t            return UUID;\n\t        },\n\t        'isArray'  : function(arg) {\n\t            return isArray(arg);\n\t        },\n\t        'get_subscibed_channels' : function() {\n\t            return generate_channel_list(CHANNELS, true);\n\t        },\n\t        'presence_heartbeat' : function(args) {\n\t            var callback = args['callback'] || function() {}\n\t            var err      = args['error']    || function() {}\n\t            var jsonp    = jsonp_cb();\n\t            var data     = { 'uuid' : UUID, 'auth' : AUTH_KEY };\n\t\n\t            var st = JSON['stringify'](STATE);\n\t            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n\t\n\t            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n\t\n\t            if (jsonp != '0') { data['callback'] = jsonp; }\n\t\n\t            var channels        = encode(generate_channel_list(CHANNELS, true)['join'](','));\n\t            var channel_groups  = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n\t\n\t            if (!channels) channels = ',';\n\t            if (channel_groups) data['channel-group'] = channel_groups;\n\t\n\t            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\t\n\t            xdr({\n\t                callback : jsonp,\n\t                data     : _get_url_params(data),\n\t                timeout  : SECOND * 5,\n\t                url      : [\n\t                    STD_ORIGIN, 'v2', 'presence',\n\t                    'sub-key', SUBSCRIBE_KEY,\n\t                    'channel' , channels,\n\t                    'heartbeat'\n\t                ],\n\t                success  : function(response) {\n\t                    _invoke_callback(response, callback, err);\n\t                },\n\t                fail     : function(response) { _invoke_error(response, err); }\n\t            });\n\t        },\n\t        'stop_timers': function () {\n\t            clearTimeout(_poll_timer);\n\t            clearTimeout(_poll_timer2);\n\t            clearTimeout(PRESENCE_HB_TIMEOUT);\n\t        },\n\t        'shutdown': function () {\n\t            SELF['stop_timers']();\n\t            shutdown && shutdown();\n\t        },\n\t\n\t        // Expose PUBNUB Functions\n\t        'xdr'           : xdr,\n\t        'ready'         : ready,\n\t        'db'            : db,\n\t        'uuid'          : generate_uuid,\n\t        'map'           : map,\n\t        'each'          : each,\n\t        'each-channel'  : each_channel,\n\t        'grep'          : grep,\n\t        'offline'       : function(){ _reset_offline(\n\t            1, { \"message\" : \"Offline. Please check your network settings.\" })\n\t        },\n\t        'supplant'      : supplant,\n\t        'now'           : rnow,\n\t        'unique'        : unique,\n\t        'updater'       : updater\n\t    };\n\t\n\t    function _poll_online() {\n\t        _is_online() || _reset_offline( 1, {\n\t            \"error\" : \"Offline. Please check your network settings. \"\n\t        });\n\t        _poll_timer && clearTimeout(_poll_timer);\n\t        _poll_timer = timeout( _poll_online, SECOND );\n\t    }\n\t\n\t    function _poll_online2() {\n\t        if (!TIME_CHECK) return;\n\t        SELF['time'](function(success){\n\t            detect_time_detla( function(){}, success );\n\t            success || _reset_offline( 1, {\n\t                \"error\" : \"Heartbeat failed to connect to Pubnub Servers.\" +\n\t                    \"Please check your network settings.\"\n\t                });\n\t            _poll_timer2 && clearTimeout(_poll_timer2);\n\t            _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n\t        });\n\t    }\n\t\n\t    function _reset_offline(err, msg) {\n\t        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n\t        SUB_RECEIVER = null;\n\t\n\t        clearTimeout(_poll_timer);\n\t        clearTimeout(_poll_timer2);\n\t    }\n\t    \n\t    if (!UUID) UUID = SELF['uuid']();\n\t    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n\t    db['set']( SUBSCRIBE_KEY + 'uuid', UUID );\n\t\n\t    _poll_timer  = timeout( _poll_online,  SECOND    );\n\t    _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n\t    PRESENCE_HB_TIMEOUT = timeout(\n\t        start_presence_heartbeat,\n\t        ( PRESENCE_HB_INTERVAL - 3 ) * SECOND\n\t    );\n\t\n\t    // Detect Age of Message\n\t    function detect_latency(tt) {\n\t        var adjusted_time = rnow() - TIME_DRIFT;\n\t        return adjusted_time - tt / 10000;\n\t    }\n\t\n\t    detect_time_detla();\n\t    function detect_time_detla( cb, time ) {\n\t        var stime = rnow();\n\t\n\t        time && calculate(time) || SELF['time'](calculate);\n\t\n\t        function calculate(time) {\n\t            if (!time) return;\n\t            var ptime   = time / 10000\n\t            ,   latency = (rnow() - stime) / 2;\n\t            TIME_DRIFT = rnow() - (ptime + latency);\n\t            cb && cb(TIME_DRIFT);\n\t        }\n\t    }\n\t\n\t    return SELF;\n\t}\n\tfunction crypto_obj() {\n\t\n\t    function SHA256(s) {\n\t        return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);\n\t    }\n\t\n\t    var iv = \"0123456789012345\";\n\t\n\t    var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];\n\t    var allowedKeyLengths = [128, 256];\n\t    var allowedModes = ['ecb', 'cbc'];\n\t\n\t    var defaultOptions = {\n\t        'encryptKey': true,\n\t        'keyEncoding': 'utf8',\n\t        'keyLength': 256,\n\t        'mode': 'cbc'\n\t    };\n\t\n\t    function parse_options(options) {\n\t\n\t        // Defaults\n\t        options = options || {};\n\t        if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];\n\t        if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];\n\t        if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];\n\t        if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];\n\t\n\t        // Validation\n\t        if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];\n\t        if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];\n\t        if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];\n\t\n\t        return options;\n\t\n\t    }\n\t\n\t    function decode_key(key, options) {\n\t        if (options['keyEncoding'] == 'base64') {\n\t            return CryptoJS['enc']['Base64']['parse'](key);\n\t        } else if (options['keyEncoding'] == 'hex') {\n\t            return CryptoJS['enc']['Hex']['parse'](key);\n\t        } else {\n\t            return key;\n\t        }\n\t    }\n\t\n\t    function get_padded_key(key, options) {\n\t        key = decode_key(key, options);\n\t        if (options['encryptKey']) {\n\t            return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));\n\t        } else {\n\t            return key;\n\t        }\n\t    }\n\t\n\t    function get_mode(options) {\n\t        if (options['mode'] == 'ecb') {\n\t            return CryptoJS['mode']['ECB'];\n\t        } else {\n\t            return CryptoJS['mode']['CBC'];\n\t        }\n\t    }\n\t\n\t    function get_iv(options) {\n\t        return (options['mode'] == 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;\n\t    }\n\t\n\t    return {\n\t\n\t        'encrypt': function(data, key, options) {\n\t            if (!key) return data;\n\t            options = parse_options(options);\n\t            var iv = get_iv(options);\n\t            var mode = get_mode(options);\n\t            var cipher_key = get_padded_key(key, options);\n\t            var hex_message = JSON['stringify'](data);\n\t            var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, {'iv': iv, 'mode': mode})['ciphertext'];\n\t            var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);\n\t            return base_64_encrypted || data;\n\t        },\n\t\n\t        'decrypt': function(data, key, options) {\n\t            if (!key) return data;\n\t            options = parse_options(options);\n\t            var iv = get_iv(options);\n\t            var mode = get_mode(options);\n\t            var cipher_key = get_padded_key(key, options);\n\t            try {\n\t                var binary_enc = CryptoJS['enc']['Base64']['parse'](data);\n\t                var json_plain = CryptoJS['AES']['decrypt']({'ciphertext': binary_enc}, cipher_key, {'iv': iv, 'mode': mode})['toString'](CryptoJS['enc']['Utf8']);\n\t                var plaintext = JSON['parse'](json_plain);\n\t                return plaintext;\n\t            }\n\t            catch (e) {\n\t                return undefined;\n\t            }\n\t        }\n\t    };\n\t}\n\t/**\n\t * UTIL LOCALS\n\t */\n\t\n\tvar SWF             = 'https://pubnub.a.ssl.fastly.net/pubnub.swf'\n\t,   ASYNC           = 'async'\n\t,   UA              = navigator.userAgent\n\t,   PNSDK           = 'PubNub-JS-' + 'Web' + '/' + '3.7.16'\n\t,   XORIGN          = UA.indexOf('MSIE 6') == -1;\n\t\n\t/**\n\t * CONSOLE COMPATIBILITY\n\t */\n\twindow.console || (window.console=window.console||{});\n\tconsole.log    || (\n\t    console.log   =\n\t    console.error =\n\t    ((window.opera||{}).postError||function(){})\n\t);\n\t\n\t/**\n\t * LOCAL STORAGE OR COOKIE\n\t */\n\tvar db = (function(){\n\t    var store = {};\n\t    var ls = false;\n\t    try {\n\t        ls = window['localStorage'];\n\t    } catch (e) { }\n\t    var cookieGet = function(key) {\n\t        if (document.cookie.indexOf(key) == -1) return null;\n\t        return ((document.cookie||'').match(\n\t            RegExp(key+'=([^;]+)')\n\t        )||[])[1] || null;\n\t    };\n\t    var cookieSet = function( key, value ) {\n\t        document.cookie = key + '=' + value +\n\t            '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';\n\t    };\n\t    var cookieTest = (function() {\n\t        try {\n\t            cookieSet('pnctest', '1');\n\t            return cookieGet('pnctest') === '1';\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    }());\n\t    return {\n\t        'get' : function(key) {\n\t            try {\n\t                if (ls) return ls.getItem(key);\n\t                if (cookieTest) return cookieGet(key);\n\t                return store[key];\n\t            } catch(e) {\n\t                return store[key];\n\t            }\n\t        },\n\t        'set' : function( key, value ) {\n\t            try {\n\t                if (ls) return ls.setItem( key, value ) && 0;\n\t                if (cookieTest) cookieSet( key, value );\n\t                store[key] = value;\n\t            } catch(e) {\n\t                store[key] = value;\n\t            }\n\t        }\n\t    };\n\t})();\n\t\n\tfunction get_hmac_SHA256(data,key) {\n\t    var hash = CryptoJS['HmacSHA256'](data, key);\n\t    return hash.toString(CryptoJS['enc']['Base64']);\n\t}\n\t\n\t/**\n\t * $\n\t * =\n\t * var div = $('divid');\n\t */\n\tfunction $(id) { return document.getElementById(id) }\n\t\n\t/**\n\t * ERROR\n\t * =====\n\t * error('message');\n\t */\n\tfunction error(message) { console['error'](message) }\n\t\n\t/**\n\t * SEARCH\n\t * ======\n\t * var elements = search('a div span');\n\t */\n\tfunction search( elements, start) {\n\t    var list = [];\n\t    each( elements.split(/\\s+/), function(el) {\n\t        each( (start || document).getElementsByTagName(el), function(node) {\n\t            list.push(node);\n\t        } );\n\t    });\n\t    return list;\n\t}\n\t\n\t/**\n\t * BIND\n\t * ====\n\t * bind( 'keydown', search('a')[0], function(element) {\n\t *     ...\n\t * } );\n\t */\n\tfunction bind( type, el, fun ) {\n\t    each( type.split(','), function(etype) {\n\t        var rapfun = function(e) {\n\t            if (!e) e = window.event;\n\t            if (!fun(e)) {\n\t                e.cancelBubble = true;\n\t                e.preventDefault  && e.preventDefault();\n\t                e.stopPropagation && e.stopPropagation();\n\t            }\n\t        };\n\t\n\t        if ( el.addEventListener ) el.addEventListener( etype, rapfun, false );\n\t        else if ( el.attachEvent ) el.attachEvent( 'on' + etype, rapfun );\n\t        else  el[ 'on' + etype ] = rapfun;\n\t    } );\n\t}\n\t\n\t/**\n\t * UNBIND\n\t * ======\n\t * unbind( 'keydown', search('a')[0] );\n\t */\n\tfunction unbind( type, el, fun ) {\n\t    if ( el.removeEventListener ) el.removeEventListener( type, false );\n\t    else if ( el.detachEvent ) el.detachEvent( 'on' + type, false );\n\t    else  el[ 'on' + type ] = null;\n\t}\n\t\n\t/**\n\t * HEAD\n\t * ====\n\t * head().appendChild(elm);\n\t */\n\tfunction head() { return search('head')[0] }\n\t\n\t/**\n\t * ATTR\n\t * ====\n\t * var attribute = attr( node, 'attribute' );\n\t */\n\tfunction attr( node, attribute, value ) {\n\t    if (value) node.setAttribute( attribute, value );\n\t    else return node && node.getAttribute && node.getAttribute(attribute);\n\t}\n\t\n\t/**\n\t * CSS\n\t * ===\n\t * var obj = create('div');\n\t */\n\tfunction css( element, styles ) {\n\t    for (var style in styles) if (styles.hasOwnProperty(style))\n\t        try {element.style[style] = styles[style] + (\n\t            '|width|height|top|left|'.indexOf(style) > 0 &&\n\t            typeof styles[style] == 'number'\n\t            ? 'px' : ''\n\t        )}catch(e){}\n\t}\n\t\n\t/**\n\t * CREATE\n\t * ======\n\t * var obj = create('div');\n\t */\n\tfunction create(element) { return document.createElement(element) }\n\t\n\t\n\t/**\n\t * jsonp_cb\n\t * ========\n\t * var callback = jsonp_cb();\n\t */\n\tfunction jsonp_cb() { return XORIGN || FDomainRequest() ? 0 : unique() }\n\t\n\t\n\t\n\t/**\n\t * EVENTS\n\t * ======\n\t * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {\n\t *     // Do Stuff with message\n\t * } );\n\t *\n\t * PUBNUB.events.fire( 'you-stepped-on-flower', \"message-data\" );\n\t * PUBNUB.events.fire( 'you-stepped-on-flower', {message:\"data\"} );\n\t * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );\n\t *\n\t */\n\tvar events = {\n\t    'list'   : {},\n\t    'unbind' : function( name ) { events.list[name] = [] },\n\t    'bind'   : function( name, fun ) {\n\t        (events.list[name] = events.list[name] || []).push(fun);\n\t    },\n\t    'fire' : function( name, data ) {\n\t        each(\n\t            events.list[name] || [],\n\t            function(fun) { fun(data) }\n\t        );\n\t    }\n\t};\n\t\n\t/**\n\t * XDR Cross Domain Request\n\t * ========================\n\t *  xdr({\n\t *     url     : ['http://www.blah.com/url'],\n\t *     success : function(response) {},\n\t *     fail    : function() {}\n\t *  });\n\t */\n\tfunction xdr( setup ) {\n\t    if (XORIGN || FDomainRequest()) return ajax(setup);\n\t\n\t    var script    = create('script')\n\t    ,   callback  = setup.callback\n\t    ,   id        = unique()\n\t    ,   finished  = 0\n\t    ,   xhrtme    = setup.timeout || DEF_TIMEOUT\n\t    ,   timer     = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n\t    ,   fail      = setup.fail    || function(){}\n\t    ,   data      = setup.data    || {}\n\t    ,   success   = setup.success || function(){}\n\t    ,   append    = function() { head().appendChild(script) }\n\t    ,   done      = function( failed, response ) {\n\t            if (finished) return;\n\t            finished = 1;\n\t\n\t            script.onerror = null;\n\t            clearTimeout(timer);\n\t\n\t            (failed || !response) || success(response);\n\t\n\t            timeout( function() {\n\t                failed && fail();\n\t                var s = $(id)\n\t                ,   p = s && s.parentNode;\n\t                p && p.removeChild(s);\n\t            }, SECOND );\n\t        };\n\t\n\t    window[callback] = function(response) {\n\t        done( 0, response );\n\t    };\n\t\n\t    if (!setup.blocking) script[ASYNC] = ASYNC;\n\t\n\t    script.onerror = function() { done(1) };\n\t    script.src     = build_url( setup.url, data );\n\t\n\t    attr( script, 'id', id );\n\t\n\t    append();\n\t    return done;\n\t}\n\t\n\t/**\n\t * CORS XHR Request\n\t * ================\n\t *  xdr({\n\t *     url     : ['http://www.blah.com/url'],\n\t *     success : function(response) {},\n\t *     fail    : function() {}\n\t *  });\n\t */\n\tfunction ajax( setup ) {\n\t    var xhr, response\n\t    ,   finished = function() {\n\t            if (loaded) return;\n\t            loaded = 1;\n\t\n\t            clearTimeout(timer);\n\t\n\t            try       { response = JSON['parse'](xhr.responseText); }\n\t            catch (r) { return done(1); }\n\t\n\t            complete = 1;\n\t            success(response);\n\t        }\n\t    ,   complete = 0\n\t    ,   loaded   = 0\n\t    ,   xhrtme   = setup.timeout || DEF_TIMEOUT\n\t    ,   timer    = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n\t    ,   fail     = setup.fail    || function(){}\n\t    ,   data     = setup.data    || {}\n\t    ,   success  = setup.success || function(){}\n\t    ,   async    = !(setup.blocking)\n\t    ,   done     = function(failed,response) {\n\t            if (complete) return;\n\t            complete = 1;\n\t\n\t            clearTimeout(timer);\n\t\n\t            if (xhr) {\n\t                xhr.onerror = xhr.onload = null;\n\t                xhr.abort && xhr.abort();\n\t                xhr = null;\n\t            }\n\t\n\t            failed && fail(response);\n\t        };\n\t\n\t    // Send\n\t    try {\n\t        xhr = FDomainRequest()      ||\n\t              window.XDomainRequest &&\n\t              new XDomainRequest()  ||\n\t              new XMLHttpRequest();\n\t\n\t        xhr.onerror = xhr.onabort   = function(e){ done(\n\t            1, e || (xhr && xhr.responseText) || { \"error\" : \"Network Connection Error\"}\n\t        ) };\n\t        xhr.onload  = xhr.onloadend = finished;\n\t        xhr.onreadystatechange = function() {\n\t            if (xhr && xhr.readyState == 4) {\n\t                switch(xhr.status) {\n\t                    case 200:\n\t                        break;\n\t                    default:\n\t                        try {\n\t                            response = JSON['parse'](xhr.responseText);\n\t                            done(1,response);\n\t                        }\n\t                        catch (r) { return done(1, {status : xhr.status, payload : null, message : xhr.responseText}); }\n\t                        return;\n\t                }\n\t            }\n\t        }\n\t\n\t        var url = build_url(setup.url,data);\n\t\n\t        xhr.open( 'GET', url, async );\n\t        if (async) xhr.timeout = xhrtme;\n\t        xhr.send();\n\t    }\n\t    catch(eee) {\n\t        done(0);\n\t        XORIGN = 0;\n\t        return xdr(setup);\n\t    }\n\t\n\t    // Return 'done'\n\t    return done;\n\t}\n\t\n\t// Test Connection State\n\tfunction _is_online() {\n\t    if (!('onLine' in navigator)) return 1;\n\t    try       { return navigator['onLine'] }\n\t    catch (e) { return true }\n\t}\n\t\n\t\n\tfunction sendBeacon(url) {\n\t    if (!('sendBeacon' in navigator)) return false;\n\t\n\t    return navigator['sendBeacon'](url);\n\t}\n\t\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t/* =-=========================     PUBNUB     ===========================-= */\n\t/* =-====================================================================-= */\n\t/* =-====================================================================-= */\n\t\n\tvar PDIV          = $('pubnub') || 0\n\t,   CREATE_PUBNUB = function(setup) {\n\t\n\t    // Force JSONP if requested from user.\n\t    if (setup['jsonp'])  XORIGN = 0;\n\t    else                 XORIGN = UA.indexOf('MSIE 6') == -1;\n\t\n\t    var SUBSCRIBE_KEY = setup['subscribe_key'] || ''\n\t    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n\t    ,   UUID          = setup['uuid'] || db['get'](SUBSCRIBE_KEY+'uuid')||'';\n\t\n\t    var leave_on_unload = setup['leave_on_unload'] || 0;\n\t\n\t    setup['xdr']        = xdr;\n\t    setup['db']         = db;\n\t    setup['error']      = setup['error'] || error;\n\t    setup['_is_online'] = _is_online;\n\t    setup['jsonp_cb']   = jsonp_cb;\n\t    setup['hmac_SHA256']= get_hmac_SHA256;\n\t    setup['crypto_obj'] = crypto_obj();\n\t    setup['sendBeacon'] = sendBeacon;\n\t    setup['params']     = { 'pnsdk' : PNSDK }\n\t\n\t    var SELF = function(setup) {\n\t        return CREATE_PUBNUB(setup);\n\t    };\n\t\n\t    var PN = PN_API(setup);\n\t\n\t    for (var prop in PN) {\n\t        if (PN.hasOwnProperty(prop)) {\n\t            SELF[prop] = PN[prop];\n\t        }\n\t    }\n\t    SELF['css']         = css;\n\t    SELF['$']           = $;\n\t    SELF['create']      = create;\n\t    SELF['bind']        = bind;\n\t    SELF['head']        = head;\n\t    SELF['search']      = search;\n\t    SELF['attr']        = attr;\n\t    SELF['events']      = events;\n\t    SELF['init']        = SELF;\n\t    SELF['secure']      = SELF;\n\t    SELF['crypto_obj']  = crypto_obj(); // export to instance\n\t\n\t\n\t    // Add Leave Functions\n\t    bind( 'beforeunload', window, function() {\n\t        if (leave_on_unload) SELF['each-channel'](function(ch){ SELF['LEAVE']( ch.name, 0 ) });\n\t        return true;\n\t    } );\n\t\n\t    // Return without Testing\n\t    if (setup['notest']) return SELF;\n\t\n\t    bind( 'offline', window,   SELF['offline'] );\n\t    bind( 'offline', document, SELF['offline'] );\n\t\n\t    // Return PUBNUB Socket Object\n\t    return SELF;\n\t};\n\tCREATE_PUBNUB['init']   = CREATE_PUBNUB;\n\tCREATE_PUBNUB['secure'] = CREATE_PUBNUB;\n\tCREATE_PUBNUB['crypto_obj'] = crypto_obj(); // export to constructor\n\t\n\t// Bind for PUBNUB Readiness to Subscribe\n\tif (document.readyState === 'complete') {\n\t    timeout( ready, 0 );\n\t}\n\telse {\n\t    bind( 'load', window, function(){ timeout( ready, 0 ) } );\n\t}\n\t\n\tvar pdiv = PDIV || {};\n\t\n\t// CREATE A PUBNUB GLOBAL OBJECT\n\tPUBNUB = CREATE_PUBNUB({\n\t    'notest'        : 1,\n\t    'publish_key'   : attr( pdiv, 'pub-key' ),\n\t    'subscribe_key' : attr( pdiv, 'sub-key' ),\n\t    'ssl'           : !document.location.href.indexOf('https') ||\n\t                      attr( pdiv, 'ssl' ) == 'on',\n\t    'origin'        : attr( pdiv, 'origin' ),\n\t    'uuid'          : attr( pdiv, 'uuid' )\n\t});\n\t\n\t// jQuery Interface\n\twindow['jQuery'] && (window['jQuery']['PUBNUB'] = CREATE_PUBNUB);\n\t\n\t// For Modern JS + Testling.js - http://testling.com/\n\ttypeof(module) !== 'undefined' && (module['exports'] = PUBNUB) && ready();\n\t\n\tvar pubnubs = $('pubnubs') || 0;\n\t\n\t// LEAVE NOW IF NO PDIV.\n\tif (!PDIV) return;\n\t\n\t// PUBNUB Flash Socket\n\tcss( PDIV, { 'position' : 'absolute', 'top' : -SECOND } );\n\t\n\tif ('opera' in window || attr( PDIV, 'flash' )) PDIV['innerHTML'] =\n\t    '<object id=pubnubs data='  + SWF +\n\t    '><param name=movie value=' + SWF +\n\t    '><param name=allowscriptaccess value=always></object>';\n\t\n\t// Create Interface for Opera Flash\n\tPUBNUB['rdx'] = function( id, data ) {\n\t    if (!data) return FDomainRequest[id]['onerror']();\n\t    FDomainRequest[id]['responseText'] = unescape(data);\n\t    FDomainRequest[id]['onload']();\n\t};\n\t\n\tfunction FDomainRequest() {\n\t    if (!pubnubs || !pubnubs['get']) return 0;\n\t\n\t    var fdomainrequest = {\n\t        'id'    : FDomainRequest['id']++,\n\t        'send'  : function() {},\n\t        'abort' : function() { fdomainrequest['id'] = {} },\n\t        'open'  : function( method, url ) {\n\t            FDomainRequest[fdomainrequest['id']] = fdomainrequest;\n\t            pubnubs['get']( fdomainrequest['id'], url );\n\t        }\n\t    };\n\t\n\t    return fdomainrequest;\n\t}\n\tFDomainRequest['id'] = SECOND;\n\t\n\t})();\n\t(function(){\n\t\n\t// ---------------------------------------------------------------------------\n\t// WEBSOCKET INTERFACE\n\t// ---------------------------------------------------------------------------\n\tvar WS = PUBNUB['ws'] = function( url, protocols ) {\n\t    if (!(this instanceof WS)) return new WS( url, protocols );\n\t\n\t    var self     = this\n\t    ,   url      = self.url      = url || ''\n\t    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'\n\t    ,   bits     = url.split('/')\n\t    ,   setup    = {\n\t         'ssl'           : bits[0] === 'wss:'\n\t        ,'origin'        : bits[2]\n\t        ,'publish_key'   : bits[3]\n\t        ,'subscribe_key' : bits[4]\n\t        ,'channel'       : bits[5]\n\t    };\n\t\n\t    // READY STATES\n\t    self['CONNECTING'] = 0; // The connection is not yet open.\n\t    self['OPEN']       = 1; // The connection is open and ready to communicate.\n\t    self['CLOSING']    = 2; // The connection is in the process of closing.\n\t    self['CLOSED']     = 3; // The connection is closed or couldn't be opened.\n\t\n\t    // CLOSE STATES\n\t    self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.\n\t    self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.\n\t    self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.\n\t    self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.\n\t    self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.\n\t    self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.\n\t    self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.\n\t\n\t    // Events Default\n\t    self['onclose']   = self['onerror'] =\n\t    self['onmessage'] = self['onopen']  =\n\t    self['onsend']    =  function(){};\n\t\n\t    // Attributes\n\t    self['binaryType']     = '';\n\t    self['extensions']     = '';\n\t    self['bufferedAmount'] = 0;\n\t    self['trasnmitting']   = false;\n\t    self['buffer']         = [];\n\t    self['readyState']     = self['CONNECTING'];\n\t\n\t    // Close if no setup.\n\t    if (!url) {\n\t        self['readyState'] = self['CLOSED'];\n\t        self['onclose']({\n\t            'code'     : self['CLOSE_ABNORMAL'],\n\t            'reason'   : 'Missing URL',\n\t            'wasClean' : true\n\t        });\n\t        return self;\n\t    }\n\t\n\t    // PubNub WebSocket Emulation\n\t    self.pubnub       = PUBNUB['init'](setup);\n\t    self.pubnub.setup = setup;\n\t    self.setup        = setup;\n\t\n\t    self.pubnub['subscribe']({\n\t        'restore'    : false,\n\t        'channel'    : setup['channel'],\n\t        'disconnect' : self['onerror'],\n\t        'reconnect'  : self['onopen'],\n\t        'error'      : function() {\n\t            self['onclose']({\n\t                'code'     : self['CLOSE_ABNORMAL'],\n\t                'reason'   : 'Missing URL',\n\t                'wasClean' : false\n\t            });\n\t        },\n\t        'callback'   : function(message) {\n\t            self['onmessage']({ 'data' : message });\n\t        },\n\t        'connect'    : function() {\n\t            self['readyState'] = self['OPEN'];\n\t            self['onopen']();\n\t        }\n\t    });\n\t};\n\t\n\t// ---------------------------------------------------------------------------\n\t// WEBSOCKET SEND\n\t// ---------------------------------------------------------------------------\n\tWS.prototype.send = function(data) {\n\t    var self = this;\n\t    self.pubnub['publish']({\n\t        'channel'  : self.pubnub.setup['channel'],\n\t        'message'  : data,\n\t        'callback' : function(response) {\n\t            self['onsend']({ 'data' : response });\n\t        }\n\t    });\n\t};\n\t\n\t// ---------------------------------------------------------------------------\n\t// WEBSOCKET CLOSE\n\t// ---------------------------------------------------------------------------\n\tWS.prototype.close = function() {\n\t    var self = this;\n\t    self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });\n\t    self['readyState'] = self['CLOSED'];\n\t    self['onclose']({});\n\t};\n\t\n\t})();\n\t/*\n\tCryptoJS v3.1.2\n\tcode.google.com/p/crypto-js\n\t(c) 2009-2013 by Jeff Mott. All rights reserved.\n\tcode.google.com/p/crypto-js/wiki/License\n\t*/\n\tvar CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\n\tr=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n\t32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n\t2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\n\tu=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);\n\ta._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,\n\td)).finalize(c)}}});var t=f.algo={};return f}(Math);\n\t\n\t// SHA256\n\t(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=\n\tc[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\n\td[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);\n\t\n\t// HMAC SHA256\n\t(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;\"string\"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=\n\tthis._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();\n\t\n\t// Base64\n\t(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join(\"\")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<\n\tl;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"}})();\n\t\n\t// BlockCipher\n\t(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},\n\t_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),\n\tf=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,\n\tm,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,\n\tE,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/\n\t4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);\n\t(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,\n\tl)}})();\n\t\n\t// Cipher\n\tCryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},\n\tfinalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return(\"string\"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return(\"string\"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=\n\tc[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,\n\te,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,\n\tthis,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,\n\t1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},\n\tdecrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return\"string\"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,\n\tb.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();\n\t\n\t// AES\n\t(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,\n\t16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>\n\t8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=\n\td[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();\n\t\n\t// Mode ECB\n\tCryptoJS.mode.ECB = (function () {\n\t    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\t\n\t    ECB.Encryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.encryptBlock(words, offset);\n\t        }\n\t    });\n\t\n\t    ECB.Decryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.decryptBlock(words, offset);\n\t        }\n\t    });\n\t\n\t    return ECB;\n\t}());// Moved to hmac-sha-256.js\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module)))\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Cache = function () {\n\t    function Cache(storage, prefix) {\n\t        _classCallCheck(this, Cache);\n\t\n\t        this.setPrefix(prefix);\n\t        this._storage = storage;\n\t    }\n\t\n\t    Cache.prototype.setPrefix = function setPrefix(prefix) {\n\t        this._prefix = prefix || Cache.defaultPrefix;\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype.setItem = function setItem(key, data) {\n\t        this._storage[this._prefixKey(key)] = JSON.stringify(data);\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype.removeItem = function removeItem(key) {\n\t        delete this._storage[this._prefixKey(key)];\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype.getItem = function getItem(key) {\n\t        var item = this._storage[this._prefixKey(key)];\n\t        if (!item) return null;\n\t        return JSON.parse(item);\n\t    };\n\t\n\t    Cache.prototype.clean = function clean() {\n\t\n\t        for (var key in this._storage) {\n\t\n\t            if (!this._storage.hasOwnProperty(key)) continue;\n\t\n\t            if (key.indexOf(this._prefix) === 0) {\n\t                delete this._storage[key];\n\t            }\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    Cache.prototype._prefixKey = function _prefixKey(key) {\n\t        return this._prefix + key;\n\t    };\n\t\n\t    return Cache;\n\t}();\n\t\n\tCache.defaultPrefix = 'rc-';\n\texports.default = Cache;\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Observable = function () {\n\t    function Observable() {\n\t        _classCallCheck(this, Observable);\n\t\n\t        this.off();\n\t    }\n\t\n\t    Observable.prototype.hasListeners = function hasListeners(event) {\n\t        return event in this._listeners;\n\t    };\n\t\n\t    Observable.prototype.on = function on(events, callback) {\n\t        var _this = this;\n\t\n\t        if (typeof events == 'string') events = [events];\n\t        if (!events) throw new Error('No events to subscribe to');\n\t        if (typeof callback !== 'function') throw new Error('Callback must be a function');\n\t\n\t        events.forEach(function (event) {\n\t\n\t            if (!_this.hasListeners(event)) _this._listeners[event] = [];\n\t\n\t            _this._listeners[event].push(callback);\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Observable.prototype.emit = function emit(event) {\n\t        var _this2 = this;\n\t\n\t        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t            args[_key - 1] = arguments[_key];\n\t        }\n\t\n\t        var result = null;\n\t\n\t        if (!this.hasListeners(event)) return null;\n\t\n\t        this._listeners[event].some(function (callback) {\n\t\n\t            result = callback.apply(_this2, args);\n\t            return result === false;\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    Observable.prototype.off = function off(event, callback) {\n\t        var _this3 = this;\n\t\n\t        if (!event) {\n\t\n\t            this._listeners = {};\n\t        } else {\n\t\n\t            if (!callback) {\n\t\n\t                delete this._listeners[event];\n\t            } else {\n\t\n\t                if (!this.hasListeners(event)) return this;\n\t\n\t                this._listeners[event].forEach(function (cb, i) {\n\t\n\t                    if (cb === callback) delete _this3._listeners[event][i];\n\t                });\n\t            }\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    return Observable;\n\t}();\n\t\n\texports.default = Observable;\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Queue = function () {\n\t    function Queue(cache, cacheId) {\n\t        _classCallCheck(this, Queue);\n\t\n\t        this._cache = cache;\n\t        this._cacheId = cacheId;\n\t        this._promise = null;\n\t    }\n\t\n\t    Queue.prototype.isPaused = function isPaused() {\n\t\n\t        var time = this._cache.getItem(this._cacheId);\n\t\n\t        return !!time && Date.now() - parseInt(time) < Queue._releaseTimeout;\n\t    };\n\t\n\t    Queue.prototype.pause = function pause() {\n\t        this._cache.setItem(this._cacheId, Date.now());\n\t        return this;\n\t    };\n\t\n\t    Queue.prototype.resume = function resume() {\n\t        this._cache.removeItem(this._cacheId);\n\t        return this;\n\t    };\n\t\n\t    Queue.prototype.poll = function poll() {\n\t        var _this = this;\n\t\n\t        if (this._promise) return this._promise;\n\t\n\t        this._promise = new _Externals.Promise(function (resolve, reject) {\n\t\n\t            (0, _Utils.poll)(function (next) {\n\t\n\t                if (_this.isPaused()) return next();\n\t\n\t                _this._promise = null;\n\t\n\t                _this.resume(); // this is actually not needed but why not\n\t\n\t                resolve(null);\n\t            }, Queue._pollInterval);\n\t        });\n\t\n\t        return this._promise;\n\t    };\n\t\n\t    return Queue;\n\t}();\n\t\n\tQueue._pollInterval = 250;\n\tQueue._releaseTimeout = 5000;\n\texports.default = Queue;\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.findHeaderName = findHeaderName;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _ApiResponse = __webpack_require__(16);\n\t\n\tvar _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Client = function (_Observable) {\n\t    _inherits(Client, _Observable);\n\t\n\t    function Client() {\n\t        var _temp, _this, _ret;\n\t\n\t        _classCallCheck(this, Client);\n\t\n\t        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t            args[_key] = arguments[_key];\n\t        }\n\t\n\t        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Observable.call.apply(_Observable, [this].concat(args))), _this), _this.events = {\n\t            beforeRequest: 'beforeRequest',\n\t            requestSuccess: 'requestSuccess',\n\t            requestError: 'requestError'\n\t        }, _temp), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t    Client.prototype.sendRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n\t            var apiResponse;\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            apiResponse = new _ApiResponse2.default(request);\n\t                            _context.prev = 1;\n\t\n\t\n\t                            //TODO Stop request if listeners return false\n\t                            this.emit(this.events.beforeRequest, apiResponse);\n\t\n\t                            _context.next = 5;\n\t                            return this._loadResponse(request);\n\t\n\t                        case 5:\n\t                            apiResponse._response = _context.sent;\n\t                            _context.next = 8;\n\t                            return apiResponse._init();\n\t\n\t                        case 8:\n\t                            if (apiResponse.ok()) {\n\t                                _context.next = 10;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Response has unsuccessful status');\n\t\n\t                        case 10:\n\t\n\t                            this.emit(this.events.requestSuccess, apiResponse);\n\t\n\t                            return _context.abrupt(\"return\", apiResponse);\n\t\n\t                        case 14:\n\t                            _context.prev = 14;\n\t                            _context.t0 = _context[\"catch\"](1);\n\t\n\t\n\t                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);\n\t\n\t                            this.emit(this.events.requestError, _context.t0);\n\t\n\t                            throw _context.t0;\n\t\n\t                        case 19:\n\t                        case \"end\":\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this, [[1, 14]]);\n\t        }));\n\t\n\t        function sendRequest(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return sendRequest;\n\t    }();\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @return {Promise<Response>}\n\t     * @private\n\t     */\n\t\n\t\n\t    Client.prototype._loadResponse = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {\n\t            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t                while (1) {\n\t                    switch (_context2.prev = _context2.next) {\n\t                        case 0:\n\t                            _context2.next = 2;\n\t                            return _Externals.fetch.call(null, request);\n\t\n\t                        case 2:\n\t                            return _context2.abrupt(\"return\", _context2.sent);\n\t\n\t                        case 3:\n\t                        case \"end\":\n\t                            return _context2.stop();\n\t                    }\n\t                }\n\t            }, _callee2, this);\n\t        }));\n\t\n\t        function _loadResponse(_x2) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _loadResponse;\n\t    }();\n\t\n\t    /**\n\t     * Wraps the JS Error object with transaction information\n\t     * @param {Error|IApiError} e\n\t     * @param {ApiResponse} apiResponse\n\t     * @return {IApiError}\n\t     */\n\t\n\t\n\t    Client.prototype.makeError = function makeError(e, apiResponse) {\n\t\n\t        // Wrap only if regular error\n\t        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {\n\t\n\t            e.apiResponse = apiResponse;\n\t            e.originalMessage = e.message;\n\t            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;\n\t        }\n\t\n\t        return e;\n\t    };\n\t\n\t    /**\n\t     *\n\t     * @param {object} init\n\t     * @param {object} [init.url]\n\t     * @param {object} [init.body]\n\t     * @param {string} [init.method]\n\t     * @param {object} [init.query]\n\t     * @param {object} [init.headers]\n\t     * @return {Request}\n\t     */\n\t\n\t\n\t    Client.prototype.createRequest = function createRequest(init) {\n\t\n\t        init = init || {};\n\t        init.headers = init.headers || {};\n\t\n\t        // Sanity checks\n\t        if (!init.url) throw new Error('Url is not defined');\n\t        if (!init.method) init.method = 'GET';\n\t        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {\n\t            throw new Error('Method has wrong value: ' + init.method);\n\t        }\n\t\n\t        // Defaults\n\t        init.credentials = init.credentials || 'include';\n\t        init.mode = init.mode || 'cors';\n\t\n\t        // Append Query String\n\t        if (init.query) {\n\t            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);\n\t        }\n\t\n\t        if (!findHeaderName('Accept', init.headers)) {\n\t            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;\n\t        }\n\t\n\t        // Serialize body\n\t        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {\n\t\n\t            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);\n\t\n\t            if (!contentTypeHeaderName) {\n\t                contentTypeHeaderName = _ApiResponse2.default._contentType;\n\t                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;\n\t            }\n\t\n\t            var contentType = init.headers[contentTypeHeaderName];\n\t\n\t            // Assign a new encoded body\n\t            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {\n\t                init.body = JSON.stringify(init.body);\n\t            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {\n\t                init.body = (0, _Utils.queryStringify)(init.body);\n\t            }\n\t        }\n\t\n\t        // Create a request with encoded body\n\t        var req = new _Externals.Request(init.url, init);\n\t\n\t        // Keep the original body accessible directly (for mocks)\n\t        req.originalBody = init.body;\n\t\n\t        return req;\n\t    };\n\t\n\t    return Client;\n\t}(_Observable3.default);\n\t\n\tClient._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];\n\texports.default = Client;\n\tfunction findHeaderName(name, headers) {\n\t    name = name.toLowerCase();\n\t    return Object.keys(headers).reduce(function (res, key) {\n\t        if (res) return res;\n\t        if (name == key.toLowerCase()) return key;\n\t        return res;\n\t    }, null);\n\t}\n\t\n\t/**\n\t * @name IApiError\n\t * @property {string} stack\n\t * @property {string} originalMessage\n\t * @property {ApiResponse} apiResponse\n\t */\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ApiResponse = function () {\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @param {Response} response\n\t     * @param {string} responseText\n\t     */\n\t\n\t    function ApiResponse(request, response, responseText) {\n\t        _classCallCheck(this, ApiResponse);\n\t\n\t        /** @type {Request} */\n\t        this._request = request;\n\t\n\t        /** @type {Response} */\n\t        this._response = response;\n\t\n\t        this._text = responseText;\n\t        this._json = null;\n\t        this._multipart = [];\n\t    }\n\t\n\t    ApiResponse.prototype._init = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            if (!(this._isMultipart() || this._isJson())) {\n\t                                _context.next = 4;\n\t                                break;\n\t                            }\n\t\n\t                            _context.next = 3;\n\t                            return this.response().text();\n\t\n\t                        case 3:\n\t                            this._text = _context.sent;\n\t\n\t                        case 4:\n\t                            return _context.abrupt('return', this);\n\t\n\t                        case 5:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function _init() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _init;\n\t    }();\n\t\n\t    /**\n\t     * @return {Response}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.response = function response() {\n\t        return this._response;\n\t    };\n\t\n\t    /**\n\t     * @return {Request}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.request = function request() {\n\t        return this._request;\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.ok = function ok() {\n\t        return this._response && this._response.ok;\n\t    };\n\t\n\t    /**\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.text = function text() {\n\t        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');\n\t        return this._text;\n\t    };\n\t\n\t    /**\n\t     * @return {object}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.json = function json() {\n\t        if (!this._isJson()) throw new Error('Response is not JSON');\n\t        if (!this._json) {\n\t            this._json = this._text ? JSON.parse(this._text) : null;\n\t        }\n\t        return this._json;\n\t    };\n\t\n\t    /**\n\t     * @param [skipOKCheck]\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.error = function error(skipOKCheck) {\n\t\n\t        if (this.ok() && !skipOKCheck) return null;\n\t\n\t        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');\n\t\n\t        try {\n\t\n\t            if (this.json().message) message = this.json().message;\n\t            if (this.json().error_description) message = this.json().error_description;\n\t            if (this.json().description) message = this.json().description;\n\t        } catch (e) {}\n\t\n\t        return message;\n\t    };\n\t\n\t    /**\n\t     * @return {ApiResponse[]}\n\t     */\n\t\n\t\n\t    ApiResponse.prototype.multipart = function multipart() {\n\t\n\t        if (!this._isMultipart()) throw new Error('Response is not multipart');\n\t\n\t        if (!this._multipart.length) {\n\t\n\t            // Step 1. Split multipart response\n\t\n\t            var text = this.text();\n\t\n\t            if (!text) throw new Error('No response body');\n\t\n\t            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];\n\t\n\t            if (!boundary) throw new Error('Cannot find boundary');\n\t\n\t            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);\n\t\n\t            if (parts[0].trim() === '') parts.shift();\n\t            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();\n\t\n\t            if (parts.length < 1) throw new Error('No parts in body');\n\t\n\t            // Step 2. Parse status info\n\t\n\t            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();\n\t\n\t            // Step 3. Parse all other parts\n\t\n\t            this._multipart = parts.map(function (part, i) {\n\t\n\t                var status = statusInfo.response[i].status;\n\t\n\t                return ApiResponse.create(part, status);\n\t            });\n\t        }\n\t\n\t        return this._multipart;\n\t    };\n\t\n\t    ApiResponse.prototype._isContentType = function _isContentType(contentType) {\n\t        return this._getContentType().indexOf(contentType) > -1;\n\t    };\n\t\n\t    ApiResponse.prototype._getContentType = function _getContentType() {\n\t        return this._response.headers.get(ApiResponse._contentType) || '';\n\t    };\n\t\n\t    ApiResponse.prototype._isMultipart = function _isMultipart() {\n\t        return this._isContentType(ApiResponse._multipartContentType);\n\t    };\n\t\n\t    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {\n\t        return this._isContentType(ApiResponse._urlencodedContentType);\n\t    };\n\t\n\t    ApiResponse.prototype._isJson = function _isJson() {\n\t        return this._isContentType(ApiResponse._jsonContentType);\n\t    };\n\t\n\t    /**\n\t     * Method is used to create ApiResponse object from string parts of multipart/mixed response\n\t     * @param {string} [text]\n\t     * @param {number} [status]\n\t     * @param {string} [statusText]\n\t     * @return {ApiResponse}\n\t     */\n\t\n\t\n\t    ApiResponse.create = function create(text, status, statusText) {\n\t\n\t        text = text || '';\n\t        status = status || 200;\n\t        statusText = statusText || 'OK';\n\t\n\t        text = text.replace(/\\r/g, '');\n\t\n\t        var headers = new _Externals.Headers(),\n\t            headersAndBody = text.split(ApiResponse._bodySeparator),\n\t            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';\n\t\n\t        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;\n\t\n\t        (headersText || '').split('\\n').forEach(function (header) {\n\t\n\t            var split = header.trim().split(ApiResponse._headerSeparator),\n\t                key = split.shift().trim(),\n\t                value = split.join(ApiResponse._headerSeparator).trim();\n\t\n\t            if (key) headers.append(key, value);\n\t        });\n\t\n\t        return new ApiResponse(null, new _Externals.Response(text ? text : null, {\n\t            headers: headers,\n\t            status: status,\n\t            statusText: statusText\n\t        }), text);\n\t    };\n\t\n\t    return ApiResponse;\n\t}();\n\t\n\tApiResponse._contentType = 'Content-Type';\n\tApiResponse._jsonContentType = 'application/json';\n\tApiResponse._multipartContentType = 'multipart/mixed';\n\tApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';\n\tApiResponse._headerSeparator = ':';\n\tApiResponse._bodySeparator = '\\n\\n';\n\tApiResponse._boundarySeparator = '--';\n\texports.default = ApiResponse;\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Registry = __webpack_require__(18);\n\t\n\tvar _Registry2 = _interopRequireDefault(_Registry);\n\t\n\tvar _Client = __webpack_require__(15);\n\t\n\tvar _Client2 = _interopRequireDefault(_Client);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Client = function (_HttpClient) {\n\t    _inherits(Client, _HttpClient);\n\t\n\t    function Client() {\n\t        _classCallCheck(this, Client);\n\t\n\t        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));\n\t\n\t        _this._registry = new _Registry2.default();\n\t        return _this;\n\t    }\n\t\n\t    Client.prototype.registry = function registry() {\n\t        return this._registry;\n\t    };\n\t\n\t    Client.prototype._loadResponse = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n\t            var mock;\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            mock = this._registry.find(request);\n\t                            _context.next = 3;\n\t                            return mock.getResponse(request);\n\t\n\t                        case 3:\n\t                            return _context.abrupt('return', _context.sent);\n\t\n\t                        case 4:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function _loadResponse(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _loadResponse;\n\t    }();\n\t\n\t    return Client;\n\t}(_Client2.default);\n\t\n\texports.default = Client;\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Mock = __webpack_require__(19);\n\t\n\tvar _Mock2 = _interopRequireDefault(_Mock);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Registry = function () {\n\t    function Registry() {\n\t        _classCallCheck(this, Registry);\n\t\n\t        this._mocks = [];\n\t    }\n\t\n\t    Registry.prototype.add = function add(mock) {\n\t        this._mocks.push(mock);\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.clear = function clear() {\n\t        this._mocks = [];\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.find = function find(request) {\n\t\n\t        //console.log('Registry is looking for', request);\n\t\n\t        var mock = this._mocks.shift();\n\t\n\t        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);\n\t\n\t        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());\n\t\n\t        return mock;\n\t    };\n\t\n\t    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText) {\n\t\n\t        this.add(new _Mock2.default(method, path, response, status, statusText));\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.authentication = function authentication() {\n\t\n\t        this.apiCall('POST', '/restapi/oauth/token', {\n\t            'access_token': 'ACCESS_TOKEN',\n\t            'token_type': 'bearer',\n\t            'expires_in': 3600,\n\t            'refresh_token': 'REFRESH_TOKEN',\n\t            'refresh_token_expires_in': 60480,\n\t            'scope': 'SMS RCM Foo Boo',\n\t            'expireTime': new Date().getTime() + 3600000\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.logout = function logout() {\n\t\n\t        this.apiCall('POST', '/restapi/oauth/revoke', {});\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.presenceLoad = function presenceLoad(id) {\n\t\n\t        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {\n\t            \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id + \"/presence\",\n\t            \"extension\": {\n\t                \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id,\n\t                \"id\": id,\n\t                \"extensionNumber\": \"101\"\n\t            },\n\t            \"activeCalls\": [],\n\t            \"presenceStatus\": \"Available\",\n\t            \"telephonyStatus\": \"Ringing\",\n\t            \"userStatus\": \"Available\",\n\t            \"dndStatus\": \"TakeAllCalls\",\n\t            \"extensionId\": id\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {\n\t\n\t        expiresIn = expiresIn || 15 * 60 * 60;\n\t\n\t        var date = new Date();\n\t\n\t        this.apiCall('POST', '/restapi/v1.0/subscription', {\n\t            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],\n\t            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),\n\t            'expiresIn': expiresIn,\n\t            'deliveryMode': {\n\t                'transportType': 'PubNub',\n\t                'encryption': false,\n\t                'address': '123_foo',\n\t                'subscriberKey': 'sub-c-foo',\n\t                'secretKey': 'sec-c-bar'\n\t            },\n\t            'id': 'foo-bar-baz',\n\t            'creationTime': date.toISOString(),\n\t            'status': 'Active',\n\t            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {\n\t\n\t        id = id || '1';\n\t\n\t        var date = new Date();\n\t\n\t        this.apiCall('POST', '/restapi/v1.0/subscription', {\n\t            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],\n\t            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),\n\t            'deliveryMode': {\n\t                'transportType': 'PubNub',\n\t                'encryption': true,\n\t                'address': '123_foo',\n\t                'subscriberKey': 'sub-c-foo',\n\t                'secretKey': 'sec-c-bar',\n\t                'encryptionAlgorithm': 'AES',\n\t                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='\n\t            },\n\t            'creationTime': date.toISOString(),\n\t            'id': 'foo-bar-baz',\n\t            'status': 'Active',\n\t            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {\n\t\n\t        if (!failure) {\n\t\n\t            this.apiCall('POST', '/restapi/oauth/token', {\n\t                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',\n\t                'token_type': 'bearer',\n\t                'expires_in': 3600,\n\t                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',\n\t                'refresh_token_expires_in': 60480,\n\t                'scope': 'SMS RCM Foo Boo'\n\t            });\n\t        } else {\n\t\n\t            this.apiCall('POST', '/restapi/oauth/token', {\n\t                'message': 'Wrong token',\n\t                'error_description': 'Wrong token',\n\t                'description': 'Wrong token'\n\t            }, 400);\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    return Registry;\n\t}();\n\t\n\texports.default = Registry;\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _ApiResponse = __webpack_require__(16);\n\t\n\tvar _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Mock = function () {\n\t    function Mock(method, path, json, status, statusText, delay) {\n\t        _classCallCheck(this, Mock);\n\t\n\t        this._method = method.toUpperCase();\n\t        this._path = path;\n\t        this._json = json || {};\n\t        this._delay = delay || 10;\n\t        this._status = status || 200;\n\t        this._statusText = statusText || 'OK';\n\t    }\n\t\n\t    Mock.prototype.path = function path() {\n\t        return this._path;\n\t    };\n\t\n\t    Mock.prototype.method = function method() {\n\t        return this._method;\n\t    };\n\t\n\t    Mock.prototype.test = function test(request) {\n\t\n\t        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;\n\t    };\n\t\n\t    Mock.prototype.getResponse = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            _context.next = 2;\n\t                            return (0, _Utils.delay)(this._delay);\n\t\n\t                        case 2:\n\t                            return _context.abrupt('return', this.createResponse(this._json));\n\t\n\t                        case 3:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function getResponse(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return getResponse;\n\t    }();\n\t\n\t    Mock.prototype.createResponse = function createResponse(json, init) {\n\t\n\t        init = init || {};\n\t\n\t        init.status = init.status || this._status;\n\t        init.statusText = init.statusText || this._statusText;\n\t\n\t        var str = JSON.stringify(json),\n\t            res = new _Externals.Response(str, init);\n\t\n\t        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);\n\t\n\t        return res;\n\t    };\n\t\n\t    return Mock;\n\t}();\n\t\n\texports.default = Mock;\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _Queue = __webpack_require__(14);\n\t\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\t\n\tvar _Auth = __webpack_require__(21);\n\t\n\tvar _Auth2 = _interopRequireDefault(_Auth);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Platform = function (_Observable) {\n\t    _inherits(Platform, _Observable);\n\t\n\t    // 10 hours\n\t\n\t    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {\n\t        _classCallCheck(this, Platform);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n\t\n\t        _this.events = {\n\t            beforeLogin: 'beforeLogin',\n\t            loginSuccess: 'loginSuccess',\n\t            loginError: 'loginError',\n\t            beforeRefresh: 'beforeRefresh',\n\t            refreshSuccess: 'refreshSuccess',\n\t            refreshError: 'refreshError',\n\t            beforeLogout: 'beforeLogout',\n\t            logoutSuccess: 'logoutSuccess',\n\t            logoutError: 'logoutError'\n\t        };\n\t\n\t\n\t        _this._server = server;\n\t        _this._appKey = appKey;\n\t        _this._appSecret = appSecret;\n\t\n\t        /** @type {Cache} */\n\t        _this._cache = cache;\n\t\n\t        /** @type {Client} */\n\t        _this._client = client;\n\t\n\t        _this._queue = new _Queue2.default(_this._cache, Platform._cacheId + '-refresh');\n\t\n\t        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);\n\t\n\t        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;\n\t\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * @return {Auth}\n\t     */\n\t    // 1 week\n\t\n\t\n\t    Platform.prototype.auth = function auth() {\n\t        return this._auth;\n\t    };\n\t\n\t    /**\n\t     * @return {Client}\n\t     */\n\t\n\t\n\t    Platform.prototype.client = function client() {\n\t        return this._client;\n\t    };\n\t\n\t    /**\n\t     * @param {string} path\n\t     * @param {object} [options]\n\t     * @param {boolean} [options.addServer]\n\t     * @param {string} [options.addMethod]\n\t     * @param {boolean} [options.addToken]\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    Platform.prototype.createUrl = function createUrl(path, options) {\n\t\n\t        path = path || '';\n\t        options = options || {};\n\t\n\t        var builtUrl = '',\n\t            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;\n\t\n\t        if (options.addServer && !hasHttp) builtUrl += this._server;\n\t\n\t        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;\n\t\n\t        builtUrl += path;\n\t\n\t        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';\n\t\n\t        if (options.addMethod) builtUrl += '_method=' + options.addMethod;\n\t        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();\n\t\n\t        return builtUrl;\n\t    };\n\t\n\t    /**\n\t     * @param {string} options.redirectUri\n\t     * @param {string} options.state\n\t     * @param {string} options.brandId\n\t     * @param {string} options.display\n\t     * @param {string} options.prompt\n\t     * @param {object} [options]\n\t     * @return {string}\n\t     */\n\t\n\t\n\t    Platform.prototype.authUrl = function authUrl(options) {\n\t\n\t        options = options || {};\n\t\n\t        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({\n\t            'response_type': 'code',\n\t            'redirect_uri': options.redirectUri || '',\n\t            'client_id': this._appKey,\n\t            'state': options.state || '',\n\t            'brand_id': options.brandId || '',\n\t            'display': options.display || '',\n\t            'prompt': options.prompt || ''\n\t        }), { addServer: true });\n\t    };\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @return {Object}\n\t     */\n\t\n\t\n\t    Platform.prototype.parseAuthRedirectUrl = function parseAuthRedirectUrl(url) {\n\t\n\t        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),\n\t            error = qs.error_description || qs.error;\n\t\n\t        if (error) {\n\t            var e = new Error(error);\n\t            e.error = qs.error;\n\t            throw e;\n\t        }\n\t\n\t        return qs;\n\t    };\n\t\n\t    /**\n\t     * Convenience method to handle 3-legged OAuth\n\t     *\n\t     * Attention! This is an experimental method and it's signature and behavior may change without notice.\n\t     *\n\t     * @experimental\n\t     * @param {number} [options.width]\n\t     * @param {number} [options.height]\n\t     * @param {object} [options.login] additional options for login()\n\t     * @param {string} [options.origin]\n\t     * @param {string} [options.property] name of window.postMessage's event data property\n\t     * @param {string} [options.target] target for window.open()\n\t     * @param {string} options.url\n\t     * @return {Promise}\n\t     */\n\t\n\t\n\t    Platform.prototype.authWindow = function authWindow(options) {\n\t        var _this2 = this;\n\t\n\t        return new _Externals.Promise(function (resolve, reject) {\n\t\n\t            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');\n\t\n\t            if (!options.url) throw new Error('Missing mandatory URL parameter');\n\t\n\t            options = options || {};\n\t            options.url = options.url || 400;\n\t            options.width = options.width || 400;\n\t            options.height = options.height || 600;\n\t            options.origin = options.origin || window.location.origin;\n\t            options.property = options.property || 'RCAuthorizationCode';\n\t            options.target = options.target || '_blank';\n\t\n\t            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;\n\t            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;\n\t\n\t            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;\n\t            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\t\n\t            var left = width / 2 - options.width / 2 + dualScreenLeft;\n\t            var top = height / 2 - options.height / 2 + dualScreenTop;\n\t            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');\n\t\n\t            if (window.focus) win.focus();\n\t\n\t            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';\n\t            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';\n\t            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';\n\t\n\t            var eventListener = function eventListener(e) {\n\t\n\t                if (e.origin != options.origin) return;\n\t                if (!e.data || !e.data[options.property]) return; // keep waiting\n\t\n\t                win.close();\n\t                window[eventRemoveMethod](messageEvent, eventListener);\n\t\n\t                try {\n\t\n\t                    var loginOptions = _this2.parseAuthRedirectUrl(e.data[options.property]);\n\t\n\t                    if (!loginOptions.code) throw new Error('No authorization code');\n\t\n\t                    resolve(loginOptions);\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            };\n\t\n\t            window[eventMethod](messageEvent, eventListener, false);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @return {Promise<boolean>}\n\t     */\n\t\n\t\n\t    Platform.prototype.loggedIn = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            _context.prev = 0;\n\t                            _context.next = 3;\n\t                            return this._ensureAuthentication();\n\t\n\t                        case 3:\n\t                            return _context.abrupt(\"return\", true);\n\t\n\t                        case 6:\n\t                            _context.prev = 6;\n\t                            _context.t0 = _context[\"catch\"](0);\n\t                            return _context.abrupt(\"return\", false);\n\t\n\t                        case 9:\n\t                        case \"end\":\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this, [[0, 6]]);\n\t        }));\n\t\n\t        function loggedIn() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return loggedIn;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} options.username\n\t     * @param {string} options.password\n\t     * @param {string} options.extension\n\t     * @param {string} options.code\n\t     * @param {string} options.redirectUri\n\t     * @param {string} options.endpointId\n\t     * @param {string} options.remember\n\t     * @param {string} options.accessTokenTtl\n\t     * @param {string} options.refreshTokenTtl\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.login = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {\n\t            var body, apiResponse, json;\n\t            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t                while (1) {\n\t                    switch (_context2.prev = _context2.next) {\n\t                        case 0:\n\t                            _context2.prev = 0;\n\t\n\t\n\t                            options = options || {};\n\t\n\t                            this.emit(this.events.beforeLogin);\n\t\n\t                            body = {};\n\t\n\t\n\t                            if (!options.code) {\n\t\n\t                                body.grant_type = 'password';\n\t                                body.username = options.username;\n\t                                body.password = options.password;\n\t                                body.extension = options.extension || '';\n\t                            } else if (options.code) {\n\t\n\t                                body.grant_type = 'authorization_code';\n\t                                body.code = options.code;\n\t                                body.redirect_uri = options.redirectUri;\n\t                                //body.client_id = this.getCredentials().key; // not needed\n\t                            }\n\t\n\t                            if (options.endpointId) body.endpoint_id = options.endpointId;\n\t                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;\n\t                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;\n\t                            if (options.remember && !options.refreshTokenTtl) body.refreshTokenTtl = options.remember ? Platform._refreshTokenTtlRemember : Platform._refreshTokenTtl;\n\t\n\t                            _context2.next = 11;\n\t                            return this._tokenRequest(Platform._tokenEndpoint, body);\n\t\n\t                        case 11:\n\t                            apiResponse = _context2.sent;\n\t                            json = apiResponse.json();\n\t\n\t\n\t                            this._auth.setData(json);\n\t\n\t                            this.emit(this.events.loginSuccess, apiResponse);\n\t\n\t                            return _context2.abrupt(\"return\", apiResponse);\n\t\n\t                        case 18:\n\t                            _context2.prev = 18;\n\t                            _context2.t0 = _context2[\"catch\"](0);\n\t\n\t\n\t                            this._cache.clean();\n\t\n\t                            this.emit(this.events.loginError, _context2.t0);\n\t\n\t                            throw _context2.t0;\n\t\n\t                        case 23:\n\t                        case \"end\":\n\t                            return _context2.stop();\n\t                    }\n\t                }\n\t            }, _callee2, this, [[0, 18]]);\n\t        }));\n\t\n\t        function login(_x) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return login;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.refresh = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n\t            var res, json;\n\t            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n\t                while (1) {\n\t                    switch (_context3.prev = _context3.next) {\n\t                        case 0:\n\t                            _context3.prev = 0;\n\t\n\t\n\t                            this.emit(this.events.beforeRefresh);\n\t\n\t                            if (!this._queue.isPaused()) {\n\t                                _context3.next = 9;\n\t                                break;\n\t                            }\n\t\n\t                            _context3.next = 5;\n\t                            return this._queue.poll();\n\t\n\t                        case 5:\n\t                            if (this._isAccessTokenValid()) {\n\t                                _context3.next = 7;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Automatic authentification timeout');\n\t\n\t                        case 7:\n\t\n\t                            this.emit(this.events.refreshSuccess, null);\n\t\n\t                            return _context3.abrupt(\"return\", null);\n\t\n\t                        case 9:\n\t\n\t                            this._queue.pause();\n\t\n\t                            // Make sure all existing AJAX calls had a chance to reach the server\n\t                            _context3.next = 12;\n\t                            return (0, _Utils.delay)(Platform._refreshDelayMs);\n\t\n\t                        case 12:\n\t                            if (this._auth.refreshToken()) {\n\t                                _context3.next = 14;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Refresh token is missing');\n\t\n\t                        case 14:\n\t                            if (this._auth.refreshTokenValid()) {\n\t                                _context3.next = 16;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Refresh token has expired');\n\t\n\t                        case 16:\n\t                            if (this._queue.isPaused()) {\n\t                                _context3.next = 18;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Queue was resumed before refresh call');\n\t\n\t                        case 18:\n\t                            _context3.next = 20;\n\t                            return this._tokenRequest(Platform._tokenEndpoint, {\n\t                                \"grant_type\": \"refresh_token\",\n\t                                \"refresh_token\": this._auth.refreshToken(),\n\t                                \"access_token_ttl\": this._auth.data().expires_in + 1,\n\t                                \"refresh_token_ttl\": this._auth.data().refresh_token_expires_in + 1\n\t                            });\n\t\n\t                        case 20:\n\t                            res = _context3.sent;\n\t                            json = res.json();\n\t\n\t                            if (json.access_token) {\n\t                                _context3.next = 24;\n\t                                break;\n\t                            }\n\t\n\t                            throw this._client.makeError(new Error('Malformed OAuth response'), res);\n\t\n\t                        case 24:\n\t\n\t                            this._auth.setData(json);\n\t                            this._queue.resume();\n\t\n\t                            this.emit(this.events.refreshSuccess, res);\n\t\n\t                            return _context3.abrupt(\"return\", res);\n\t\n\t                        case 30:\n\t                            _context3.prev = 30;\n\t                            _context3.t0 = _context3[\"catch\"](0);\n\t\n\t\n\t                            _context3.t0 = this._client.makeError(_context3.t0);\n\t\n\t                            if (Platform._clearCacheOnRefreshError) {\n\t                                this._cache.clean();\n\t                            }\n\t\n\t                            this.emit(this.events.refreshError, _context3.t0);\n\t\n\t                            throw _context3.t0;\n\t\n\t                        case 36:\n\t                        case \"end\":\n\t                            return _context3.stop();\n\t                    }\n\t                }\n\t            }, _callee3, this, [[0, 30]]);\n\t        }));\n\t\n\t        function refresh() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return refresh;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.logout = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n\t            var res;\n\t            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n\t                while (1) {\n\t                    switch (_context4.prev = _context4.next) {\n\t                        case 0:\n\t                            _context4.prev = 0;\n\t\n\t\n\t                            this.emit(this.events.beforeLogout);\n\t\n\t                            this._queue.pause();\n\t\n\t                            _context4.next = 5;\n\t                            return this._tokenRequest(Platform._revokeEndpoint, {\n\t                                token: this._auth.accessToken()\n\t                            });\n\t\n\t                        case 5:\n\t                            res = _context4.sent;\n\t\n\t\n\t                            this._queue.resume();\n\t                            this._cache.clean();\n\t\n\t                            this.emit(this.events.logoutSuccess, res);\n\t\n\t                            return _context4.abrupt(\"return\", res);\n\t\n\t                        case 12:\n\t                            _context4.prev = 12;\n\t                            _context4.t0 = _context4[\"catch\"](0);\n\t\n\t\n\t                            this._queue.resume();\n\t\n\t                            this.emit(this.events.logoutError, _context4.t0);\n\t\n\t                            throw _context4.t0;\n\t\n\t                        case 17:\n\t                        case \"end\":\n\t                            return _context4.stop();\n\t                    }\n\t                }\n\t            }, _callee4, this, [[0, 12]]);\n\t        }));\n\t\n\t        function logout() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return logout;\n\t    }();\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @param {object} [options]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<Request>}\n\t     */\n\t\n\t\n\t    Platform.prototype.inflateRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(request, options) {\n\t            return regeneratorRuntime.wrap(function _callee5$(_context5) {\n\t                while (1) {\n\t                    switch (_context5.prev = _context5.next) {\n\t                        case 0:\n\t\n\t                            options = options || {};\n\t\n\t                            if (!options.skipAuthCheck) {\n\t                                _context5.next = 3;\n\t                                break;\n\t                            }\n\t\n\t                            return _context5.abrupt(\"return\", request);\n\t\n\t                        case 3:\n\t                            _context5.next = 5;\n\t                            return this._ensureAuthentication();\n\t\n\t                        case 5:\n\t\n\t                            request.headers.set('X-User-Agent', this._userAgent);\n\t                            request.headers.set('Client-Id', this._appKey);\n\t                            request.headers.set('Authorization', this._authHeader());\n\t                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...\n\t\n\t                            return _context5.abrupt(\"return\", request);\n\t\n\t                        case 9:\n\t                        case \"end\":\n\t                            return _context5.stop();\n\t                    }\n\t                }\n\t            }, _callee5, this);\n\t        }));\n\t\n\t        function inflateRequest(_x2, _x3) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return inflateRequest;\n\t    }();\n\t\n\t    /**\n\t     * @param {Request} request\n\t     * @param {object} [options]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.sendRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {\n\t            return regeneratorRuntime.wrap(function _callee6$(_context6) {\n\t                while (1) {\n\t                    switch (_context6.prev = _context6.next) {\n\t                        case 0:\n\t                            _context6.prev = 0;\n\t                            _context6.next = 3;\n\t                            return this.inflateRequest(request, options);\n\t\n\t                        case 3:\n\t                            request = _context6.sent;\n\t                            _context6.next = 6;\n\t                            return this._client.sendRequest(request);\n\t\n\t                        case 6:\n\t                            return _context6.abrupt(\"return\", _context6.sent);\n\t\n\t                        case 9:\n\t                            _context6.prev = 9;\n\t                            _context6.t0 = _context6[\"catch\"](0);\n\t\n\t                            if (!(!_context6.t0.apiResponse || !_context6.t0.apiResponse.response() || _context6.t0.apiResponse.response().status != 401)) {\n\t                                _context6.next = 13;\n\t                                break;\n\t                            }\n\t\n\t                            throw _context6.t0;\n\t\n\t                        case 13:\n\t\n\t                            this._auth.cancelAccessToken();\n\t\n\t                            _context6.next = 16;\n\t                            return this.sendRequest(request, options);\n\t\n\t                        case 16:\n\t                            return _context6.abrupt(\"return\", _context6.sent);\n\t\n\t                        case 17:\n\t                        case \"end\":\n\t                            return _context6.stop();\n\t                    }\n\t                }\n\t            }, _callee6, this, [[0, 9]]);\n\t        }));\n\t\n\t        function sendRequest(_x4, _x5) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return sendRequest;\n\t    }();\n\t\n\t    /**\n\t     * General purpose function to send anything to server\n\t     * @param {string} options.url\n\t     * @param {object} [options.body]\n\t     * @param {string} [options.method]\n\t     * @param {object} [options.query]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.send = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {\n\t            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t            return regeneratorRuntime.wrap(function _callee7$(_context7) {\n\t                while (1) {\n\t                    switch (_context7.prev = _context7.next) {\n\t                        case 0:\n\t\n\t                            //FIXME https://github.com/bitinn/node-fetch/issues/43\n\t                            options.url = this.createUrl(options.url, { addServer: true });\n\t\n\t                            _context7.next = 3;\n\t                            return this.sendRequest(this._client.createRequest(options), options);\n\t\n\t                        case 3:\n\t                            return _context7.abrupt(\"return\", _context7.sent);\n\t\n\t                        case 4:\n\t                        case \"end\":\n\t                            return _context7.stop();\n\t                    }\n\t                }\n\t            }, _callee7, this);\n\t        }));\n\t\n\t        function send(_x6) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return send;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {object} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.get = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(url, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee8$(_context8) {\n\t                while (1) {\n\t                    switch (_context8.prev = _context8.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'GET';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            _context8.next = 6;\n\t                            return this.send(options);\n\t\n\t                        case 6:\n\t                            return _context8.abrupt(\"return\", _context8.sent);\n\t\n\t                        case 7:\n\t                        case \"end\":\n\t                            return _context8.stop();\n\t                    }\n\t                }\n\t            }, _callee8, this);\n\t        }));\n\t\n\t        function get(_x8, _x9, _x10) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return get;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {object} body\n\t     * @param {object} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.post = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, body, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee9$(_context9) {\n\t                while (1) {\n\t                    switch (_context9.prev = _context9.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'POST';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            options.body = body;\n\t                            _context9.next = 7;\n\t                            return this.send(options);\n\t\n\t                        case 7:\n\t                            return _context9.abrupt(\"return\", _context9.sent);\n\t\n\t                        case 8:\n\t                        case \"end\":\n\t                            return _context9.stop();\n\t                    }\n\t                }\n\t            }, _callee9, this);\n\t        }));\n\t\n\t        function post(_x11, _x12, _x13, _x14) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return post;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {object} [body]\n\t     * @param {object} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype.put = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee10$(_context10) {\n\t                while (1) {\n\t                    switch (_context10.prev = _context10.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'PUT';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            options.body = body;\n\t                            _context10.next = 7;\n\t                            return this.send(options);\n\t\n\t                        case 7:\n\t                            return _context10.abrupt(\"return\", _context10.sent);\n\t\n\t                        case 8:\n\t                        case \"end\":\n\t                            return _context10.stop();\n\t                    }\n\t                }\n\t            }, _callee10, this);\n\t        }));\n\t\n\t        function put(_x15, _x16, _x17, _x18) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return put;\n\t    }();\n\t\n\t    /**\n\t     * @param {string} url\n\t     * @param {string} [query]\n\t     * @param {object} [options]\n\t     * @param {object} [options.headers]\n\t     * @param {boolean} [options.skipAuthCheck]\n\t     * @return {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Platform.prototype['delete'] = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, query, options) {\n\t            return regeneratorRuntime.wrap(function _callee11$(_context11) {\n\t                while (1) {\n\t                    switch (_context11.prev = _context11.next) {\n\t                        case 0:\n\t                            options = options || {};\n\t                            options.method = 'DELETE';\n\t                            options.url = url;\n\t                            options.query = query;\n\t                            _context11.next = 6;\n\t                            return this.send(options);\n\t\n\t                        case 6:\n\t                            return _context11.abrupt(\"return\", _context11.sent);\n\t\n\t                        case 7:\n\t                        case \"end\":\n\t                            return _context11.stop();\n\t                    }\n\t                }\n\t            }, _callee11, this);\n\t        }));\n\t\n\t        function _delete(_x19, _x20, _x21) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _delete;\n\t    }();\n\t\n\t    Platform.prototype._tokenRequest = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(path, body) {\n\t            return regeneratorRuntime.wrap(function _callee12$(_context12) {\n\t                while (1) {\n\t                    switch (_context12.prev = _context12.next) {\n\t                        case 0:\n\t                            _context12.next = 2;\n\t                            return this.send({\n\t                                url: path,\n\t                                skipAuthCheck: true,\n\t                                body: body,\n\t                                method: 'POST',\n\t                                headers: {\n\t                                    'Authorization': 'Basic ' + this._apiKey(),\n\t                                    'Content-Type': 'application/x-www-form-urlencoded'\n\t                                }\n\t                            });\n\t\n\t                        case 2:\n\t                            return _context12.abrupt(\"return\", _context12.sent);\n\t\n\t                        case 3:\n\t                        case \"end\":\n\t                            return _context12.stop();\n\t                    }\n\t                }\n\t            }, _callee12, this);\n\t        }));\n\t\n\t        function _tokenRequest(_x22, _x23) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _tokenRequest;\n\t    }();\n\t\n\t    Platform.prototype._ensureAuthentication = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {\n\t            return regeneratorRuntime.wrap(function _callee13$(_context13) {\n\t                while (1) {\n\t                    switch (_context13.prev = _context13.next) {\n\t                        case 0:\n\t                            if (!this._isAccessTokenValid()) {\n\t                                _context13.next = 2;\n\t                                break;\n\t                            }\n\t\n\t                            return _context13.abrupt(\"return\", null);\n\t\n\t                        case 2:\n\t                            _context13.next = 4;\n\t                            return this.refresh();\n\t\n\t                        case 4:\n\t                            return _context13.abrupt(\"return\", _context13.sent);\n\t\n\t                        case 5:\n\t                        case \"end\":\n\t                            return _context13.stop();\n\t                    }\n\t                }\n\t            }, _callee13, this);\n\t        }));\n\t\n\t        function _ensureAuthentication() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _ensureAuthentication;\n\t    }();\n\t\n\t    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {\n\t\n\t        return this._auth.accessTokenValid() && !this._queue.isPaused();\n\t    };\n\t\n\t    Platform.prototype._apiKey = function _apiKey() {\n\t        var apiKey = this._appKey + ':' + this._appSecret;\n\t        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');\n\t    };\n\t\n\t    Platform.prototype._authHeader = function _authHeader() {\n\t        var token = this._auth.accessToken();\n\t        return this._auth.tokenType() + (token ? ' ' + token : '');\n\t    };\n\t\n\t    return Platform;\n\t}(_Observable3.default);\n\t\n\tPlatform._urlPrefix = '/restapi';\n\tPlatform._apiVersion = 'v1.0';\n\tPlatform._refreshTokenTtl = 10 * 60 * 60;\n\tPlatform._refreshTokenTtlRemember = 7 * 24 * 60 * 60;\n\tPlatform._tokenEndpoint = '/restapi/oauth/token';\n\tPlatform._revokeEndpoint = '/restapi/oauth/revoke';\n\tPlatform._authorizeEndpoint = '/restapi/oauth/authorize';\n\tPlatform._refreshDelayMs = 100;\n\tPlatform._cacheId = 'platform';\n\tPlatform._clearCacheOnRefreshError = false;\n\texports.default = Platform;\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Auth = function () {\n\t    function Auth(cache, cacheId) {\n\t        _classCallCheck(this, Auth);\n\t\n\t        /** @type {Cache} */\n\t        this._cache = cache;\n\t        this._cacheId = cacheId;\n\t    } // 1 minute\n\t\n\t\n\t    Auth.prototype.accessToken = function accessToken() {\n\t        return this.data().access_token;\n\t    };\n\t\n\t    Auth.prototype.refreshToken = function refreshToken() {\n\t        return this.data().refresh_token;\n\t    };\n\t\n\t    Auth.prototype.tokenType = function tokenType() {\n\t        return this.data().token_type;\n\t    };\n\t\n\t    /**\n\t     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}\n\t     */\n\t\n\t\n\t    Auth.prototype.data = function data() {\n\t\n\t        return this._cache.getItem(this._cacheId) || {\n\t            token_type: '',\n\t            access_token: '',\n\t            expires_in: 0,\n\t            refresh_token: '',\n\t            refresh_token_expires_in: 0\n\t        };\n\t    };\n\t\n\t    /**\n\t     * @param {object} newData\n\t     * @return {Auth}\n\t     */\n\t\n\t\n\t    Auth.prototype.setData = function setData(newData) {\n\t\n\t        newData = newData || {};\n\t\n\t        var data = this.data();\n\t\n\t        Object.keys(newData).forEach(function (key) {\n\t            data[key] = newData[key];\n\t        });\n\t\n\t        data.expire_time = Date.now() + data.expires_in * 1000;\n\t        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;\n\t\n\t        this._cache.setItem(this._cacheId, data);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Check if there is a valid (not expired) access token\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    Auth.prototype.accessTokenValid = function accessTokenValid() {\n\t\n\t        var authData = this.data();\n\t        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();\n\t    };\n\t\n\t    /**\n\t     * Check if there is a valid (not expired) access token\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    Auth.prototype.refreshTokenValid = function refreshTokenValid() {\n\t\n\t        return this.data().refresh_token_expire_time > Date.now();\n\t    };\n\t\n\t    /**\n\t     * @return {Auth}\n\t     */\n\t\n\t\n\t    Auth.prototype.cancelAccessToken = function cancelAccessToken() {\n\t\n\t        return this.setData({\n\t            access_token: '',\n\t            expires_in: 0\n\t        });\n\t    };\n\t\n\t    /**\n\t     * This method sets a special authentication mode used in Service Web\n\t     * @return {Auth}\n\t     */\n\t\n\t\n\t    Auth.prototype.forceAuthentication = function forceAuthentication() {\n\t\n\t        this.setData({\n\t            token_type: Auth.forcedTokenType,\n\t            access_token: '',\n\t            expires_in: 0,\n\t            refresh_token: '',\n\t            refresh_token_expires_in: 0\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    return Auth;\n\t}();\n\t\n\t//export interface IAuthData {\n\t//    remember?:boolean;\n\t//    token_type?:string;\n\t//    access_token?:string;\n\t//    expires_in?:number; // actually it's string\n\t//    expire_time?:number;\n\t//    refresh_token?:string;\n\t//    refresh_token_expires_in?:number; // actually it's string\n\t//    refresh_token_expire_time?:number;\n\t//    scope?:string;\n\t//}\n\t\n\t\n\tAuth.refreshHandicapMs = 60 * 1000;\n\tAuth.forcedTokenType = 'forced';\n\texports.default = Auth;\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _PubnubMock = __webpack_require__(23);\n\t\n\tvar _PubnubMock2 = _interopRequireDefault(_PubnubMock);\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar PubnubMockFactory = function () {\n\t    function PubnubMockFactory() {\n\t        _classCallCheck(this, PubnubMockFactory);\n\t\n\t        this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n\t    }\n\t\n\t    PubnubMockFactory.prototype.init = function init(options) {\n\t        return new _PubnubMock2.default(options);\n\t    };\n\t\n\t    return PubnubMockFactory;\n\t}();\n\t\n\texports.default = PubnubMockFactory;\n\t\n\t/***/ },\n\t/* 23 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _Externals = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar PubnubMock = function (_Observable) {\n\t    _inherits(PubnubMock, _Observable);\n\t\n\t    function PubnubMock(options) {\n\t        _classCallCheck(this, PubnubMock);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n\t\n\t        _this.options = options;\n\t        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n\t        return _this;\n\t    }\n\t\n\t    PubnubMock.prototype.ready = function ready() {};\n\t\n\t    PubnubMock.prototype.subscribe = function subscribe(options) {\n\t        this.on('message-' + options.channel, options.message);\n\t    };\n\t\n\t    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {\n\t        this.off('message-' + options.channel);\n\t    };\n\t\n\t    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {\n\t        this.emit('message-' + channel, msg, 'env', channel);\n\t    };\n\t\n\t    return PubnubMock;\n\t}(_Observable3.default);\n\t\n\texports.default = PubnubMock;\n\t\n\t/***/ },\n\t/* 24 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _Observable2 = __webpack_require__(13);\n\t\n\tvar _Observable3 = _interopRequireDefault(_Observable2);\n\t\n\tvar _Client = __webpack_require__(15);\n\t\n\tvar _Client2 = _interopRequireDefault(_Client);\n\t\n\tvar _Utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Subscription = function (_Observable) {\n\t    _inherits(Subscription, _Observable);\n\t\n\t    function Subscription(pubnubFactory, platform) {\n\t        _classCallCheck(this, Subscription);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n\t\n\t        _this.events = {\n\t            notification: 'notification',\n\t            removeSuccess: 'removeSuccess',\n\t            removeError: 'removeError',\n\t            renewSuccess: 'renewSuccess',\n\t            renewError: 'renewError',\n\t            subscribeSuccess: 'subscribeSuccess',\n\t            subscribeError: 'subscribeError'\n\t        };\n\t\n\t\n\t        _this._pubnubFactory = pubnubFactory;\n\t        _this._platform = platform;\n\t        _this._pubnub = null;\n\t        _this._timeout = null;\n\t        _this._subscription = {};\n\t\n\t        return _this;\n\t    }\n\t\n\t    Subscription.prototype.subscribed = function subscribed() {\n\t\n\t        return !!(this._subscription.id && this._subscription.deliveryMode && this._subscription.deliveryMode.subscriberKey && this._subscription.deliveryMode.address);\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t\n\t\n\t    Subscription.prototype.alive = function alive() {\n\t        return this.subscribed() && Date.now() < this.expirationTime();\n\t    };\n\t\n\t    Subscription.prototype.expirationTime = function expirationTime() {\n\t        return new Date(this._subscription.expirationTime || 0).getTime() - Subscription._renewHandicapMs;\n\t    };\n\t\n\t    Subscription.prototype.setSubscription = function setSubscription(subscription) {\n\t\n\t        subscription = subscription || {};\n\t\n\t        this._clearTimeout();\n\t\n\t        this._subscription = subscription;\n\t\n\t        if (!this._pubnub) this._subscribeAtPubnub();\n\t\n\t        this._setTimeout();\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype.subscription = function subscription() {\n\t        return this._subscription;\n\t    };\n\t\n\t    /**\n\t     * Creates or updates subscription if there is an active one\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.register = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            if (!this.alive()) {\n\t                                _context.next = 6;\n\t                                break;\n\t                            }\n\t\n\t                            _context.next = 3;\n\t                            return this.renew();\n\t\n\t                        case 3:\n\t                            return _context.abrupt('return', _context.sent);\n\t\n\t                        case 6:\n\t                            _context.next = 8;\n\t                            return this.subscribe();\n\t\n\t                        case 8:\n\t                            return _context.abrupt('return', _context.sent);\n\t\n\t                        case 9:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this);\n\t        }));\n\t\n\t        function register() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return register;\n\t    }();\n\t\n\t    Subscription.prototype.eventFilters = function eventFilters() {\n\t        return this._subscription.eventFilters || [];\n\t    };\n\t\n\t    /**\n\t     * @param {string[]} events\n\t     * @return {Subscription}\n\t     */\n\t\n\t\n\t    Subscription.prototype.addEventFilters = function addEventFilters(events) {\n\t        this.setEventFilters(this.eventFilters().concat(events));\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * @param {string[]} events\n\t     * @return {Subscription}\n\t     */\n\t\n\t\n\t    Subscription.prototype.setEventFilters = function setEventFilters(events) {\n\t        this._subscription.eventFilters = events;\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.subscribe = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n\t            var response, json;\n\t            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t                while (1) {\n\t                    switch (_context2.prev = _context2.next) {\n\t                        case 0:\n\t                            _context2.prev = 0;\n\t\n\t\n\t                            this._clearTimeout();\n\t\n\t                            if (this.eventFilters().length) {\n\t                                _context2.next = 4;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Events are undefined');\n\t\n\t                        case 4:\n\t                            _context2.next = 6;\n\t                            return this._platform.post('/restapi/v1.0/subscription', {\n\t                                eventFilters: this._getFullEventFilters(),\n\t                                deliveryMode: {\n\t                                    transportType: 'PubNub'\n\t                                }\n\t                            });\n\t\n\t                        case 6:\n\t                            response = _context2.sent;\n\t                            json = response.json();\n\t\n\t\n\t                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);\n\t\n\t                            return _context2.abrupt('return', response);\n\t\n\t                        case 12:\n\t                            _context2.prev = 12;\n\t                            _context2.t0 = _context2['catch'](0);\n\t\n\t\n\t                            _context2.t0 = this._platform.client().makeError(_context2.t0);\n\t\n\t                            this.reset().emit(this.events.subscribeError, _context2.t0);\n\t\n\t                            throw _context2.t0;\n\t\n\t                        case 17:\n\t                        case 'end':\n\t                            return _context2.stop();\n\t                    }\n\t                }\n\t            }, _callee2, this, [[0, 12]]);\n\t        }));\n\t\n\t        function subscribe() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return subscribe;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.renew = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n\t            var response, json;\n\t            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n\t                while (1) {\n\t                    switch (_context3.prev = _context3.next) {\n\t                        case 0:\n\t                            _context3.prev = 0;\n\t\n\t\n\t                            this._clearTimeout();\n\t\n\t                            if (this.subscribed()) {\n\t                                _context3.next = 4;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('No subscription');\n\t\n\t                        case 4:\n\t                            if (this.eventFilters().length) {\n\t                                _context3.next = 6;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('Events are undefined');\n\t\n\t                        case 6:\n\t                            _context3.next = 8;\n\t                            return this._platform.put('/restapi/v1.0/subscription/' + this._subscription.id, {\n\t                                eventFilters: this._getFullEventFilters()\n\t                            });\n\t\n\t                        case 8:\n\t                            response = _context3.sent;\n\t                            json = response.json();\n\t\n\t\n\t                            this.setSubscription(json).emit(this.events.renewSuccess, response);\n\t\n\t                            return _context3.abrupt('return', response);\n\t\n\t                        case 14:\n\t                            _context3.prev = 14;\n\t                            _context3.t0 = _context3['catch'](0);\n\t\n\t\n\t                            _context3.t0 = this._platform.client().makeError(_context3.t0);\n\t\n\t                            this.reset().emit(this.events.renewError, _context3.t0);\n\t\n\t                            throw _context3.t0;\n\t\n\t                        case 19:\n\t                        case 'end':\n\t                            return _context3.stop();\n\t                    }\n\t                }\n\t            }, _callee3, this, [[0, 14]]);\n\t        }));\n\t\n\t        function renew() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return renew;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.remove = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n\t            var response;\n\t            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n\t                while (1) {\n\t                    switch (_context4.prev = _context4.next) {\n\t                        case 0:\n\t                            _context4.prev = 0;\n\t\n\t                            if (this.subscribed()) {\n\t                                _context4.next = 3;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error('No subscription');\n\t\n\t                        case 3:\n\t                            _context4.next = 5;\n\t                            return this._platform.delete('/restapi/v1.0/subscription/' + this._subscription.id);\n\t\n\t                        case 5:\n\t                            response = _context4.sent;\n\t\n\t\n\t                            this.reset().emit(this.events.removeSuccess, response);\n\t\n\t                            return _context4.abrupt('return', response);\n\t\n\t                        case 10:\n\t                            _context4.prev = 10;\n\t                            _context4.t0 = _context4['catch'](0);\n\t\n\t\n\t                            _context4.t0 = this._platform.client().makeError(_context4.t0);\n\t\n\t                            this.emit(this.events.removeError, _context4.t0);\n\t\n\t                            throw _context4.t0;\n\t\n\t                        case 15:\n\t                        case 'end':\n\t                            return _context4.stop();\n\t                    }\n\t                }\n\t            }, _callee4, this, [[0, 10]]);\n\t        }));\n\t\n\t        function remove() {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return remove;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    Subscription.prototype.resubscribe = function resubscribe() {\n\t\n\t        return this.reset().setEventFilters(this.eventFilters()).subscribe();\n\t    };\n\t\n\t    /**\n\t     * Remove subscription and disconnect from PUBNUB\n\t     * This method resets subscription at client side but backend is not notified\n\t     */\n\t\n\t\n\t    Subscription.prototype.reset = function reset() {\n\t        this._clearTimeout();\n\t        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this._subscription.deliveryMode.address });\n\t        this._subscription = {};\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {\n\t        var _this2 = this;\n\t\n\t        return this.eventFilters().map(function (event) {\n\t            return _this2._platform.createUrl(event);\n\t        });\n\t    };\n\t\n\t    Subscription.prototype._setTimeout = function _setTimeout() {\n\t        var _this3 = this;\n\t\n\t        this._clearTimeout();\n\t\n\t        if (!this.alive()) throw new Error('Subscription is not alive');\n\t\n\t        (0, _Utils.poll)(function (next) {\n\t\n\t            if (_this3.alive()) return next();\n\t\n\t            _this3.renew();\n\t        }, Subscription._pollInterval, this._timeout);\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._clearTimeout = function _clearTimeout() {\n\t\n\t        (0, _Utils.stopPolling)(this._timeout);\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._decrypt = function _decrypt(message) {\n\t\n\t        if (!this.subscribed()) throw new Error('No subscription');\n\t\n\t        if (this._subscription.deliveryMode.encryptionKey) {\n\t\n\t            var PUBNUB = this._pubnubFactory;\n\t\n\t            message = PUBNUB.crypto_obj.decrypt(message, this._subscription.deliveryMode.encryptionKey, {\n\t                encryptKey: false,\n\t                keyEncoding: 'base64',\n\t                keyLength: 128,\n\t                mode: 'ecb'\n\t            });\n\t        }\n\t\n\t        return message;\n\t    };\n\t\n\t    Subscription.prototype._notify = function _notify(message) {\n\t\n\t        this.emit(this.events.notification, this._decrypt(message));\n\t\n\t        return this;\n\t    };\n\t\n\t    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {\n\t\n\t        if (!this.alive()) throw new Error('Subscription is not alive');\n\t\n\t        var PUBNUB = this._pubnubFactory;\n\t\n\t        this._pubnub = PUBNUB.init({\n\t            ssl: true,\n\t            subscribe_key: this._subscription.deliveryMode.subscriberKey\n\t        });\n\t\n\t        this._pubnub.ready();\n\t\n\t        this._pubnub.subscribe({\n\t            channel: this._subscription.deliveryMode.address,\n\t            message: this._notify.bind(this),\n\t            connect: function connect() {}\n\t        });\n\t\n\t        return this;\n\t    };\n\t\n\t    return Subscription;\n\t}(_Observable3.default);\n\t\n\t//export interface ISubscription {\n\t//    id?:string;\n\t//    uri?: string;\n\t//    eventFilters?:string[];\n\t//    expirationTime?:string; // 2014-03-12T19:54:35.613Z\n\t//    expiresIn?:number;\n\t//    deliveryMode?: {\n\t//        transportType?:string;\n\t//        encryption?:boolean;\n\t//        address?:string;\n\t//        subscriberKey?:string;\n\t//        encryptionKey?:string;\n\t//        secretKey?:string;\n\t//    };\n\t//    creationTime?:string; // 2014-03-12T19:54:35.613Z\n\t//    status?:string; // Active\n\t//}\n\t\n\t\n\tSubscription._renewHandicapMs = 2 * 60 * 1000;\n\tSubscription._pollInterval = 10 * 1000;\n\texports.default = Subscription;\n\t\n\t/***/ },\n\t/* 25 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _Subscription2 = __webpack_require__(24);\n\t\n\tvar _Subscription3 = _interopRequireDefault(_Subscription2);\n\t\n\tvar _Queue = __webpack_require__(14);\n\t\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar CachedSubscription = function (_Subscription) {\n\t    _inherits(CachedSubscription, _Subscription);\n\t\n\t    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {\n\t        _classCallCheck(this, CachedSubscription);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));\n\t\n\t        _this._cache = cache;\n\t        _this._cacheKey = cacheKey;\n\t        _this._renewQueue = new _Queue2.default(_this._cache, cacheKey + '-renew');\n\t        _this._resubscribeQueue = new _Queue2.default(_this._cache, cacheKey + '-resubscribe');\n\t\n\t        _this.events = _extends({}, _this.events, {\n\t            queuedRenewSuccess: 'queuedRenewSuccess',\n\t            queuedRenewError: 'queuedRenewError',\n\t            queuedResubscribeSuccess: 'queuedResubscribeSuccess',\n\t            queuedResubscribeError: 'queuedResubscribeError'\n\t        });\n\t\n\t        _this.on(_this.events.renewError, function () {\n\t            _this.resubscribe();\n\t        });\n\t\n\t        _this.on([_this.events.subscribeSuccess, _this.events.renewSuccess], function () {\n\t            _this._cache.setItem(_this._cacheKey, _this.subscription());\n\t        });\n\t\n\t        _this.on(_this.events.removeSuccess, function () {\n\t            _this._cache.removeItem(_this._cacheKey);\n\t        });\n\t\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * TODO Combine with Platform.refresh and move elsewhere\n\t     * @param actionCb\n\t     * @param queue\n\t     * @param successEvent\n\t     * @param errorEvent\n\t     * @param errorMessage\n\t     * @return {*}\n\t     * @private\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype._queue = function () {\n\t        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(actionCb, queue, successEvent, errorEvent, errorMessage) {\n\t            var res;\n\t            return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                while (1) {\n\t                    switch (_context.prev = _context.next) {\n\t                        case 0:\n\t                            _context.prev = 0;\n\t\n\t                            if (!queue.isPaused()) {\n\t                                _context.next = 8;\n\t                                break;\n\t                            }\n\t\n\t                            _context.next = 4;\n\t                            return queue.poll();\n\t\n\t                        case 4:\n\t                            if (this.alive()) {\n\t                                _context.next = 6;\n\t                                break;\n\t                            }\n\t\n\t                            throw new Error(errorMessage);\n\t\n\t                        case 6:\n\t\n\t                            this.emit(successEvent, null);\n\t\n\t                            return _context.abrupt('return', null);\n\t\n\t                        case 8:\n\t\n\t                            queue.pause();\n\t\n\t                            _context.next = 11;\n\t                            return actionCb.call(this);\n\t\n\t                        case 11:\n\t                            res = _context.sent;\n\t\n\t\n\t                            queue.resume();\n\t\n\t                            this.emit(successEvent, res);\n\t\n\t                            return _context.abrupt('return', res);\n\t\n\t                        case 17:\n\t                            _context.prev = 17;\n\t                            _context.t0 = _context['catch'](0);\n\t\n\t\n\t                            this.emit(errorEvent, _context.t0);\n\t\n\t                            throw _context.t0;\n\t\n\t                        case 21:\n\t                        case 'end':\n\t                            return _context.stop();\n\t                    }\n\t                }\n\t            }, _callee, this, [[0, 17]]);\n\t        }));\n\t\n\t        function _queue(_x, _x2, _x3, _x4, _x5) {\n\t            return ref.apply(this, arguments);\n\t        }\n\t\n\t        return _queue;\n\t    }();\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype.renew = function renew() {\n\t\n\t        return this._queue(_Subscription.prototype.renew, this._renewQueue, this.events.queuedRenewSuccess, this.events.queuedRenewError, 'Subscription is not alive after renew timeout');\n\t    };\n\t\n\t    /**\n\t     * @returns {Promise<ApiResponse>}\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype.resubscribe = function resubscribe() {\n\t\n\t        return this._queue(_Subscription.prototype.resubscribe, this._resubscribeQueue, this.events.queuedResubscribeSuccess, this.events.queuedResubscribeError, 'Subscription is not alive after resubscribe timeout');\n\t    };\n\t\n\t    /**\n\t     * @param {string[]} events\n\t     * @return {CachedSubscription}\n\t     */\n\t\n\t\n\t    CachedSubscription.prototype.restore = function restore(events) {\n\t\n\t        var cachedSubscriptionData = this._cache.getItem(this._cacheKey);\n\t\n\t        if (cachedSubscriptionData) {\n\t            try {\n\t                this.setSubscription(cachedSubscriptionData);\n\t            } catch (e) {}\n\t        } else {\n\t            this.setEventFilters(events);\n\t        }\n\t\n\t        return this;\n\t    };\n\t\n\t    return CachedSubscription;\n\t}(_Subscription3.default);\n\t\n\texports.default = CachedSubscription;\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ringcentral-bundle.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(7).Buffer))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\t(function () {\n\t  try {\n\t    cachedSetTimeout = setTimeout;\n\t  } catch (e) {\n\t    cachedSetTimeout = function () {\n\t      throw new Error('setTimeout is not defined');\n\t    }\n\t  }\n\t  try {\n\t    cachedClearTimeout = clearTimeout;\n\t  } catch (e) {\n\t    cachedClearTimeout = function () {\n\t      throw new Error('clearTimeout is not defined');\n\t    }\n\t  }\n\t} ())\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = cachedSetTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    cachedClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        cachedSetTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(8)\n\tvar ieee754 = __webpack_require__(9)\n\tvar isArray = __webpack_require__(10)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\tvar rootParent = {}\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n\t *     on objects.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\tfunction typedArraySupport () {\n\t  function Bar () {}\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.foo = function () { return 42 }\n\t    arr.constructor = Bar\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        arr.constructor === Bar && // constructor can be set\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\t/**\n\t * Class: Buffer\n\t * =============\n\t *\n\t * The Buffer constructor returns instances of `Uint8Array` that are augmented\n\t * with function properties for all the node `Buffer` API functions. We use\n\t * `Uint8Array` so that square bracket notation works as expected -- it returns\n\t * a single octet.\n\t *\n\t * By augmenting the instances, we can avoid modifying the `Uint8Array`\n\t * prototype.\n\t */\n\tfunction Buffer (arg) {\n\t  if (!(this instanceof Buffer)) {\n\t    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n\t    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n\t    return new Buffer(arg)\n\t  }\n\t\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this.length = 0\n\t    this.parent = undefined\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    return fromNumber(this, arg)\n\t  }\n\t\n\t  // Slightly less common case.\n\t  if (typeof arg === 'string') {\n\t    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n\t  }\n\t\n\t  // Unusual.\n\t  return fromObject(this, arg)\n\t}\n\t\n\tfunction fromNumber (that, length) {\n\t  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < length; i++) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\t\n\t  // Assumption: byteLength() return value is always < kMaxLength.\n\t  var length = byteLength(string, encoding) | 0\n\t  that = allocate(that, length)\n\t\n\t  that.write(string, encoding)\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, object) {\n\t  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\t\n\t  if (isArray(object)) return fromArray(that, object)\n\t\n\t  if (object == null) {\n\t    throw new TypeError('must start with number, buffer, array or string')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined') {\n\t    if (object.buffer instanceof ArrayBuffer) {\n\t      return fromTypedArray(that, object)\n\t    }\n\t    if (object instanceof ArrayBuffer) {\n\t      return fromArrayBuffer(that, object)\n\t    }\n\t  }\n\t\n\t  if (object.length) return fromArrayLike(that, object)\n\t\n\t  return fromJsonObject(that, object)\n\t}\n\t\n\tfunction fromBuffer (that, buffer) {\n\t  var length = checked(buffer.length) | 0\n\t  that = allocate(that, length)\n\t  buffer.copy(that, 0, 0, length)\n\t  return that\n\t}\n\t\n\tfunction fromArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Duplicate of fromArray() to keep fromArray() monomorphic.\n\tfunction fromTypedArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  // Truncating the elements is probably not what people expect from typed\n\t  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n\t  // of the old Buffer constructor.\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    array.byteLength\n\t    that = Buffer._augment(new Uint8Array(array))\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromTypedArray(that, new Uint8Array(array))\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n\t// Returns a zero-length buffer for inputs that don't conform to the spec.\n\tfunction fromJsonObject (that, object) {\n\t  var array\n\t  var length = 0\n\t\n\t  if (object.type === 'Buffer' && isArray(object.data)) {\n\t    array = object.data\n\t    length = checked(array.length) | 0\n\t  }\n\t  that = allocate(that, length)\n\t\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t} else {\n\t  // pre-set for values that may exist in the future\n\t  Buffer.prototype.length = undefined\n\t  Buffer.prototype.parent = undefined\n\t}\n\t\n\tfunction allocate (that, length) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = Buffer._augment(new Uint8Array(length))\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that.length = length\n\t    that._isBuffer = true\n\t  }\n\t\n\t  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n\t  if (fromPool) that.parent = rootParent\n\t\n\t  return that\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (subject, encoding) {\n\t  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\t\n\t  var buf = new Buffer(subject, encoding)\n\t  delete buf.parent\n\t  return buf\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  var i = 0\n\t  var len = Math.min(x, y)\n\t  while (i < len) {\n\t    if (a[i] !== b[i]) break\n\t\n\t    ++i\n\t  }\n\t\n\t  if (i !== len) {\n\t    x = a[i]\n\t    y = b[i]\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'raw':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\t\n\t  if (list.length === 0) {\n\t    return new Buffer(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; i++) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buf = new Buffer(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    item.copy(buf, pos)\n\t    pos += item.length\n\t  }\n\t  return buf\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (typeof string !== 'string') string = '' + string\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'binary':\n\t      // Deprecated\n\t      case 'raw':\n\t      case 'raws':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  start = start | 0\n\t  end = end === undefined || end === Infinity ? this.length : end | 0\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t  if (start < 0) start = 0\n\t  if (end > this.length) end = this.length\n\t  if (end <= start) return ''\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'binary':\n\t        return binarySlice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return 0\n\t  return Buffer.compare(this, b)\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n\t  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n\t  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n\t  byteOffset >>= 0\n\t\n\t  if (this.length === 0) return -1\n\t  if (byteOffset >= this.length) return -1\n\t\n\t  // Negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\t\n\t  if (typeof val === 'string') {\n\t    if (val.length === 0) return -1 // special case: looking for empty string always fails\n\t    return String.prototype.indexOf.call(this, val, byteOffset)\n\t  }\n\t  if (Buffer.isBuffer(val)) {\n\t    return arrayIndexOf(this, val, byteOffset)\n\t  }\n\t  if (typeof val === 'number') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n\t      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n\t    }\n\t    return arrayIndexOf(this, [ val ], byteOffset)\n\t  }\n\t\n\t  function arrayIndexOf (arr, val, byteOffset) {\n\t    var foundIndex = -1\n\t    for (var i = 0; byteOffset + i < arr.length; i++) {\n\t      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n\t      } else {\n\t        foundIndex = -1\n\t      }\n\t    }\n\t    return -1\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\t// `get` is deprecated\n\tBuffer.prototype.get = function get (offset) {\n\t  console.log('.get() is deprecated. Access using array indexes instead.')\n\t  return this.readUInt8(offset)\n\t}\n\t\n\t// `set` is deprecated\n\tBuffer.prototype.set = function set (v, offset) {\n\t  console.log('.set() is deprecated. Access using array indexes instead.')\n\t  return this.writeUInt8(v, offset)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; i++) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) throw new Error('Invalid hex string')\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction binaryWrite (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    var swap = encoding\n\t    encoding = offset\n\t    offset = length | 0\n\t    length = swap\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'binary':\n\t        return binaryWrite(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction binarySlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; i++) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = Buffer._augment(this.subarray(start, end))\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; i++) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  if (newBuf.length) newBuf.parent = this.parent || this\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t  if (offset < 0) throw new RangeError('index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; i--) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; i++) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    target._set(this.subarray(start, start + len), targetStart)\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// fill(value, start=0, end=buffer.length)\n\tBuffer.prototype.fill = function fill (value, start, end) {\n\t  if (!value) value = 0\n\t  if (!start) start = 0\n\t  if (!end) end = this.length\n\t\n\t  if (end < start) throw new RangeError('end < start')\n\t\n\t  // Fill 0 bytes; we're done\n\t  if (end === start) return\n\t  if (this.length === 0) return\n\t\n\t  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n\t  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\t\n\t  var i\n\t  if (typeof value === 'number') {\n\t    for (i = start; i < end; i++) {\n\t      this[i] = value\n\t    }\n\t  } else {\n\t    var bytes = utf8ToBytes(value.toString())\n\t    var len = bytes.length\n\t    for (i = start; i < end; i++) {\n\t      this[i] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n\t * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n\t */\n\tBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n\t  if (typeof Uint8Array !== 'undefined') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t      return (new Buffer(this)).buffer\n\t    } else {\n\t      var buf = new Uint8Array(this.length)\n\t      for (var i = 0, len = buf.length; i < len; i += 1) {\n\t        buf[i] = this[i]\n\t      }\n\t      return buf.buffer\n\t    }\n\t  } else {\n\t    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n\t  }\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar BP = Buffer.prototype\n\t\n\t/**\n\t * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n\t */\n\tBuffer._augment = function _augment (arr) {\n\t  arr.constructor = Buffer\n\t  arr._isBuffer = true\n\t\n\t  // save reference to original Uint8Array set method before overwriting\n\t  arr._set = arr.set\n\t\n\t  // deprecated\n\t  arr.get = BP.get\n\t  arr.set = BP.set\n\t\n\t  arr.write = BP.write\n\t  arr.toString = BP.toString\n\t  arr.toLocaleString = BP.toString\n\t  arr.toJSON = BP.toJSON\n\t  arr.equals = BP.equals\n\t  arr.compare = BP.compare\n\t  arr.indexOf = BP.indexOf\n\t  arr.copy = BP.copy\n\t  arr.slice = BP.slice\n\t  arr.readUIntLE = BP.readUIntLE\n\t  arr.readUIntBE = BP.readUIntBE\n\t  arr.readUInt8 = BP.readUInt8\n\t  arr.readUInt16LE = BP.readUInt16LE\n\t  arr.readUInt16BE = BP.readUInt16BE\n\t  arr.readUInt32LE = BP.readUInt32LE\n\t  arr.readUInt32BE = BP.readUInt32BE\n\t  arr.readIntLE = BP.readIntLE\n\t  arr.readIntBE = BP.readIntBE\n\t  arr.readInt8 = BP.readInt8\n\t  arr.readInt16LE = BP.readInt16LE\n\t  arr.readInt16BE = BP.readInt16BE\n\t  arr.readInt32LE = BP.readInt32LE\n\t  arr.readInt32BE = BP.readInt32BE\n\t  arr.readFloatLE = BP.readFloatLE\n\t  arr.readFloatBE = BP.readFloatBE\n\t  arr.readDoubleLE = BP.readDoubleLE\n\t  arr.readDoubleBE = BP.readDoubleBE\n\t  arr.writeUInt8 = BP.writeUInt8\n\t  arr.writeUIntLE = BP.writeUIntLE\n\t  arr.writeUIntBE = BP.writeUIntBE\n\t  arr.writeUInt16LE = BP.writeUInt16LE\n\t  arr.writeUInt16BE = BP.writeUInt16BE\n\t  arr.writeUInt32LE = BP.writeUInt32LE\n\t  arr.writeUInt32BE = BP.writeUInt32BE\n\t  arr.writeIntLE = BP.writeIntLE\n\t  arr.writeIntBE = BP.writeIntBE\n\t  arr.writeInt8 = BP.writeInt8\n\t  arr.writeInt16LE = BP.writeInt16LE\n\t  arr.writeInt16BE = BP.writeInt16BE\n\t  arr.writeInt32LE = BP.writeInt32LE\n\t  arr.writeInt32BE = BP.writeInt32BE\n\t  arr.writeFloatLE = BP.writeFloatLE\n\t  arr.writeFloatBE = BP.writeFloatBE\n\t  arr.writeDoubleLE = BP.writeDoubleLE\n\t  arr.writeDoubleBE = BP.writeDoubleBE\n\t  arr.fill = BP.fill\n\t  arr.inspect = BP.inspect\n\t  arr.toArrayBuffer = BP.toArrayBuffer\n\t\n\t  return arr\n\t}\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; i++) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; i++) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\t;(function (exports) {\n\t\t'use strict';\n\t\n\t  var Arr = (typeof Uint8Array !== 'undefined')\n\t    ? Uint8Array\n\t    : Array\n\t\n\t\tvar PLUS   = '+'.charCodeAt(0)\n\t\tvar SLASH  = '/'.charCodeAt(0)\n\t\tvar NUMBER = '0'.charCodeAt(0)\n\t\tvar LOWER  = 'a'.charCodeAt(0)\n\t\tvar UPPER  = 'A'.charCodeAt(0)\n\t\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\t\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\t\n\t\tfunction decode (elt) {\n\t\t\tvar code = elt.charCodeAt(0)\n\t\t\tif (code === PLUS ||\n\t\t\t    code === PLUS_URL_SAFE)\n\t\t\t\treturn 62 // '+'\n\t\t\tif (code === SLASH ||\n\t\t\t    code === SLASH_URL_SAFE)\n\t\t\t\treturn 63 // '/'\n\t\t\tif (code < NUMBER)\n\t\t\t\treturn -1 //no match\n\t\t\tif (code < NUMBER + 10)\n\t\t\t\treturn code - NUMBER + 26 + 26\n\t\t\tif (code < UPPER + 26)\n\t\t\t\treturn code - UPPER\n\t\t\tif (code < LOWER + 26)\n\t\t\t\treturn code - LOWER + 26\n\t\t}\n\t\n\t\tfunction b64ToByteArray (b64) {\n\t\t\tvar i, j, l, tmp, placeHolders, arr\n\t\n\t\t\tif (b64.length % 4 > 0) {\n\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t\t}\n\t\n\t\t\t// the number of equal signs (place holders)\n\t\t\t// if there are two placeholders, than the two characters before it\n\t\t\t// represent one byte\n\t\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t\t// this is just a cheap hack to not do indexOf twice\n\t\t\tvar len = b64.length\n\t\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\t\n\t\t\t// base64 is 4/3 + up to two characters of the original data\n\t\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\t\n\t\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\t\n\t\t\tvar L = 0\n\t\n\t\t\tfunction push (v) {\n\t\t\t\tarr[L++] = v\n\t\t\t}\n\t\n\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\tif (placeHolders === 2) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t} else if (placeHolders === 1) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\treturn arr\n\t\t}\n\t\n\t\tfunction uint8ToBase64 (uint8) {\n\t\t\tvar i,\n\t\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\t\toutput = \"\",\n\t\t\t\ttemp, length\n\t\n\t\t\tfunction encode (num) {\n\t\t\t\treturn lookup.charAt(num)\n\t\t\t}\n\t\n\t\t\tfunction tripletToBase64 (num) {\n\t\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t\t}\n\t\n\t\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\t\toutput += tripletToBase64(temp)\n\t\t\t}\n\t\n\t\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\t\tswitch (extraBytes) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\t\toutput += '=='\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\t\toutput += '='\n\t\t\t\t\tbreak\n\t\t\t}\n\t\n\t\t\treturn output\n\t\t}\n\t\n\t\texports.toByteArray = b64ToByteArray\n\t\texports.fromByteArray = uint8ToBase64\n\t}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar config = {\n\t    key: '8mOtYiilT5OUPwwdeGgvpw',\n\t    secret: 'cqNn89RmR2SR76Kpp8xJaAdNzNOqR8Qfmjb0B-gDOHTw',\n\t\n\t    incomingAudio: '../src/assets/audio/incoming.ogg',\n\t    outgoingAudio: '../src/assets/audio/outgoing.ogg'\n\t};\n\texports.default = config;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _rcWebphone = __webpack_require__(13);\n\t\n\tvar _rcWebphone2 = _interopRequireDefault(_rcWebphone);\n\t\n\tvar _rcConfig = __webpack_require__(11);\n\t\n\tvar _rcConfig2 = _interopRequireDefault(_rcConfig);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar PhoneService = function () {\n\t    var webPhone;\n\t    var session;\n\t    var handlers = {\n\t        invite: [],\n\t        accepted: [],\n\t        progress: [],\n\t        rejected: [],\n\t        terminated: [],\n\t        failed: [],\n\t        bye: [],\n\t        refer: []\n\t    };\n\t    function listen(session) {\n\t        session.on('accepted', function () {\n\t            handlers['accepted'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('progress', function () {\n\t            handlers['progress'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('rejected', function () {\n\t            handlers['rejected'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('terminated', function () {\n\t            handlers['terminated'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('failed', function () {\n\t            handlers['failed'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('bye', function () {\n\t            handlers['bye'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t        session.on('refer', function () {\n\t            handlers['refer'].forEach(function (handler) {\n\t                return handler(session);\n\t            });\n\t        });\n\t    }\n\t    return {\n\t        init: function init(options) {\n\t            return _rcSdk.RC.sdk.platform().post('/client-info/sip-provision', {\n\t                sipInfo: [{\n\t                    transport: 'WSS'\n\t                }]\n\t            }).then(function (res) {\n\t                return new _rcWebphone2.default(res.json(), { // optional\n\t                    appKey: _rcConfig2.default.key,\n\t                    logLevel: 1,\n\t                    audioHelper: {\n\t                        enabled: true, // enables audio feedback when web phone is ringing or making a call\n\t                        incoming: options.incomingAudio, // path to audio file for incoming call\n\t                        outgoing: options.outgoingAudio // path to aduotfile for outgoing call\n\t                    }\n\t                });\n\t            }).then(function (p) {\n\t                webPhone = p;\n\t                console.log(webPhone);\n\t                webPhone.userAgent.on('invite', function (s) {\n\t                    session = s;\n\t                    handlers['invite'].forEach(function (handler) {\n\t                        return handler(session);\n\t                    });\n\t                    listen(session);\n\t                });\n\t            }).catch(function (e) {\n\t                return console.error(e);\n\t            });\n\t        },\n\t        on: function on(name, callback) {\n\t            handlers[name].push(callback);\n\t        },\n\t        call: function call(fromNumber, toNumber, options) {\n\t            console.log(webPhone);\n\t            session = webPhone.userAgent.invite(toNumber, {\n\t                media: {\n\t                    render: {\n\t                        remote: options.remoteVideo,\n\t                        local: options.localVideo\n\t                    }\n\t                },\n\t                fromNumber: fromNumber\n\t            });\n\t            listen(session);\n\t        },\n\t        accept: function accept(options) {\n\t            console.log(session);\n\t            if (session.accept && !session.startTime) return session.accept({\n\t                media: {\n\t                    render: {\n\t                        remote: options.remoteVideo,\n\t                        local: options.localVideo\n\t                    }\n\t                }\n\t            });\n\t            return null;\n\t        },\n\t        reject: function reject() {\n\t            return session.reject();\n\t        },\n\t        hangup: function hangup() {\n\t            return session.bye();\n\t        },\n\t        hold: function hold(flag) {\n\t            if (flag) {\n\t                return session.hold().then(function () {\n\t                    return session;\n\t                });\n\t            }\n\t            return session.unhold().then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        mute: function mute(flag) {\n\t            if (flag) session.mute();else session.unmute();\n\t            return session;\n\t        },\n\t        flip: function flip(number) {\n\t            return session.flip(number).then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        forward: function forward(number) {\n\t            return session.forward(number).then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        transfer: function transfer(number) {\n\t            return session.transfer(number).then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        park: function park() {\n\t            return session.park().then(function () {\n\t                return session;\n\t            });\n\t        },\n\t        dtmf: function dtmf(number) {\n\t            return session.dtmf(number);\n\t        },\n\t        record: function record(flag) {\n\t            if (flag) {\n\t                return session.startRecord().then(function () {\n\t                    return session;\n\t                });\n\t            } else {\n\t                return session.stopRecord().then(function () {\n\t                    return session;\n\t                });\n\t            }\n\t        }\n\t    };\n\t}();\n\texports.default = PhoneService;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _ringcentralWebPhone = __webpack_require__(14);\n\t\n\tvar _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _ringcentralWebPhone2.default;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {\n\t            return factory(SIP);\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module === 'object') {\n\t        module.exports = factory(require('sip.js'));\n\t        module.exports.default = module.exports; //ES6\n\t    } else {\n\t        root.RingCentral = root.RingCentral || {};\n\t        root.RingCentral.WebPhone = factory(root.SIP);\n\t    }\n\t}(this, function(SIP) {\n\t\n\t    var messages = {\n\t        park: {reqid: 1, command: 'callpark'},\n\t        startRecord: {reqid: 2, command: 'startcallrecord'},\n\t        stopRecord: {reqid: 3, command: 'stopcallrecord'},\n\t        flip: {reqid: 3, command: 'callflip', target: ''},\n\t        monitor: {reqid: 4, command: 'monitor'},\n\t        barge: {reqid: 5, command: 'barge'},\n\t        whisper: {reqid: 6, command: 'whisper'},\n\t        takeover: {reqid: 7, command: 'takeover'}\n\t    };\n\t\n\t    var responseTimeout = 10000;\n\t\n\t    function uuid() {\n\t        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t            return v.toString(16);\n\t        });\n\t    }\n\t\n\t    function delay(ms) {\n\t        return new Promise(function(resolve, reject) {\n\t            setTimeout(resolve, ms);\n\t        });\n\t    }\n\t\n\t    function extend(dst, src) {\n\t        src = src || {};\n\t        dst = dst || {};\n\t        Object.keys(src).forEach(function(k) {\n\t            dst[k] = src[k];\n\t        });\n\t        return dst;\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @param options\n\t     * @constructor\n\t     */\n\t    function AudioHelper(options) {\n\t\n\t        options = options || {};\n\t\n\t        this._enabled = !!options.enabled;\n\t        this._incoming = options.incoming || '../audio/incoming.ogg';\n\t        this._outgoing = options.outgoing || '../audio/outgoing.ogg';\n\t        this._audio = {};\n\t\n\t    }\n\t\n\t    AudioHelper.prototype._playSound = function(url, val, volume) {\n\t\n\t        if (!this._enabled) return this;\n\t\n\t        if (!this._audio[url]) {\n\t            if (val) {\n\t                this._audio[url] = new Audio();\n\t                this._audio[url].src = url;\n\t                this._audio[url].loop = true;\n\t                this._audio[url].volume = volume;\n\t                this._audio[url].play();\n\t            }\n\t        } else {\n\t            if (val) {\n\t                this._audio[url].currentTime = 0;\n\t                this._audio[url].play();\n\t            } else {\n\t                this._audio[url].pause();\n\t            }\n\t        }\n\t\n\t        return this;\n\t\n\t    };\n\t\n\t    AudioHelper.prototype.playIncoming = function(val) {\n\t        return this._playSound(this._incoming, val, 0.5);\n\t    };\n\t\n\t    AudioHelper.prototype.playOutgoing = function(val) {\n\t        return this._playSound(this._outgoing, val, 1);\n\t    };\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @param {object} regData\n\t     * @param {object} [options]\n\t     * @param {string} [options.uuid]\n\t     * @param {string} [options.appKey]\n\t     * @param {string} [options.appName]\n\t     * @param {string} [options.appVersion]\n\t     * @param {string} [options.audioHelper]\n\t     * @param {string} [options.onSession] fired each time UserAgent starts working with session\n\t     * @constructor\n\t     */\n\t    function WebPhone(regData, options) {\n\t\n\t        regData = regData || {};\n\t        options = options || {};\n\t\n\t        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;\n\t        this.sipFlags = regData.sipFlags;\n\t\n\t        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable\n\t        localStorage.setItem('rc-webPhone-uuid', id);\n\t\n\t        this.endpointHeader = 'P-rc-endpoint-id: ' + id;\n\t\n\t        var configuration = {\n\t            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,\n\t            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport\n\t                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy\n\t                : this.sipInfo.wsServers,\n\t            authorizationUser: this.sipInfo.authorizationId,\n\t            password: this.sipInfo.password,\n\t            traceSip: true,\n\t            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?\n\t            turnServers: [],\n\t            log: {\n\t                level: options.logLevel || 1 //FIXME LOG LEVEL 3\n\t            },\n\t            domain: this.sipInfo.domain,\n\t            autostart: true,\n\t            register: true,\n\t            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000\n\t        };\n\t\n\t        this.appKey = options.appKey;\n\t        this.appName = options.appName;\n\t        this.appVersion = options.appVersion;\n\t        this.userAgentHeader = 'RC-User-Agent: ' +\n\t                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +\n\t                               'RCWEBPHONE/' + WebPhone.version;\n\t\n\t        this.clientIdHeader = 'Client-id:' + options.appKey;\n\t\n\t        this.userAgent = new SIP.UA(configuration).register({\n\t            extraHeaders: [\n\t                this.endpointHeader,\n\t                this.userAgentHeader,\n\t                this.clientIdHeader\n\t            ]\n\t        });\n\t\n\t        this.userAgent.endpointHeader = this.endpointHeader;\n\t        this.userAgent.userAgentHeader = this.userAgentHeader;\n\t        this.userAgent.clientIdHeader = this.clientIdHeader;\n\t        this.userAgent.sipInfo = this.sipInfo;\n\t\n\t        this.userAgent.__invite = this.userAgent.invite;\n\t        this.userAgent.invite = invite;\n\t\n\t        this.userAgent.on('invite', function(session) {\n\t            this.userAgent.audioHelper.playIncoming(true);\n\t            patchSession(session);\n\t        }.bind(this));\n\t\n\t        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);\n\t\n\t        this.userAgent.onSession = options.onSession || null;\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    WebPhone.version = '0.3.1';\n\t    WebPhone.uuid = uuid;\n\t    WebPhone.delay = delay;\n\t    WebPhone.extend = extend;\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    function patchSession(session) {\n\t\n\t        if (session.__patched) return session;\n\t\n\t        session.__patched = true;\n\t\n\t        session.__sendRequest = session.sendRequest;\n\t        session.__receiveRequest = session.receiveRequest;\n\t        session.__receiveInviteResponse = session.receiveInviteResponse;\n\t        session.__receiveResponse = session.receiveResponse;\n\t        session.__accept = session.accept;\n\t        session.__hold = session.hold;\n\t        session.__unhold = session.unhold;\n\t        session.__dtmf = session.dtmf;\n\t\n\t        session.sendRequest = sendRequest;\n\t        session.receiveRequest = receiveRequest;\n\t        session.receiveInviteResponse = receiveInviteResponse;\n\t        session.receiveResponse = receiveResponse;\n\t        session.accept = accept;\n\t        session.hold = hold;\n\t        session.unhold = unhold;\n\t        session.dtmf = dtmf;\n\t\n\t        session.blindTransfer = blindTransfer;\n\t        session.transfer = transfer;\n\t        session.park = park;\n\t        session.forward = forward;\n\t        session.startRecord = startRecord;\n\t        session.stopRecord = stopRecord;\n\t        session.flip = flip;\n\t\n\t        session.on('replaced', patchSession);\n\t        // session.on('connecting', onConnecting);\n\t\n\t        // Audio\n\t        session.on('accepted', stopPlaying);\n\t        session.on('rejected', stopPlaying);\n\t        session.on('bye', stopPlaying);\n\t        session.on('terminated', stopPlaying);\n\t        session.on('cancel', stopPlaying);\n\t        session.on('failed', stopPlaying);\n\t        session.on('replaced', stopPlaying);\n\t        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);\n\t        session.mediaHandler.on('iceConnectionFailed', stopPlaying);\n\t\n\t        function stopPlaying() {\n\t            session.ua.audioHelper.playOutgoing(false);\n\t            session.ua.audioHelper.playIncoming(false);\n\t            session.removeListener('accepted', stopPlaying);\n\t            session.removeListener('rejected', stopPlaying);\n\t            session.removeListener('bye', stopPlaying);\n\t            session.removeListener('terminated', stopPlaying);\n\t            session.removeListener('cancel', stopPlaying);\n\t            session.removeListener('failed', stopPlaying);\n\t            session.removeListener('replaced', stopPlaying);\n\t            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);\n\t            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);\n\t        }\n\t\n\t        if (session.ua.onSession) session.ua.onSession(session);\n\t\n\t        return session;\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @private\n\t     * @param {SIP.Session} session\n\t     * @param {object} command\n\t     * @param {object} [options]\n\t     * @return {Promise}\n\t     */\n\t    function sendReceive(session, command, options) {\n\t\n\t        options = options || {};\n\t\n\t        extend(command, options);\n\t\n\t        var cseq = null;\n\t\n\t        return new Promise(function(resolve, reject) {\n\t\n\t            session.sendRequest(SIP.C.INFO, {\n\t                body: JSON.stringify({\n\t                    request: command\n\t                }),\n\t                extraHeaders: [\n\t                    \"Content-Type: application/json;charset=utf-8\",\n\t                    session.ua.userAgentHeader,\n\t                    session.ua.endpointHeader,\n\t                    session.ua.clientIdHeader\n\t                ],\n\t                receiveResponse: function(response) {\n\t                    var timeout = null;\n\t                    if (response.status_code === 200) {\n\t                        cseq = response.cseq;\n\t                        var onInfo = function(request) {\n\t                            if (response.cseq === cseq) {\n\t\n\t                                var body = request && request.body || '{}';\n\t                                var obj;\n\t\n\t                                try {\n\t                                    obj = JSON.parse(body);\n\t                                } catch (e) {\n\t                                    obj = {};\n\t                                }\n\t\n\t                                if (obj.response && obj.response.command === command.command) {\n\t                                    if (obj.response.result) {\n\t                                        if (obj.response.result.code == 0) {\n\t                                            return resolve(obj.response.result);\n\t                                        } else {\n\t                                            return reject(obj.response.result);\n\t                                        }\n\t                                    }\n\t                                }\n\t                                timeout && clearTimeout(timeout);\n\t                                session.removeListener('RC_SIP_INFO', onInfo);\n\t                                resolve(null); //FIXME What to resolve\n\t                            }\n\t                        };\n\t\n\t                        timeout = setTimeout(function() {\n\t                            reject(new Error('Timeout: no reply'));\n\t                            session.removeListener('RC_SIP_INFO', onInfo);\n\t                        }, responseTimeout);\n\t                        session.on('RC_SIP_INFO', onInfo);\n\t                    }\n\t                    else {\n\t                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));\n\t                    }\n\t                }\n\t            });\n\t\n\t        });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    function sendRequest(type, config) {\n\t        if (type == SIP.C.PRACK) {\n\t            type = SIP.C.ACK;\n\t        }\n\t        return this.__sendRequest(type, config);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Fired each time a provisional (100-199) response is received.\n\t     * Early media is supported by SIP.js library\n\t     * But in case it is sent without 100rel support we play it manually\n\t     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n\t     *\n\t     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n\t     * @param {SIP.Session} session\n\t     * @param response\n\t     * @param {funciton} cb\n\t     */\n\t    function patch100rel(session, response, cb) {\n\t\n\t        //Early media is supported by SIP.js library\n\t        //But in case it is sent without 100rel support we play it manually\n\t        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n\t        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\\n') !== -1) {\n\t            if (!response.hasHeader('require')) response.setHeader('require', '100rel');\n\t        }\n\t\n\t        return cb.call(session, response);\n\t\n\t    }\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param response\n\t     * @return {*}\n\t     */\n\t    function receiveInviteResponse(response) {\n\t        return patch100rel(this, response, this.__receiveInviteResponse);\n\t    }\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param response\n\t     * @return {*}\n\t     */\n\t    function receiveResponse(response) {\n\t        return patch100rel(this, response, this.__receiveResponse);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @private\n\t     * @param {SIP.Session} session\n\t     * @param {boolean} flag\n\t     * @return {Promise}\n\t     */\n\t    function setRecord(session, flag) {\n\t\n\t        var message = !!flag\n\t            ? messages.startRecord\n\t            : messages.stopRecord;\n\t\n\t        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {\n\t            return sendReceive(session, message)\n\t                .then(function(data) {\n\t                    session.__onRecord = !!flag;\n\t                    return data;\n\t                });\n\t        }\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @private\n\t     * @param {SIP.Session} session\n\t     * @param {boolean} flag\n\t     * @return {Promise}\n\t     */\n\t    function setHold(session, flag) {\n\t        return new Promise(function(resolve, reject) {\n\t\n\t            var options = {\n\t                eventHandlers: {\n\t                    succeeded: resolve,\n\t                    failed: reject\n\t                }\n\t            };\n\t\n\t            if (flag) {\n\t                session.__hold(options);\n\t            } else {\n\t                session.__unhold(options);\n\t            }\n\t\n\t        });\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.UA}\n\t     * @param number\n\t     * @param options\n\t     * @return {SIP.Session}\n\t     */\n\t    function invite(number, options) {\n\t\n\t        var ua = this;\n\t\n\t        options = options || {};\n\t        options.extraHeaders = options.extraHeaders || [];\n\t\n\t        options.extraHeaders.push(ua.userAgentHeader);\n\t        options.extraHeaders.push(ua.endpointHeader);\n\t        options.extraHeaders.push(ua.clientIdHeader);\n\t\n\t        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number\n\t\n\t        //FIXME Backend should know it already\n\t        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }\n\t\n\t        options.media = options.media || {};\n\t        options.media.constraints = options.media.constraints || {audio: true, video: false};\n\t\n\t        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n\t\n\t        ua.audioHelper.playOutgoing(true);\n\t\n\t        return patchSession(ua.__invite(number, options));\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param request\n\t     * @return {*}\n\t     */\n\t    function receiveRequest(request) {\n\t        var session = this;\n\t        switch (request.method) {\n\t            case SIP.C.INFO:\n\t                session.emit('RC_SIP_INFO', request);\n\t                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case\n\t                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n\t                    var contentType = request.getHeader('content-type');\n\t                    if (contentType.match(/^application\\/json/i)) {\n\t                        request.reply(200);\n\t                        return session;\n\t                    }\n\t                }\n\t                break;\n\t            //Refresh invite should not be rejected with 488\n\t            case SIP.C.INVITE:\n\t                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {\n\t                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {\n\t                        //TODO: check that SDP did not change\n\t                        session.logger.log('re-INVITE received');\n\t                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;\n\t                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {\n\t                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;\n\t                            session.setInvite2xxTimer(request, localSDP);\n\t                            session.setACKTimer();\n\t                        });\n\t                        return session;\n\t                    }\n\t                    //else will be rejected with 488 by SIP.js\n\t                }\n\t                break;\n\t            //We need to analize NOTIFY messages sometimes, so we fire an event\n\t            case SIP.C.NOTIFY:\n\t                session.emit('RC_SIP_NOTIFY', request);\n\t                break;\n\t        }\n\t        return session.__receiveRequest.apply(session, arguments);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param {object} options\n\t     * @return {Promise}\n\t     */\n\t    function accept(options) {\n\t\n\t        var session = this;\n\t\n\t        options = options || {};\n\t        options.extraHeaders = options.extraHeaders || [];\n\t\n\t        options.extraHeaders.push(session.ua.userAgentHeader);\n\t        options.extraHeaders.push(session.ua.endpointHeader);\n\t        options.extraHeaders.push(session.ua.clientIdHeader);\n\t\n\t        options.media = options.media || {};\n\t        options.media.constraints = options.media.constraints || {audio: true, video: false};\n\t\n\t        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n\t\n\t        return new Promise(function(resolve, reject) {\n\t\n\t            function onAnswered() {\n\t                resolve(session);\n\t                session.removeListener('failed', onFail);\n\t            }\n\t\n\t            function onFail(e) {\n\t                reject(e);\n\t                session.removeListener('accepted', onAnswered);\n\t            }\n\t\n\t            //TODO More events?\n\t            session.once('accepted', onAnswered);\n\t            session.once('failed', onFail);\n\t\n\t            session.__accept(options);\n\t\n\t        });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @param {string} dtmf\n\t     * @param {number} duration\n\t     * @return {Promise}\n\t     */\n\t    function dtmf(dtmf, duration) {\n\t        var session = this;\n\t        duration = parseInt(duration) || 1000;\n\t        var peer = session.mediaHandler.peerConnection;\n\t        var stream = session.getLocalStreams()[0];\n\t        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);\n\t        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {\n\t            return dtmfSender.insertDTMF(dtmf, duration);\n\t        }\n\t        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\\'t insert DTMF' : 'Unknown')));\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @return {Promise}\n\t     */\n\t    function hold() {\n\t        return setHold(this, true);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @return {Promise}\n\t     */\n\t    function unhold() {\n\t        return setHold(this, false);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session} session\n\t     * @param {string} target\n\t     * @param {object} options\n\t     * @return {Promise}\n\t     */\n\t    function blindTransfer(target, options) {\n\t\n\t        options = options || {};\n\t\n\t        var session = this;\n\t        var extraHeaders = options.extraHeaders || [];\n\t        var originalTarget = target;\n\t\n\t        return new Promise(function(resolve, reject) {\n\t            //Blind Transfer is taken from SIP.js source\n\t\n\t            // Check Session Status\n\t            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {\n\t                throw new SIP.Exceptions.InvalidStateError(session.status);\n\t            }\n\t\n\t            // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n\t            // so try to make one ahead of time\n\t            try {\n\t                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n\t            } catch (e) {\n\t                session.logger.debug(\".refer() cannot parse Refer_To from\", target);\n\t                session.logger.debug(\"...falling through to normalizeTarget()\");\n\t            }\n\t\n\t            // Check target validity\n\t            target = session.ua.normalizeTarget(target);\n\t            if (!target) {\n\t                throw new TypeError('Invalid target: ' + originalTarget);\n\t            }\n\t\n\t            extraHeaders.push('Contact: ' + session.contact);\n\t            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n\t            extraHeaders.push('Refer-To: ' + target);\n\t            extraHeaders.push(session.ua.userAgentHeader);\n\t            extraHeaders.push(session.ua.endpointHeader);\n\t            extraHeaders.push(session.ua.clientIdHeader);\n\t\n\t            // Send the request\n\t            session.sendRequest(SIP.C.REFER, {\n\t                extraHeaders: extraHeaders,\n\t                body: options.body,\n\t                receiveResponse: function(response) {\n\t                    var timeout = null;\n\t                    if (response.status_code === 202) {\n\t                        var callId = response.call_id;\n\t\n\t                        var onNotify = function(request) {\n\t                            if (request.call_id === callId) {\n\t                                var body = request && request.body || '';\n\t                                switch (true) {\n\t                                    case /1[0-9]{2}/.test(body):\n\t                                        request.reply(200);\n\t                                        break;\n\t                                    case /2[0-9]{2}/.test(body):\n\t                                        session.terminate();\n\t                                        clearTimeout(timeout);\n\t                                        session.removeListener('RC_SIP_NOTIFY', onNotify);\n\t                                        resolve();\n\t                                        break;\n\t                                    default:\n\t                                        reject(body);\n\t                                        break;\n\t                                }\n\t                            }\n\t                        };\n\t\n\t                        timeout = setTimeout(function() {\n\t                            reject(new Error('Timeout: no reply'));\n\t                            session.removeListener('RC_SIP_NOTIFY', onNotify);\n\t                        }, responseTimeout);\n\t                        session.on('RC_SIP_NOTIFY', onNotify);\n\t                    }\n\t                    else {\n\t                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));\n\t                    }\n\t                }\n\t            });\n\t\n\t        });\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param {string} target\n\t     * @param {object} options\n\t     * @return {Promise}\n\t     */\n\t    function transfer(target, options) {\n\t\n\t        var session = this;\n\t\n\t        return (session.isOnHold() ? Promise.resolve(null) : session.hold())\n\t            .then(function() { return delay(300); })\n\t            .then(function() {\n\t                return session.blindTransfer(target, options);\n\t            });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param {string} target\n\t     * @param {object} acceptOptions\n\t     * @param {object} [transferOptions]\n\t     * @return {Promise}\n\t     */\n\t    function forward(target, acceptOptions, transferOptions) {\n\t\n\t        var interval = null,\n\t            session = this;\n\t\n\t        return session.accept(acceptOptions)\n\t            .then(function() {\n\t\n\t                return new Promise(function(resolve, reject) {\n\t                    interval = setInterval(function() {\n\t                        if (session.status === 12) {\n\t                            clearInterval(interval);\n\t                            session.mute();\n\t                            setTimeout(function() {\n\t                                resolve(session.transfer(target, transferOptions));\n\t                            }, 700);\n\t                        }\n\t                    }, 50);\n\t                });\n\t\n\t            });\n\t\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @return {Promise}\n\t     */\n\t    function startRecord() {\n\t        return setRecord(this, true);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @return {Promise}\n\t     */\n\t    function stopRecord() {\n\t        return setRecord(this, false);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @param target\n\t     * @return {Promise}\n\t     */\n\t    function flip(target) {\n\t        return sendReceive(this, messages.flip, {target: target});\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * @this {SIP.Session}\n\t     * @return {Promise}\n\t     */\n\t    function park() {\n\t        return sendReceive(this, messages.park);\n\t    }\n\t\n\t    /*--------------------------------------------------------------------------------------------------------------------*/\n\t\n\t    return WebPhone;\n\t\n\t}));\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tmodule.exports = __webpack_require__(16)(__webpack_require__(49));\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @name SIP\n\t * @namespace\n\t */\n\t\"use strict\";\n\t\n\tmodule.exports = function (environment) {\n\t\n\tvar pkg = __webpack_require__(17);\n\t\n\tvar SIP = Object.defineProperties({}, {\n\t  version: {\n\t    get: function(){ return pkg.version; }\n\t  },\n\t  name: {\n\t    get: function(){ return pkg.title; }\n\t  }\n\t});\n\t\n\t__webpack_require__(18)(SIP, environment);\n\tSIP.LoggerFactory = __webpack_require__(19)(environment.console);\n\tSIP.EventEmitter = __webpack_require__(20)(environment.console);\n\tSIP.C = __webpack_require__(22)(SIP.name, SIP.version);\n\tSIP.Exceptions = __webpack_require__(23);\n\tSIP.Timers = __webpack_require__(24)(environment.timers);\n\tSIP.Transport = environment.Transport(SIP, environment.WebSocket);\n\t__webpack_require__(25)(SIP);\n\t__webpack_require__(26)(SIP);\n\t__webpack_require__(27)(SIP);\n\t__webpack_require__(28)(SIP);\n\t__webpack_require__(29)(SIP);\n\t__webpack_require__(30)(SIP);\n\t__webpack_require__(32)(SIP);\n\t__webpack_require__(33)(SIP);\n\tSIP.MediaHandler = __webpack_require__(34)(SIP.EventEmitter);\n\t__webpack_require__(35)(SIP);\n\t__webpack_require__(36)(SIP);\n\t__webpack_require__(37)(SIP, environment);\n\t__webpack_require__(39)(SIP);\n\tSIP.WebRTC = __webpack_require__(40)(SIP, environment);\n\t__webpack_require__(43)(SIP, environment);\n\tSIP.Hacks = __webpack_require__(44)(SIP);\n\t__webpack_require__(45)(SIP);\n\tSIP.DigestAuthentication = __webpack_require__(46)(SIP.Utils);\n\tSIP.Grammar = __webpack_require__(47)(SIP);\n\t\n\treturn SIP;\n\t};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"_args\": [\n\t\t\t[\n\t\t\t\t\"sip.js@0.7.5\",\n\t\t\t\t\"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\"\n\t\t\t]\n\t\t],\n\t\t\"_from\": \"sip.js@0.7.5\",\n\t\t\"_id\": \"sip.js@0.7.5\",\n\t\t\"_inCache\": true,\n\t\t\"_installable\": true,\n\t\t\"_location\": \"/sip.js\",\n\t\t\"_nodeVersion\": \"4.4.3\",\n\t\t\"_npmOperationalInternal\": {\n\t\t\t\"host\": \"packages-12-west.internal.npmjs.com\",\n\t\t\t\"tmp\": \"tmp/sip.js-0.7.5.tgz_1461594418690_0.5839933124370873\"\n\t\t},\n\t\t\"_npmUser\": {\n\t\t\t\"email\": \"1212jtraceur@gmail.com\",\n\t\t\t\"name\": \"josephfrazier\"\n\t\t},\n\t\t\"_npmVersion\": \"2.15.1\",\n\t\t\"_phantomChildren\": {},\n\t\t\"_requested\": {\n\t\t\t\"name\": \"sip.js\",\n\t\t\t\"raw\": \"sip.js@0.7.5\",\n\t\t\t\"rawSpec\": \"0.7.5\",\n\t\t\t\"scope\": null,\n\t\t\t\"spec\": \"0.7.5\",\n\t\t\t\"type\": \"version\"\n\t\t},\n\t\t\"_requiredBy\": [\n\t\t\t\"/ringcentral-web-phone\"\n\t\t],\n\t\t\"_resolved\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz\",\n\t\t\"_shasum\": \"86ace7051594f91b4551bdb8120a16c44962d3a2\",\n\t\t\"_shrinkwrap\": null,\n\t\t\"_spec\": \"sip.js@0.7.5\",\n\t\t\"_where\": \"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\",\n\t\t\"author\": {\n\t\t\t\"email\": \"developer@onsip.com\",\n\t\t\t\"name\": \"OnSIP\",\n\t\t\t\"url\": \"http://sipjs.com/authors/\"\n\t\t},\n\t\t\"browser\": {\n\t\t\t\"./src/environment.js\": \"./src/environment_browser.js\"\n\t\t},\n\t\t\"bugs\": {\n\t\t\t\"url\": \"https://github.com/onsip/SIP.js/issues\"\n\t\t},\n\t\t\"contributors\": [\n\t\t\t{\n\t\t\t\t\"url\": \"https://github.com/onsip/SIP.js/blob/master/THANKS.md\"\n\t\t\t}\n\t\t],\n\t\t\"dependencies\": {\n\t\t\t\"promiscuous\": \"^0.6.0\",\n\t\t\t\"ws\": \"^0.6.4\"\n\t\t},\n\t\t\"description\": \"A simple, intuitive, and powerful JavaScript signaling library\",\n\t\t\"devDependencies\": {\n\t\t\t\"beefy\": \"^2.1.5\",\n\t\t\t\"browserify\": \"^4.1.8\",\n\t\t\t\"grunt\": \"~0.4.0\",\n\t\t\t\"grunt-browserify\": \"^4.0.1\",\n\t\t\t\"grunt-cli\": \"~0.1.6\",\n\t\t\t\"grunt-contrib-copy\": \"^0.5.0\",\n\t\t\t\"grunt-contrib-jasmine\": \"^0.9.2\",\n\t\t\t\"grunt-contrib-jshint\": \">0.5.0\",\n\t\t\t\"grunt-contrib-uglify\": \"~0.2.0\",\n\t\t\t\"grunt-peg\": \"~1.3.1\",\n\t\t\t\"grunt-trimtrailingspaces\": \"^0.4.0\",\n\t\t\t\"pegjs\": \"^0.8.0\"\n\t\t},\n\t\t\"directories\": {},\n\t\t\"dist\": {\n\t\t\t\"shasum\": \"86ace7051594f91b4551bdb8120a16c44962d3a2\",\n\t\t\t\"tarball\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz\"\n\t\t},\n\t\t\"engines\": {\n\t\t\t\"node\": \">=0.8\"\n\t\t},\n\t\t\"gitHead\": \"bae44bd0359f4d70ded309a32361f04a04e78d6e\",\n\t\t\"homepage\": \"http://sipjs.com\",\n\t\t\"keywords\": [\n\t\t\t\"sip\",\n\t\t\t\"websocket\",\n\t\t\t\"webrtc\",\n\t\t\t\"library\",\n\t\t\t\"javascript\"\n\t\t],\n\t\t\"license\": \"MIT\",\n\t\t\"main\": \"src/index.js\",\n\t\t\"maintainers\": [\n\t\t\t{\n\t\t\t\t\"email\": \"eric.green@onsip.com\",\n\t\t\t\t\"name\": \"egreen_onsip\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"email\": \"james@onsip.com\",\n\t\t\t\t\"name\": \"james-criscuolo\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"email\": \"1212jtraceur@gmail.com\",\n\t\t\t\t\"name\": \"josephfrazier\"\n\t\t\t}\n\t\t],\n\t\t\"name\": \"sip.js\",\n\t\t\"optionalDependencies\": {\n\t\t\t\"promiscuous\": \"^0.6.0\"\n\t\t},\n\t\t\"readme\": \"ERROR: No README data found!\",\n\t\t\"repository\": {\n\t\t\t\"type\": \"git\",\n\t\t\t\"url\": \"git+https://github.com/onsip/SIP.js.git\"\n\t\t},\n\t\t\"scripts\": {\n\t\t\t\"build\": \"grunt build\",\n\t\t\t\"prepublish\": \"cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js\",\n\t\t\t\"repl\": \"beefy test/repl.js --open\",\n\t\t\t\"test\": \"grunt travis --verbose\"\n\t\t},\n\t\t\"title\": \"SIP.js\",\n\t\t\"version\": \"0.7.5\"\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Utils\n\t */\n\t\n\tmodule.exports = function (SIP, environment) {\n\tvar Utils;\n\t\n\tUtils= {\n\t\n\t  Promise: environment.Promise,\n\t\n\t  defer: function defer () {\n\t    var deferred = {};\n\t    deferred.promise = new Utils.Promise(function (resolve, reject) {\n\t      deferred.resolve = resolve;\n\t      deferred.reject = reject;\n\t    });\n\t    return deferred;\n\t  },\n\t\n\t  promisify: function promisify (object, methodName, callbacksFirst) {\n\t    var oldMethod = object[methodName];\n\t    return function promisifiedMethod (arg, onSuccess, onFailure) {\n\t      return new Utils.Promise(function (resolve, reject) {\n\t        var oldArgs = [arg, resolve, reject];\n\t        if (callbacksFirst) {\n\t          oldArgs = [resolve, reject, arg];\n\t        }\n\t        oldMethod.apply(object, oldArgs);\n\t      }).then(onSuccess, onFailure);\n\t    };\n\t  },\n\t\n\t  augment: function (object, constructor, args, override) {\n\t    var idx, proto;\n\t\n\t    // Add public properties from constructor's prototype onto object\n\t    proto = constructor.prototype;\n\t    for (idx in proto) {\n\t      if (override || object[idx] === undefined) {\n\t        object[idx] = proto[idx];\n\t      }\n\t    }\n\t\n\t    // Construct the object as though it were just created by constructor\n\t    constructor.apply(object, args);\n\t  },\n\t\n\t  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {\n\t    if (isDeprecated && options[loser]) {\n\t      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n\t    }\n\t\n\t    if (options[winner] && options[loser]) {\n\t      logger.warn(winner + ' overriding ' + loser);\n\t    }\n\t\n\t    options[winner] = options[winner] || options[loser] || defaultValue;\n\t  },\n\t\n\t  str_utf8_length: function(string) {\n\t    return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n\t  },\n\t\n\t  generateFakeSDP: function(body) {\n\t    if (!body) {\n\t      return;\n\t    }\n\t\n\t    var start = body.indexOf('o=');\n\t    var end = body.indexOf('\\r\\n', start);\n\t\n\t    return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n\t  },\n\t\n\t  isFunction: function(fn) {\n\t    if (fn !== undefined) {\n\t      return Object.prototype.toString.call(fn) === '[object Function]';\n\t    } else {\n\t      return false;\n\t    }\n\t  },\n\t\n\t  isDecimal: function (num) {\n\t    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));\n\t  },\n\t\n\t  createRandomToken: function(size, base) {\n\t    var i, r,\n\t      token = '';\n\t\n\t    base = base || 32;\n\t\n\t    for( i=0; i < size; i++ ) {\n\t      r = Math.random() * base|0;\n\t      token += r.toString(base);\n\t    }\n\t\n\t    return token;\n\t  },\n\t\n\t  newTag: function() {\n\t    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n\t  },\n\t\n\t  // http://stackoverflow.com/users/109538/broofa\n\t  newUUID: function() {\n\t    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n\t      return v.toString(16);\n\t    });\n\t\n\t    return UUID;\n\t  },\n\t\n\t  hostType: function(host) {\n\t    if (!host) {\n\t      return;\n\t    } else {\n\t      host = SIP.Grammar.parse(host,'host');\n\t      if (host !== -1) {\n\t        return host.host_type;\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Normalize SIP URI.\n\t  * NOTE: It does not allow a SIP URI without username.\n\t  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n\t  * Detects the domain part (if given) and properly hex-escapes the user portion.\n\t  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n\t  * @private\n\t  * @param {String} target\n\t  * @param {String} [domain]\n\t  */\n\t  normalizeTarget: function(target, domain) {\n\t    var uri, target_array, target_user, target_domain;\n\t\n\t    // If no target is given then raise an error.\n\t    if (!target) {\n\t      return;\n\t    // If a SIP.URI instance is given then return it.\n\t    } else if (target instanceof SIP.URI) {\n\t      return target;\n\t\n\t    // If a string is given split it by '@':\n\t    // - Last fragment is the desired domain.\n\t    // - Otherwise append the given domain argument.\n\t    } else if (typeof target === 'string') {\n\t      target_array = target.split('@');\n\t\n\t      switch(target_array.length) {\n\t        case 1:\n\t          if (!domain) {\n\t            return;\n\t          }\n\t          target_user = target;\n\t          target_domain = domain;\n\t          break;\n\t        case 2:\n\t          target_user = target_array[0];\n\t          target_domain = target_array[1];\n\t          break;\n\t        default:\n\t          target_user = target_array.slice(0, target_array.length-1).join('@');\n\t          target_domain = target_array[target_array.length-1];\n\t      }\n\t\n\t      // Remove the URI scheme (if present).\n\t      target_user = target_user.replace(/^(sips?|tel):/i, '');\n\t\n\t      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n\t      if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n\t        target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n\t      }\n\t\n\t      // Build the complete SIP URI.\n\t      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;\n\t\n\t      // Finally parse the resulting URI.\n\t      if (uri = SIP.URI.parse(target)) {\n\t        return uri;\n\t      } else {\n\t        return;\n\t      }\n\t    } else {\n\t      return;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Hex-escape a SIP URI user.\n\t  * @private\n\t  * @param {String} user\n\t  */\n\t  escapeUser: function(user) {\n\t    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n\t    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n\t  },\n\t\n\t  headerize: function(string) {\n\t    var exceptions = {\n\t      'Call-Id': 'Call-ID',\n\t      'Cseq': 'CSeq',\n\t      'Min-Se': 'Min-SE',\n\t      'Rack': 'RAck',\n\t      'Rseq': 'RSeq',\n\t      'Www-Authenticate': 'WWW-Authenticate'\n\t      },\n\t      name = string.toLowerCase().replace(/_/g,'-').split('-'),\n\t      hname = '',\n\t      parts = name.length, part;\n\t\n\t    for (part = 0; part < parts; part++) {\n\t      if (part !== 0) {\n\t        hname +='-';\n\t      }\n\t      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);\n\t    }\n\t    if (exceptions[hname]) {\n\t      hname = exceptions[hname];\n\t    }\n\t    return hname;\n\t  },\n\t\n\t  sipErrorCause: function(status_code) {\n\t    var cause;\n\t\n\t    for (cause in SIP.C.SIP_ERROR_CAUSES) {\n\t      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n\t        return SIP.C.causes[cause];\n\t      }\n\t    }\n\t\n\t    return SIP.C.causes.SIP_FAILURE_CODE;\n\t  },\n\t\n\t  getReasonPhrase: function getReasonPhrase (code, specific) {\n\t    return specific || SIP.C.REASON_PHRASE[code] || '';\n\t  },\n\t\n\t  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {\n\t    reason = SIP.Utils.getReasonPhrase(code, reason);\n\t    return 'SIP ;cause=' + code + ' ;text=\"' + reason + '\"';\n\t  },\n\t\n\t  getCancelReason: function getCancelReason (code, reason) {\n\t    if (code && code < 200 || code > 699) {\n\t      throw new TypeError('Invalid status_code: ' + code);\n\t    } else if (code) {\n\t      return SIP.Utils.getReasonHeaderValue(code, reason);\n\t    }\n\t  },\n\t\n\t  buildStatusLine: function buildStatusLine (code, reason) {\n\t    code = code || null;\n\t    reason = reason || null;\n\t\n\t    // Validate code and reason values\n\t    if (!code || (code < 100 || code > 699)) {\n\t      throw new TypeError('Invalid status_code: '+ code);\n\t    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n\t      throw new TypeError('Invalid reason_phrase: '+ reason);\n\t    }\n\t\n\t    reason = Utils.getReasonPhrase(code, reason);\n\t\n\t    return 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\t  },\n\t\n\t  /**\n\t  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n\t  * @private\n\t  */\n\t  getRandomTestNetIP: function() {\n\t    function getOctet(from,to) {\n\t      return Math.floor(Math.random()*(to-from+1)+from);\n\t    }\n\t    return '192.0.2.' + getOctet(1, 254);\n\t  },\n\t\n\t  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info\n\t  calculateMD5: function(string) {\n\t    function RotateLeft(lValue, iShiftBits) {\n\t      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n\t    }\n\t\n\t    function AddUnsigned(lX,lY) {\n\t      var lX4,lY4,lX8,lY8,lResult;\n\t      lX8 = (lX & 0x80000000);\n\t      lY8 = (lY & 0x80000000);\n\t      lX4 = (lX & 0x40000000);\n\t      lY4 = (lY & 0x40000000);\n\t      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n\t      if (lX4 & lY4) {\n\t        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n\t      }\n\t      if (lX4 | lY4) {\n\t        if (lResult & 0x40000000) {\n\t          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n\t        } else {\n\t          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n\t        }\n\t      } else {\n\t        return (lResult ^ lX8 ^ lY8);\n\t      }\n\t    }\n\t\n\t    function F(x,y,z) {\n\t      return (x & y) | ((~x) & z);\n\t    }\n\t\n\t    function G(x,y,z) {\n\t      return (x & z) | (y & (~z));\n\t    }\n\t\n\t    function H(x,y,z) {\n\t      return (x ^ y ^ z);\n\t    }\n\t\n\t    function I(x,y,z) {\n\t      return (y ^ (x | (~z)));\n\t    }\n\t\n\t    function FF(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function GG(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function HH(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function II(a,b,c,d,x,s,ac) {\n\t      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n\t      return AddUnsigned(RotateLeft(a, s), b);\n\t    }\n\t\n\t    function ConvertToWordArray(string) {\n\t      var lWordCount;\n\t      var lMessageLength = string.length;\n\t      var lNumberOfWords_temp1=lMessageLength + 8;\n\t      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n\t      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n\t      var lWordArray=Array(lNumberOfWords-1);\n\t      var lBytePosition = 0;\n\t      var lByteCount = 0;\n\t      while ( lByteCount < lMessageLength ) {\n\t        lWordCount = (lByteCount-(lByteCount % 4))/4;\n\t        lBytePosition = (lByteCount % 4)*8;\n\t        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n\t        lByteCount++;\n\t      }\n\t      lWordCount = (lByteCount-(lByteCount % 4))/4;\n\t      lBytePosition = (lByteCount % 4)*8;\n\t      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n\t      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n\t      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n\t      return lWordArray;\n\t    }\n\t\n\t    function WordToHex(lValue) {\n\t      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n\t      for (lCount = 0;lCount<=3;lCount++) {\n\t        lByte = (lValue>>>(lCount*8)) & 255;\n\t        WordToHexValue_temp = \"0\" + lByte.toString(16);\n\t        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n\t      }\n\t      return WordToHexValue;\n\t    }\n\t\n\t    function Utf8Encode(string) {\n\t      string = string.replace(/\\r\\n/g,\"\\n\");\n\t      var utftext = \"\";\n\t\n\t      for (var n = 0; n < string.length; n++) {\n\t        var c = string.charCodeAt(n);\n\t\n\t        if (c < 128) {\n\t          utftext += String.fromCharCode(c);\n\t        }\n\t        else if((c > 127) && (c < 2048)) {\n\t          utftext += String.fromCharCode((c >> 6) | 192);\n\t          utftext += String.fromCharCode((c & 63) | 128);\n\t        }\n\t        else {\n\t          utftext += String.fromCharCode((c >> 12) | 224);\n\t          utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t          utftext += String.fromCharCode((c & 63) | 128);\n\t        }\n\t      }\n\t      return utftext;\n\t    }\n\t\n\t    var x=[];\n\t    var k,AA,BB,CC,DD,a,b,c,d;\n\t    var S11=7, S12=12, S13=17, S14=22;\n\t    var S21=5, S22=9 , S23=14, S24=20;\n\t    var S31=4, S32=11, S33=16, S34=23;\n\t    var S41=6, S42=10, S43=15, S44=21;\n\t\n\t    string = Utf8Encode(string);\n\t\n\t    x = ConvertToWordArray(string);\n\t\n\t    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\t\n\t    for (k=0;k<x.length;k+=16) {\n\t      AA=a; BB=b; CC=c; DD=d;\n\t      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n\t      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n\t      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n\t      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n\t      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n\t      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n\t      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n\t      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n\t      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n\t      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n\t      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n\t      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n\t      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n\t      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n\t      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n\t      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n\t      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n\t      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n\t      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n\t      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n\t      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n\t      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n\t      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n\t      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n\t      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n\t      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n\t      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n\t      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n\t      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n\t      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n\t      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n\t      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n\t      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n\t      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n\t      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n\t      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n\t      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n\t      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n\t      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n\t      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n\t      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n\t      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n\t      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n\t      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n\t      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n\t      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n\t      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n\t      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n\t      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n\t      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n\t      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n\t      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n\t      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n\t      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n\t      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n\t      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n\t      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n\t      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n\t      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n\t      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n\t      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n\t      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n\t      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n\t      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n\t      a=AddUnsigned(a,AA);\n\t      b=AddUnsigned(b,BB);\n\t      c=AddUnsigned(c,CC);\n\t      d=AddUnsigned(d,DD);\n\t    }\n\t\n\t    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n\t\n\t    return temp.toLowerCase();\n\t  }\n\t};\n\t\n\tSIP.Utils = Utils;\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar levels = {\n\t  'error': 0,\n\t  'warn': 1,\n\t  'log': 2,\n\t  'debug': 3\n\t};\n\t\n\tmodule.exports = function (console) {\n\t\n\tvar LoggerFactory = function () {\n\t  var logger,\n\t    level = 2,\n\t    builtinEnabled = true,\n\t    connector = null;\n\t\n\t    this.loggers = {};\n\t\n\t    logger = this.getLogger('sip.loggerfactory');\n\t\n\t\n\t  Object.defineProperties(this, {\n\t    builtinEnabled: {\n\t      get: function(){ return builtinEnabled; },\n\t      set: function(value){\n\t        if (typeof value === 'boolean') {\n\t          builtinEnabled = value;\n\t        } else {\n\t          logger.error('invalid \"builtinEnabled\" parameter value: '+ JSON.stringify(value));\n\t        }\n\t      }\n\t    },\n\t\n\t    level: {\n\t      get: function() {return level; },\n\t      set: function(value) {\n\t        if (value >= 0 && value <=3) {\n\t          level = value;\n\t        } else if (value > 3) {\n\t          level = 3;\n\t        } else if (levels.hasOwnProperty(value)) {\n\t          level = levels[value];\n\t        } else {\n\t          logger.error('invalid \"level\" parameter value: '+ JSON.stringify(value));\n\t        }\n\t      }\n\t    },\n\t\n\t    connector: {\n\t      get: function() {return connector; },\n\t      set: function(value){\n\t        if(value === null || value === \"\" || value === undefined) {\n\t          connector = null;\n\t        } else if (typeof value === 'function') {\n\t          connector = value;\n\t        } else {\n\t          logger.error('invalid \"connector\" parameter value: '+ JSON.stringify(value));\n\t        }\n\t      }\n\t    }\n\t  });\n\t};\n\t\n\tLoggerFactory.prototype.print = function(target, category, label, content) {\n\t  if (typeof content === 'string') {\n\t    var prefix = [new Date(), category];\n\t    if (label) {\n\t      prefix.push(label);\n\t    }\n\t    content = prefix.concat(content).join(' | ');\n\t  }\n\t  target.call(console, content);\n\t};\n\t\n\tfunction Logger (logger, category, label) {\n\t  this.logger = logger;\n\t  this.category = category;\n\t  this.label = label;\n\t}\n\t\n\tObject.keys(levels).forEach(function (targetName) {\n\t  Logger.prototype[targetName] = function (content) {\n\t    this.logger[targetName](this.category, this.label, content);\n\t  };\n\t\n\t  LoggerFactory.prototype[targetName] = function (category, label, content) {\n\t    if (this.level >= levels[targetName]) {\n\t      if (this.builtinEnabled) {\n\t        this.print(console[targetName], category, label, content);\n\t      }\n\t\n\t      if (this.connector) {\n\t        this.connector(targetName, category, label, content);\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\tLoggerFactory.prototype.getLogger = function(category, label) {\n\t  var logger;\n\t\n\t  if (label && this.level === 3) {\n\t    return new Logger(this, category, label);\n\t  } else if (this.loggers[category]) {\n\t    return this.loggers[category];\n\t  } else {\n\t    logger = new Logger(this, category);\n\t    this.loggers[category] = logger;\n\t    return logger;\n\t  }\n\t};\n\t\n\treturn LoggerFactory;\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar NodeEventEmitter = __webpack_require__(21).EventEmitter;\n\t\n\tmodule.exports = function (console) {\n\t\n\t// Don't use `new SIP.EventEmitter()` for inheriting.\n\t// Use Object.create(SIP.EventEmitter.prototoype);\n\tfunction EventEmitter () {\n\t  NodeEventEmitter.call(this);\n\t}\n\t\n\tEventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {\n\t  constructor: {\n\t    value: EventEmitter,\n\t    enumerable: false,\n\t    writable: true,\n\t    configurable: true\n\t  }\n\t});\n\t\n\tEventEmitter.prototype.off = function off (eventName, listener) {\n\t  var warning = '';\n\t  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\\n';\n\t  warning += 'Please use removeListener or removeAllListeners instead.\\n';\n\t  warning += 'See here for more details:\\n';\n\t  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';\n\t  console.warn(warning);\n\t\n\t  if (arguments.length < 2) {\n\t    return this.removeAllListeners.apply(this, arguments);\n\t  } else {\n\t    return this.removeListener(eventName, listener);\n\t  }\n\t};\n\t\n\treturn EventEmitter;\n\t\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Constants\n\t */\n\t\n\t/**\n\t * SIP Constants.\n\t * @augments SIP\n\t */\n\t\n\tmodule.exports = function (name, version) {\n\treturn {\n\t  USER_AGENT: name +'/'+ version,\n\t\n\t  // SIP scheme\n\t  SIP:  'sip',\n\t  SIPS: 'sips',\n\t\n\t  // End and Failure causes\n\t  causes: {\n\t    // Generic error causes\n\t    CONNECTION_ERROR:         'Connection Error',\n\t    REQUEST_TIMEOUT:          'Request Timeout',\n\t    SIP_FAILURE_CODE:         'SIP Failure Code',\n\t    INTERNAL_ERROR:           'Internal Error',\n\t\n\t    // SIP error causes\n\t    BUSY:                     'Busy',\n\t    REJECTED:                 'Rejected',\n\t    REDIRECTED:               'Redirected',\n\t    UNAVAILABLE:              'Unavailable',\n\t    NOT_FOUND:                'Not Found',\n\t    ADDRESS_INCOMPLETE:       'Address Incomplete',\n\t    INCOMPATIBLE_SDP:         'Incompatible SDP',\n\t    AUTHENTICATION_ERROR:     'Authentication Error',\n\t    DIALOG_ERROR:             'Dialog Error',\n\t\n\t    // Session error causes\n\t    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',\n\t    WEBRTC_ERROR:             'WebRTC Error',\n\t    CANCELED:                 'Canceled',\n\t    NO_ANSWER:                'No Answer',\n\t    EXPIRES:                  'Expires',\n\t    NO_ACK:                   'No ACK',\n\t    NO_PRACK:                 'No PRACK',\n\t    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n\t    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',\n\t    RTP_TIMEOUT:              'RTP Timeout'\n\t  },\n\t\n\t  supported: {\n\t    UNSUPPORTED:        'none',\n\t    SUPPORTED:          'supported',\n\t    REQUIRED:           'required'\n\t  },\n\t\n\t  SIP_ERROR_CAUSES: {\n\t    REDIRECTED: [300,301,302,305,380],\n\t    BUSY: [486,600],\n\t    REJECTED: [403,603],\n\t    NOT_FOUND: [404,604],\n\t    UNAVAILABLE: [480,410,408,430],\n\t    ADDRESS_INCOMPLETE: [484],\n\t    INCOMPATIBLE_SDP: [488,606],\n\t    AUTHENTICATION_ERROR:[401,407]\n\t  },\n\t\n\t  // SIP Methods\n\t  ACK:        'ACK',\n\t  BYE:        'BYE',\n\t  CANCEL:     'CANCEL',\n\t  INFO:       'INFO',\n\t  INVITE:     'INVITE',\n\t  MESSAGE:    'MESSAGE',\n\t  NOTIFY:     'NOTIFY',\n\t  OPTIONS:    'OPTIONS',\n\t  REGISTER:   'REGISTER',\n\t  UPDATE:     'UPDATE',\n\t  SUBSCRIBE:  'SUBSCRIBE',\n\t  REFER:      'REFER',\n\t  PRACK:      'PRACK',\n\t\n\t  /* SIP Response Reasons\n\t   * DOC: http://www.iana.org/assignments/sip-parameters\n\t   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n\t   */\n\t  REASON_PHRASE: {\n\t    100: 'Trying',\n\t    180: 'Ringing',\n\t    181: 'Call Is Being Forwarded',\n\t    182: 'Queued',\n\t    183: 'Session Progress',\n\t    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199\n\t    200: 'OK',\n\t    202: 'Accepted',  // RFC 3265\n\t    204: 'No Notification',  //RFC 5839\n\t    300: 'Multiple Choices',\n\t    301: 'Moved Permanently',\n\t    302: 'Moved Temporarily',\n\t    305: 'Use Proxy',\n\t    380: 'Alternative Service',\n\t    400: 'Bad Request',\n\t    401: 'Unauthorized',\n\t    402: 'Payment Required',\n\t    403: 'Forbidden',\n\t    404: 'Not Found',\n\t    405: 'Method Not Allowed',\n\t    406: 'Not Acceptable',\n\t    407: 'Proxy Authentication Required',\n\t    408: 'Request Timeout',\n\t    410: 'Gone',\n\t    412: 'Conditional Request Failed',  // RFC 3903\n\t    413: 'Request Entity Too Large',\n\t    414: 'Request-URI Too Long',\n\t    415: 'Unsupported Media Type',\n\t    416: 'Unsupported URI Scheme',\n\t    417: 'Unknown Resource-Priority',  // RFC 4412\n\t    420: 'Bad Extension',\n\t    421: 'Extension Required',\n\t    422: 'Session Interval Too Small',  // RFC 4028\n\t    423: 'Interval Too Brief',\n\t    428: 'Use Identity Header',  // RFC 4474\n\t    429: 'Provide Referrer Identity',  // RFC 3892\n\t    430: 'Flow Failed',  // RFC 5626\n\t    433: 'Anonymity Disallowed',  // RFC 5079\n\t    436: 'Bad Identity-Info',  // RFC 4474\n\t    437: 'Unsupported Certificate',  // RFC 4744\n\t    438: 'Invalid Identity Header',  // RFC 4744\n\t    439: 'First Hop Lacks Outbound Support',  // RFC 5626\n\t    440: 'Max-Breadth Exceeded',  // RFC 5393\n\t    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events\n\t    470: 'Consent Needed',  // RFC 5360\n\t    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.\n\t    480: 'Temporarily Unavailable',\n\t    481: 'Call/Transaction Does Not Exist',\n\t    482: 'Loop Detected',\n\t    483: 'Too Many Hops',\n\t    484: 'Address Incomplete',\n\t    485: 'Ambiguous',\n\t    486: 'Busy Here',\n\t    487: 'Request Terminated',\n\t    488: 'Not Acceptable Here',\n\t    489: 'Bad Event',  // RFC 3265\n\t    491: 'Request Pending',\n\t    493: 'Undecipherable',\n\t    494: 'Security Agreement Required',  // RFC 3329\n\t    500: 'Internal Server Error',\n\t    501: 'Not Implemented',\n\t    502: 'Bad Gateway',\n\t    503: 'Service Unavailable',\n\t    504: 'Server Time-out',\n\t    505: 'Version Not Supported',\n\t    513: 'Message Too Large',\n\t    580: 'Precondition Failure',  // RFC 3312\n\t    600: 'Busy Everywhere',\n\t    603: 'Decline',\n\t    604: 'Does Not Exist Anywhere',\n\t    606: 'Not Acceptable'\n\t  },\n\t\n\t  /* SIP Option Tags\n\t   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4\n\t   */\n\t  OPTION_TAGS: {\n\t    '100rel':                   true,  // RFC 3262\n\t    199:                        true,  // RFC 6228\n\t    answermode:                 true,  // RFC 5373\n\t    'early-session':            true,  // RFC 3959\n\t    eventlist:                  true,  // RFC 4662\n\t    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n\t    'from-change':              true,  // RFC 4916\n\t    'geolocation-http':         true,  // RFC 6442\n\t    'geolocation-sip':          true,  // RFC 6442\n\t    gin:                        true,  // RFC 6140\n\t    gruu:                       true,  // RFC 5627\n\t    histinfo:                   true,  // RFC 7044\n\t    ice:                        true,  // RFC 5768\n\t    join:                       true,  // RFC 3911\n\t    'multiple-refer':           true,  // RFC 5368\n\t    norefersub:                 true,  // RFC 4488\n\t    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n\t    outbound:                   true,  // RFC 5626\n\t    path:                       true,  // RFC 3327\n\t    policy:                     true,  // RFC 6794\n\t    precondition:               true,  // RFC 3312\n\t    pref:                       true,  // RFC 3840\n\t    privacy:                    true,  // RFC 3323\n\t    'recipient-list-invite':    true,  // RFC 5366\n\t    'recipient-list-message':   true,  // RFC 5365\n\t    'recipient-list-subscribe': true,  // RFC 5367\n\t    replaces:                   true,  // RFC 3891\n\t    'resource-priority':        true,  // RFC 4412\n\t    'sdp-anat':                 true,  // RFC 4092\n\t    'sec-agree':                true,  // RFC 3329\n\t    tdialog:                    true,  // RFC 4538\n\t    timer:                      true,  // RFC 4028\n\t    uui:                        true   // RFC 7433\n\t  }\n\t};\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Exceptions\n\t */\n\t\n\t/**\n\t * SIP Exceptions.\n\t * @augments SIP\n\t */\n\tmodule.exports = {\n\t  ConfigurationError: (function(){\n\t    var exception = function(parameter, value) {\n\t      this.code = 1;\n\t      this.name = 'CONFIGURATION_ERROR';\n\t      this.parameter = parameter;\n\t      this.value = value;\n\t      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter \"'+ this.parameter +'\"';\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }()),\n\t\n\t  InvalidStateError: (function(){\n\t    var exception = function(status) {\n\t      this.code = 2;\n\t      this.name = 'INVALID_STATE_ERROR';\n\t      this.status = status;\n\t      this.message = 'Invalid status: ' + status;\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }()),\n\t\n\t  NotSupportedError: (function(){\n\t    var exception = function(message) {\n\t      this.code = 3;\n\t      this.name = 'NOT_SUPPORTED_ERROR';\n\t      this.message = message;\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }()),\n\t\n\t  GetDescriptionError: (function(){\n\t    var exception = function(message) {\n\t      this.code = 4;\n\t      this.name = 'GET_DESCRIPTION_ERROR';\n\t      this.message = message;\n\t    };\n\t    exception.prototype = new Error();\n\t    return exception;\n\t  }())\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP TIMERS\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t */\n\tvar\n\t  T1 = 500,\n\t  T2 = 4000,\n\t  T4 = 5000;\n\tmodule.exports = function (timers) {\n\t  var Timers = {\n\t    T1: T1,\n\t    T2: T2,\n\t    T4: T4,\n\t    TIMER_B: 64 * T1,\n\t    TIMER_D: 0  * T1,\n\t    TIMER_F: 64 * T1,\n\t    TIMER_H: 64 * T1,\n\t    TIMER_I: 0  * T1,\n\t    TIMER_J: 0  * T1,\n\t    TIMER_K: 0  * T4,\n\t    TIMER_L: 64 * T1,\n\t    TIMER_M: 64 * T1,\n\t    TIMER_N: 64 * T1,\n\t    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1\n\t  };\n\t\n\t  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']\n\t  .forEach(function (name) {\n\t    // can't just use timers[name].bind(timers) since it bypasses jasmine's\n\t    // clock-mocking\n\t    Timers[name] = function () {\n\t      return timers[name].apply(timers, arguments);\n\t    };\n\t  });\n\t\n\t  return Timers;\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Message Parser\n\t */\n\t\n\t/**\n\t * Extract and parse every header of a SIP message.\n\t * @augments SIP\n\t * @namespace\n\t */\n\tmodule.exports = function (SIP) {\n\tvar Parser;\n\t\n\tfunction getHeader(data, headerStart) {\n\t  var\n\t    // 'start' position of the header.\n\t    start = headerStart,\n\t    // 'end' position of the header.\n\t    end = 0,\n\t    // 'partial end' position of the header.\n\t    partialEnd = 0;\n\t\n\t  //End of message.\n\t  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n\t    return -2;\n\t  }\n\t\n\t  while(end === 0) {\n\t    // Partial End of Header.\n\t    partialEnd = data.indexOf('\\r\\n', start);\n\t\n\t    // 'indexOf' returns -1 if the value to be found never occurs.\n\t    if (partialEnd === -1) {\n\t      return partialEnd;\n\t    }\n\t\n\t    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n\t      // Not the end of the message. Continue from the next position.\n\t      start = partialEnd + 2;\n\t    } else {\n\t      end = partialEnd;\n\t    }\n\t  }\n\t\n\t  return end;\n\t}\n\t\n\tfunction parseHeader(message, data, headerStart, headerEnd) {\n\t  var header, idx, length, parsed,\n\t    hcolonIndex = data.indexOf(':', headerStart),\n\t    headerName = data.substring(headerStart, hcolonIndex).trim(),\n\t    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n\t\n\t  // If header-field is well-known, parse it.\n\t  switch(headerName.toLowerCase()) {\n\t    case 'via':\n\t    case 'v':\n\t      message.addHeader('via', headerValue);\n\t      if(message.getHeaders('via').length === 1) {\n\t        parsed = message.parseHeader('Via');\n\t        if(parsed) {\n\t          message.via = parsed;\n\t          message.via_branch = parsed.branch;\n\t        }\n\t      } else {\n\t        parsed = 0;\n\t      }\n\t      break;\n\t    case 'from':\n\t    case 'f':\n\t      message.setHeader('from', headerValue);\n\t      parsed = message.parseHeader('from');\n\t      if(parsed) {\n\t        message.from = parsed;\n\t        message.from_tag = parsed.getParam('tag');\n\t      }\n\t      break;\n\t    case 'to':\n\t    case 't':\n\t      message.setHeader('to', headerValue);\n\t      parsed = message.parseHeader('to');\n\t      if(parsed) {\n\t        message.to = parsed;\n\t        message.to_tag = parsed.getParam('tag');\n\t      }\n\t      break;\n\t    case 'record-route':\n\t      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n\t\n\t      if (parsed === -1) {\n\t        parsed = undefined;\n\t        break;\n\t      }\n\t\n\t      length = parsed.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = parsed[idx];\n\t        message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n\t        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n\t      }\n\t      break;\n\t    case 'call-id':\n\t    case 'i':\n\t      message.setHeader('call-id', headerValue);\n\t      parsed = message.parseHeader('call-id');\n\t      if(parsed) {\n\t        message.call_id = headerValue;\n\t      }\n\t      break;\n\t    case 'contact':\n\t    case 'm':\n\t      parsed = SIP.Grammar.parse(headerValue, 'Contact');\n\t\n\t      if (parsed === -1) {\n\t        parsed = undefined;\n\t        break;\n\t      }\n\t\n\t      length = parsed.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = parsed[idx];\n\t        message.addHeader('contact', headerValue.substring(header.position, header.offset));\n\t        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n\t      }\n\t      break;\n\t    case 'content-length':\n\t    case 'l':\n\t      message.setHeader('content-length', headerValue);\n\t      parsed = message.parseHeader('content-length');\n\t      break;\n\t    case 'content-type':\n\t    case 'c':\n\t      message.setHeader('content-type', headerValue);\n\t      parsed = message.parseHeader('content-type');\n\t      break;\n\t    case 'cseq':\n\t      message.setHeader('cseq', headerValue);\n\t      parsed = message.parseHeader('cseq');\n\t      if(parsed) {\n\t        message.cseq = parsed.value;\n\t      }\n\t      if(message instanceof SIP.IncomingResponse) {\n\t        message.method = parsed.method;\n\t      }\n\t      break;\n\t    case 'max-forwards':\n\t      message.setHeader('max-forwards', headerValue);\n\t      parsed = message.parseHeader('max-forwards');\n\t      break;\n\t    case 'www-authenticate':\n\t      message.setHeader('www-authenticate', headerValue);\n\t      parsed = message.parseHeader('www-authenticate');\n\t      break;\n\t    case 'proxy-authenticate':\n\t      message.setHeader('proxy-authenticate', headerValue);\n\t      parsed = message.parseHeader('proxy-authenticate');\n\t      break;\n\t    case 'refer-to':\n\t    case 'r':\n\t      message.setHeader('refer-to', headerValue);\n\t      parsed = message.parseHeader('refer-to');\n\t      if (parsed) {\n\t        message.refer_to = parsed;\n\t      }\n\t      break;\n\t    default:\n\t      // Do not parse this header.\n\t      message.setHeader(headerName, headerValue);\n\t      parsed = 0;\n\t  }\n\t\n\t  if (parsed === undefined) {\n\t    return {\n\t      error: 'error parsing header \"'+ headerName +'\"'\n\t    };\n\t  } else {\n\t    return true;\n\t  }\n\t}\n\t\n\t/** Parse SIP Message\n\t * @function\n\t * @param {String} message SIP message.\n\t * @param {Object} logger object.\n\t * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n\t */\n\tParser = {};\n\tParser.parseMessage = function(data, ua) {\n\t  var message, firstLine, contentLength, bodyStart, parsed,\n\t    headerStart = 0,\n\t    headerEnd = data.indexOf('\\r\\n'),\n\t    logger = ua.getLogger('sip.parser');\n\t\n\t  if(headerEnd === -1) {\n\t    logger.warn('no CRLF found, not a SIP message, discarded');\n\t    return;\n\t  }\n\t\n\t  // Parse first line. Check if it is a Request or a Reply.\n\t  firstLine = data.substring(0, headerEnd);\n\t  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n\t\n\t  if(parsed === -1) {\n\t    logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n\t    return;\n\t  } else if(!parsed.status_code) {\n\t    message = new SIP.IncomingRequest(ua);\n\t    message.method = parsed.method;\n\t    message.ruri = parsed.uri;\n\t  } else {\n\t    message = new SIP.IncomingResponse(ua);\n\t    message.status_code = parsed.status_code;\n\t    message.reason_phrase = parsed.reason_phrase;\n\t  }\n\t\n\t  message.data = data;\n\t  headerStart = headerEnd + 2;\n\t\n\t  /* Loop over every line in data. Detect the end of each header and parse\n\t  * it or simply add to the headers collection.\n\t  */\n\t  while(true) {\n\t    headerEnd = getHeader(data, headerStart);\n\t\n\t    // The SIP message has normally finished.\n\t    if(headerEnd === -2) {\n\t      bodyStart = headerStart + 2;\n\t      break;\n\t    }\n\t    // data.indexOf returned -1 due to a malformed message.\n\t    else if(headerEnd === -1) {\n\t      logger.error('malformed message');\n\t      return;\n\t    }\n\t\n\t    parsed = parseHeader(message, data, headerStart, headerEnd);\n\t\n\t    if(parsed !== true) {\n\t      logger.error(parsed.error);\n\t      return;\n\t    }\n\t\n\t    headerStart = headerEnd + 2;\n\t  }\n\t\n\t  /* RFC3261 18.3.\n\t   * If there are additional bytes in the transport packet\n\t   * beyond the end of the body, they MUST be discarded.\n\t   */\n\t  if(message.hasHeader('content-length')) {\n\t    contentLength = message.getHeader('content-length');\n\t    message.body = data.substr(bodyStart, contentLength);\n\t  } else {\n\t    message.body = data.substring(bodyStart);\n\t  }\n\t\n\t  return message;\n\t};\n\t\n\tSIP.Parser = Parser;\n\t};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Message\n\t */\n\t\n\tmodule.exports = function (SIP) {\n\tvar\n\t  OutgoingRequest,\n\t  IncomingMessage,\n\t  IncomingRequest,\n\t  IncomingResponse;\n\t\n\tfunction getSupportedHeader (request) {\n\t  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;\n\t  var optionTags = [];\n\t  var optionTagSet = {};\n\t\n\t  if (request.method === SIP.C.REGISTER) {\n\t    optionTags.push('path', 'gruu');\n\t  } else if (request.method === SIP.C.INVITE &&\n\t             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {\n\t    optionTags.push('gruu');\n\t  }\n\t\n\t  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n\t    optionTags.push('100rel');\n\t  }\n\t  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {\n\t    optionTags.push('replaces');\n\t  }\n\t\n\t  optionTags.push('outbound');\n\t\n\t  optionTags = optionTags.concat(request.ua.configuration.extraSupported);\n\t\n\t  optionTags = optionTags.filter(function(optionTag) {\n\t    var registered = SIP.C.OPTION_TAGS[optionTag];\n\t    var unique = !optionTagSet[optionTag];\n\t    optionTagSet[optionTag] = true;\n\t    return (registered || allowUnregistered) && unique;\n\t  });\n\t\n\t  return 'Supported: ' + optionTags.join(', ') + '\\r\\n';\n\t}\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class for outgoing SIP request.\n\t * @param {String} method request method\n\t * @param {String} ruri request uri\n\t * @param {SIP.UA} ua\n\t * @param {Object} params parameters that will have priority over ua.configuration parameters:\n\t * <br>\n\t *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set\n\t * @param {Object} [headers] extra headers\n\t * @param {String} [body]\n\t */\n\tOutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {\n\t  var\n\t    to,\n\t    from,\n\t    call_id,\n\t    cseq,\n\t    to_uri,\n\t    from_uri;\n\t\n\t  params = params || {};\n\t\n\t  // Mandatory parameters check\n\t  if(!method || !ruri || !ua) {\n\t    return null;\n\t  }\n\t\n\t  this.logger = ua.getLogger('sip.sipmessage');\n\t  this.ua = ua;\n\t  this.headers = {};\n\t  this.method = method;\n\t  this.ruri = ruri;\n\t  this.body = body;\n\t  this.extraHeaders = (extraHeaders || []).slice();\n\t  this.statusCode = params.status_code;\n\t  this.reasonPhrase = params.reason_phrase;\n\t\n\t  // Fill the Common SIP Request Headers\n\t\n\t  // Route\n\t  if (params.route_set) {\n\t    this.setHeader('route', params.route_set);\n\t  } else if (ua.configuration.usePreloadedRoute){\n\t    this.setHeader('route', ua.transport.server.sip_uri);\n\t  }\n\t\n\t  // Via\n\t  // Empty Via header. Will be filled by the client transaction.\n\t  this.setHeader('via', '');\n\t\n\t  // Max-Forwards\n\t  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);\n\t\n\t  // To\n\t  to_uri = params.to_uri || ruri;\n\t  to = (params.to_displayName || params.to_displayName === 0) ? '\"' + params.to_displayName + '\" ' : '';\n\t  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';\n\t  to += params.to_tag ? ';tag=' + params.to_tag : '';\n\t  this.to = new SIP.NameAddrHeader.parse(to);\n\t  this.setHeader('to', to);\n\t\n\t  // From\n\t  from_uri = params.from_uri || ua.configuration.uri;\n\t  if (params.from_displayName || params.from_displayName === 0) {\n\t    from = '\"' + params.from_displayName + '\" ';\n\t  } else if (ua.configuration.displayName) {\n\t    from = '\"' + ua.configuration.displayName + '\" ';\n\t  } else {\n\t    from = '';\n\t  }\n\t  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';\n\t  from += params.from_tag || SIP.Utils.newTag();\n\t  this.from = new SIP.NameAddrHeader.parse(from);\n\t  this.setHeader('from', from);\n\t\n\t  // Call-ID\n\t  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));\n\t  this.call_id = call_id;\n\t  this.setHeader('call-id', call_id);\n\t\n\t  // CSeq\n\t  cseq = params.cseq || Math.floor(Math.random() * 10000);\n\t  this.cseq = cseq;\n\t  this.setHeader('cseq', cseq + ' ' + method);\n\t};\n\t\n\tOutgoingRequest.prototype = {\n\t  /**\n\t   * Replace the the given header by the given value.\n\t   * @param {String} name header name\n\t   * @param {String | Array} value header value\n\t   */\n\t  setHeader: function(name, value) {\n\t    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n\t  },\n\t\n\t  /**\n\t   * Get the value of the given header name at the given position.\n\t   * @param {String} name header name\n\t   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.\n\t   */\n\t  getHeader: function(name) {\n\t    var regexp, idx,\n\t      length = this.extraHeaders.length,\n\t      header = this.headers[SIP.Utils.headerize(name)];\n\t\n\t    if(header) {\n\t      if(header[0]) {\n\t        return header[0];\n\t      }\n\t    } else {\n\t      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = this.extraHeaders[idx];\n\t        if (regexp.test(header)) {\n\t          return header.substring(header.indexOf(':')+1).trim();\n\t        }\n\t      }\n\t    }\n\t\n\t    return;\n\t  },\n\t\n\t  /**\n\t   * Get the header/s of the given name.\n\t   * @param {String} name header name\n\t   * @returns {Array} Array with all the headers of the specified name.\n\t   */\n\t  getHeaders: function(name) {\n\t    var idx, length, regexp,\n\t      header = this.headers[SIP.Utils.headerize(name)],\n\t      result = [];\n\t\n\t    if(header) {\n\t      length = header.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        result.push(header[idx]);\n\t      }\n\t      return result;\n\t    } else {\n\t      length = this.extraHeaders.length;\n\t      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n\t      for (idx = 0; idx < length; idx++) {\n\t        header = this.extraHeaders[idx];\n\t        if (regexp.test(header)) {\n\t          result.push(header.substring(header.indexOf(':')+1).trim());\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Verify the existence of the given header.\n\t   * @param {String} name header name\n\t   * @returns {boolean} true if header with given name exists, false otherwise\n\t   */\n\t  hasHeader: function(name) {\n\t    var regexp, idx,\n\t      length = this.extraHeaders.length;\n\t\n\t    if (this.headers[SIP.Utils.headerize(name)]) {\n\t      return true;\n\t    } else {\n\t      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n\t      for (idx = 0; idx < length; idx++) {\n\t        if (regexp.test(this.extraHeaders[idx])) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  toString: function() {\n\t    var msg = '', header, length, idx;\n\t\n\t    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\\r\\n';\n\t\n\t    for (header in this.headers) {\n\t      length = this.headers[header].length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        msg += header + ': ' + this.headers[header][idx] + '\\r\\n';\n\t      }\n\t    }\n\t\n\t    length = this.extraHeaders.length;\n\t    for (idx = 0; idx < length; idx++) {\n\t      msg += this.extraHeaders[idx].trim() +'\\r\\n';\n\t    }\n\t\n\t    msg += getSupportedHeader(this);\n\t    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\t\n\t    if(this.body) {\n\t      length = SIP.Utils.str_utf8_length(this.body);\n\t      msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n\t      msg += this.body;\n\t    } else {\n\t      msg += 'Content-Length: 0\\r\\n\\r\\n';\n\t    }\n\t\n\t    return msg;\n\t  }\n\t};\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class for incoming SIP message.\n\t */\n\tIncomingMessage = function(){\n\t  this.data = null;\n\t  this.headers = null;\n\t  this.method =  null;\n\t  this.via = null;\n\t  this.via_branch = null;\n\t  this.call_id = null;\n\t  this.cseq = null;\n\t  this.from = null;\n\t  this.from_tag = null;\n\t  this.to = null;\n\t  this.to_tag = null;\n\t  this.body = null;\n\t};\n\t\n\tIncomingMessage.prototype = {\n\t  /**\n\t  * Insert a header of the given name and value into the last position of the\n\t  * header array.\n\t  * @param {String} name header name\n\t  * @param {String} value header value\n\t  */\n\t  addHeader: function(name, value) {\n\t    var header = { raw: value };\n\t\n\t    name = SIP.Utils.headerize(name);\n\t\n\t    if(this.headers[name]) {\n\t      this.headers[name].push(header);\n\t    } else {\n\t      this.headers[name] = [header];\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get the value of the given header name at the given position.\n\t   * @param {String} name header name\n\t   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.\n\t   */\n\t  getHeader: function(name) {\n\t    var header = this.headers[SIP.Utils.headerize(name)];\n\t\n\t    if(header) {\n\t      if(header[0]) {\n\t        return header[0].raw;\n\t      }\n\t    } else {\n\t      return;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get the header/s of the given name.\n\t   * @param {String} name header name\n\t   * @returns {Array} Array with all the headers of the specified name.\n\t   */\n\t  getHeaders: function(name) {\n\t    var idx, length,\n\t      header = this.headers[SIP.Utils.headerize(name)],\n\t      result = [];\n\t\n\t    if(!header) {\n\t      return [];\n\t    }\n\t\n\t    length = header.length;\n\t    for (idx = 0; idx < length; idx++) {\n\t      result.push(header[idx].raw);\n\t    }\n\t\n\t    return result;\n\t  },\n\t\n\t  /**\n\t   * Verify the existence of the given header.\n\t   * @param {String} name header name\n\t   * @returns {boolean} true if header with given name exists, false otherwise\n\t   */\n\t  hasHeader: function(name) {\n\t    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;\n\t  },\n\t\n\t  /**\n\t  * Parse the given header on the given index.\n\t  * @param {String} name header name\n\t  * @param {Number} [idx=0] header index\n\t  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n\t  */\n\t  parseHeader: function(name, idx) {\n\t    var header, value, parsed;\n\t\n\t    name = SIP.Utils.headerize(name);\n\t\n\t    idx = idx || 0;\n\t\n\t    if(!this.headers[name]) {\n\t      this.logger.log('header \"' + name + '\" not present');\n\t      return;\n\t    } else if(idx >= this.headers[name].length) {\n\t      this.logger.log('not so many \"' + name + '\" headers present');\n\t      return;\n\t    }\n\t\n\t    header = this.headers[name][idx];\n\t    value = header.raw;\n\t\n\t    if(header.parsed) {\n\t      return header.parsed;\n\t    }\n\t\n\t    //substitute '-' by '_' for grammar rule matching.\n\t    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));\n\t\n\t    if(parsed === -1) {\n\t      this.headers[name].splice(idx, 1); //delete from headers\n\t      this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n\t      return;\n\t    } else {\n\t      header.parsed = parsed;\n\t      return parsed;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Message Header attribute selector. Alias of parseHeader.\n\t   * @param {String} name header name\n\t   * @param {Number} [idx=0] header index\n\t   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n\t   *\n\t   * @example\n\t   * message.s('via',3).port\n\t   */\n\t  s: function(name, idx) {\n\t    return this.parseHeader(name, idx);\n\t  },\n\t\n\t  /**\n\t  * Replace the value of the given header by the value.\n\t  * @param {String} name header name\n\t  * @param {String} value header value\n\t  */\n\t  setHeader: function(name, value) {\n\t    var header = { raw: value };\n\t    this.headers[SIP.Utils.headerize(name)] = [header];\n\t  },\n\t\n\t  toString: function() {\n\t    return this.data;\n\t  }\n\t};\n\t\n\t/**\n\t * @augments IncomingMessage\n\t * @class Class for incoming SIP request.\n\t */\n\tIncomingRequest = function(ua) {\n\t  this.logger = ua.getLogger('sip.sipmessage');\n\t  this.ua = ua;\n\t  this.headers = {};\n\t  this.ruri = null;\n\t  this.transport = null;\n\t  this.server_transaction = null;\n\t};\n\tIncomingRequest.prototype = new IncomingMessage();\n\t\n\t/**\n\t* Stateful reply.\n\t* @param {Number} code status code\n\t* @param {String} reason reason phrase\n\t* @param {Object} headers extra headers\n\t* @param {String} body body\n\t* @param {Function} [onSuccess] onSuccess callback\n\t* @param {Function} [onFailure] onFailure callback\n\t*/\n\tIncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {\n\t  var rr, vias, length, idx, response,\n\t    to = this.getHeader('To'),\n\t    r = 0,\n\t    v = 0;\n\t\n\t  response = SIP.Utils.buildStatusLine(code, reason);\n\t  extraHeaders = (extraHeaders || []).slice();\n\t\n\t  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {\n\t    rr = this.getHeaders('record-route');\n\t    length = rr.length;\n\t\n\t    for(r; r < length; r++) {\n\t      response += 'Record-Route: ' + rr[r] + '\\r\\n';\n\t    }\n\t  }\n\t\n\t  vias = this.getHeaders('via');\n\t  length = vias.length;\n\t\n\t  for(v; v < length; v++) {\n\t    response += 'Via: ' + vias[v] + '\\r\\n';\n\t  }\n\t\n\t  if(!this.to_tag && code > 100) {\n\t    to += ';tag=' + SIP.Utils.newTag();\n\t  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n\t    to += ';tag=' + this.to_tag;\n\t  }\n\t\n\t  response += 'To: ' + to + '\\r\\n';\n\t  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n\t  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n\t  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\t\n\t  length = extraHeaders.length;\n\t  for (idx = 0; idx < length; idx++) {\n\t    response += extraHeaders[idx].trim() +'\\r\\n';\n\t  }\n\t\n\t  response += getSupportedHeader(this);\n\t  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\t\n\t  if(body) {\n\t    length = SIP.Utils.str_utf8_length(body);\n\t    response += 'Content-Type: application/sdp\\r\\n';\n\t    response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n\t    response += body;\n\t  } else {\n\t    response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\t  }\n\t\n\t  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);\n\t\n\t  return response;\n\t};\n\t\n\t/**\n\t* Stateless reply.\n\t* @param {Number} code status code\n\t* @param {String} reason reason phrase\n\t*/\n\tIncomingRequest.prototype.reply_sl = function(code, reason) {\n\t  var to, response,\n\t    v = 0,\n\t    vias = this.getHeaders('via'),\n\t    length = vias.length;\n\t\n\t  response = SIP.Utils.buildStatusLine(code, reason);\n\t\n\t  for(v; v < length; v++) {\n\t    response += 'Via: ' + vias[v] + '\\r\\n';\n\t  }\n\t\n\t  to = this.getHeader('To');\n\t\n\t  if(!this.to_tag && code > 100) {\n\t    to += ';tag=' + SIP.Utils.newTag();\n\t  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n\t    to += ';tag=' + this.to_tag;\n\t  }\n\t\n\t  response += 'To: ' + to + '\\r\\n';\n\t  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n\t  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n\t  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\t  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\t  response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\t\n\t  this.transport.send(response);\n\t};\n\t\n\t\n\t/**\n\t * @augments IncomingMessage\n\t * @class Class for incoming SIP response.\n\t */\n\tIncomingResponse = function(ua) {\n\t  this.logger = ua.getLogger('sip.sipmessage');\n\t  this.headers = {};\n\t  this.status_code = null;\n\t  this.reason_phrase = null;\n\t};\n\tIncomingResponse.prototype = new IncomingMessage();\n\t\n\tSIP.OutgoingRequest = OutgoingRequest;\n\tSIP.IncomingRequest = IncomingRequest;\n\tSIP.IncomingResponse = IncomingResponse;\n\t};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP URI\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP URI.\n\t *\n\t * @param {String} [scheme]\n\t * @param {String} [user]\n\t * @param {String} host\n\t * @param {String} [port]\n\t * @param {Object} [parameters]\n\t * @param {Object} [headers]\n\t *\n\t */\n\tmodule.exports = function (SIP) {\n\tvar URI;\n\t\n\tURI = function(scheme, user, host, port, parameters, headers) {\n\t  var param, header, raw, normal;\n\t\n\t  // Checks\n\t  if(!host) {\n\t    throw new TypeError('missing or invalid \"host\" parameter');\n\t  }\n\t\n\t  // Initialize parameters\n\t  scheme = scheme || SIP.C.SIP;\n\t  this.parameters = {};\n\t  this.headers = {};\n\t\n\t  for (param in parameters) {\n\t    this.setParam(param, parameters[param]);\n\t  }\n\t\n\t  for (header in headers) {\n\t    this.setHeader(header, headers[header]);\n\t  }\n\t\n\t  // Raw URI\n\t  raw = {\n\t    scheme: scheme,\n\t    user: user,\n\t    host: host,\n\t    port: port\n\t  };\n\t\n\t  // Normalized URI\n\t  normal = {\n\t    scheme: scheme.toLowerCase(),\n\t    user: user,\n\t    host: host.toLowerCase(),\n\t    port: port\n\t  };\n\t\n\t  Object.defineProperties(this, {\n\t    _normal: {\n\t      get: function() { return normal; }\n\t    },\n\t\n\t    _raw: {\n\t      get: function() { return raw; }\n\t    },\n\t\n\t    scheme: {\n\t      get: function() { return normal.scheme; },\n\t      set: function(value) {\n\t        raw.scheme = value;\n\t        normal.scheme = value.toLowerCase();\n\t      }\n\t    },\n\t\n\t    user: {\n\t      get: function() { return normal.user; },\n\t      set: function(value) {\n\t        normal.user = raw.user = value;\n\t      }\n\t    },\n\t\n\t    host: {\n\t      get: function() { return normal.host; },\n\t      set: function(value) {\n\t        raw.host = value;\n\t        normal.host = value.toLowerCase();\n\t      }\n\t    },\n\t\n\t    aor: {\n\t      get: function() { return normal.user + '@' + normal.host; }\n\t    },\n\t\n\t    port: {\n\t      get: function() { return normal.port; },\n\t      set: function(value) {\n\t        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);\n\t      }\n\t    }\n\t  });\n\t};\n\t\n\tURI.prototype = {\n\t  setParam: function(key, value) {\n\t    if(key) {\n\t      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();\n\t    }\n\t  },\n\t\n\t  getParam: function(key) {\n\t    if(key) {\n\t      return this.parameters[key.toLowerCase()];\n\t    }\n\t  },\n\t\n\t  hasParam: function(key) {\n\t    if(key) {\n\t      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n\t    }\n\t  },\n\t\n\t  deleteParam: function(parameter) {\n\t    var value;\n\t    parameter = parameter.toLowerCase();\n\t    if (this.parameters.hasOwnProperty(parameter)) {\n\t      value = this.parameters[parameter];\n\t      delete this.parameters[parameter];\n\t      return value;\n\t    }\n\t  },\n\t\n\t  clearParams: function() {\n\t    this.parameters = {};\n\t  },\n\t\n\t  setHeader: function(name, value) {\n\t    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n\t  },\n\t\n\t  getHeader: function(name) {\n\t    if(name) {\n\t      return this.headers[SIP.Utils.headerize(name)];\n\t    }\n\t  },\n\t\n\t  hasHeader: function(name) {\n\t    if(name) {\n\t      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;\n\t    }\n\t  },\n\t\n\t  deleteHeader: function(header) {\n\t    var value;\n\t    header = SIP.Utils.headerize(header);\n\t    if(this.headers.hasOwnProperty(header)) {\n\t      value = this.headers[header];\n\t      delete this.headers[header];\n\t      return value;\n\t    }\n\t  },\n\t\n\t  clearHeaders: function() {\n\t    this.headers = {};\n\t  },\n\t\n\t  clone: function() {\n\t    return new URI(\n\t      this._raw.scheme,\n\t      this._raw.user,\n\t      this._raw.host,\n\t      this._raw.port,\n\t      JSON.parse(JSON.stringify(this.parameters)),\n\t      JSON.parse(JSON.stringify(this.headers)));\n\t  },\n\t\n\t  toRaw: function() {\n\t    return this._toString(this._raw);\n\t  },\n\t\n\t  toString: function() {\n\t    return this._toString(this._normal);\n\t  },\n\t\n\t  _toString: function(uri) {\n\t    var header, parameter, idx, uriString, headers = [];\n\t\n\t    uriString  = uri.scheme + ':';\n\t    // add slashes if it's not a sip(s) URI\n\t    if (!uri.scheme.toLowerCase().match(\"^sips?$\")) {\n\t      uriString += \"//\";\n\t    }\n\t    if (uri.user) {\n\t      uriString += SIP.Utils.escapeUser(uri.user) + '@';\n\t    }\n\t    uriString += uri.host;\n\t    if (uri.port || uri.port === 0) {\n\t      uriString += ':' + uri.port;\n\t    }\n\t\n\t    for (parameter in this.parameters) {\n\t      uriString += ';' + parameter;\n\t\n\t      if (this.parameters[parameter] !== null) {\n\t        uriString += '='+ this.parameters[parameter];\n\t      }\n\t    }\n\t\n\t    for(header in this.headers) {\n\t      for(idx in this.headers[header]) {\n\t        headers.push(header + '=' + this.headers[header][idx]);\n\t      }\n\t    }\n\t\n\t    if (headers.length > 0) {\n\t      uriString += '?' + headers.join('&');\n\t    }\n\t\n\t    return uriString;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t  * Parse the given string and returns a SIP.URI instance or undefined if\n\t  * it is an invalid URI.\n\t  * @public\n\t  * @param {String} uri\n\t  */\n\tURI.parse = function(uri) {\n\t  uri = SIP.Grammar.parse(uri,'SIP_URI');\n\t\n\t  if (uri !== -1) {\n\t    return uri;\n\t  } else {\n\t    return undefined;\n\t  }\n\t};\n\t\n\tSIP.URI = URI;\n\t};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP NameAddrHeader\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a Name Address SIP header.\n\t *\n\t * @param {SIP.URI} uri\n\t * @param {String} [displayName]\n\t * @param {Object} [parameters]\n\t *\n\t */\n\tmodule.exports = function (SIP) {\n\tvar NameAddrHeader;\n\t\n\tNameAddrHeader = function(uri, displayName, parameters) {\n\t  var param;\n\t\n\t  // Checks\n\t  if(!uri || !(uri instanceof SIP.URI)) {\n\t    throw new TypeError('missing or invalid \"uri\" parameter');\n\t  }\n\t\n\t  // Initialize parameters\n\t  this.uri = uri;\n\t  this.parameters = {};\n\t\n\t  for (param in parameters) {\n\t    this.setParam(param, parameters[param]);\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    friendlyName: {\n\t      get: function() { return this.displayName || uri.aor; }\n\t    },\n\t\n\t    displayName: {\n\t      get: function() { return displayName; },\n\t      set: function(value) {\n\t        displayName = (value === 0) ? '0' : value;\n\t      }\n\t    }\n\t  });\n\t};\n\tNameAddrHeader.prototype = {\n\t  setParam: function (key, value) {\n\t    if(key) {\n\t      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n\t    }\n\t  },\n\t  getParam: SIP.URI.prototype.getParam,\n\t  hasParam: SIP.URI.prototype.hasParam,\n\t  deleteParam: SIP.URI.prototype.deleteParam,\n\t  clearParams: SIP.URI.prototype.clearParams,\n\t\n\t  clone: function() {\n\t    return new NameAddrHeader(\n\t      this.uri.clone(),\n\t      this.displayName,\n\t      JSON.parse(JSON.stringify(this.parameters)));\n\t  },\n\t\n\t  toString: function() {\n\t    var body, parameter;\n\t\n\t    body  = (this.displayName || this.displayName === 0) ? '\"' + this.displayName + '\" ' : '';\n\t    body += '<' + this.uri.toString() + '>';\n\t\n\t    for (parameter in this.parameters) {\n\t      body += ';' + parameter;\n\t\n\t      if (this.parameters[parameter] !== null) {\n\t        body += '='+ this.parameters[parameter];\n\t      }\n\t    }\n\t\n\t    return body;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n\t  * it is an invalid NameAddrHeader.\n\t  * @public\n\t  * @param {String} name_addr_header\n\t  */\n\tNameAddrHeader.parse = function(name_addr_header) {\n\t  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');\n\t\n\t  if (name_addr_header !== -1) {\n\t    return name_addr_header;\n\t  } else {\n\t    return undefined;\n\t  }\n\t};\n\t\n\tSIP.NameAddrHeader = NameAddrHeader;\n\t};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Transactions\n\t */\n\t\n\t/**\n\t * SIP Transactions module.\n\t * @augments SIP\n\t */\n\tmodule.exports = function (SIP) {\n\tvar\n\t  C = {\n\t    // Transaction states\n\t    STATUS_TRYING:     1,\n\t    STATUS_PROCEEDING: 2,\n\t    STATUS_CALLING:    3,\n\t    STATUS_ACCEPTED:   4,\n\t    STATUS_COMPLETED:  5,\n\t    STATUS_TERMINATED: 6,\n\t    STATUS_CONFIRMED:  7,\n\t\n\t    // Transaction types\n\t    NON_INVITE_CLIENT: 'nict',\n\t    NON_INVITE_SERVER: 'nist',\n\t    INVITE_CLIENT: 'ict',\n\t    INVITE_SERVER: 'ist'\n\t  };\n\t\n\tfunction buildViaHeader (request_sender, transport, id) {\n\t  var via;\n\t  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n\t  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;\n\t  if (request_sender.ua.configuration.forceRport) {\n\t    via += ';rport';\n\t  }\n\t  return via;\n\t}\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Non Invite Client Transaction\n\t* @param {SIP.RequestSender} request_sender\n\t* @param {SIP.OutgoingRequest} request\n\t* @param {SIP.Transport} transport\n\t*/\n\tvar NonInviteClientTransaction = function(request_sender, request, transport) {\n\t  var via;\n\t\n\t  this.type = C.NON_INVITE_CLIENT;\n\t  this.transport = transport;\n\t  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n\t  this.request_sender = request_sender;\n\t  this.request = request;\n\t\n\t  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\t\n\t  via = buildViaHeader(request_sender, transport, this.id);\n\t  this.request.setHeader('via', via);\n\t\n\t  this.request_sender.ua.newTransaction(this);\n\t};\n\tNonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tNonInviteClientTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tNonInviteClientTransaction.prototype.send = function() {\n\t  var tr = this;\n\t\n\t  this.stateChanged(C.STATUS_TRYING);\n\t  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n\t\n\t  if(!this.transport.send(this.request)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\tNonInviteClientTransaction.prototype.onTransportError = function() {\n\t  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n\t  SIP.Timers.clearTimeout(this.F);\n\t  SIP.Timers.clearTimeout(this.K);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t  this.request_sender.onTransportError();\n\t};\n\t\n\tNonInviteClientTransaction.prototype.timer_F = function() {\n\t  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t  this.request_sender.onRequestTimeout();\n\t};\n\t\n\tNonInviteClientTransaction.prototype.timer_K = function() {\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t};\n\t\n\tNonInviteClientTransaction.prototype.receiveResponse = function(response) {\n\t  var\n\t    tr = this,\n\t    status_code = response.status_code;\n\t\n\t  if(status_code < 200) {\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_PROCEEDING);\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t    }\n\t  } else {\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_COMPLETED);\n\t        SIP.Timers.clearTimeout(this.F);\n\t\n\t        if(status_code === 408) {\n\t          this.request_sender.onRequestTimeout();\n\t        } else {\n\t          this.request_sender.receiveResponse(response);\n\t        }\n\t\n\t        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n\t        break;\n\t      case C.STATUS_COMPLETED:\n\t        break;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Invite Client Transaction\n\t* @param {SIP.RequestSender} request_sender\n\t* @param {SIP.OutgoingRequest} request\n\t* @param {SIP.Transport} transport\n\t*/\n\tvar InviteClientTransaction = function(request_sender, request, transport) {\n\t  var via,\n\t    tr = this;\n\t\n\t  this.type = C.INVITE_CLIENT;\n\t  this.transport = transport;\n\t  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n\t  this.request_sender = request_sender;\n\t  this.request = request;\n\t\n\t  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n\t\n\t  via = buildViaHeader(request_sender, transport, this.id);\n\t  this.request.setHeader('via', via);\n\t\n\t  this.request_sender.ua.newTransaction(this);\n\t\n\t  // Add the cancel property to the request.\n\t  //Will be called from the request instance, not the transaction itself.\n\t  this.request.cancel = function(reason) {\n\t    tr.cancel_request(tr, reason);\n\t  };\n\t};\n\tInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tInviteClientTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tInviteClientTransaction.prototype.send = function() {\n\t  var tr = this;\n\t  this.stateChanged(C.STATUS_CALLING);\n\t  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n\t\n\t  if(!this.transport.send(this.request)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\tInviteClientTransaction.prototype.onTransportError = function() {\n\t  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n\t  SIP.Timers.clearTimeout(this.B);\n\t  SIP.Timers.clearTimeout(this.D);\n\t  SIP.Timers.clearTimeout(this.M);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t\n\t  if (this.state !== C.STATUS_ACCEPTED) {\n\t    this.request_sender.onTransportError();\n\t  }\n\t};\n\t\n\t// RFC 6026 7.2\n\tInviteClientTransaction.prototype.timer_M = function() {\n\t  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);\n\t\n\t  if(this.state === C.STATUS_ACCEPTED) {\n\t    SIP.Timers.clearTimeout(this.B);\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.request_sender.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\t// RFC 3261 17.1.1\n\tInviteClientTransaction.prototype.timer_B = function() {\n\t  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);\n\t  if(this.state === C.STATUS_CALLING) {\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.request_sender.ua.destroyTransaction(this);\n\t    this.request_sender.onRequestTimeout();\n\t  }\n\t};\n\t\n\tInviteClientTransaction.prototype.timer_D = function() {\n\t  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);\n\t  SIP.Timers.clearTimeout(this.B);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.request_sender.ua.destroyTransaction(this);\n\t};\n\t\n\tInviteClientTransaction.prototype.sendACK = function(response) {\n\t  var tr = this;\n\t\n\t  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\\r\\n';\n\t  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\\r\\n';\n\t\n\t  if(this.request.headers['Route']) {\n\t    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\\r\\n';\n\t  }\n\t\n\t  this.ack += 'To: ' + response.getHeader('to') + '\\r\\n';\n\t  this.ack += 'From: ' + this.request.headers['From'].toString() + '\\r\\n';\n\t  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\\r\\n';\n\t  this.ack += 'Content-Length: 0\\r\\n';\n\t  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];\n\t  this.ack += ' ACK\\r\\n\\r\\n';\n\t\n\t  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);\n\t\n\t  this.transport.send(this.ack);\n\t};\n\t\n\tInviteClientTransaction.prototype.cancel_request = function(tr, reason) {\n\t  var request = tr.request;\n\t\n\t  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n\t  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n\t\n\t  if(this.request.headers['Route']) {\n\t    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n\t  }\n\t\n\t  this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n\t  this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n\t  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n\t  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +\n\t  ' CANCEL\\r\\n';\n\t\n\t  if(reason) {\n\t    this.cancel += 'Reason: ' + reason + '\\r\\n';\n\t  }\n\t\n\t  this.cancel += 'Content-Length: 0\\r\\n\\r\\n';\n\t\n\t  // Send only if a provisional response (>100) has been received.\n\t  if(this.state === C.STATUS_PROCEEDING) {\n\t    this.transport.send(this.cancel);\n\t  }\n\t};\n\t\n\tInviteClientTransaction.prototype.receiveResponse = function(response) {\n\t  var\n\t  tr = this,\n\t  status_code = response.status_code;\n\t\n\t  if(status_code >= 100 && status_code <= 199) {\n\t    switch(this.state) {\n\t      case C.STATUS_CALLING:\n\t        this.stateChanged(C.STATUS_PROCEEDING);\n\t        this.request_sender.receiveResponse(response);\n\t        if(this.cancel) {\n\t          this.transport.send(this.cancel);\n\t        }\n\t        break;\n\t      case C.STATUS_PROCEEDING:\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t    }\n\t  } else if(status_code >= 200 && status_code <= 299) {\n\t    switch(this.state) {\n\t      case C.STATUS_CALLING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_ACCEPTED);\n\t        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t      case C.STATUS_ACCEPTED:\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t    }\n\t  } else if(status_code >= 300 && status_code <= 699) {\n\t    switch(this.state) {\n\t      case C.STATUS_CALLING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_COMPLETED);\n\t        this.sendACK(response);\n\t        this.request_sender.receiveResponse(response);\n\t        break;\n\t      case C.STATUS_COMPLETED:\n\t        this.sendACK(response);\n\t        break;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * @augments SIP.Transactions\n\t * @class ACK Client Transaction\n\t * @param {SIP.RequestSender} request_sender\n\t * @param {SIP.OutgoingRequest} request\n\t * @param {SIP.Transport} transport\n\t */\n\tvar AckClientTransaction = function(request_sender, request, transport) {\n\t  var via;\n\t\n\t  this.transport = transport;\n\t  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n\t  this.request_sender = request_sender;\n\t  this.request = request;\n\t\n\t  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\t\n\t  via = buildViaHeader(request_sender, transport, this.id);\n\t  this.request.setHeader('via', via);\n\t};\n\tAckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tAckClientTransaction.prototype.send = function() {\n\t  if(!this.transport.send(this.request)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\tAckClientTransaction.prototype.onTransportError = function() {\n\t  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n\t  this.request_sender.onTransportError();\n\t};\n\t\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Non Invite Server Transaction\n\t* @param {SIP.IncomingRequest} request\n\t* @param {SIP.UA} ua\n\t*/\n\tvar NonInviteServerTransaction = function(request, ua) {\n\t  this.type = C.NON_INVITE_SERVER;\n\t  this.id = request.via_branch;\n\t  this.request = request;\n\t  this.transport = request.transport;\n\t  this.ua = ua;\n\t  this.last_response = '';\n\t  request.server_transaction = this;\n\t\n\t  this.logger = ua.getLogger('sip.transaction.nist', this.id);\n\t\n\t  this.state = C.STATUS_TRYING;\n\t\n\t  ua.newTransaction(this);\n\t};\n\tNonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tNonInviteServerTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tNonInviteServerTransaction.prototype.timer_J = function() {\n\t  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.ua.destroyTransaction(this);\n\t};\n\t\n\tNonInviteServerTransaction.prototype.onTransportError = function() {\n\t  if (!this.transportError) {\n\t    this.transportError = true;\n\t\n\t    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n\t\n\t    SIP.Timers.clearTimeout(this.J);\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\tNonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n\t  var tr = this;\n\t  var deferred = SIP.Utils.defer();\n\t\n\t  if(status_code === 100) {\n\t    /* RFC 4320 4.1\n\t     * 'A SIP element MUST NOT\n\t     * send any provisional response with a\n\t     * Status-Code other than 100 to a non-INVITE request.'\n\t     */\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t        this.stateChanged(C.STATUS_PROCEEDING);\n\t        if(!this.transport.send(response))  {\n\t          this.onTransportError();\n\t        }\n\t        break;\n\t      case C.STATUS_PROCEEDING:\n\t        this.last_response = response;\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t          deferred.reject();\n\t        } else {\n\t          deferred.resolve();\n\t        }\n\t        break;\n\t    }\n\t  } else if(status_code >= 200 && status_code <= 699) {\n\t    switch(this.state) {\n\t      case C.STATUS_TRYING:\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_COMPLETED);\n\t        this.last_response = response;\n\t        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t          deferred.reject();\n\t        } else {\n\t          deferred.resolve();\n\t        }\n\t        break;\n\t      case C.STATUS_COMPLETED:\n\t        break;\n\t    }\n\t  }\n\t\n\t  return deferred.promise;\n\t};\n\t\n\t/**\n\t* @augments SIP.Transactions\n\t* @class Invite Server Transaction\n\t* @param {SIP.IncomingRequest} request\n\t* @param {SIP.UA} ua\n\t*/\n\tvar InviteServerTransaction = function(request, ua) {\n\t  this.type = C.INVITE_SERVER;\n\t  this.id = request.via_branch;\n\t  this.request = request;\n\t  this.transport = request.transport;\n\t  this.ua = ua;\n\t  this.last_response = '';\n\t  request.server_transaction = this;\n\t\n\t  this.logger = ua.getLogger('sip.transaction.ist', this.id);\n\t\n\t  this.state = C.STATUS_PROCEEDING;\n\t\n\t  ua.newTransaction(this);\n\t\n\t  this.resendProvisionalTimer = null;\n\t\n\t  request.reply(100);\n\t};\n\tInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tInviteServerTransaction.prototype.stateChanged = function(state) {\n\t  this.state = state;\n\t  this.emit('stateChanged');\n\t};\n\t\n\tInviteServerTransaction.prototype.timer_H = function() {\n\t  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);\n\t\n\t  if(this.state === C.STATUS_COMPLETED) {\n\t    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n\t  }\n\t\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.ua.destroyTransaction(this);\n\t};\n\t\n\tInviteServerTransaction.prototype.timer_I = function() {\n\t  this.stateChanged(C.STATUS_TERMINATED);\n\t  this.ua.destroyTransaction(this);\n\t};\n\t\n\t// RFC 6026 7.1\n\tInviteServerTransaction.prototype.timer_L = function() {\n\t  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);\n\t\n\t  if(this.state === C.STATUS_ACCEPTED) {\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\tInviteServerTransaction.prototype.onTransportError = function() {\n\t  if (!this.transportError) {\n\t    this.transportError = true;\n\t\n\t    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n\t\n\t    if (this.resendProvisionalTimer !== null) {\n\t      SIP.Timers.clearInterval(this.resendProvisionalTimer);\n\t      this.resendProvisionalTimer = null;\n\t    }\n\t\n\t    SIP.Timers.clearTimeout(this.L);\n\t    SIP.Timers.clearTimeout(this.H);\n\t    SIP.Timers.clearTimeout(this.I);\n\t\n\t    this.stateChanged(C.STATUS_TERMINATED);\n\t    this.ua.destroyTransaction(this);\n\t  }\n\t};\n\t\n\tInviteServerTransaction.prototype.resend_provisional = function() {\n\t  if(!this.transport.send(this.last_response)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\t// INVITE Server Transaction RFC 3261 17.2.1\n\tInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n\t  var tr = this;\n\t  var deferred = SIP.Utils.defer();\n\t\n\t  if(status_code >= 100 && status_code <= 199) {\n\t    switch(this.state) {\n\t      case C.STATUS_PROCEEDING:\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t        }\n\t        this.last_response = response;\n\t        break;\n\t    }\n\t  }\n\t\n\t  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n\t    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n\t    if(this.resendProvisionalTimer === null) {\n\t      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),\n\t        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n\t    }\n\t  } else if(status_code >= 200 && status_code <= 299) {\n\t    switch(this.state) {\n\t      case C.STATUS_PROCEEDING:\n\t        this.stateChanged(C.STATUS_ACCEPTED);\n\t        this.last_response = response;\n\t        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n\t\n\t        if (this.resendProvisionalTimer !== null) {\n\t          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n\t          this.resendProvisionalTimer = null;\n\t        }\n\t        /* falls through */\n\t        case C.STATUS_ACCEPTED:\n\t          // Note that this point will be reached for proceeding tr.state also.\n\t          if(!this.transport.send(response)) {\n\t            this.onTransportError();\n\t            deferred.reject();\n\t          } else {\n\t            deferred.resolve();\n\t          }\n\t          break;\n\t    }\n\t  } else if(status_code >= 300 && status_code <= 699) {\n\t    switch(this.state) {\n\t      case C.STATUS_PROCEEDING:\n\t        if (this.resendProvisionalTimer !== null) {\n\t          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n\t          this.resendProvisionalTimer = null;\n\t        }\n\t\n\t        if(!this.transport.send(response)) {\n\t          this.onTransportError();\n\t          deferred.reject();\n\t        } else {\n\t          this.stateChanged(C.STATUS_COMPLETED);\n\t          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n\t          deferred.resolve();\n\t        }\n\t        break;\n\t    }\n\t  }\n\t\n\t  return deferred.promise;\n\t};\n\t\n\t/**\n\t * @function\n\t * @param {SIP.UA} ua\n\t * @param {SIP.IncomingRequest} request\n\t *\n\t * @return {boolean}\n\t * INVITE:\n\t *  _true_ if retransmission\n\t *  _false_ new request\n\t *\n\t * ACK:\n\t *  _true_  ACK to non2xx response\n\t *  _false_ ACK must be passed to TU (accepted state)\n\t *          ACK to 2xx response\n\t *\n\t * CANCEL:\n\t *  _true_  no matching invite transaction\n\t *  _false_ matching invite transaction and no final response sent\n\t *\n\t * OTHER:\n\t *  _true_  retransmission\n\t *  _false_ new request\n\t */\n\tvar checkTransaction = function(ua, request) {\n\t  var tr;\n\t\n\t  switch(request.method) {\n\t    case SIP.C.INVITE:\n\t      tr = ua.transactions.ist[request.via_branch];\n\t      if(tr) {\n\t        switch(tr.state) {\n\t          case C.STATUS_PROCEEDING:\n\t            tr.transport.send(tr.last_response);\n\t            break;\n\t\n\t            // RFC 6026 7.1 Invite retransmission\n\t            //received while in C.STATUS_ACCEPTED state. Absorb it.\n\t          case C.STATUS_ACCEPTED:\n\t            break;\n\t        }\n\t        return true;\n\t      }\n\t      break;\n\t    case SIP.C.ACK:\n\t      tr = ua.transactions.ist[request.via_branch];\n\t\n\t      // RFC 6026 7.1\n\t      if(tr) {\n\t        if(tr.state === C.STATUS_ACCEPTED) {\n\t          return false;\n\t        } else if(tr.state === C.STATUS_COMPLETED) {\n\t          tr.state = C.STATUS_CONFIRMED;\n\t          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n\t          return true;\n\t        }\n\t      }\n\t\n\t      // ACK to 2XX Response.\n\t      else {\n\t        return false;\n\t      }\n\t      break;\n\t    case SIP.C.CANCEL:\n\t      tr = ua.transactions.ist[request.via_branch];\n\t      if(tr) {\n\t        request.reply_sl(200);\n\t        if(tr.state === C.STATUS_PROCEEDING) {\n\t          return false;\n\t        } else {\n\t          return true;\n\t        }\n\t      } else {\n\t        request.reply_sl(481);\n\t        return true;\n\t      }\n\t      break;\n\t    default:\n\t\n\t      // Non-INVITE Server Transaction RFC 3261 17.2.2\n\t      tr = ua.transactions.nist[request.via_branch];\n\t      if(tr) {\n\t        switch(tr.state) {\n\t          case C.STATUS_TRYING:\n\t            break;\n\t          case C.STATUS_PROCEEDING:\n\t          case C.STATUS_COMPLETED:\n\t            tr.transport.send(tr.last_response);\n\t            break;\n\t        }\n\t        return true;\n\t      }\n\t      break;\n\t  }\n\t};\n\t\n\tSIP.Transactions = {\n\t  C: C,\n\t  checkTransaction: checkTransaction,\n\t  NonInviteClientTransaction: NonInviteClientTransaction,\n\t  InviteClientTransaction: InviteClientTransaction,\n\t  AckClientTransaction: AckClientTransaction,\n\t  NonInviteServerTransaction: NonInviteServerTransaction,\n\t  InviteServerTransaction: InviteServerTransaction\n\t};\n\t\n\t};\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview SIP Dialog\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP dialog.\n\t * @param {SIP.RTCSession} owner\n\t * @param {SIP.IncomingRequest|SIP.IncomingResponse} message\n\t * @param {Enum} type UAC / UAS\n\t * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED\n\t */\n\tmodule.exports = function (SIP) {\n\t\n\tvar RequestSender = __webpack_require__(31)(SIP);\n\t\n\tvar Dialog,\n\t  C = {\n\t    // Dialog states\n\t    STATUS_EARLY:       1,\n\t    STATUS_CONFIRMED:   2\n\t  };\n\t\n\t// RFC 3261 12.1\n\tDialog = function(owner, message, type, state) {\n\t  var contact;\n\t\n\t  this.uac_pending_reply = false;\n\t  this.uas_pending_reply = false;\n\t\n\t  if(!message.hasHeader('contact')) {\n\t    return {\n\t      error: 'unable to create a Dialog without Contact header field'\n\t    };\n\t  }\n\t\n\t  if(message instanceof SIP.IncomingResponse) {\n\t    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n\t  } else {\n\t    // Create confirmed dialog if state is not defined\n\t    state = state || C.STATUS_CONFIRMED;\n\t  }\n\t\n\t  contact = message.parseHeader('contact');\n\t\n\t  // RFC 3261 12.1.1\n\t  if(type === 'UAS') {\n\t    this.id = {\n\t      call_id: message.call_id,\n\t      local_tag: message.to_tag,\n\t      remote_tag: message.from_tag,\n\t      toString: function() {\n\t        return this.call_id + this.local_tag + this.remote_tag;\n\t      }\n\t    };\n\t    this.state = state;\n\t    this.remote_seqnum = message.cseq;\n\t    this.local_uri = message.parseHeader('to').uri;\n\t    this.remote_uri = message.parseHeader('from').uri;\n\t    this.remote_target = contact.uri;\n\t    this.route_set = message.getHeaders('record-route');\n\t    this.invite_seqnum = message.cseq;\n\t    this.local_seqnum = message.cseq;\n\t  }\n\t  // RFC 3261 12.1.2\n\t  else if(type === 'UAC') {\n\t    this.id = {\n\t      call_id: message.call_id,\n\t      local_tag: message.from_tag,\n\t      remote_tag: message.to_tag,\n\t      toString: function() {\n\t        return this.call_id + this.local_tag + this.remote_tag;\n\t      }\n\t    };\n\t    this.state = state;\n\t    this.invite_seqnum = message.cseq;\n\t    this.local_seqnum = message.cseq;\n\t    this.local_uri = message.parseHeader('from').uri;\n\t    this.pracked = [];\n\t    this.remote_uri = message.parseHeader('to').uri;\n\t    this.remote_target = contact.uri;\n\t    this.route_set = message.getHeaders('record-route').reverse();\n\t\n\t    //RENDERBODY\n\t    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {\n\t      this.mediaHandler = owner.mediaHandlerFactory(owner);\n\t    }\n\t  }\n\t\n\t  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());\n\t  this.owner = owner;\n\t  owner.ua.dialogs[this.id.toString()] = this;\n\t  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));\n\t  owner.emit('dialog', this);\n\t};\n\t\n\tDialog.prototype = {\n\t  /**\n\t   * @param {SIP.IncomingMessage} message\n\t   * @param {Enum} UAC/UAS\n\t   */\n\t  update: function(message, type) {\n\t    this.state = C.STATUS_CONFIRMED;\n\t\n\t    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');\n\t\n\t    if(type === 'UAC') {\n\t      // RFC 3261 13.2.2.4\n\t      this.route_set = message.getHeaders('record-route').reverse();\n\t    }\n\t  },\n\t\n\t  terminate: function() {\n\t    this.logger.log('dialog ' + this.id.toString() + ' deleted');\n\t    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {\n\t      this.mediaHandler.peerConnection.close();\n\t    }\n\t    delete this.owner.ua.dialogs[this.id.toString()];\n\t  },\n\t\n\t  /**\n\t  * @param {String} method request method\n\t  * @param {Object} extraHeaders extra headers\n\t  * @returns {SIP.OutgoingRequest}\n\t  */\n\t\n\t  // RFC 3261 12.2.1.1\n\t  createRequest: function(method, extraHeaders, body) {\n\t    var cseq, request;\n\t    extraHeaders = (extraHeaders || []).slice();\n\t\n\t    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }\n\t\n\t    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;\n\t\n\t    request = new SIP.OutgoingRequest(\n\t      method,\n\t      this.remote_target,\n\t      this.owner.ua, {\n\t        'cseq': cseq,\n\t        'call_id': this.id.call_id,\n\t        'from_uri': this.local_uri,\n\t        'from_tag': this.id.local_tag,\n\t        'to_uri': this.remote_uri,\n\t        'to_tag': this.id.remote_tag,\n\t        'route_set': this.route_set\n\t      }, extraHeaders, body);\n\t\n\t    request.dialog = this;\n\t\n\t    return request;\n\t  },\n\t\n\t  /**\n\t  * @param {SIP.IncomingRequest} request\n\t  * @returns {Boolean}\n\t  */\n\t\n\t  // RFC 3261 12.2.2\n\t  checkInDialogRequest: function(request) {\n\t    var self = this;\n\t\n\t    if(!this.remote_seqnum) {\n\t      this.remote_seqnum = request.cseq;\n\t    } else if(request.cseq < this.remote_seqnum) {\n\t        //Do not try to reply to an ACK request.\n\t        if (request.method !== SIP.C.ACK) {\n\t          request.reply(500);\n\t        }\n\t        if (request.cseq === this.invite_seqnum) {\n\t          return true;\n\t        }\n\t        return false;\n\t    } else if(request.cseq > this.remote_seqnum) {\n\t      this.remote_seqnum = request.cseq;\n\t    }\n\t\n\t    switch(request.method) {\n\t      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-\n\t      case SIP.C.INVITE:\n\t        if (this.uac_pending_reply === true) {\n\t          request.reply(491);\n\t        } else if (this.uas_pending_reply === true) {\n\t          var retryAfter = (Math.random() * 10 | 0) + 1;\n\t          request.reply(500, null, ['Retry-After:' + retryAfter]);\n\t          return false;\n\t        } else {\n\t          this.uas_pending_reply = true;\n\t          request.server_transaction.on('stateChanged', function stateChanged(){\n\t            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n\t                this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n\t                this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\t\n\t              this.removeListener('stateChanged', stateChanged);\n\t              self.uas_pending_reply = false;\n\t\n\t              if (self.uac_pending_reply === false) {\n\t                self.owner.onReadyToReinvite();\n\t              }\n\t            }\n\t          });\n\t        }\n\t\n\t        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted\n\t        if(request.hasHeader('contact')) {\n\t          request.server_transaction.on('stateChanged', function(){\n\t            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {\n\t              self.remote_target = request.parseHeader('contact').uri;\n\t            }\n\t          });\n\t        }\n\t        break;\n\t      case SIP.C.NOTIFY:\n\t        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted\n\t        if(request.hasHeader('contact')) {\n\t          request.server_transaction.on('stateChanged', function(){\n\t            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {\n\t              self.remote_target = request.parseHeader('contact').uri;\n\t            }\n\t          });\n\t        }\n\t        break;\n\t    }\n\t\n\t    return true;\n\t  },\n\t\n\t  sendRequest: function(applicant, method, options) {\n\t    options = options || {};\n\t\n\t    var\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t      body = options.body || null,\n\t      request = this.createRequest(method, extraHeaders, body),\n\t      request_sender = new RequestSender(this, applicant, request);\n\t\n\t    request_sender.send();\n\t\n\t    return request;\n\t  },\n\t\n\t  /**\n\t  * @param {SIP.IncomingRequest} request\n\t  */\n\t  receiveRequest: function(request) {\n\t    //Check in-dialog request\n\t    if(!this.checkInDialogRequest(request)) {\n\t      return;\n\t    }\n\t\n\t    this.owner.receiveRequest(request);\n\t  }\n\t};\n\t\n\tDialog.C = C;\n\tSIP.Dialog = Dialog;\n\t};\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview In-Dialog Request Sender\n\t */\n\t\n\t/**\n\t * @augments SIP.Dialog\n\t * @class Class creating an In-dialog request sender.\n\t * @param {SIP.Dialog} dialog\n\t * @param {Object} applicant\n\t * @param {SIP.OutgoingRequest} request\n\t */\n\t/**\n\t * @fileoverview in-Dialog Request Sender\n\t */\n\t\n\tmodule.exports = function (SIP) {\n\tvar RequestSender;\n\t\n\tRequestSender = function(dialog, applicant, request) {\n\t\n\t  this.dialog = dialog;\n\t  this.applicant = applicant;\n\t  this.request = request;\n\t\n\t  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n\t  this.reattempt = false;\n\t  this.reattemptTimer = null;\n\t};\n\t\n\tRequestSender.prototype = {\n\t  send: function() {\n\t    var self = this,\n\t      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);\n\t\n\t      request_sender.send();\n\t\n\t    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-\n\t    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n\t      this.dialog.uac_pending_reply = true;\n\t      request_sender.clientTransaction.on('stateChanged', function stateChanged(){\n\t        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n\t            this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n\t            this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\t\n\t          this.removeListener('stateChanged', stateChanged);\n\t          self.dialog.uac_pending_reply = false;\n\t\n\t          if (self.dialog.uas_pending_reply === false) {\n\t            self.dialog.owner.onReadyToReinvite();\n\t          }\n\t        }\n\t      });\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    this.applicant.onRequestTimeout();\n\t  },\n\t\n\t  onTransportError: function() {\n\t    this.applicant.onTransportError();\n\t  },\n\t\n\t  receiveResponse: function(response) {\n\t    var self = this;\n\t\n\t    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n\t    if (response.status_code === 408 || response.status_code === 481) {\n\t      this.applicant.onDialogError(response);\n\t    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {\n\t      if (this.reattempt) {\n\t        this.applicant.receiveResponse(response);\n\t      } else {\n\t        this.request.cseq.value = this.dialog.local_seqnum += 1;\n\t        this.reattemptTimer = SIP.Timers.setTimeout(\n\t          function() {\n\t            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {\n\t              self.reattempt = true;\n\t              self.request_sender.send();\n\t            }\n\t          },\n\t          this.getReattemptTimeout()\n\t        );\n\t      }\n\t    } else {\n\t      this.applicant.receiveResponse(response);\n\t    }\n\t  }\n\t};\n\t\n\treturn RequestSender;\n\t};\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview Request Sender\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a request sender.\n\t * @param {Object} applicant\n\t * @param {SIP.UA} ua\n\t */\n\tmodule.exports = function (SIP) {\n\tvar RequestSender;\n\t\n\tRequestSender = function(applicant, ua) {\n\t  this.logger = ua.getLogger('sip.requestsender');\n\t  this.ua = ua;\n\t  this.applicant = applicant;\n\t  this.method = applicant.request.method;\n\t  this.request = applicant.request;\n\t  this.credentials = null;\n\t  this.challenged = false;\n\t  this.staled = false;\n\t\n\t  // If ua is in closing process or even closed just allow sending Bye and ACK\n\t  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n\t    this.onTransportError();\n\t  }\n\t};\n\t\n\t/**\n\t* Create the client transaction and send the message.\n\t*/\n\tRequestSender.prototype = {\n\t  send: function() {\n\t    switch(this.method) {\n\t      case \"INVITE\":\n\t        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n\t        break;\n\t      case \"ACK\":\n\t        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n\t        break;\n\t      default:\n\t        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n\t    }\n\t    this.clientTransaction.send();\n\t\n\t    return this.clientTransaction;\n\t  },\n\t\n\t  /**\n\t  * Callback fired when receiving a request timeout error from the client transaction.\n\t  * To be re-defined by the applicant.\n\t  * @event\n\t  */\n\t  onRequestTimeout: function() {\n\t    this.applicant.onRequestTimeout();\n\t  },\n\t\n\t  /**\n\t  * Callback fired when receiving a transport error from the client transaction.\n\t  * To be re-defined by the applicant.\n\t  * @event\n\t  */\n\t  onTransportError: function() {\n\t    this.applicant.onTransportError();\n\t  },\n\t\n\t  /**\n\t  * Called from client transaction when receiving a correct response to the request.\n\t  * Authenticate request if needed or pass the response back to the applicant.\n\t  * @param {SIP.IncomingResponse} response\n\t  */\n\t  receiveResponse: function(response) {\n\t    var cseq, challenge, authorization_header_name,\n\t      status_code = response.status_code;\n\t\n\t    /*\n\t    * Authentication\n\t    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n\t    */\n\t    if (status_code === 401 || status_code === 407) {\n\t\n\t      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n\t      if (response.status_code === 401) {\n\t        challenge = response.parseHeader('www-authenticate');\n\t        authorization_header_name = 'authorization';\n\t      } else {\n\t        challenge = response.parseHeader('proxy-authenticate');\n\t        authorization_header_name = 'proxy-authorization';\n\t      }\n\t\n\t      // Verify it seems a valid challenge.\n\t      if (! challenge) {\n\t        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n\t        this.applicant.receiveResponse(response);\n\t        return;\n\t      }\n\t\n\t      if (!this.challenged || (!this.staled && challenge.stale === true)) {\n\t        if (!this.credentials) {\n\t          this.credentials = this.ua.configuration.authenticationFactory(this.ua);\n\t        }\n\t\n\t        // Verify that the challenge is really valid.\n\t        if (!this.credentials.authenticate(this.request, challenge)) {\n\t          this.applicant.receiveResponse(response);\n\t          return;\n\t        }\n\t        this.challenged = true;\n\t\n\t        if (challenge.stale) {\n\t          this.staled = true;\n\t        }\n\t\n\t        if (response.method === SIP.C.REGISTER) {\n\t          cseq = this.applicant.cseq += 1;\n\t        } else if (this.request.dialog){\n\t          cseq = this.request.dialog.local_seqnum += 1;\n\t        } else {\n\t          cseq = this.request.cseq + 1;\n\t          this.request.cseq = cseq;\n\t        }\n\t        this.request.setHeader('cseq', cseq +' '+ this.method);\n\t\n\t        this.request.setHeader(authorization_header_name, this.credentials.toString());\n\t        this.send();\n\t      } else {\n\t        this.applicant.receiveResponse(response);\n\t      }\n\t    } else {\n\t      this.applicant.receiveResponse(response);\n\t    }\n\t  }\n\t};\n\t\n\tSIP.RequestSender = RequestSender;\n\t};\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP) {\n\t\n\tvar RegisterContext;\n\t\n\tRegisterContext = function (ua) {\n\t  var params = {},\n\t      regId = 1;\n\t\n\t  this.registrar = ua.configuration.registrarServer;\n\t  this.expires = ua.configuration.registerExpires;\n\t\n\t\n\t  // Contact header\n\t  this.contact = ua.contact.toString();\n\t\n\t  if(regId) {\n\t    this.contact += ';reg-id='+ regId;\n\t    this.contact += ';+sip.instance=\"<urn:uuid:'+ ua.configuration.instanceId+'>\"';\n\t  }\n\t\n\t  // Call-ID and CSeq values RFC3261 10.2\n\t  this.call_id = SIP.Utils.createRandomToken(22);\n\t  this.cseq = 80;\n\t\n\t  this.to_uri = ua.configuration.uri;\n\t\n\t  params.to_uri = this.to_uri;\n\t  params.to_displayName = ua.configuration.displayName;\n\t  params.call_id = this.call_id;\n\t  params.cseq = this.cseq;\n\t\n\t  // Extends ClientContext\n\t  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);\n\t\n\t  this.registrationTimer = null;\n\t  this.registrationExpiredTimer = null;\n\t\n\t  // Set status\n\t  this.registered = false;\n\t\n\t  this.logger = ua.getLogger('sip.registercontext');\n\t};\n\t\n\tRegisterContext.prototype = {\n\t  register: function (options) {\n\t    var self = this, extraHeaders;\n\t\n\t    // Handle Options\n\t    this.options = options || {};\n\t    extraHeaders = (this.options.extraHeaders || []).slice();\n\t    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n\t    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t    // Save original extraHeaders to be used in .close\n\t    this.closeHeaders = this.options.closeWithHeaders ?\n\t      (this.options.extraHeaders || []).slice() : [];\n\t\n\t    this.receiveResponse = function(response) {\n\t      var contact, expires,\n\t        contacts = response.getHeaders('contact').length,\n\t        cause;\n\t\n\t      // Discard responses to older REGISTER/un-REGISTER requests.\n\t      if(response.cseq !== this.cseq) {\n\t        return;\n\t      }\n\t\n\t      // Clear registration timer\n\t      if (this.registrationTimer !== null) {\n\t        SIP.Timers.clearTimeout(this.registrationTimer);\n\t        this.registrationTimer = null;\n\t      }\n\t\n\t      switch(true) {\n\t        case /^1[0-9]{2}$/.test(response.status_code):\n\t          this.emit('progress', response);\n\t          break;\n\t        case /^2[0-9]{2}$/.test(response.status_code):\n\t          this.emit('accepted', response);\n\t\n\t          if(response.hasHeader('expires')) {\n\t            expires = response.getHeader('expires');\n\t          }\n\t\n\t          if (this.registrationExpiredTimer !== null) {\n\t            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n\t            this.registrationExpiredTimer = null;\n\t          }\n\t\n\t          // Search the Contact pointing to us and update the expires value accordingly.\n\t          if (!contacts) {\n\t            this.logger.warn('no Contact header in response to REGISTER, response ignored');\n\t            break;\n\t          }\n\t\n\t          while(contacts--) {\n\t            contact = response.parseHeader('contact', contacts);\n\t            if(contact.uri.user === this.ua.contact.uri.user) {\n\t              expires = contact.getParam('expires');\n\t              break;\n\t            } else {\n\t              contact = null;\n\t            }\n\t          }\n\t\n\t          if (!contact) {\n\t            this.logger.warn('no Contact header pointing to us, response ignored');\n\t            break;\n\t          }\n\t\n\t          if(!expires) {\n\t            expires = this.expires;\n\t          }\n\t\n\t          // Re-Register before the expiration interval has elapsed.\n\t          // For that, decrease the expires value. ie: 3 seconds\n\t          this.registrationTimer = SIP.Timers.setTimeout(function() {\n\t            self.registrationTimer = null;\n\t            self.register(self.options);\n\t          }, (expires * 1000) - 3000);\n\t          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n\t            self.logger.warn('registration expired');\n\t            if (self.registered) {\n\t              self.unregistered(null, SIP.C.causes.EXPIRES);\n\t            }\n\t          }, expires * 1000);\n\t\n\t          //Save gruu values\n\t          if (contact.hasParam('temp-gruu')) {\n\t            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g,''));\n\t          }\n\t          if (contact.hasParam('pub-gruu')) {\n\t            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g,''));\n\t          }\n\t\n\t          this.registered = true;\n\t          this.emit('registered', response || null);\n\t          break;\n\t        // Interval too brief RFC3261 10.2.8\n\t        case /^423$/.test(response.status_code):\n\t          if(response.hasHeader('min-expires')) {\n\t            // Increase our registration interval to the suggested minimum\n\t            this.expires = response.getHeader('min-expires');\n\t            // Attempt the registration again immediately\n\t            this.register(this.options);\n\t          } else { //This response MUST contain a Min-Expires header field\n\t            this.logger.warn('423 response received for REGISTER without Min-Expires');\n\t            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n\t          }\n\t          break;\n\t        default:\n\t          cause = SIP.Utils.sipErrorCause(response.status_code);\n\t          this.registrationFailure(response, cause);\n\t      }\n\t    };\n\t\n\t    this.onRequestTimeout = function() {\n\t      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    };\n\t\n\t    this.onTransportError = function() {\n\t      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n\t    };\n\t\n\t    this.cseq++;\n\t    this.request.cseq = this.cseq;\n\t    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n\t    this.request.extraHeaders = extraHeaders;\n\t    this.send();\n\t  },\n\t\n\t  registrationFailure: function (response, cause) {\n\t    this.emit('failed', response || null, cause || null);\n\t  },\n\t\n\t  onTransportClosed: function() {\n\t    this.registered_before = this.registered;\n\t    if (this.registrationTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.registrationTimer);\n\t      this.registrationTimer = null;\n\t    }\n\t\n\t    if (this.registrationExpiredTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n\t      this.registrationExpiredTimer = null;\n\t    }\n\t\n\t    if(this.registered) {\n\t      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onTransportConnected: function() {\n\t    this.register(this.options);\n\t  },\n\t\n\t  close: function() {\n\t    var options = {\n\t      all: false,\n\t      extraHeaders: this.closeHeaders\n\t    };\n\t\n\t    this.registered_before = this.registered;\n\t    this.unregister(options);\n\t  },\n\t\n\t  unregister: function(options) {\n\t    var extraHeaders;\n\t\n\t    options = options || {};\n\t\n\t    if(!this.registered && !options.all) {\n\t      this.logger.warn('already unregistered');\n\t      return;\n\t    }\n\t\n\t    extraHeaders = (options.extraHeaders || []).slice();\n\t\n\t    this.registered = false;\n\t\n\t    // Clear the registration timer.\n\t    if (this.registrationTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.registrationTimer);\n\t      this.registrationTimer = null;\n\t    }\n\t\n\t    if(options.all) {\n\t      extraHeaders.push('Contact: *');\n\t      extraHeaders.push('Expires: 0');\n\t    } else {\n\t      extraHeaders.push('Contact: '+ this.contact + ';expires=0');\n\t    }\n\t\n\t\n\t    this.receiveResponse = function(response) {\n\t      var cause;\n\t\n\t      switch(true) {\n\t        case /^1[0-9]{2}$/.test(response.status_code):\n\t          this.emit('progress', response);\n\t          break;\n\t        case /^2[0-9]{2}$/.test(response.status_code):\n\t          this.emit('accepted', response);\n\t          if (this.registrationExpiredTimer !== null) {\n\t            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n\t            this.registrationExpiredTimer = null;\n\t          }\n\t          this.unregistered(response);\n\t          break;\n\t        default:\n\t          cause = SIP.Utils.sipErrorCause(response.status_code);\n\t          this.unregistered(response,cause);\n\t      }\n\t    };\n\t\n\t    this.onRequestTimeout = function() {\n\t      // Not actually unregistered...\n\t      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    };\n\t\n\t    this.onTransportError = function() {\n\t      // Not actually unregistered...\n\t      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n\t    };\n\t\n\t    this.cseq++;\n\t    this.request.cseq = this.cseq;\n\t    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n\t    this.request.extraHeaders = extraHeaders;\n\t\n\t    this.send();\n\t  },\n\t\n\t  unregistered: function(response, cause) {\n\t    this.registered = false;\n\t    this.emit('unregistered', response || null, cause || null);\n\t  }\n\t\n\t};\n\t\n\t\n\tSIP.RegisterContext = RegisterContext;\n\t};\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview MediaHandler\n\t */\n\t\n\t/* MediaHandler\n\t * @class PeerConnection helper Class.\n\t * @param {SIP.Session} session\n\t * @param {Object} [options]\n\t */\n\tmodule.exports = function (EventEmitter) {\n\tvar MediaHandler = function(session, options) {\n\t  // keep jshint happy\n\t  session = session;\n\t  options = options;\n\t};\n\t\n\tMediaHandler.prototype = Object.create(EventEmitter.prototype, {\n\t  isReady: {value: function isReady () {}},\n\t\n\t  close: {value: function close () {}},\n\t\n\t  /**\n\t   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.\n\t   */\n\t  getDescription: {value: function getDescription (mediaHint) {\n\t    // keep jshint happy\n\t    mediaHint = mediaHint;\n\t  }},\n\t\n\t  /**\n\t  * Message reception.\n\t  * @param {String} type\n\t  * @param {String} description\n\t  */\n\t  setDescription: {value: function setDescription (description) {\n\t    // keep jshint happy\n\t    description = description;\n\t  }}\n\t});\n\t\n\treturn MediaHandler;\n\t};\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP) {\n\tvar ClientContext;\n\t\n\tClientContext = function (ua, method, target, options) {\n\t  var originalTarget = target;\n\t\n\t  // Validate arguments\n\t  if (target === undefined) {\n\t    throw new TypeError('Not enough arguments');\n\t  }\n\t\n\t  this.ua = ua;\n\t  this.logger = ua.getLogger('sip.clientcontext');\n\t  this.method = method;\n\t  target = ua.normalizeTarget(target);\n\t  if (!target) {\n\t    throw new TypeError('Invalid target: ' + originalTarget);\n\t  }\n\t\n\t  /* Options\n\t   * - extraHeaders\n\t   * - params\n\t   * - contentType\n\t   * - body\n\t   */\n\t  options = Object.create(options || Object.prototype);\n\t  options.extraHeaders = (options.extraHeaders || []).slice();\n\t\n\t  if (options.contentType) {\n\t    this.contentType = options.contentType;\n\t    options.extraHeaders.push('Content-Type: ' + this.contentType);\n\t  }\n\t\n\t  // Build the request\n\t  this.request = new SIP.OutgoingRequest(this.method,\n\t                                         target,\n\t                                         this.ua,\n\t                                         options.params,\n\t                                         options.extraHeaders);\n\t  if (options.body) {\n\t    this.body = options.body;\n\t    this.request.body = this.body;\n\t  }\n\t\n\t  /* Set other properties from the request */\n\t  this.localIdentity = this.request.from;\n\t  this.remoteIdentity = this.request.to;\n\t\n\t  this.data = {};\n\t};\n\tClientContext.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tClientContext.prototype.send = function () {\n\t  (new SIP.RequestSender(this, this.ua)).send();\n\t  return this;\n\t};\n\t\n\tClientContext.prototype.cancel = function (options) {\n\t  options = options || {};\n\t\n\t  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n\t  this.request.cancel(cancel_reason);\n\t\n\t  this.emit('cancel');\n\t};\n\t\n\tClientContext.prototype.receiveResponse = function (response) {\n\t  var cause = SIP.Utils.getReasonPhrase(response.status_code);\n\t\n\t  switch(true) {\n\t    case /^1[0-9]{2}$/.test(response.status_code):\n\t      this.emit('progress', response, cause);\n\t      break;\n\t\n\t    case /^2[0-9]{2}$/.test(response.status_code):\n\t      if(this.ua.applicants[this]) {\n\t        delete this.ua.applicants[this];\n\t      }\n\t      this.emit('accepted', response, cause);\n\t      break;\n\t\n\t    default:\n\t      if(this.ua.applicants[this]) {\n\t        delete this.ua.applicants[this];\n\t      }\n\t      this.emit('rejected', response, cause);\n\t      this.emit('failed', response, cause);\n\t      break;\n\t  }\n\t\n\t};\n\t\n\tClientContext.prototype.onRequestTimeout = function () {\n\t  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n\t};\n\t\n\tClientContext.prototype.onTransportError = function () {\n\t  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n\t};\n\t\n\tSIP.ClientContext = ClientContext;\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP) {\n\tvar ServerContext;\n\t\n\tServerContext = function (ua, request) {\n\t  this.ua = ua;\n\t  this.logger = ua.getLogger('sip.servercontext');\n\t  this.request = request;\n\t  if (request.method === SIP.C.INVITE) {\n\t    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);\n\t  } else {\n\t    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);\n\t  }\n\t\n\t  if (request.body) {\n\t    this.body = request.body;\n\t  }\n\t  if (request.hasHeader('Content-Type')) {\n\t    this.contentType = request.getHeader('Content-Type');\n\t  }\n\t  this.method = request.method;\n\t\n\t  this.data = {};\n\t\n\t  this.localIdentity = request.to;\n\t  this.remoteIdentity = request.from;\n\t};\n\t\n\tServerContext.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\tServerContext.prototype.progress = function (options) {\n\t  options = Object.create(options || Object.prototype);\n\t  options.statusCode || (options.statusCode = 180);\n\t  options.minCode = 100;\n\t  options.maxCode = 199;\n\t  options.events = ['progress'];\n\t  return this.reply(options);\n\t};\n\t\n\tServerContext.prototype.accept = function (options) {\n\t  options = Object.create(options || Object.prototype);\n\t  options.statusCode || (options.statusCode = 200);\n\t  options.minCode = 200;\n\t  options.maxCode = 299;\n\t  options.events = ['accepted'];\n\t  return this.reply(options);\n\t};\n\t\n\tServerContext.prototype.reject = function (options) {\n\t  options = Object.create(options || Object.prototype);\n\t  options.statusCode || (options.statusCode = 480);\n\t  options.minCode = 300;\n\t  options.maxCode = 699;\n\t  options.events = ['rejected', 'failed'];\n\t  return this.reply(options);\n\t};\n\t\n\tServerContext.prototype.reply = function (options) {\n\t  options = options || {}; // This is okay, so long as we treat options as read-only in this method\n\t  var\n\t    statusCode = options.statusCode || 100,\n\t    minCode = options.minCode || 100,\n\t    maxCode = options.maxCode || 699,\n\t    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),\n\t    extraHeaders = options.extraHeaders || [],\n\t    body = options.body,\n\t    events = options.events || [],\n\t    response;\n\t\n\t  if (statusCode < minCode || statusCode > maxCode) {\n\t    throw new TypeError('Invalid statusCode: ' + statusCode);\n\t  }\n\t  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\t  events.forEach(function (event) {\n\t    this.emit(event, response, reasonPhrase);\n\t  }, this);\n\t\n\t  return this;\n\t};\n\t\n\tServerContext.prototype.onRequestTimeout = function () {\n\t  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n\t};\n\t\n\tServerContext.prototype.onTransportError = function () {\n\t  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n\t};\n\t\n\tSIP.ServerContext = ServerContext;\n\t};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tmodule.exports = function (SIP, environment) {\n\t\n\tvar DTMF = __webpack_require__(38)(SIP);\n\t\n\tvar Session, InviteServerContext, InviteClientContext,\n\t C = {\n\t    //Session states\n\t    STATUS_NULL:                        0,\n\t    STATUS_INVITE_SENT:                 1,\n\t    STATUS_1XX_RECEIVED:                2,\n\t    STATUS_INVITE_RECEIVED:             3,\n\t    STATUS_WAITING_FOR_ANSWER:          4,\n\t    STATUS_ANSWERED:                    5,\n\t    STATUS_WAITING_FOR_PRACK:           6,\n\t    STATUS_WAITING_FOR_ACK:             7,\n\t    STATUS_CANCELED:                    8,\n\t    STATUS_TERMINATED:                  9,\n\t    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n\t    STATUS_EARLY_MEDIA:                11,\n\t    STATUS_CONFIRMED:                  12\n\t  };\n\t\n\t/*\n\t * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]\n\t *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)\n\t */\n\tSession = function (mediaHandlerFactory) {\n\t  this.status = C.STATUS_NULL;\n\t  this.dialog = null;\n\t  this.earlyDialogs = {};\n\t  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;\n\t  // this.mediaHandler gets set by ICC/ISC constructors\n\t  this.hasOffer = false;\n\t  this.hasAnswer = false;\n\t\n\t  // Session Timers\n\t  this.timers = {\n\t    ackTimer: null,\n\t    expiresTimer: null,\n\t    invite2xxTimer: null,\n\t    userNoAnswerTimer: null,\n\t    rel1xxTimer: null,\n\t    prackTimer: null\n\t  };\n\t\n\t  // Session info\n\t  this.startTime = null;\n\t  this.endTime = null;\n\t  this.tones = null;\n\t\n\t  // Mute/Hold state\n\t  this.local_hold = false;\n\t  this.remote_hold = false;\n\t\n\t  this.pending_actions = {\n\t    actions: [],\n\t\n\t    length: function() {\n\t      return this.actions.length;\n\t    },\n\t\n\t    isPending: function(name){\n\t      var\n\t      idx = 0,\n\t      length = this.actions.length;\n\t\n\t      for (idx; idx<length; idx++) {\n\t        if (this.actions[idx].name === name) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    },\n\t\n\t    shift: function() {\n\t      return this.actions.shift();\n\t    },\n\t\n\t    push: function(name) {\n\t      this.actions.push({\n\t        name: name\n\t      });\n\t    },\n\t\n\t    pop: function(name) {\n\t      var\n\t      idx = 0,\n\t      length = this.actions.length;\n\t\n\t      for (idx; idx<length; idx++) {\n\t        if (this.actions[idx].name === name) {\n\t          this.actions.splice(idx,1);\n\t          length --;\n\t          idx--;\n\t        }\n\t      }\n\t    }\n\t   };\n\t\n\t  this.early_sdp = null;\n\t  this.rel100 = SIP.C.supported.UNSUPPORTED;\n\t};\n\t\n\tSession.prototype = {\n\t  dtmf: function(tones, options) {\n\t    var tone, dtmfs = [],\n\t        self = this;\n\t\n\t    options = options || {};\n\t\n\t    if (tones === undefined) {\n\t      throw new TypeError('Not enough arguments');\n\t    }\n\t\n\t    // Check Session Status\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    // Check tones\n\t    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n\t      throw new TypeError('Invalid tones: '+ tones);\n\t    }\n\t\n\t    tones = tones.toString().split('');\n\t\n\t    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }\n\t\n\t    if (this.tones) {\n\t      // Tones are already queued, just add to the queue\n\t      this.tones =  this.tones.concat(dtmfs);\n\t      return this;\n\t    }\n\t\n\t    var sendDTMF = function () {\n\t      var dtmf, timeout;\n\t\n\t      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n\t        // Stop sending DTMF\n\t        self.tones = null;\n\t        return this;\n\t      }\n\t\n\t      dtmf = self.tones.shift();\n\t\n\t      if (tone === ',') {\n\t        timeout = 2000;\n\t      } else {\n\t        dtmf.on('failed', function(){self.tones = null;});\n\t        dtmf.send(options);\n\t        timeout = dtmf.duration + dtmf.interToneGap;\n\t      }\n\t\n\t      // Set timeout for the next tone\n\t      SIP.Timers.setTimeout(sendDTMF, timeout);\n\t    };\n\t\n\t    this.tones = dtmfs;\n\t    sendDTMF();\n\t    return this;\n\t  },\n\t\n\t  bye: function(options) {\n\t    options = Object.create(options || Object.prototype);\n\t    var statusCode = options.statusCode;\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      this.logger.error('Error: Attempted to send BYE in a terminated session.');\n\t      return this;\n\t    }\n\t\n\t    this.logger.log('terminating Session');\n\t\n\t    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n\t      throw new TypeError('Invalid statusCode: '+ statusCode);\n\t    }\n\t\n\t    options.receiveResponse = function () {};\n\t\n\t    return this.\n\t      sendRequest(SIP.C.BYE, options).\n\t      terminated();\n\t  },\n\t\n\t  refer: function(target, options) {\n\t    options = options || {};\n\t    var extraHeaders = (options.extraHeaders || []).slice(),\n\t        withReplaces =\n\t          target instanceof SIP.InviteServerContext ||\n\t          target instanceof SIP.InviteClientContext,\n\t        originalTarget = target;\n\t\n\t    if (target === undefined) {\n\t      throw new TypeError('Not enough arguments');\n\t    }\n\t\n\t    // Check Session Status\n\t    if (this.status !== C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    // transform `target` so that it can be a Refer-To header value\n\t    if (withReplaces) {\n\t      //Attended Transfer\n\t      // B.transfer(C)\n\t      target = '\"' + target.remoteIdentity.friendlyName + '\" ' +\n\t        '<' + target.dialog.remote_target.toString() +\n\t        '?Replaces=' + target.dialog.id.call_id +\n\t        '%3Bto-tag%3D' + target.dialog.id.remote_tag +\n\t        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';\n\t    } else {\n\t      //Blind Transfer\n\t      // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n\t      // so try to make one ahead of time\n\t      try {\n\t        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n\t      } catch (e) {\n\t        this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n\t        this.logger.debug(\"...falling through to normalizeTarget()\");\n\t      }\n\t\n\t      // Check target validity\n\t      target = this.ua.normalizeTarget(target);\n\t      if (!target) {\n\t        throw new TypeError('Invalid target: ' + originalTarget);\n\t      }\n\t    }\n\t\n\t    extraHeaders.push('Contact: '+ this.contact);\n\t    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t    extraHeaders.push('Refer-To: '+ target);\n\t\n\t    // Send the request\n\t    this.sendRequest(SIP.C.REFER, {\n\t      extraHeaders: extraHeaders,\n\t      body: options.body,\n\t      receiveResponse: function (response) {\n\t        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {\n\t          return;\n\t        }\n\t        // hang up only if we transferred to a SIP address\n\t        if (withReplaces || (target.scheme && target.scheme.match(\"^sips?$\"))) {\n\t          this.terminate();\n\t        }\n\t      }.bind(this)\n\t    });\n\t    return this;\n\t  },\n\t\n\t  followRefer: function followRefer (callback) {\n\t    return function referListener (callback, request) {\n\t      // open non-SIP URIs if possible and keep session open\n\t      var referTo = request.parseHeader('refer-to');\n\t      var target = referTo.uri;\n\t      if (!target.scheme.match(\"^sips?$\")) {\n\t        var targetString = target.toString();\n\t        if (typeof environment.open === \"function\") {\n\t          environment.open(targetString);\n\t        } else {\n\t          this.logger.warn(\"referred to non-SIP URI but `open` isn't in the environment: \" + targetString);\n\t        }\n\t        return;\n\t      }\n\t\n\t      var extraHeaders = [];\n\t\n\t      /* Copy the Replaces query into a Replaces header */\n\t      /* TODO - make sure we don't copy a poorly formatted header? */\n\t      var replaces = target.getHeader('Replaces');\n\t      if (replaces !== undefined) {\n\t        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));\n\t      }\n\t\n\t      // don't embed headers into Request-URI of INVITE\n\t      target.clearHeaders();\n\t\n\t      /*\n\t        Harmless race condition.  Both sides of REFER\n\t        may send a BYE, but in the end the dialogs are destroyed.\n\t      */\n\t      var getReferMedia = this.mediaHandler.getReferMedia;\n\t      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;\n\t\n\t      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);\n\t\n\t      var referSession = this.ua.invite(target, {\n\t        media: mediaHint,\n\t        params: {\n\t          to_displayName: referTo.friendlyName\n\t        },\n\t        extraHeaders: extraHeaders\n\t      });\n\t\n\t      callback.call(this, request, referSession);\n\t\n\t      this.terminate();\n\t    }.bind(this, callback);\n\t  },\n\t\n\t  sendRequest: function(method,options) {\n\t    options = options || {};\n\t    var self = this;\n\t\n\t    var request = new SIP.OutgoingRequest(\n\t      method,\n\t      this.dialog.remote_target,\n\t      this.ua,\n\t      {\n\t        cseq: options.cseq || (this.dialog.local_seqnum += 1),\n\t        call_id: this.dialog.id.call_id,\n\t        from_uri: this.dialog.local_uri,\n\t        from_tag: this.dialog.id.local_tag,\n\t        to_uri: this.dialog.remote_uri,\n\t        to_tag: this.dialog.id.remote_tag,\n\t        route_set: this.dialog.route_set,\n\t        statusCode: options.statusCode,\n\t        reasonPhrase: options.reasonPhrase\n\t      },\n\t      options.extraHeaders || [],\n\t      options.body\n\t    );\n\t\n\t    new SIP.RequestSender({\n\t      request: request,\n\t      onRequestTimeout: function() {\n\t        self.onRequestTimeout();\n\t      },\n\t      onTransportError: function() {\n\t        self.onTransportError();\n\t      },\n\t      receiveResponse: options.receiveResponse || function(response) {\n\t        self.receiveNonInviteResponse(response);\n\t      }\n\t    }, this.ua).send();\n\t\n\t    // Emit the request event\n\t    this.emit(method.toLowerCase(), request);\n\t\n\t    return this;\n\t  },\n\t\n\t  close: function() {\n\t    var idx;\n\t\n\t    if(this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    this.logger.log('closing INVITE session ' + this.id);\n\t\n\t    // 1st Step. Terminate media.\n\t    if (this.mediaHandler){\n\t      this.mediaHandler.close();\n\t    }\n\t\n\t    // 2nd Step. Terminate signaling.\n\t\n\t    // Clear session timers\n\t    for(idx in this.timers) {\n\t      SIP.Timers.clearTimeout(this.timers[idx]);\n\t    }\n\t\n\t    // Terminate dialogs\n\t\n\t    // Terminate confirmed dialog\n\t    if(this.dialog) {\n\t      this.dialog.terminate();\n\t      delete this.dialog;\n\t    }\n\t\n\t    // Terminate early dialogs\n\t    for(idx in this.earlyDialogs) {\n\t      this.earlyDialogs[idx].terminate();\n\t      delete this.earlyDialogs[idx];\n\t    }\n\t\n\t    this.status = C.STATUS_TERMINATED;\n\t\n\t    delete this.ua.sessions[this.id];\n\t    return this;\n\t  },\n\t\n\t  createDialog: function(message, type, early) {\n\t    var dialog, early_dialog,\n\t      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],\n\t      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],\n\t      id = message.call_id + local_tag + remote_tag;\n\t\n\t    early_dialog = this.earlyDialogs[id];\n\t\n\t    // Early Dialog\n\t    if (early) {\n\t      if (early_dialog) {\n\t        return true;\n\t      } else {\n\t        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);\n\t\n\t        // Dialog has been successfully created.\n\t        if(early_dialog.error) {\n\t          this.logger.error(early_dialog.error);\n\t          this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n\t          return false;\n\t        } else {\n\t          this.earlyDialogs[id] = early_dialog;\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t    // Confirmed Dialog\n\t    else {\n\t      // In case the dialog is in _early_ state, update it\n\t      if (early_dialog) {\n\t        early_dialog.update(message, type);\n\t        this.dialog = early_dialog;\n\t        delete this.earlyDialogs[id];\n\t        for (var dia in this.earlyDialogs) {\n\t          this.earlyDialogs[dia].terminate();\n\t          delete this.earlyDialogs[dia];\n\t        }\n\t        return true;\n\t      }\n\t\n\t      // Otherwise, create a _confirmed_ dialog\n\t      dialog = new SIP.Dialog(this, message, type);\n\t\n\t      if(dialog.error) {\n\t        this.logger.error(dialog.error);\n\t        this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n\t        return false;\n\t      } else {\n\t        this.to_tag = message.to_tag;\n\t        this.dialog = dialog;\n\t        return true;\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Check if Session is ready for a re-INVITE\n\t  *\n\t  * @returns {Boolean}\n\t  */\n\t  isReadyToReinvite: function() {\n\t    return this.mediaHandler.isReady() &&\n\t      !this.dialog.uac_pending_reply &&\n\t      !this.dialog.uas_pending_reply;\n\t  },\n\t\n\t  /**\n\t   * Mute\n\t   */\n\t  mute: function(options) {\n\t    var ret = this.mediaHandler.mute(options);\n\t    if (ret) {\n\t      this.onmute(ret);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Unmute\n\t   */\n\t  unmute: function(options) {\n\t    var ret = this.mediaHandler.unmute(options);\n\t    if (ret) {\n\t      this.onunmute(ret);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Hold\n\t   */\n\t  hold: function(options) {\n\t\n\t    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.mediaHandler.hold();\n\t\n\t    // Check if RTCSession is ready to send a reINVITE\n\t    if (!this.isReadyToReinvite()) {\n\t      /* If there is a pending 'unhold' action, cancel it and don't queue this one\n\t       * Else, if there isn't any 'hold' action, add this one to the queue\n\t       * Else, if there is already a 'hold' action, skip\n\t       */\n\t      if (this.pending_actions.isPending('unhold')) {\n\t        this.pending_actions.pop('unhold');\n\t      } else if (!this.pending_actions.isPending('hold')) {\n\t        this.pending_actions.push('hold');\n\t      }\n\t      return;\n\t    } else if (this.local_hold === true) {\n\t        return;\n\t    }\n\t\n\t    this.onhold('local');\n\t\n\t    options = options || {};\n\t    options.mangle = function(body){\n\t\n\t      // Don't receive media\n\t      // TODO - This will break for media streams with different directions.\n\t      if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {\n\t        body = body.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n\t      } else {\n\t        body = body.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n\t        body = body.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n\t      }\n\t\n\t      return body;\n\t    };\n\t\n\t    this.sendReinvite(options);\n\t  },\n\t\n\t  /**\n\t   * Unhold\n\t   */\n\t  unhold: function(options) {\n\t\n\t    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.mediaHandler.unhold();\n\t\n\t    if (!this.isReadyToReinvite()) {\n\t      /* If there is a pending 'hold' action, cancel it and don't queue this one\n\t       * Else, if there isn't any 'unhold' action, add this one to the queue\n\t       * Else, if there is already a 'unhold' action, skip\n\t       */\n\t      if (this.pending_actions.isPending('hold')) {\n\t        this.pending_actions.pop('hold');\n\t      } else if (!this.pending_actions.isPending('unhold')) {\n\t        this.pending_actions.push('unhold');\n\t      }\n\t      return;\n\t    } else if (this.local_hold === false) {\n\t      return;\n\t    }\n\t\n\t    this.onunhold('local');\n\t\n\t    this.sendReinvite(options);\n\t  },\n\t\n\t  /**\n\t   * isOnHold\n\t   */\n\t  isOnHold: function() {\n\t    return {\n\t      local: this.local_hold,\n\t      remote: this.remote_hold\n\t    };\n\t  },\n\t\n\t  /**\n\t   * In dialog INVITE Reception\n\t   * @private\n\t   */\n\t  receiveReinvite: function(request) {\n\t    var self = this;\n\t\n\t    if (!request.body) {\n\t      return;\n\t    }\n\t\n\t    if (request.getHeader('Content-Type') !== 'application/sdp') {\n\t      this.logger.warn('invalid Content-Type');\n\t      request.reply(415);\n\t      return;\n\t    }\n\t\n\t    this.mediaHandler.setDescription(request.body)\n\t    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n\t    .then(function(body) {\n\t      request.reply(200, null, ['Contact: ' + self.contact], body,\n\t        function() {\n\t          self.status = C.STATUS_WAITING_FOR_ACK;\n\t          self.setInvite2xxTimer(request, body);\n\t          self.setACKTimer();\n\t\n\t          // Are we holding?\n\t          var hold = (/a=(sendonly|inactive)/).test(request.body);\n\t\n\t          if (self.remote_hold && !hold) {\n\t            self.onunhold('remote');\n\t          } else if (!self.remote_hold && hold) {\n\t            self.onhold('remote');\n\t          }\n\t        });\n\t    })\n\t    .catch(function onFailure (e) {\n\t      var statusCode;\n\t      if (e instanceof SIP.Exceptions.GetDescriptionError) {\n\t        statusCode = 500;\n\t      } else {\n\t        self.logger.error(e);\n\t        statusCode = 488;\n\t      }\n\t      request.reply(statusCode);\n\t    });\n\t  },\n\t\n\t  sendReinvite: function(options) {\n\t    options = options || {};\n\t\n\t    var\n\t      self = this,\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t      eventHandlers = options.eventHandlers || {},\n\t      mangle = options.mangle || null,\n\t      succeeded;\n\t\n\t    if (eventHandlers.succeeded) {\n\t      succeeded = eventHandlers.succeeded;\n\t    }\n\t    this.reinviteSucceeded = function(){\n\t      SIP.Timers.clearTimeout(self.timers.ackTimer);\n\t      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n\t      self.status = C.STATUS_CONFIRMED;\n\t      succeeded && succeeded.apply(this, arguments);\n\t    };\n\t    if (eventHandlers.failed) {\n\t      this.reinviteFailed = eventHandlers.failed;\n\t    } else {\n\t      this.reinviteFailed = function(){};\n\t    }\n\t\n\t    extraHeaders.push('Contact: ' + this.contact);\n\t    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t    extraHeaders.push('Content-Type: application/sdp');\n\t\n\t    this.receiveResponse = this.receiveReinviteResponse;\n\t    //REVISIT\n\t    this.mediaHandler.getDescription(self.mediaHint)\n\t    .then(mangle)\n\t    .then(\n\t      function(body){\n\t        self.dialog.sendRequest(self, SIP.C.INVITE, {\n\t          extraHeaders: extraHeaders,\n\t          body: body\n\t        });\n\t      },\n\t      function() {\n\t        if (self.isReadyToReinvite()) {\n\t          self.onReadyToReinvite();\n\t        }\n\t        self.reinviteFailed();\n\t      }\n\t    );\n\t  },\n\t\n\t  receiveRequest: function (request) {\n\t    switch (request.method) {\n\t      case SIP.C.BYE:\n\t        request.reply(200);\n\t        if(this.status === C.STATUS_CONFIRMED) {\n\t          this.emit('bye', request);\n\t          this.terminated(request, SIP.C.causes.BYE);\n\t        }\n\t        break;\n\t      case SIP.C.INVITE:\n\t        if(this.status === C.STATUS_CONFIRMED) {\n\t          this.logger.log('re-INVITE received');\n\t          this.receiveReinvite(request);\n\t        }\n\t        break;\n\t      case SIP.C.INFO:\n\t        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {\n\t          var body, tone, duration,\n\t              contentType = request.getHeader('content-type'),\n\t              reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/,\n\t              reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\t\n\t          if (contentType) {\n\t            if (contentType.match(/^application\\/dtmf-relay/i)) {\n\t              if (request.body) {\n\t                body = request.body.split('\\r\\n', 2);\n\t                if (body.length === 2) {\n\t                  if (reg_tone.test(body[0])) {\n\t                    tone = body[0].replace(reg_tone,\"$2\");\n\t                  }\n\t                  if (reg_duration.test(body[1])) {\n\t                    duration = parseInt(body[1].replace(reg_duration,\"$2\"), 10);\n\t                  }\n\t                }\n\t              }\n\t\n\t              new DTMF(this, tone, {duration: duration}).init_incoming(request);\n\t            } else {\n\t              request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n\t            }\n\t          }\n\t        }\n\t        break;\n\t      case SIP.C.REFER:\n\t        if(this.status ===  C.STATUS_CONFIRMED) {\n\t          this.logger.log('REFER received');\n\t          var hasReferListener = this.listeners('refer').length,\n\t              notifyBody;\n\t\n\t          if (hasReferListener) {\n\t            request.reply(202, 'Accepted');\n\t            notifyBody = 'SIP/2.0 100 Trying';\n\t\n\t            this.sendRequest(SIP.C.NOTIFY, {\n\t              extraHeaders:[\n\t                'Event: refer',\n\t                'Subscription-State: terminated',\n\t                'Content-Type: message/sipfrag'\n\t              ],\n\t              body: notifyBody,\n\t              receiveResponse: function() {}\n\t            });\n\t\n\t            this.emit('refer', request);\n\t          } else {\n\t            // RFC 3515.2.4.2: 'the UA MAY decline the request.'\n\t            request.reply(603, 'Declined');\n\t          }\n\t        }\n\t        break;\n\t      case SIP.C.NOTIFY:\n\t        request.reply(200, 'OK');\n\t        this.emit('notify', request);\n\t        break;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Reception of Response for in-dialog INVITE\n\t   * @private\n\t   */\n\t  receiveReinviteResponse: function(response) {\n\t    var self = this,\n\t        contentType = response.getHeader('Content-Type');\n\t\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return;\n\t    }\n\t\n\t    switch(true) {\n\t      case /^1[0-9]{2}$/.test(response.status_code):\n\t        break;\n\t      case /^2[0-9]{2}$/.test(response.status_code):\n\t        this.status = C.STATUS_CONFIRMED;\n\t\n\t        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});\n\t\n\t        if(!response.body) {\n\t          this.reinviteFailed();\n\t          break;\n\t        } else if (contentType !== 'application/sdp') {\n\t          this.reinviteFailed();\n\t          break;\n\t        }\n\t\n\t        //REVISIT\n\t        this.mediaHandler.setDescription(response.body)\n\t        .then(\n\t          function onSuccess () {\n\t            self.reinviteSucceeded();\n\t          },\n\t          function onFailure () {\n\t            self.reinviteFailed();\n\t          }\n\t        );\n\t        break;\n\t      default:\n\t        this.reinviteFailed();\n\t    }\n\t  },\n\t\n\t  acceptAndTerminate: function(response, status_code, reason_phrase) {\n\t    var extraHeaders = [];\n\t\n\t    if (status_code) {\n\t      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));\n\t    }\n\t\n\t    // An error on dialog creation will fire 'failed' event\n\t    if (this.dialog || this.createDialog(response, 'UAC')) {\n\t      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n\t      this.sendRequest(SIP.C.BYE, {\n\t        extraHeaders: extraHeaders\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * RFC3261 13.3.1.4\n\t   * Response retransmissions cannot be accomplished by transaction layer\n\t   *  since it is destroyed when receiving the first 2xx answer\n\t   */\n\t  setInvite2xxTimer: function(request, body) {\n\t    var self = this,\n\t        timeout = SIP.Timers.T1;\n\t\n\t    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n\t      if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n\t        return;\n\t      }\n\t\n\t      self.logger.log('no ACK received, attempting to retransmit OK');\n\t\n\t      request.reply(200, null, ['Contact: ' + self.contact], body);\n\t\n\t      timeout = Math.min(timeout * 2, SIP.Timers.T2);\n\t\n\t      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n\t    }, timeout);\n\t  },\n\t\n\t  /**\n\t   * RFC3261 14.2\n\t   * If a UAS generates a 2xx response and never receives an ACK,\n\t   *  it SHOULD generate a BYE to terminate the dialog.\n\t   */\n\t  setACKTimer: function() {\n\t    var self = this;\n\t\n\t    this.timers.ackTimer = SIP.Timers.setTimeout(function() {\n\t      if(self.status === C.STATUS_WAITING_FOR_ACK) {\n\t        self.logger.log('no ACK received for an extended period of time, terminating the call');\n\t        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n\t        self.sendRequest(SIP.C.BYE);\n\t        self.terminated(null, SIP.C.causes.NO_ACK);\n\t      }\n\t    }, SIP.Timers.TIMER_H);\n\t  },\n\t\n\t  /*\n\t   * @private\n\t   */\n\t  onReadyToReinvite: function() {\n\t    var action = this.pending_actions.shift();\n\t\n\t    if (!action || !this[action.name]) {\n\t      return;\n\t    }\n\t\n\t    this[action.name]();\n\t  },\n\t\n\t  onTransportError: function() {\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    }\n\t  },\n\t\n\t  onDialogError: function(response) {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(response, SIP.C.causes.DIALOG_ERROR);\n\t      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   */\n\t  onhold: function(originator) {\n\t    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;\n\t    this.emit('hold', { originator: originator });\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   */\n\t  onunhold: function(originator) {\n\t    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;\n\t    this.emit('unhold', { originator: originator });\n\t  },\n\t\n\t  /*\n\t   * @private\n\t   */\n\t  onmute: function(options) {\n\t    this.emit('muted', {\n\t      audio: options.audio,\n\t      video: options.video\n\t    });\n\t  },\n\t\n\t  /*\n\t   * @private\n\t   */\n\t  onunmute: function(options) {\n\t    this.emit('unmuted', {\n\t      audio: options.audio,\n\t      video: options.video\n\t    });\n\t  },\n\t\n\t  failed: function(response, cause) {\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t    this.emit('failed', response || null, cause || null);\n\t    return this;\n\t  },\n\t\n\t  rejected: function(response, cause) {\n\t    this.emit('rejected',\n\t      response || null,\n\t      cause || null\n\t    );\n\t    return this;\n\t  },\n\t\n\t  canceled: function() {\n\t    this.emit('cancel');\n\t    return this;\n\t  },\n\t\n\t  accepted: function(response, cause) {\n\t    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);\n\t\n\t    this.startTime = new Date();\n\t\n\t    if (this.replacee) {\n\t      this.replacee.emit('replaced', this);\n\t      this.replacee.terminate();\n\t    }\n\t    this.emit('accepted', response, cause);\n\t    return this;\n\t  },\n\t\n\t  terminated: function(message, cause) {\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    this.endTime = new Date();\n\t\n\t    this.close();\n\t    this.emit('terminated',\n\t      message || null,\n\t      cause || null\n\t    );\n\t    return this;\n\t  },\n\t\n\t  connecting: function(request) {\n\t    this.emit('connecting', { request: request });\n\t    return this;\n\t  }\n\t};\n\t\n\tSession.desugar = function desugar(options) {\n\t  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {\n\t    options = {\n\t      media: {\n\t        constraints: {\n\t          audio: true,\n\t          video: options.tagName === 'VIDEO'\n\t        },\n\t        render: {\n\t          remote: options\n\t        }\n\t      }\n\t    };\n\t  }\n\t  return options || {};\n\t};\n\t\n\t\n\tSession.C = C;\n\tSIP.Session = Session;\n\t\n\t\n\tInviteServerContext = function(ua, request) {\n\t  var expires,\n\t    self = this,\n\t    contentType = request.getHeader('Content-Type'),\n\t    contentDisp = request.parseHeader('Content-Disposition');\n\t\n\t  // Check body and content type\n\t  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {\n\t    this.renderbody = request.body;\n\t    this.rendertype = contentType;\n\t  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {\n\t    request.reply(415);\n\t    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it\n\t    return;\n\t  }\n\t\n\t  //TODO: move this into media handler\n\t  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n\t  SIP.Hacks.AllBrowsers.maskDtls(request);\n\t\n\t  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n\t  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n\t\n\t  this.status = C.STATUS_INVITE_RECEIVED;\n\t  this.from_tag = request.from_tag;\n\t  this.id = request.call_id + this.from_tag;\n\t  this.request = request;\n\t  this.contact = this.ua.contact.toString();\n\t\n\t  this.receiveNonInviteResponse = function () {}; // intentional no-op\n\t\n\t  this.logger = ua.getLogger('sip.inviteservercontext', this.id);\n\t\n\t  //Save the session into the ua sessions collection.\n\t  this.ua.sessions[this.id] = this;\n\t\n\t  //Get the Expires header value if exists\n\t  if(request.hasHeader('expires')) {\n\t    expires = request.getHeader('expires') * 1000;\n\t  }\n\t\n\t  //Set 100rel if necessary\n\t  function set100rel(h,c) {\n\t    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n\t      self.rel100 = c;\n\t    }\n\t  }\n\t  set100rel('require', SIP.C.supported.REQUIRED);\n\t  set100rel('supported', SIP.C.supported.SUPPORTED);\n\t\n\t  /* Set the to_tag before\n\t   * replying a response code that will create a dialog.\n\t   */\n\t  request.to_tag = SIP.Utils.newTag();\n\t\n\t  // An error on dialog creation will fire 'failed' event\n\t  if(!this.createDialog(request, 'UAS', true)) {\n\t    request.reply(500, 'Missing Contact header field');\n\t    return;\n\t  }\n\t\n\t  //Initialize Media Session\n\t  this.mediaHandler = this.mediaHandlerFactory(this, {\n\t    RTCConstraints: {\"optional\": [{'DtlsSrtpKeyAgreement': 'true'}]}\n\t  });\n\t\n\t  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n\t    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n\t    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n\t  }\n\t\n\t  function fireNewSession() {\n\t    var options = {extraHeaders: ['Contact: ' + self.contact]};\n\t\n\t    if (self.rel100 !== SIP.C.supported.REQUIRED) {\n\t      self.progress(options);\n\t    }\n\t    self.status = C.STATUS_WAITING_FOR_ANSWER;\n\t\n\t    // Set userNoAnswerTimer\n\t    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {\n\t      request.reply(408);\n\t      self.failed(request, SIP.C.causes.NO_ANSWER);\n\t      self.terminated(request, SIP.C.causes.NO_ANSWER);\n\t    }, self.ua.configuration.noAnswerTimeout);\n\t\n\t    /* Set expiresTimer\n\t     * RFC3261 13.3.1\n\t     */\n\t    if (expires) {\n\t      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {\n\t        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {\n\t          request.reply(487);\n\t          self.failed(request, SIP.C.causes.EXPIRES);\n\t          self.terminated(request, SIP.C.causes.EXPIRES);\n\t        }\n\t      }, expires);\n\t    }\n\t\n\t    self.emit('invite',request);\n\t  }\n\t\n\t  if (!request.body || this.renderbody) {\n\t    SIP.Timers.setTimeout(fireNewSession, 0);\n\t  } else {\n\t    this.hasOffer = true;\n\t    this.mediaHandler.setDescription(request.body)\n\t    .then(\n\t      fireNewSession,\n\t      function onFailure (e) {\n\t        self.logger.warn('invalid SDP');\n\t        self.logger.warn(e);\n\t        request.reply(488);\n\t      }\n\t    );\n\t  }\n\t};\n\t\n\tInviteServerContext.prototype = {\n\t  reject: function(options) {\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.logger.log('rejecting RTCSession');\n\t\n\t    SIP.ServerContext.prototype.reject.call(this, options);\n\t    return this.terminated();\n\t  },\n\t\n\t  terminate: function(options) {\n\t    options = options || {};\n\t\n\t    var\n\t    extraHeaders = (options.extraHeaders || []).slice(),\n\t    body = options.body,\n\t    dialog,\n\t    self = this;\n\t\n\t    if (this.status === C.STATUS_WAITING_FOR_ACK &&\n\t       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n\t      dialog = this.dialog;\n\t\n\t      this.receiveRequest = function(request) {\n\t        if (request.method === SIP.C.ACK) {\n\t          this.request(SIP.C.BYE, {\n\t            extraHeaders: extraHeaders,\n\t            body: body\n\t          });\n\t          dialog.terminate();\n\t        }\n\t      };\n\t\n\t      this.request.server_transaction.on('stateChanged', function(){\n\t        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\t          this.request = new SIP.OutgoingRequest(\n\t            SIP.C.BYE,\n\t            this.dialog.remote_target,\n\t            this.ua,\n\t            {\n\t              'cseq': this.dialog.local_seqnum+=1,\n\t              'call_id': this.dialog.id.call_id,\n\t              'from_uri': this.dialog.local_uri,\n\t              'from_tag': this.dialog.id.local_tag,\n\t              'to_uri': this.dialog.remote_uri,\n\t              'to_tag': this.dialog.id.remote_tag,\n\t              'route_set': this.dialog.route_set\n\t            },\n\t            extraHeaders,\n\t            body\n\t          );\n\t\n\t          new SIP.RequestSender(\n\t            {\n\t              request: this.request,\n\t              onRequestTimeout: function() {\n\t                self.onRequestTimeout();\n\t              },\n\t              onTransportError: function() {\n\t                self.onTransportError();\n\t              },\n\t              receiveResponse: function() {\n\t                return;\n\t              }\n\t            },\n\t            this.ua\n\t          ).send();\n\t          dialog.terminate();\n\t        }\n\t      });\n\t\n\t      this.emit('bye', this.request);\n\t      this.terminated();\n\t\n\t      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n\t      this.dialog = dialog;\n\t\n\t      // Restore the dialog into 'ua' so the ACK can reach 'this' session\n\t      this.ua.dialogs[dialog.id.toString()] = dialog;\n\t\n\t    } else if (this.status === C.STATUS_CONFIRMED) {\n\t      this.bye(options);\n\t    } else {\n\t      this.reject(options);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /*\n\t   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t   */\n\t  progress: function (options) {\n\t    options = options || {};\n\t    var\n\t      statusCode = options.statusCode || 180,\n\t      reasonPhrase = options.reasonPhrase,\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t      iceServers,\n\t      stunServers = options.stunServers || null,\n\t      turnServers = options.turnServers || null,\n\t      body = options.body,\n\t      response;\n\t\n\t    if (statusCode < 100 || statusCode > 199) {\n\t      throw new TypeError('Invalid statusCode: ' + statusCode);\n\t    }\n\t\n\t    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    if (stunServers || turnServers) {\n\t      if (stunServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid stunServers: '+ stunServers);\n\t        } else {\n\t          this.stunServers = iceServers;\n\t        }\n\t      }\n\t\n\t      if (turnServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid turnServers: '+ turnServers);\n\t        } else {\n\t          this.turnServers = iceServers;\n\t        }\n\t      }\n\t\n\t      this.mediaHandler.updateIceServers({\n\t        stunServers: this.stunServers,\n\t        turnServers: this.turnServers\n\t      });\n\t    }\n\t\n\t    function do100rel() {\n\t      /* jshint validthis: true */\n\t      statusCode = options.statusCode || 183;\n\t\n\t      // Set status and add extra headers\n\t      this.status = C.STATUS_WAITING_FOR_PRACK;\n\t      extraHeaders.push('Contact: '+ this.contact);\n\t      extraHeaders.push('Require: 100rel');\n\t      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));\n\t\n\t      // Save media hint for later (referred sessions)\n\t      this.mediaHint = options.media;\n\t\n\t      // Get the session description to add to preaccept with\n\t      this.mediaHandler.getDescription(options.media)\n\t      .then(\n\t        function onSuccess (body) {\n\t          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n\t            return;\n\t          }\n\t\n\t          this.early_sdp = body;\n\t          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;\n\t\n\t          // Retransmit until we get a response or we time out (see prackTimer below)\n\t          var timeout = SIP.Timers.T1;\n\t          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n\t            this.request.reply(statusCode, null, extraHeaders, body);\n\t            timeout *= 2;\n\t            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n\t          }.bind(this), timeout);\n\t\n\t          // Timeout and reject INVITE if no response\n\t          this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n\t            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n\t              return;\n\t            }\n\t\n\t            this.logger.log('no PRACK received, rejecting the call');\n\t            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n\t            this.request.reply(504);\n\t            this.terminated(null, SIP.C.causes.NO_PRACK);\n\t          }.bind(this), SIP.Timers.T1 * 64);\n\t\n\t          // Send the initial response\n\t          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\t          this.emit('progress', response, reasonPhrase);\n\t        }.bind(this),\n\t\n\t        function onFailure () {\n\t          this.request.reply(480);\n\t          this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t        }.bind(this)\n\t      );\n\t    } // end do100rel\n\t\n\t    function normalReply() {\n\t      /* jshint validthis:true */\n\t      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\t      this.emit('progress', response, reasonPhrase);\n\t    }\n\t\n\t    if (options.statusCode !== 100 &&\n\t        (this.rel100 === SIP.C.supported.REQUIRED ||\n\t         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||\n\t         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {\n\t      do100rel.apply(this);\n\t    } else {\n\t      normalReply.apply(this);\n\t    }\n\t    return this;\n\t  },\n\t\n\t  /*\n\t   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t   */\n\t  accept: function(options) {\n\t    options = Object.create(Session.desugar(options));\n\t    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n\t    this.mediaHint = options.media;\n\t\n\t    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21\n\t    var\n\t      //idx, length, hasAudio, hasVideo,\n\t      self = this,\n\t      request = this.request,\n\t      extraHeaders = (options.extraHeaders || []).slice(),\n\t    //mediaStream = options.mediaStream || null,\n\t      iceServers,\n\t      stunServers = options.stunServers || null,\n\t      turnServers = options.turnServers || null,\n\t      sdpCreationSucceeded = function(body) {\n\t        var\n\t          response,\n\t          // run for reply success callback\n\t          replySucceeded = function() {\n\t            self.status = C.STATUS_WAITING_FOR_ACK;\n\t\n\t            self.setInvite2xxTimer(request, body);\n\t            self.setACKTimer();\n\t          },\n\t\n\t          // run for reply failure callback\n\t          replyFailed = function() {\n\t            self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n\t          };\n\t\n\t        // Chrome might call onaddstream before accept() is called, which means\n\t        // mediaHandler.render() was called without a renderHint, so we need to\n\t        // re-render now that mediaHint.render has been set.\n\t        //\n\t        // Chrome seems to be in the right regarding this, see\n\t        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream\n\t        self.mediaHandler.render();\n\t\n\t        extraHeaders.push('Contact: ' + self.contact);\n\t        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t        if(!self.hasOffer) {\n\t          self.hasOffer = true;\n\t        } else {\n\t          self.hasAnswer = true;\n\t        }\n\t        response = request.reply(200, null, extraHeaders,\n\t                      body,\n\t                      replySucceeded,\n\t                      replyFailed\n\t                     );\n\t        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail\n\t          self.accepted(response, SIP.Utils.getReasonPhrase(200));\n\t        }\n\t      },\n\t\n\t      sdpCreationFailed = function() {\n\t        if (self.status === C.STATUS_TERMINATED) {\n\t          return;\n\t        }\n\t        // TODO - fail out on error\n\t        self.request.reply(480);\n\t        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n\t        self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t      };\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n\t      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n\t      return this;\n\t    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n\t      this.status = C.STATUS_ANSWERED;\n\t    } else if (this.status !== C.STATUS_EARLY_MEDIA) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    if ((stunServers || turnServers) &&\n\t        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {\n\t      if (stunServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid stunServers: '+ stunServers);\n\t        } else {\n\t          this.stunServers = iceServers;\n\t        }\n\t      }\n\t\n\t      if (turnServers) {\n\t        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\t        if (!iceServers) {\n\t          throw new TypeError('Invalid turnServers: '+ turnServers);\n\t        } else {\n\t          this.turnServers = iceServers;\n\t        }\n\t      }\n\t\n\t      this.mediaHandler.updateIceServers({\n\t        stunServers: this.stunServers,\n\t        turnServers: this.turnServers\n\t      });\n\t    }\n\t\n\t    // An error on dialog creation will fire 'failed' event\n\t    if(!this.createDialog(request, 'UAS')) {\n\t      request.reply(500, 'Missing Contact header field');\n\t      return this;\n\t    }\n\t\n\t    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);\n\t\n\t    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21\n\t    /*\n\t    length = this.getRemoteStreams().length;\n\t\n\t    for (idx = 0; idx < length; idx++) {\n\t      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {\n\t        hasVideo = true;\n\t      }\n\t      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {\n\t        hasAudio = true;\n\t      }\n\t    }\n\t\n\t    if (!hasAudio && this.mediaConstraints.audio === true) {\n\t      this.mediaConstraints.audio = false;\n\t      if (mediaStream) {\n\t        length = mediaStream.getAudioTracks().length;\n\t        for (idx = 0; idx < length; idx++) {\n\t          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (!hasVideo && this.mediaConstraints.video === true) {\n\t      this.mediaConstraints.video = false;\n\t      if (mediaStream) {\n\t        length = mediaStream.getVideoTracks().length;\n\t        for (idx = 0; idx < length; idx++) {\n\t          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);\n\t        }\n\t      }\n\t    }\n\t    */\n\t\n\t    if (this.status === C.STATUS_EARLY_MEDIA) {\n\t      sdpCreationSucceeded();\n\t    } else {\n\t      this.mediaHandler.getDescription(self.mediaHint)\n\t      .then(\n\t        sdpCreationSucceeded,\n\t        sdpCreationFailed\n\t      );\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  receiveRequest: function(request) {\n\t\n\t    // ISC RECEIVE REQUEST\n\t\n\t    function confirmSession() {\n\t      /* jshint validthis:true */\n\t      var contentType;\n\t\n\t      SIP.Timers.clearTimeout(this.timers.ackTimer);\n\t      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n\t      this.status = C.STATUS_CONFIRMED;\n\t      this.unmute();\n\t\n\t      // TODO - this logic assumes Content-Disposition defaults\n\t      contentType = request.getHeader('Content-Type');\n\t      if (contentType !== 'application/sdp') {\n\t        this.renderbody = request.body;\n\t        this.rendertype = contentType;\n\t      }\n\t    }\n\t\n\t    switch(request.method) {\n\t    case SIP.C.CANCEL:\n\t      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n\t       * was in progress and that the UAC MAY continue with the session established by\n\t       * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n\t       * established session. So the CANCEL is processed only if the session is not yet\n\t       * established.\n\t       */\n\t\n\t      /*\n\t       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n\t       *request opening the session.\n\t       */\n\t      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||\n\t         this.status === C.STATUS_WAITING_FOR_PRACK ||\n\t         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||\n\t         this.status === C.STATUS_EARLY_MEDIA ||\n\t         this.status === C.STATUS_ANSWERED) {\n\t\n\t        this.status = C.STATUS_CANCELED;\n\t        this.request.reply(487);\n\t        this.canceled(request);\n\t        this.rejected(request, SIP.C.causes.CANCELED);\n\t        this.failed(request, SIP.C.causes.CANCELED);\n\t        this.terminated(request, SIP.C.causes.CANCELED);\n\t      }\n\t      break;\n\t    case SIP.C.ACK:\n\t      if(this.status === C.STATUS_WAITING_FOR_ACK) {\n\t        if (!this.hasAnswer) {\n\t          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n\t            // ACK contains answer to an INVITE w/o SDP negotiation\n\t            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n\t            SIP.Hacks.AllBrowsers.maskDtls(request);\n\t\n\t            this.hasAnswer = true;\n\t            this.mediaHandler.setDescription(request.body)\n\t            .then(\n\t              confirmSession.bind(this),\n\t              function onFailure (e) {\n\t                this.logger.warn(e);\n\t                this.terminate({\n\t                  statusCode: '488',\n\t                  reasonPhrase: 'Bad Media Description'\n\t                });\n\t                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              }.bind(this)\n\t            );\n\t          } else if (this.early_sdp) {\n\t            confirmSession.apply(this);\n\t          } else {\n\t            //TODO: Pass to mediahandler\n\t            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t          }\n\t        } else {\n\t          confirmSession.apply(this);\n\t        }\n\t      }\n\t      break;\n\t    case SIP.C.PRACK:\n\t      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n\t        //localMedia = session.mediaHandler.localMedia;\n\t        if(!this.hasAnswer) {\n\t          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n\t            this.hasAnswer = true;\n\t            this.mediaHandler.setDescription(request.body)\n\t            .then(\n\t              function onSuccess () {\n\t                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n\t                SIP.Timers.clearTimeout(this.timers.prackTimer);\n\t                request.reply(200);\n\t                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n\t                  this.status = C.STATUS_EARLY_MEDIA;\n\t                  this.accept();\n\t                }\n\t                this.status = C.STATUS_EARLY_MEDIA;\n\t                //REVISIT\n\t                this.mute();\n\t              }.bind(this),\n\t              function onFailure (e) {\n\t                //TODO: Send to media handler\n\t                this.logger.warn(e);\n\t                this.terminate({\n\t                  statusCode: '488',\n\t                  reasonPhrase: 'Bad Media Description'\n\t                });\n\t                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              }.bind(this)\n\t            );\n\t          } else {\n\t            this.terminate({\n\t              statusCode: '488',\n\t              reasonPhrase: 'Bad Media Description'\n\t            });\n\t            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t          }\n\t        } else {\n\t          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n\t          SIP.Timers.clearTimeout(this.timers.prackTimer);\n\t          request.reply(200);\n\t\n\t          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n\t            this.status = C.STATUS_EARLY_MEDIA;\n\t            this.accept();\n\t          }\n\t          this.status = C.STATUS_EARLY_MEDIA;\n\t          //REVISIT\n\t          this.mute();\n\t        }\n\t      } else if(this.status === C.STATUS_EARLY_MEDIA) {\n\t        request.reply(200);\n\t      }\n\t      break;\n\t    default:\n\t      Session.prototype.receiveRequest.apply(this, [request]);\n\t      break;\n\t    }\n\t  },\n\t\n\t  onTransportError: function() {\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    }\n\t  }\n\t\n\t};\n\t\n\tSIP.InviteServerContext = InviteServerContext;\n\t\n\tInviteClientContext = function(ua, target, options) {\n\t  options = Object.create(Session.desugar(options));\n\t  options.params = Object.create(options.params || Object.prototype);\n\t\n\t  var iceServers,\n\t    extraHeaders = (options.extraHeaders || []).slice(),\n\t    stunServers = options.stunServers || null,\n\t    turnServers = options.turnServers || null,\n\t    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,\n\t    isMediaSupported = mediaHandlerFactory.isSupported;\n\t\n\t  // Check WebRTC support\n\t  if (isMediaSupported && !isMediaSupported()) {\n\t    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n\t  }\n\t\n\t  this.RTCConstraints = options.RTCConstraints || {};\n\t  this.inviteWithoutSdp = options.inviteWithoutSdp || false;\n\t\n\t  // Set anonymous property\n\t  this.anonymous = options.anonymous || false;\n\t\n\t  // Custom data to be sent either in INVITE or in ACK\n\t  this.renderbody = options.renderbody || null;\n\t  this.rendertype = options.rendertype || 'text/plain';\n\t\n\t  options.params.from_tag = this.from_tag;\n\t\n\t  /* Do not add ;ob in initial forming dialog requests if the registration over\n\t   *  the current connection got a GRUU URI.\n\t   */\n\t  this.contact = ua.contact.toString({\n\t    anonymous: this.anonymous,\n\t    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n\t  });\n\t\n\t  if (this.anonymous) {\n\t    options.params.from_displayName = 'Anonymous';\n\t    options.params.from_uri = 'sip:anonymous@anonymous.invalid';\n\t\n\t    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());\n\t    extraHeaders.push('Privacy: id');\n\t  }\n\t  extraHeaders.push('Contact: '+ this.contact);\n\t  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t  if (!this.inviteWithoutSdp) {\n\t    extraHeaders.push('Content-Type: application/sdp');\n\t  } else if (this.renderbody) {\n\t    extraHeaders.push('Content-Type: ' + this.rendertype);\n\t    extraHeaders.push('Content-Disposition: render;handling=optional');\n\t  }\n\t\n\t  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n\t    extraHeaders.push('Require: 100rel');\n\t  }\n\t  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {\n\t    extraHeaders.push('Require: replaces');\n\t  }\n\t\n\t  options.extraHeaders = extraHeaders;\n\t\n\t  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n\t  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);\n\t\n\t  // Check Session Status\n\t  if (this.status !== C.STATUS_NULL) {\n\t    throw new SIP.Exceptions.InvalidStateError(this.status);\n\t  }\n\t\n\t  // Session parameter initialization\n\t  this.from_tag = SIP.Utils.newTag();\n\t\n\t  // OutgoingSession specific parameters\n\t  this.isCanceled = false;\n\t  this.received_100 = false;\n\t\n\t  this.method = SIP.C.INVITE;\n\t\n\t  this.receiveNonInviteResponse = this.receiveResponse;\n\t  this.receiveResponse = this.receiveInviteResponse;\n\t\n\t  this.logger = ua.getLogger('sip.inviteclientcontext');\n\t\n\t  if (stunServers) {\n\t    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\t    if (!iceServers) {\n\t      throw new TypeError('Invalid stunServers: '+ stunServers);\n\t    } else {\n\t      this.stunServers = iceServers;\n\t    }\n\t  }\n\t\n\t  if (turnServers) {\n\t    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\t    if (!iceServers) {\n\t      throw new TypeError('Invalid turnServers: '+ turnServers);\n\t    } else {\n\t      this.turnServers = iceServers;\n\t    }\n\t  }\n\t\n\t  ua.applicants[this] = this;\n\t\n\t  this.id = this.request.call_id + this.from_tag;\n\t\n\t  //Initialize Media Session\n\t  this.mediaHandler = this.mediaHandlerFactory(this, {\n\t    RTCConstraints: this.RTCConstraints,\n\t    stunServers: this.stunServers,\n\t    turnServers: this.turnServers\n\t  });\n\t\n\t  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n\t    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n\t    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n\t  }\n\t\n\t  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n\t  this.mediaHint = options.media;\n\t};\n\t\n\tInviteClientContext.prototype = {\n\t  invite: function () {\n\t    var self = this;\n\t\n\t    //Save the session into the ua sessions collection.\n\t    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n\t    this.ua.sessions[this.id] = this;\n\t\n\t    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level\n\t    // and hand sip.js a stream as the mediaHint\n\t    if (this.inviteWithoutSdp) {\n\t      //just send an invite with no sdp...\n\t      this.request.body = self.renderbody;\n\t      this.status = C.STATUS_INVITE_SENT;\n\t      this.send();\n\t    } else {\n\t      this.mediaHandler.getDescription(self.mediaHint)\n\t      .then(\n\t        function onSuccess(offer) {\n\t          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n\t            return;\n\t          }\n\t          self.hasOffer = true;\n\t          self.request.body = offer;\n\t          self.status = C.STATUS_INVITE_SENT;\n\t          self.send();\n\t        },\n\t        function onFailure() {\n\t          if (self.status === C.STATUS_TERMINATED) {\n\t            return;\n\t          }\n\t          // TODO...fail out\n\t          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n\t          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t          self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t        }\n\t      );\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  receiveInviteResponse: function(response) {\n\t    var cause, //localMedia,\n\t      session = this,\n\t      id = response.call_id + response.from_tag + response.to_tag,\n\t      extraHeaders = [],\n\t      options = {};\n\t\n\t    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n\t      return;\n\t    }\n\t\n\t    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {\n\t      if (id !== this.dialog.id.toString() ) {\n\t        if (!this.createDialog(response, 'UAC', true)) {\n\t          return;\n\t        }\n\t        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,\n\t                                          {\n\t                                            body: SIP.Utils.generateFakeSDP(response.body)\n\t                                          });\n\t        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n\t\n\t        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n\t         * leg (due to peerConnection limitations) has been answered first. If your forking\n\t         * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n\t         */\n\t        if(this.status !== C.STATUS_CONFIRMED) {\n\t          this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n\t          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);\n\t        }\n\t        return;\n\t      } else if (this.status === C.STATUS_CONFIRMED) {\n\t        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n\t        return;\n\t      } else if (!this.hasAnswer) {\n\t        // invite w/o sdp is waiting for callback\n\t        //an invite with sdp must go on, and hasAnswer is true\n\t        return;\n\t      }\n\t    }\n\t\n\t    if (this.dialog && response.status_code < 200) {\n\t      /*\n\t        Early media has been set up with at least one other different branch,\n\t        but a final 2xx response hasn't been received\n\t      */\n\t      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n\t          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {\n\t        return;\n\t      }\n\t\n\t      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n\t        return;\n\t      }\n\t\n\t      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n\t          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n\t        return;\n\t      }\n\t\n\t      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n\t\n\t      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n\t        extraHeaders: extraHeaders,\n\t        body: SIP.Utils.generateFakeSDP(response.body)\n\t      });\n\t      return;\n\t    }\n\t\n\t    // Proceed to cancellation if the user requested.\n\t    if(this.isCanceled) {\n\t      if(response.status_code >= 100 && response.status_code < 200) {\n\t        this.request.cancel(this.cancelReason);\n\t        this.canceled(null);\n\t      } else if(response.status_code >= 200 && response.status_code < 299) {\n\t        this.acceptAndTerminate(response);\n\t        this.emit('bye', this.request);\n\t      } else if (response.status_code >= 300) {\n\t        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;\n\t        this.rejected(response, cause);\n\t        this.failed(response, cause);\n\t        this.terminated(response, cause);\n\t      }\n\t      return;\n\t    }\n\t\n\t    switch(true) {\n\t      case /^100$/.test(response.status_code):\n\t        this.received_100 = true;\n\t        this.emit('progress', response);\n\t        break;\n\t      case (/^1[0-9]{2}$/.test(response.status_code)):\n\t        // Do nothing with 1xx responses without To tag.\n\t        if(!response.to_tag) {\n\t          this.logger.warn('1xx response received without to tag');\n\t          break;\n\t        }\n\t\n\t        // Create Early Dialog if 1XX comes with contact\n\t        if(response.hasHeader('contact')) {\n\t          // An error on dialog creation will fire 'failed' event\n\t          if (!this.createDialog(response, 'UAC', true)) {\n\t            break;\n\t          }\n\t        }\n\t\n\t        this.status = C.STATUS_1XX_RECEIVED;\n\t\n\t        if(response.hasHeader('require') &&\n\t           response.getHeader('require').indexOf('100rel') !== -1) {\n\t\n\t          // Do nothing if this.dialog is already confirmed\n\t          if (this.dialog || !this.earlyDialogs[id]) {\n\t            break;\n\t          }\n\t\n\t          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n\t              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n\t            return;\n\t          }\n\t\n\t          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n\t          SIP.Hacks.AllBrowsers.maskDtls(response);\n\t\n\t          if (!response.body) {\n\t            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n\t            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n\t              extraHeaders: extraHeaders\n\t            });\n\t            this.emit('progress', response);\n\t\n\t          } else if (this.hasOffer) {\n\t            if (!this.createDialog(response, 'UAC')) {\n\t              break;\n\t            }\n\t            this.hasAnswer = true;\n\t            this.dialog.pracked.push(response.getHeader('rseq'));\n\t\n\t            this.mediaHandler.setDescription(response.body)\n\t            .then(\n\t              function onSuccess () {\n\t                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t\n\t                session.sendRequest(SIP.C.PRACK, {\n\t                  extraHeaders: extraHeaders,\n\t                  receiveResponse: function() {}\n\t                });\n\t                session.status = C.STATUS_EARLY_MEDIA;\n\t                session.mute();\n\t                session.emit('progress', response);\n\t                /*\n\t                if (session.status === C.STATUS_EARLY_MEDIA) {\n\t                  localMedia = session.mediaHandler.localMedia;\n\t                  if (localMedia.getAudioTracks().length > 0) {\n\t                    localMedia.getAudioTracks()[0].enabled = false;\n\t                  }\n\t                  if (localMedia.getVideoTracks().length > 0) {\n\t                    localMedia.getVideoTracks()[0].enabled = false;\n\t                  }\n\t                }*/\n\t              },\n\t              function onFailure (e) {\n\t                session.logger.warn(e);\n\t                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n\t                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              }\n\t            );\n\t          } else {\n\t            var earlyDialog = this.earlyDialogs[id];\n\t            var earlyMedia = earlyDialog.mediaHandler;\n\t\n\t            earlyDialog.pracked.push(response.getHeader('rseq'));\n\t\n\t            earlyMedia.setDescription(response.body)\n\t            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))\n\t            .then(function onSuccess(sdp) {\n\t              extraHeaders.push('Content-Type: application/sdp');\n\t              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n\t              earlyDialog.sendRequest(session, SIP.C.PRACK, {\n\t                extraHeaders: extraHeaders,\n\t                body: sdp\n\t              });\n\t              session.status = C.STATUS_EARLY_MEDIA;\n\t              session.emit('progress', response);\n\t            })\n\t            .catch(function onFailure(e) {\n\t              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n\t                earlyDialog.pracked.push(response.getHeader('rseq'));\n\t                if (session.status === C.STATUS_TERMINATED) {\n\t                  return;\n\t                }\n\t                // TODO - fail out on error\n\t                // session.failed(gum error);\n\t                session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\t                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n\t              } else {\n\t                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);\n\t                // Could not set remote description\n\t                session.logger.warn('invalid SDP');\n\t                session.logger.warn(e);\n\t              }\n\t            });\n\t          }\n\t        } else {\n\t          this.emit('progress', response);\n\t        }\n\t        break;\n\t      case /^2[0-9]{2}$/.test(response.status_code):\n\t        var cseq = this.request.cseq + ' ' + this.request.method;\n\t        if (cseq !== response.getHeader('cseq')) {\n\t          break;\n\t        }\n\t\n\t        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n\t          this.status = C.STATUS_CONFIRMED;\n\t          this.unmute();\n\t          /*localMedia = this.mediaHandler.localMedia;\n\t          if (localMedia.getAudioTracks().length > 0) {\n\t            localMedia.getAudioTracks()[0].enabled = true;\n\t          }\n\t          if (localMedia.getVideoTracks().length > 0) {\n\t            localMedia.getVideoTracks()[0].enabled = true;\n\t          }*/\n\t          options = {};\n\t          if (this.renderbody) {\n\t            extraHeaders.push('Content-Type: ' + this.rendertype);\n\t            options.extraHeaders = extraHeaders;\n\t            options.body = this.renderbody;\n\t          }\n\t          options.cseq = response.cseq;\n\t          this.sendRequest(SIP.C.ACK, options);\n\t          this.accepted(response);\n\t          break;\n\t        }\n\t        // Do nothing if this.dialog is already confirmed\n\t        if (this.dialog) {\n\t          break;\n\t        }\n\t\n\t        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n\t        SIP.Hacks.AllBrowsers.maskDtls(response);\n\t\n\t        // This is an invite without sdp\n\t        if (!this.hasOffer) {\n\t          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {\n\t            //REVISIT\n\t            this.hasOffer = true;\n\t            this.hasAnswer = true;\n\t            this.mediaHandler = this.earlyDialogs[id].mediaHandler;\n\t            if (!this.createDialog(response, 'UAC')) {\n\t              break;\n\t            }\n\t            this.status = C.STATUS_CONFIRMED;\n\t            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});\n\t\n\t            this.unmute();\n\t            /*\n\t            localMedia = session.mediaHandler.localMedia;\n\t            if (localMedia.getAudioTracks().length > 0) {\n\t              localMedia.getAudioTracks()[0].enabled = true;\n\t            }\n\t            if (localMedia.getVideoTracks().length > 0) {\n\t              localMedia.getVideoTracks()[0].enabled = true;\n\t            }*/\n\t            this.accepted(response);\n\t          } else {\n\t            if(!response.body) {\n\t              this.acceptAndTerminate(response, 400, 'Missing session description');\n\t              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t              break;\n\t            }\n\t            if (!this.createDialog(response, 'UAC')) {\n\t              break;\n\t            }\n\t            this.hasOffer = true;\n\t            this.mediaHandler.setDescription(response.body)\n\t            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n\t            .then(function onSuccess(sdp) {\n\t              //var localMedia;\n\t              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {\n\t                return;\n\t              }\n\t\n\t              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);\n\t\n\t              session.status = C.STATUS_CONFIRMED;\n\t              session.hasAnswer = true;\n\t\n\t              session.unmute();\n\t              /*localMedia = session.mediaHandler.localMedia;\n\t              if (localMedia.getAudioTracks().length > 0) {\n\t                localMedia.getAudioTracks()[0].enabled = true;\n\t              }\n\t              if (localMedia.getVideoTracks().length > 0) {\n\t                localMedia.getVideoTracks()[0].enabled = true;\n\t              }*/\n\t              session.sendRequest(SIP.C.ACK,{\n\t                body: sdp,\n\t                extraHeaders:['Content-Type: application/sdp'],\n\t                cseq:response.cseq\n\t              });\n\t              session.accepted(response);\n\t            })\n\t            .catch(function onFailure(e) {\n\t              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n\t                // TODO do something here\n\t                session.logger.warn(\"there was a problem\");\n\t              } else {\n\t                session.logger.warn('invalid SDP');\n\t                session.logger.warn(e);\n\t                response.reply(488);\n\t              }\n\t            });\n\t          }\n\t        } else if (this.hasAnswer){\n\t          if (this.renderbody) {\n\t            extraHeaders.push('Content-Type: ' + session.rendertype);\n\t            options.extraHeaders = extraHeaders;\n\t            options.body = this.renderbody;\n\t          }\n\t          this.sendRequest(SIP.C.ACK, options);\n\t        } else {\n\t          if(!response.body) {\n\t            this.acceptAndTerminate(response, 400, 'Missing session description');\n\t            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            break;\n\t          }\n\t          if (!this.createDialog(response, 'UAC')) {\n\t            break;\n\t          }\n\t          this.hasAnswer = true;\n\t          this.mediaHandler.setDescription(response.body)\n\t          .then(\n\t            function onSuccess () {\n\t              var options = {};//,localMedia;\n\t              session.status = C.STATUS_CONFIRMED;\n\t              session.unmute();\n\t              /*localMedia = session.mediaHandler.localMedia;\n\t              if (localMedia.getAudioTracks().length > 0) {\n\t                localMedia.getAudioTracks()[0].enabled = true;\n\t              }\n\t              if (localMedia.getVideoTracks().length > 0) {\n\t                localMedia.getVideoTracks()[0].enabled = true;\n\t              }*/\n\t              if (session.renderbody) {\n\t                extraHeaders.push('Content-Type: ' + session.rendertype);\n\t                options.extraHeaders = extraHeaders;\n\t                options.body = session.renderbody;\n\t              }\n\t              options.cseq = response.cseq;\n\t              session.sendRequest(SIP.C.ACK, options);\n\t              session.accepted(response);\n\t            },\n\t            function onFailure (e) {\n\t              session.logger.warn(e);\n\t              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n\t              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n\t            }\n\t          );\n\t        }\n\t        break;\n\t      default:\n\t        cause = SIP.Utils.sipErrorCause(response.status_code);\n\t        this.rejected(response, cause);\n\t        this.failed(response, cause);\n\t        this.terminated(response, cause);\n\t    }\n\t  },\n\t\n\t  cancel: function(options) {\n\t    options = options || {};\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {\n\t      throw new SIP.Exceptions.InvalidStateError(this.status);\n\t    }\n\t\n\t    this.logger.log('canceling RTCSession');\n\t\n\t    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n\t\n\t    // Check Session Status\n\t    if (this.status === C.STATUS_NULL ||\n\t        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {\n\t      this.isCanceled = true;\n\t      this.cancelReason = cancel_reason;\n\t    } else if (this.status === C.STATUS_INVITE_SENT ||\n\t               this.status === C.STATUS_1XX_RECEIVED ||\n\t               this.status === C.STATUS_EARLY_MEDIA) {\n\t      this.request.cancel(cancel_reason);\n\t    }\n\t\n\t    return this.canceled();\n\t  },\n\t\n\t  terminate: function(options) {\n\t    if (this.status === C.STATUS_TERMINATED) {\n\t      return this;\n\t    }\n\t\n\t    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n\t      this.bye(options);\n\t    } else {\n\t      this.cancel(options);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  receiveRequest: function(request) {\n\t    // ICC RECEIVE REQUEST\n\t\n\t    // Reject CANCELs\n\t    if (request.method === SIP.C.CANCEL) {\n\t      // TODO; make this a switch when it gets added\n\t    }\n\t\n\t    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n\t      SIP.Timers.clearTimeout(this.timers.ackTimer);\n\t      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n\t      this.status = C.STATUS_CONFIRMED;\n\t      this.unmute();\n\t\n\t      this.accepted();\n\t    }\n\t\n\t    return Session.prototype.receiveRequest.apply(this, [request]);\n\t  },\n\t\n\t  onTransportError: function() {\n\t    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n\t    }\n\t  },\n\t\n\t  onRequestTimeout: function() {\n\t    if (this.status === C.STATUS_CONFIRMED) {\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    } else if (this.status !== C.STATUS_TERMINATED) {\n\t      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n\t    }\n\t  }\n\t\n\t};\n\t\n\tSIP.InviteClientContext = InviteClientContext;\n\t\n\t};\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview DTMF\n\t */\n\t\n\t/**\n\t * @class DTMF\n\t * @param {SIP.Session} session\n\t */\n\tmodule.exports = function (SIP) {\n\t\n\tvar DTMF,\n\t  C = {\n\t    MIN_DURATION:            70,\n\t    MAX_DURATION:            6000,\n\t    DEFAULT_DURATION:        100,\n\t    MIN_INTER_TONE_GAP:      50,\n\t    DEFAULT_INTER_TONE_GAP:  500\n\t  };\n\t\n\tDTMF = function(session, tone, options) {\n\t  var duration, interToneGap;\n\t\n\t  if (tone === undefined) {\n\t    throw new TypeError('Not enough arguments');\n\t  }\n\t\n\t  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n\t  this.owner = session;\n\t  this.direction = null;\n\t\n\t  options = options || {};\n\t  duration = options.duration || null;\n\t  interToneGap = options.interToneGap || null;\n\t\n\t  // Check tone type\n\t  if (typeof tone === 'string' ) {\n\t    tone = tone.toUpperCase();\n\t  } else if (typeof tone === 'number') {\n\t    tone = tone.toString();\n\t  } else {\n\t    throw new TypeError('Invalid tone: '+ tone);\n\t  }\n\t\n\t  // Check tone value\n\t  if (!tone.match(/^[0-9A-D#*]$/)) {\n\t    throw new TypeError('Invalid tone: '+ tone);\n\t  } else {\n\t    this.tone = tone;\n\t  }\n\t\n\t  // Check duration\n\t  if (duration && !SIP.Utils.isDecimal(duration)) {\n\t    throw new TypeError('Invalid tone duration: '+ duration);\n\t  } else if (!duration) {\n\t    duration = DTMF.C.DEFAULT_DURATION;\n\t  } else if (duration < DTMF.C.MIN_DURATION) {\n\t    this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');\n\t    duration = DTMF.C.MIN_DURATION;\n\t  } else if (duration > DTMF.C.MAX_DURATION) {\n\t    this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');\n\t    duration = DTMF.C.MAX_DURATION;\n\t  } else {\n\t    duration = Math.abs(duration);\n\t  }\n\t  this.duration = duration;\n\t\n\t  // Check interToneGap\n\t  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n\t    throw new TypeError('Invalid interToneGap: '+ interToneGap);\n\t  } else if (!interToneGap) {\n\t    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;\n\t  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {\n\t    this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');\n\t    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;\n\t  } else {\n\t    interToneGap = Math.abs(interToneGap);\n\t  }\n\t  this.interToneGap = interToneGap;\n\t};\n\tDTMF.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\t\n\tDTMF.prototype.send = function(options) {\n\t  var extraHeaders, body;\n\t\n\t  this.direction = 'outgoing';\n\t\n\t  // Check RTCSession Status\n\t  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&\n\t    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n\t    throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n\t  }\n\t\n\t  // Get DTMF options\n\t  options = options || {};\n\t  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n\t\n\t  extraHeaders.push('Content-Type: application/dtmf-relay');\n\t\n\t  body = \"Signal= \" + this.tone + \"\\r\\n\";\n\t  body += \"Duration= \" + this.duration;\n\t\n\t  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n\t    extraHeaders: extraHeaders,\n\t    body: body\n\t  });\n\t\n\t  this.owner.emit('dtmf', this.request, this);\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.receiveResponse = function(response) {\n\t  var cause;\n\t\n\t  switch(true) {\n\t    case /^1[0-9]{2}$/.test(response.status_code):\n\t      // Ignore provisional responses.\n\t      break;\n\t\n\t    case /^2[0-9]{2}$/.test(response.status_code):\n\t      this.emit('succeeded', {\n\t        originator: 'remote',\n\t        response: response\n\t      });\n\t      break;\n\t\n\t    default:\n\t      cause = SIP.Utils.sipErrorCause(response.status_code);\n\t      this.emit('failed', response, cause);\n\t      break;\n\t  }\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.onRequestTimeout = function() {\n\t  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n\t  this.owner.onRequestTimeout();\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.onTransportError = function() {\n\t  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n\t  this.owner.onTransportError();\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.onDialogError = function(response) {\n\t  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n\t  this.owner.onDialogError(response);\n\t};\n\t\n\t/**\n\t * @private\n\t */\n\tDTMF.prototype.init_incoming = function(request) {\n\t  this.direction = 'incoming';\n\t  this.request = request;\n\t\n\t  request.reply(200);\n\t\n\t  if (!this.tone || !this.duration) {\n\t    this.logger.warn('invalid INFO DTMF received, discarded');\n\t  } else {\n\t    this.owner.emit('dtmf', request, this);\n\t  }\n\t};\n\t\n\tDTMF.C = C;\n\treturn DTMF;\n\t};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP Subscription.\n\t */\n\tmodule.exports = function (SIP) {\n\tSIP.Subscription = function (ua, target, event, options) {\n\t  options = Object.create(options || Object.prototype);\n\t  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();\n\t\n\t  this.id = null;\n\t  this.state = 'init';\n\t\n\t  if (!event) {\n\t    throw new TypeError('Event necessary to create a subscription.');\n\t  } else {\n\t    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n\t    //The check may need to/should probably occur on the other side,\n\t    this.event = event;\n\t  }\n\t\n\t  if(typeof options.expires !== 'number'){\n\t    ua.logger.warn('expires must be a number. Using default of 3600.');\n\t    this.expires = 3600;\n\t  } else {\n\t    this.expires = options.expires;\n\t  }\n\t\n\t  options.extraHeaders.push('Event: ' + this.event);\n\t  options.extraHeaders.push('Expires: ' + this.expires);\n\t\n\t  if (options.body) {\n\t    this.body = options.body;\n\t  }\n\t\n\t  this.contact = ua.contact.toString();\n\t\n\t  options.extraHeaders.push('Contact: '+ this.contact);\n\t  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n\t\n\t  this.logger = ua.getLogger('sip.subscription');\n\t\n\t  this.dialog = null;\n\t  this.timers = {N: null, sub_duration: null};\n\t  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];\n\t};\n\t\n\tSIP.Subscription.prototype = {\n\t  subscribe: function() {\n\t    var sub = this;\n\t\n\t     //these states point to an existing subscription, no subscribe is necessary\n\t    if (this.state === 'active') {\n\t      this.refresh();\n\t      return this;\n\t    } else if (this.state === 'notify_wait') {\n\t      return this;\n\t    }\n\t\n\t    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t    SIP.Timers.clearTimeout(this.timers.N);\n\t    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\t\n\t    this.send();\n\t\n\t    this.state = 'notify_wait';\n\t\n\t    return this;\n\t  },\n\t\n\t  refresh: function () {\n\t    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {\n\t      return;\n\t    }\n\t\n\t    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {\n\t      extraHeaders: this.extraHeaders,\n\t      body: this.body\n\t    });\n\t  },\n\t\n\t  receiveResponse: function(response) {\n\t    var expires, sub = this,\n\t        cause = SIP.Utils.getReasonPhrase(response.status_code);\n\t\n\t    if ((this.state === 'notify_wait' && response.status_code >= 300) ||\n\t        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {\n\t      this.failed(response, null);\n\t    } else if (/^2[0-9]{2}$/.test(response.status_code)){\n\t      expires = response.getHeader('Expires');\n\t      SIP.Timers.clearTimeout(this.timers.N);\n\t\n\t      if (this.createConfirmedDialog(response,'UAC')) {\n\t        this.id = this.dialog.id.toString();\n\t        this.ua.subscriptions[this.id] = this;\n\t        this.emit('accepted', response, cause);\n\t        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n\t      }\n\t\n\t      if (expires && expires <= this.expires) {\n\t        // Preserve new expires value for subsequent requests\n\t        this.expires = expires;\n\t        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);\n\t      } else {\n\t        if (!expires) {\n\t          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n\t          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n\t        } else {\n\t          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n\t          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n\t        }\n\t      }\n\t    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx\n\t  },\n\t\n\t  unsubscribe: function() {\n\t    var extraHeaders = [], sub = this;\n\t\n\t    this.state = 'terminated';\n\t\n\t    extraHeaders.push('Event: ' + this.event);\n\t    extraHeaders.push('Expires: 0');\n\t\n\t    extraHeaders.push('Contact: '+ this.contact);\n\t    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n\t\n\t    //makes sure expires isn't set, and other typical resubscribe behavior\n\t    this.receiveResponse = function(){};\n\t\n\t    this.dialog.sendRequest(this, this.method, {\n\t      extraHeaders: extraHeaders,\n\t      body: this.body\n\t    });\n\t\n\t    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t    SIP.Timers.clearTimeout(this.timers.N);\n\t    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  timer_fire: function(){\n\t    if (this.state === 'terminated') {\n\t      this.terminateDialog();\n\t      SIP.Timers.clearTimeout(this.timers.N);\n\t      SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t\n\t      delete this.ua.subscriptions[this.id];\n\t    } else if (this.state === 'pending' || this.state === 'notify_wait') {\n\t      this.close();\n\t    } else {\n\t      this.refresh();\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  close: function() {\n\t    if(this.state !== 'notify_wait' && this.state !== 'terminated') {\n\t      this.unsubscribe();\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  createConfirmedDialog: function(message, type) {\n\t    var dialog;\n\t\n\t    this.terminateDialog();\n\t    dialog = new SIP.Dialog(this, message, type);\n\t\n\t    if(!dialog.error) {\n\t      this.dialog = dialog;\n\t      return true;\n\t    }\n\t    // Dialog not created due to an error\n\t    else {\n\t      return false;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  terminateDialog: function() {\n\t    if(this.dialog) {\n\t      delete this.ua.subscriptions[this.id];\n\t      this.dialog.terminate();\n\t      delete this.dialog;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  receiveRequest: function(request) {\n\t    var sub_state, sub = this;\n\t\n\t    function setExpiresTimeout() {\n\t      if (sub_state.expires) {\n\t        SIP.Timers.clearTimeout(sub.timers.sub_duration);\n\t        sub_state.expires = Math.min(sub.expires,\n\t                                     Math.max(sub_state.expires, 0));\n\t        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),\n\t                                                    sub_state.expires * 900);\n\t      }\n\t    }\n\t\n\t    if (!this.matchEvent(request)) { //checks event and subscription_state headers\n\t      request.reply(489);\n\t      return;\n\t    }\n\t\n\t    sub_state = request.parseHeader('Subscription-State');\n\t\n\t    request.reply(200, SIP.C.REASON_200);\n\t\n\t    SIP.Timers.clearTimeout(this.timers.N);\n\t\n\t    this.emit('notify', {request: request});\n\t\n\t    // if we've set state to terminated, no further processing should take place\n\t    // and we are only interested in cleaning up after the appropriate NOTIFY\n\t    if (this.state === 'terminated') {\n\t      if (sub_state.state === 'terminated') {\n\t        this.terminateDialog();\n\t        SIP.Timers.clearTimeout(this.timers.N);\n\t        SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t\n\t        delete this.ua.subscriptions[this.id];\n\t      }\n\t      return;\n\t    }\n\t\n\t    switch (sub_state.state) {\n\t      case 'active':\n\t        this.state = 'active';\n\t        setExpiresTimeout();\n\t        break;\n\t      case 'pending':\n\t        if (this.state === 'notify_wait') {\n\t          setExpiresTimeout();\n\t        }\n\t        this.state = 'pending';\n\t        break;\n\t      case 'terminated':\n\t        SIP.Timers.clearTimeout(this.timers.sub_duration);\n\t        if (sub_state.reason) {\n\t          this.logger.log('terminating subscription with reason '+ sub_state.reason);\n\t          switch (sub_state.reason) {\n\t            case 'deactivated':\n\t            case 'timeout':\n\t              this.subscribe();\n\t              return;\n\t            case 'probation':\n\t            case 'giveup':\n\t              if(sub_state.params && sub_state.params['retry-after']) {\n\t                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n\t              } else {\n\t                this.subscribe();\n\t              }\n\t              return;\n\t            case 'rejected':\n\t            case 'noresource':\n\t            case 'invariant':\n\t              break;\n\t          }\n\t        }\n\t        this.close();\n\t        break;\n\t    }\n\t  },\n\t\n\t  failed: function(response, cause) {\n\t    this.close();\n\t    this.emit('failed', response, cause);\n\t    return this;\n\t  },\n\t\n\t  onDialogError: function(response) {\n\t    this.failed(response, SIP.C.causes.DIALOG_ERROR);\n\t  },\n\t\n\t  /**\n\t  * @private\n\t  */\n\t  matchEvent: function(request) {\n\t    var event;\n\t\n\t    // Check mandatory header Event\n\t    if (!request.hasHeader('Event')) {\n\t      this.logger.warn('missing Event header');\n\t      return false;\n\t    }\n\t    // Check mandatory header Subscription-State\n\t    if (!request.hasHeader('Subscription-State')) {\n\t      this.logger.warn('missing Subscription-State header');\n\t      return false;\n\t    }\n\t\n\t    // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n\t    event = request.parseHeader('event').event;\n\t\n\t    if (this.event !== event) {\n\t      this.logger.warn('event match failed');\n\t      request.reply(481, 'Event Match Failed');\n\t      return false;\n\t    } else {\n\t      return true;\n\t    }\n\t  }\n\t};\n\t};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview WebRTC\n\t */\n\t\n\tmodule.exports = function (SIP, environment) {\n\tvar WebRTC;\n\t\n\tWebRTC = {};\n\t\n\tWebRTC.MediaHandler = __webpack_require__(41)(SIP);\n\tWebRTC.MediaStreamManager = __webpack_require__(42)(SIP, environment);\n\t\n\tvar _isSupported;\n\t\n\tWebRTC.isSupported = function () {\n\t  if (_isSupported !== undefined) {\n\t    return _isSupported;\n\t  }\n\t\n\t  WebRTC.MediaStream = environment.MediaStream;\n\t  WebRTC.getUserMedia = environment.getUserMedia;\n\t  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;\n\t  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;\n\t\n\t  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {\n\t    if (WebRTC.getUserMedia) {\n\t      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');\n\t    }\n\t    _isSupported = true;\n\t  }\n\t  else {\n\t    _isSupported = false;\n\t  }\n\t  return _isSupported;\n\t};\n\t\n\treturn WebRTC;\n\t};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview MediaHandler\n\t */\n\t\n\t/* MediaHandler\n\t * @class PeerConnection helper Class.\n\t * @param {SIP.Session} session\n\t * @param {Object} [options]\n\t * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]\n\t *        The MediaStreamManager to acquire/release streams from/to.\n\t *        If not provided, a default MediaStreamManager will be used.\n\t */\n\tmodule.exports = function (SIP) {\n\t\n\tvar MediaHandler = function(session, options) {\n\t  options = options || {};\n\t\n\t  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);\n\t  this.session = session;\n\t  this.localMedia = null;\n\t  this.ready = true;\n\t  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);\n\t  this.audioMuted = false;\n\t  this.videoMuted = false;\n\t\n\t  // old init() from here on\n\t  var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n\t  this.RTCConstraints = options.RTCConstraints || {};\n\t\n\t  this.initPeerConnection(servers, this.RTCConstraints);\n\t\n\t  function selfEmit(mh, event) {\n\t    if (mh.mediaStreamManager.on) {\n\t      mh.mediaStreamManager.on(event, function () {\n\t        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));\n\t      });\n\t    }\n\t  }\n\t\n\t  selfEmit(this, 'userMediaRequest');\n\t  selfEmit(this, 'userMedia');\n\t  selfEmit(this, 'userMediaFailed');\n\t};\n\t\n\tMediaHandler.defaultFactory = function defaultFactory (session, options) {\n\t  return new MediaHandler(session, options);\n\t};\n\tMediaHandler.defaultFactory.isSupported = function () {\n\t  return SIP.WebRTC.isSupported();\n\t};\n\t\n\tMediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {\n\t// Functions the session can use\n\t  isReady: {writable: true, value: function isReady () {\n\t    return this.ready;\n\t  }},\n\t\n\t  close: {writable: true, value: function close () {\n\t    this.logger.log('closing PeerConnection');\n\t    this._remoteStreams = [];\n\t    // have to check signalingState since this.close() gets called multiple times\n\t    // TODO figure out why that happens\n\t    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n\t      this.peerConnection.close();\n\t\n\t      if(this.localMedia) {\n\t        this.mediaStreamManager.release(this.localMedia);\n\t      }\n\t    }\n\t  }},\n\t\n\t  /**\n\t   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]\n\t   *        the MediaStream (or the constraints describing it) to be used for the session\n\t   */\n\t  getDescription: {writable: true, value: function getDescription (mediaHint) {\n\t    var self = this;\n\t    var acquire = self.mediaStreamManager.acquire;\n\t    if (acquire.length > 1) {\n\t      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);\n\t    }\n\t    mediaHint = mediaHint || {};\n\t    if (mediaHint.dataChannel === true) {\n\t      mediaHint.dataChannel = {};\n\t    }\n\t    this.mediaHint = mediaHint;\n\t\n\t    /*\n\t     * 1. acquire streams (skip if MediaStreams passed in)\n\t     * 2. addStreams\n\t     * 3. createOffer/createAnswer\n\t     */\n\t\n\t    var streamPromise;\n\t    if (self.localMedia) {\n\t      self.logger.log('already have local media');\n\t      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);\n\t    }\n\t    else {\n\t      self.logger.log('acquiring local media');\n\t      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)\n\t        .then(function acquireSucceeded(streams) {\n\t          self.logger.log('acquired local media streams');\n\t          self.localMedia = streams;\n\t          self.session.connecting();\n\t          return streams;\n\t        }, function acquireFailed(err) {\n\t          self.logger.error('unable to acquire streams');\n\t          self.logger.error(err);\n\t          self.session.connecting();\n\t          throw err;\n\t        })\n\t        .then(this.addStreams.bind(this))\n\t      ;\n\t    }\n\t\n\t    return streamPromise\n\t      .then(function streamAdditionSucceeded() {\n\t        if (self.hasOffer('remote')) {\n\t          self.peerConnection.ondatachannel = function (evt) {\n\t            self.dataChannel = evt.channel;\n\t            self.emit('dataChannel', self.dataChannel);\n\t          };\n\t        } else if (mediaHint.dataChannel &&\n\t                   self.peerConnection.createDataChannel) {\n\t          self.dataChannel = self.peerConnection.createDataChannel(\n\t            'sipjs',\n\t            mediaHint.dataChannel\n\t          );\n\t          self.emit('dataChannel', self.dataChannel);\n\t        }\n\t\n\t        self.render();\n\t        return self.createOfferOrAnswer(self.RTCConstraints);\n\t      })\n\t    ;\n\t  }},\n\t\n\t  /**\n\t  * Message reception.\n\t  * @param {String} type\n\t  * @param {String} sdp\n\t  */\n\t  setDescription: {writable: true, value: function setDescription (sdp) {\n\t    var rawDescription = {\n\t      type: this.hasOffer('local') ? 'answer' : 'offer',\n\t      sdp: sdp\n\t    };\n\t\n\t    this.emit('setDescription', rawDescription);\n\t\n\t    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);\n\t    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);\n\t  }},\n\t\n\t  /**\n\t   * If the Session associated with this MediaHandler were to be referred,\n\t   * what mediaHint should be provided to the UA's invite method?\n\t   */\n\t  getReferMedia: {writable: true, value: function getReferMedia () {\n\t    function hasTracks (trackGetter, stream) {\n\t      return stream[trackGetter]().length > 0;\n\t    }\n\t\n\t    function bothHaveTracks (trackGetter) {\n\t      /* jshint validthis:true */\n\t      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&\n\t             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));\n\t    }\n\t\n\t    return {\n\t      constraints: {\n\t        audio: bothHaveTracks.call(this, 'getAudioTracks'),\n\t        video: bothHaveTracks.call(this, 'getVideoTracks')\n\t      }\n\t    };\n\t  }},\n\t\n\t  updateIceServers: {writeable:true, value: function (options) {\n\t    var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n\t    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;\n\t\n\t    this.initPeerConnection(servers, this.RTCConstraints);\n\t\n\t    /* once updateIce is implemented correctly, this is better than above\n\t    //no op if browser does not support this\n\t    if (!this.peerConnection.updateIce) {\n\t      return;\n\t    }\n\t\n\t    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);\n\t    */\n\t  }},\n\t\n\t// Functions the session can use, but only because it's convenient for the application\n\t  isMuted: {writable: true, value: function isMuted () {\n\t    return {\n\t      audio: this.audioMuted,\n\t      video: this.videoMuted\n\t    };\n\t  }},\n\t\n\t  mute: {writable: true, value: function mute (options) {\n\t    if (this.getLocalStreams().length === 0) {\n\t      return;\n\t    }\n\t\n\t    options = options || {\n\t      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n\t      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n\t    };\n\t\n\t    var audioMuted = false,\n\t        videoMuted = false;\n\t\n\t    if (options.audio && !this.audioMuted) {\n\t      audioMuted = true;\n\t      this.audioMuted = true;\n\t      this.toggleMuteAudio(true);\n\t    }\n\t\n\t    if (options.video && !this.videoMuted) {\n\t      videoMuted = true;\n\t      this.videoMuted = true;\n\t      this.toggleMuteVideo(true);\n\t    }\n\t\n\t    //REVISIT\n\t    if (audioMuted || videoMuted) {\n\t      return {\n\t        audio: audioMuted,\n\t        video: videoMuted\n\t      };\n\t      /*this.session.onmute({\n\t        audio: audioMuted,\n\t        video: videoMuted\n\t      });*/\n\t    }\n\t  }},\n\t\n\t  unmute: {writable: true, value: function unmute (options) {\n\t    if (this.getLocalStreams().length === 0) {\n\t      return;\n\t    }\n\t\n\t    options = options || {\n\t      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n\t      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n\t    };\n\t\n\t    var audioUnMuted = false,\n\t        videoUnMuted = false;\n\t\n\t    if (options.audio && this.audioMuted) {\n\t      audioUnMuted = true;\n\t      this.audioMuted = false;\n\t      this.toggleMuteAudio(false);\n\t    }\n\t\n\t    if (options.video && this.videoMuted) {\n\t      videoUnMuted = true;\n\t      this.videoMuted = false;\n\t      this.toggleMuteVideo(false);\n\t    }\n\t\n\t    //REVISIT\n\t    if (audioUnMuted || videoUnMuted) {\n\t      return {\n\t        audio: audioUnMuted,\n\t        video: videoUnMuted\n\t      };\n\t      /*this.session.onunmute({\n\t        audio: audioUnMuted,\n\t        video: videoUnMuted\n\t      });*/\n\t    }\n\t  }},\n\t\n\t  hold: {writable: true, value: function hold () {\n\t    this.toggleMuteAudio(true);\n\t    this.toggleMuteVideo(true);\n\t  }},\n\t\n\t  unhold: {writable: true, value: function unhold () {\n\t    if (!this.audioMuted) {\n\t      this.toggleMuteAudio(false);\n\t    }\n\t\n\t    if (!this.videoMuted) {\n\t      this.toggleMuteVideo(false);\n\t    }\n\t  }},\n\t\n\t// Functions the application can use, but not the session\n\t  getLocalStreams: {writable: true, value: function getLocalStreams () {\n\t    var pc = this.peerConnection;\n\t    if (pc && pc.signalingState === 'closed') {\n\t      this.logger.warn('peerConnection is closed, getLocalStreams returning []');\n\t      return [];\n\t    }\n\t    return (pc.getLocalStreams && pc.getLocalStreams()) ||\n\t      pc.localStreams || [];\n\t  }},\n\t\n\t  getRemoteStreams: {writable: true, value: function getRemoteStreams () {\n\t    var pc = this.peerConnection;\n\t    if (pc && pc.signalingState === 'closed') {\n\t      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');\n\t      return this._remoteStreams;\n\t    }\n\t    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||\n\t      pc.remoteStreams || [];\n\t  }},\n\t\n\t  render: {writable: true, value: function render (renderHint) {\n\t    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);\n\t    if (!renderHint) {\n\t      return false;\n\t    }\n\t    var streamGetters = {\n\t      local: 'getLocalStreams',\n\t      remote: 'getRemoteStreams'\n\t    };\n\t    Object.keys(streamGetters).forEach(function (loc) {\n\t      var streamGetter = streamGetters[loc];\n\t      var streams = this[streamGetter]();\n\t      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);\n\t    }.bind(this));\n\t  }},\n\t\n\t// Internal functions\n\t  hasOffer: {writable: true, value: function hasOffer (where) {\n\t    var offerState = 'have-' + where + '-offer';\n\t    return this.peerConnection.signalingState === offerState;\n\t    // TODO consider signalingStates with 'pranswer'?\n\t  }},\n\t\n\t  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {\n\t    var servers = [],\n\t      config = this.session.ua.configuration;\n\t\n\t    stunServers = stunServers || config.stunServers;\n\t    turnServers = turnServers || config.turnServers;\n\t\n\t    [].concat(stunServers).forEach(function (server) {\n\t      servers.push({'urls': server});\n\t    });\n\t\n\t    [].concat(turnServers).forEach(function (server) {\n\t      servers.push({\n\t        'urls': server.urls,\n\t        'username': server.username,\n\t        'credential': server.password\n\t      });\n\t    });\n\t\n\t    return servers;\n\t  }},\n\t\n\t  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {\n\t    var self = this,\n\t      config = this.session.ua.configuration;\n\t\n\t    this.onIceCompleted = SIP.Utils.defer();\n\t    this.onIceCompleted.promise.then(function(pc) {\n\t      self.emit('iceGatheringComplete', pc);\n\t      if (self.iceCheckingTimer) {\n\t        SIP.Timers.clearTimeout(self.iceCheckingTimer);\n\t        self.iceCheckingTimer = null;\n\t      }\n\t    });\n\t\n\t    if (this.peerConnection) {\n\t      this.peerConnection.close();\n\t    }\n\t\n\t    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);\n\t\n\t    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams\n\t    // even if peerConnection.onaddstream was just called. In order to make\n\t    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually\n\t    this._remoteStreams = [];\n\t\n\t    this.peerConnection.onaddstream = function(e) {\n\t      self.logger.log('stream added: '+ e.stream.id);\n\t      self._remoteStreams.push(e.stream);\n\t      self.render();\n\t      self.emit('addStream', e);\n\t    };\n\t\n\t    this.peerConnection.onremovestream = function(e) {\n\t      self.logger.log('stream removed: '+ e.stream.id);\n\t    };\n\t\n\t    this.startIceCheckingTimer = function () {\n\t      if (!self.iceCheckingTimer) {\n\t        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {\n\t          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');\n\t          self.onIceCompleted.resolve(this);\n\t        }.bind(this.peerConnection), config.iceCheckingTimeout);\n\t      }\n\t    };\n\t\n\t    this.peerConnection.onicecandidate = function(e) {\n\t      self.emit('iceCandidate', e);\n\t      if (e.candidate) {\n\t        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n\t        self.startIceCheckingTimer();\n\t      } else {\n\t        self.onIceCompleted.resolve(this);\n\t      }\n\t    };\n\t\n\t    this.peerConnection.onicegatheringstatechange = function () {\n\t      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n\t      if (this.iceGatheringState === 'gathering') {\n\t        self.emit('iceGathering', this);\n\t      }\n\t      if (this.iceGatheringState === 'complete') {\n\t        self.onIceCompleted.resolve(this);\n\t      }\n\t    };\n\t\n\t    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case\n\t      var stateEvent;\n\t\n\t      if (this.iceConnectionState === 'checking') {\n\t        self.startIceCheckingTimer();\n\t      }\n\t\n\t      switch (this.iceConnectionState) {\n\t      case 'new':\n\t        stateEvent = 'iceConnection';\n\t        break;\n\t      case 'checking':\n\t        stateEvent = 'iceConnectionChecking';\n\t        break;\n\t      case 'connected':\n\t        stateEvent = 'iceConnectionConnected';\n\t        break;\n\t      case 'completed':\n\t        stateEvent = 'iceConnectionCompleted';\n\t        break;\n\t      case 'failed':\n\t        stateEvent = 'iceConnectionFailed';\n\t        break;\n\t      case 'disconnected':\n\t        stateEvent = 'iceConnectionDisconnected';\n\t        break;\n\t      case 'closed':\n\t        stateEvent = 'iceConnectionClosed';\n\t        break;\n\t      default:\n\t        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);\n\t        return;\n\t      }\n\t      self.emit(stateEvent, this);\n\t\n\t      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated\n\t      //normal calls switch from failed to connected in some cases, so checking for failed and terminated\n\t      /*if (this.iceConnectionState === 'failed') {\n\t        self.session.terminate({\n\t        cause: SIP.C.causes.RTP_TIMEOUT,\n\t        status_code: 200,\n\t        reason_phrase: SIP.C.causes.RTP_TIMEOUT\n\t      });\n\t      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {\n\t      self.onIceCompleted(this);\n\t      }*/\n\t    };\n\t\n\t    this.peerConnection.onstatechange = function() {\n\t      self.logger.log('PeerConnection state changed to \"'+ this.readyState +'\"');\n\t    };\n\t  }},\n\t\n\t  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {\n\t    var self = this;\n\t    var methodName;\n\t    var pc = self.peerConnection;\n\t\n\t    self.ready = false;\n\t    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n\t\n\t    return SIP.Utils.promisify(pc, methodName, true)(constraints)\n\t      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))\n\t      .then(function onSetLocalDescriptionSuccess() {\n\t        var deferred = SIP.Utils.defer();\n\t        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {\n\t          deferred.resolve();\n\t        } else {\n\t          self.onIceCompleted.promise.then(deferred.resolve);\n\t        }\n\t        return deferred.promise;\n\t      })\n\t      .then(function readySuccess () {\n\t        var sdp = pc.localDescription.sdp;\n\t\n\t        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);\n\t        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);\n\t\n\t        var sdpWrapper = {\n\t          type: methodName === 'createOffer' ? 'offer' : 'answer',\n\t          sdp: sdp\n\t        };\n\t\n\t        self.emit('getDescription', sdpWrapper);\n\t\n\t        self.ready = true;\n\t        return sdpWrapper.sdp;\n\t      })\n\t      .catch(function methodFailed (e) {\n\t        self.logger.error(e);\n\t        self.ready = true;\n\t        throw new SIP.Exceptions.GetDescriptionError(e);\n\t      })\n\t    ;\n\t  }},\n\t\n\t  addStreams: {writable: true, value: function addStreams (streams) {\n\t    try {\n\t      streams = [].concat(streams);\n\t      streams.forEach(function (stream) {\n\t        this.peerConnection.addStream(stream);\n\t      }, this);\n\t    } catch(e) {\n\t      this.logger.error('error adding stream');\n\t      this.logger.error(e);\n\t      return SIP.Utils.Promise.reject(e);\n\t    }\n\t\n\t    return SIP.Utils.Promise.resolve();\n\t  }},\n\t\n\t  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {\n\t    this.getLocalStreams().forEach(function (stream) {\n\t      stream[trackGetter]().forEach(function (track) {\n\t        track.enabled = !mute;\n\t      });\n\t    });\n\t  }},\n\t\n\t  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {\n\t    this.toggleMuteHelper('getAudioTracks', mute);\n\t  }},\n\t\n\t  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {\n\t    this.toggleMuteHelper('getVideoTracks', mute);\n\t  }}\n\t});\n\t\n\t// Return since it will be assigned to a variable.\n\treturn MediaHandler;\n\t};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview MediaStreamManager\n\t */\n\t\n\t/* MediaStreamManager\n\t * @class Manages the acquisition and release of MediaStreams.\n\t * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()\n\t */\n\tmodule.exports = function (SIP, environment) {\n\t\n\t// Default MediaStreamManager provides single-use streams created with getUserMedia\n\tvar MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {\n\t  if (!SIP.WebRTC.isSupported()) {\n\t    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n\t  }\n\t\n\t  this.mediaHint = defaultMediaHint || {\n\t    constraints: {audio: true, video: true}\n\t  };\n\t\n\t  // map of streams to acquisition manner:\n\t  // true -> passed in as mediaHint.stream\n\t  // false -> getUserMedia\n\t  this.acquisitions = {};\n\t};\n\tMediaStreamManager.streamId = function (stream) {\n\t  return stream.getAudioTracks().concat(stream.getVideoTracks())\n\t    .map(function trackId (track) {\n\t      return track.id;\n\t    })\n\t    .join('');\n\t};\n\t\n\t/**\n\t * @param {(Array of) MediaStream} streams - The streams to render\n\t *\n\t * @param {(Array of) HTMLMediaElement} elements\n\t *        - The <audio>/<video> element(s) that should render the streams\n\t *\n\t * Each stream in streams renders to the corresponding element in elements,\n\t * wrapping around elements if needed.\n\t */\n\tMediaStreamManager.render = function render (streams, elements) {\n\t  if (!elements) {\n\t    return false;\n\t  }\n\t  if (Array.isArray(elements) && !elements.length) {\n\t    throw new TypeError('elements must not be empty');\n\t  }\n\t\n\t  function attachMediaStream(element, stream) {\n\t    if (typeof element.src !== 'undefined') {\n\t      environment.revokeObjectURL(element.src);\n\t      element.src = environment.createObjectURL(stream);\n\t    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {\n\t      element.srcObject = element.mozSrcObject = stream;\n\t    } else {\n\t      return false;\n\t    }\n\t\n\t    return true;\n\t  }\n\t\n\t  function ensureMediaPlaying (mediaElement) {\n\t    var interval = 100;\n\t    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {\n\t      if (mediaElement.paused) {\n\t        mediaElement.play();\n\t      }\n\t      else {\n\t        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);\n\t      }\n\t    }, interval);\n\t  }\n\t\n\t  function attachAndPlay (elements, stream, index) {\n\t    if (typeof elements === 'function') {\n\t      elements = elements();\n\t    }\n\t    var element = elements[index % elements.length];\n\t    (environment.attachMediaStream || attachMediaStream)(element, stream);\n\t    ensureMediaPlaying(element);\n\t  }\n\t\n\t  // [].concat \"casts\" `elements` into an array\n\t  // so forEach works even if `elements` was a single element\n\t  elements = [].concat(elements);\n\t  [].concat(streams).forEach(attachAndPlay.bind(null, elements));\n\t};\n\t\n\tMediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {\n\t  'acquire': {writable: true, value: function acquire (mediaHint) {\n\t    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;\n\t\n\t    var saveSuccess = function (isHintStream, streams) {\n\t      streams = [].concat(streams);\n\t      streams.forEach(function (stream) {\n\t        var streamId = MediaStreamManager.streamId(stream);\n\t        this.acquisitions[streamId] = !!isHintStream;\n\t      }, this);\n\t      return SIP.Utils.Promise.resolve(streams);\n\t    }.bind(this);\n\t\n\t    if (mediaHint.stream) {\n\t      return saveSuccess(true, mediaHint.stream);\n\t    } else {\n\t      // Fallback to audio/video enabled if no mediaHint can be found.\n\t      var constraints = mediaHint.constraints ||\n\t        (this.mediaHint && this.mediaHint.constraints) ||\n\t        {audio: true, video: true};\n\t\n\t      var deferred = SIP.Utils.defer();\n\t\n\t      /*\n\t       * Make the call asynchronous, so that ICCs have a chance\n\t       * to define callbacks to `userMediaRequest`\n\t       */\n\t      SIP.Timers.setTimeout(function () {\n\t        this.emit('userMediaRequest', constraints);\n\t\n\t        var emitThenCall = function (eventName, callback) {\n\t          var callbackArgs = Array.prototype.slice.call(arguments, 2);\n\t          // Emit with all of the arguments from the real callback.\n\t          var newArgs = [eventName].concat(callbackArgs);\n\t\n\t          this.emit.apply(this, newArgs);\n\t\n\t          return callback.apply(null, callbackArgs);\n\t        }.bind(this);\n\t\n\t        if (constraints.audio || constraints.video) {\n\t          deferred.resolve(\n\t            SIP.WebRTC.getUserMedia(constraints)\n\t            .then(\n\t              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),\n\t              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})\n\t            )\n\t          );\n\t        } else {\n\t          // Local streams were explicitly excluded.\n\t          deferred.resolve([]);\n\t        }\n\t      }.bind(this), 0);\n\t\n\t      return deferred.promise;\n\t    }\n\t  }},\n\t\n\t  'release': {writable: true, value: function release (streams) {\n\t    streams = [].concat(streams);\n\t    streams.forEach(function (stream) {\n\t      var streamId = MediaStreamManager.streamId(stream);\n\t      if (this.acquisitions[streamId] === false) {\n\t        stream.getTracks().forEach(function (track) {\n\t          track.stop();\n\t        });\n\t      }\n\t      delete this.acquisitions[streamId];\n\t    }, this);\n\t  }},\n\t});\n\t\n\t// Return since it will be assigned to a variable.\n\treturn MediaStreamManager;\n\t};\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t/**\n\t * @augments SIP\n\t * @class Class creating a SIP User Agent.\n\t * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]\n\t *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.\n\t *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.\n\t *\n\t * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t */\n\tmodule.exports = function (SIP, environment) {\n\tvar UA,\n\t  C = {\n\t    // UA status codes\n\t    STATUS_INIT:                0,\n\t    STATUS_STARTING:            1,\n\t    STATUS_READY:               2,\n\t    STATUS_USER_CLOSED:         3,\n\t    STATUS_NOT_READY:           4,\n\t\n\t    // UA error codes\n\t    CONFIGURATION_ERROR:  1,\n\t    NETWORK_ERROR:        2,\n\t\n\t    ALLOWED_METHODS: [\n\t      'ACK',\n\t      'CANCEL',\n\t      'INVITE',\n\t      'MESSAGE',\n\t      'BYE',\n\t      'OPTIONS',\n\t      'INFO',\n\t      'NOTIFY',\n\t      'REFER'\n\t    ],\n\t\n\t    ACCEPTED_BODY_TYPES: [\n\t      'application/sdp',\n\t      'application/dtmf-relay'\n\t    ],\n\t\n\t    MAX_FORWARDS: 70,\n\t    TAG_LENGTH: 10\n\t  };\n\t\n\tUA = function(configuration) {\n\t  var self = this;\n\t\n\t  // Helper function for forwarding events\n\t  function selfEmit(type) {\n\t    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n\t    return self.emit.bind(self, type);\n\t  }\n\t\n\t  // Set Accepted Body Types\n\t  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n\t\n\t  this.log = new SIP.LoggerFactory();\n\t  this.logger = this.getLogger('sip.ua');\n\t\n\t  this.cache = {\n\t    credentials: {}\n\t  };\n\t\n\t  this.configuration = {};\n\t  this.dialogs = {};\n\t\n\t  //User actions outside any session/dialog (MESSAGE)\n\t  this.applicants = {};\n\t\n\t  this.data = {};\n\t  this.sessions = {};\n\t  this.subscriptions = {};\n\t  this.transport = null;\n\t  this.contact = null;\n\t  this.status = C.STATUS_INIT;\n\t  this.error = null;\n\t  this.transactions = {\n\t    nist: {},\n\t    nict: {},\n\t    ist: {},\n\t    ict: {}\n\t  };\n\t\n\t  this.transportRecoverAttempts = 0;\n\t  this.transportRecoveryTimer = null;\n\t\n\t  Object.defineProperties(this, {\n\t    transactionsCount: {\n\t      get: function() {\n\t        var type,\n\t          transactions = ['nist','nict','ist','ict'],\n\t          count = 0;\n\t\n\t        for (type in transactions) {\n\t          count += Object.keys(this.transactions[transactions[type]]).length;\n\t        }\n\t\n\t        return count;\n\t      }\n\t    },\n\t\n\t    nictTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['nict']).length;\n\t      }\n\t    },\n\t\n\t    nistTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['nist']).length;\n\t      }\n\t    },\n\t\n\t    ictTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['ict']).length;\n\t      }\n\t    },\n\t\n\t    istTransactionsCount: {\n\t      get: function() {\n\t        return Object.keys(this.transactions['ist']).length;\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Load configuration\n\t   *\n\t   * @throws {SIP.Exceptions.ConfigurationError}\n\t   * @throws {TypeError}\n\t   */\n\t\n\t  if(configuration === undefined) {\n\t    configuration = {};\n\t  } else if (typeof configuration === 'string' || configuration instanceof String) {\n\t    configuration = {\n\t      uri: configuration\n\t    };\n\t  }\n\t\n\t  // Apply log configuration if present\n\t  if (configuration.log) {\n\t    if (configuration.log.hasOwnProperty('builtinEnabled')) {\n\t      this.log.builtinEnabled = configuration.log.builtinEnabled;\n\t    }\n\t\n\t    if (configuration.log.hasOwnProperty('level')) {\n\t      this.log.level = configuration.log.level;\n\t    }\n\t\n\t    if (configuration.log.hasOwnProperty('connector')) {\n\t      this.log.connector = configuration.log.connector;\n\t    }\n\t  }\n\t\n\t  try {\n\t    this.loadConfig(configuration);\n\t  } catch(e) {\n\t    this.status = C.STATUS_NOT_READY;\n\t    this.error = C.CONFIGURATION_ERROR;\n\t    throw e;\n\t  }\n\t\n\t  // Initialize registerContext\n\t  this.registerContext = new SIP.RegisterContext(this);\n\t  this.registerContext.on('failed', selfEmit('registrationFailed'));\n\t  this.registerContext.on('registered', selfEmit('registered'));\n\t  this.registerContext.on('unregistered', selfEmit('unregistered'));\n\t\n\t  if(this.configuration.autostart) {\n\t    this.start();\n\t  }\n\t\n\t  if (typeof environment.addEventListener === 'function') {\n\t    // Google Chrome Packaged Apps don't allow 'unload' listeners:\n\t    // unload is not available in packaged apps\n\t    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {\n\t      environment.addEventListener('unload', this.stop.bind(this));\n\t    }\n\t  }\n\t};\n\tUA.prototype = Object.create(SIP.EventEmitter.prototype);\n\t\n\t//=================\n\t//  High Level API\n\t//=================\n\t\n\tUA.prototype.register = function(options) {\n\t  this.configuration.register = true;\n\t  this.registerContext.register(options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Unregister.\n\t *\n\t * @param {Boolean} [all] unregister all user bindings.\n\t *\n\t */\n\tUA.prototype.unregister = function(options) {\n\t  this.configuration.register = false;\n\t\n\t  var context = this.registerContext;\n\t  this.afterConnected(context.unregister.bind(context, options));\n\t\n\t  return this;\n\t};\n\t\n\tUA.prototype.isRegistered = function() {\n\t  return this.registerContext.registered;\n\t};\n\t\n\t/**\n\t * Connection state.\n\t * @param {Boolean}\n\t */\n\tUA.prototype.isConnected = function() {\n\t  return this.transport ? this.transport.connected : false;\n\t};\n\t\n\tUA.prototype.afterConnected = function afterConnected (callback) {\n\t  if (this.isConnected()) {\n\t    callback();\n\t  } else {\n\t    this.once('connected', callback);\n\t  }\n\t};\n\t\n\t/**\n\t * Make an outgoing call.\n\t *\n\t * @param {String} target\n\t * @param {Object} views\n\t * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n\t *\n\t * @throws {TypeError}\n\t *\n\t */\n\tUA.prototype.invite = function(target, options) {\n\t  var context = new SIP.InviteClientContext(this, target, options);\n\t\n\t  this.afterConnected(context.invite.bind(context));\n\t  return context;\n\t};\n\t\n\tUA.prototype.subscribe = function(target, event, options) {\n\t  var sub = new SIP.Subscription(this, target, event, options);\n\t\n\t  this.afterConnected(sub.subscribe.bind(sub));\n\t  return sub;\n\t};\n\t\n\t/**\n\t * Send a message.\n\t *\n\t * @param {String} target\n\t * @param {String} body\n\t * @param {Object} [options]\n\t *\n\t * @throws {TypeError}\n\t *\n\t */\n\tUA.prototype.message = function(target, body, options) {\n\t  if (body === undefined) {\n\t    throw new TypeError('Not enough arguments');\n\t  }\n\t\n\t  // There is no Message module, so it is okay that the UA handles defaults here.\n\t  options = Object.create(options || Object.prototype);\n\t  options.contentType || (options.contentType = 'text/plain');\n\t  options.body = body;\n\t\n\t  return this.request(SIP.C.MESSAGE, target, options);\n\t};\n\t\n\tUA.prototype.request = function (method, target, options) {\n\t  var req = new SIP.ClientContext(this, method, target, options);\n\t\n\t  this.afterConnected(req.send.bind(req));\n\t  return req;\n\t};\n\t\n\t/**\n\t * Gracefully close.\n\t *\n\t */\n\tUA.prototype.stop = function() {\n\t  var session, subscription, applicant,\n\t    ua = this;\n\t\n\t  function transactionsListener() {\n\t    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n\t        ua.removeListener('transactionDestroyed', transactionsListener);\n\t        ua.transport.disconnect();\n\t    }\n\t  }\n\t\n\t  this.logger.log('user requested closure...');\n\t\n\t  if(this.status === C.STATUS_USER_CLOSED) {\n\t    this.logger.warn('UA already closed');\n\t    return this;\n\t  }\n\t\n\t  // Clear transportRecoveryTimer\n\t  SIP.Timers.clearTimeout(this.transportRecoveryTimer);\n\t\n\t  // Close registerContext\n\t  this.logger.log('closing registerContext');\n\t  this.registerContext.close();\n\t\n\t  // Run  _terminate_ on every Session\n\t  for(session in this.sessions) {\n\t    this.logger.log('closing session ' + session);\n\t    this.sessions[session].terminate();\n\t  }\n\t\n\t  //Run _close_ on every Subscription\n\t  for(subscription in this.subscriptions) {\n\t    this.logger.log('unsubscribing from subscription ' + subscription);\n\t    this.subscriptions[subscription].close();\n\t  }\n\t\n\t  // Run  _close_ on every applicant\n\t  for(applicant in this.applicants) {\n\t    this.applicants[applicant].close();\n\t  }\n\t\n\t  this.status = C.STATUS_USER_CLOSED;\n\t\n\t  /*\n\t   * If the remaining transactions are all INVITE transactions, there is no need to\n\t   * wait anymore because every session has already been closed by this method.\n\t   * - locally originated sessions where terminated (CANCEL or BYE)\n\t   * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n\t   * Remaining INVITE transactions belong tho sessions that where answered. This are in\n\t   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n\t   */\n\t  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n\t    this.transport.disconnect();\n\t  } else {\n\t    this.on('transactionDestroyed', transactionsListener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Connect to the WS server if status = STATUS_INIT.\n\t * Resume UA after being closed.\n\t *\n\t */\n\tUA.prototype.start = function() {\n\t  var server;\n\t\n\t  this.logger.log('user requested startup...');\n\t  if (this.status === C.STATUS_INIT) {\n\t    server = this.getNextWsServer();\n\t    this.status = C.STATUS_STARTING;\n\t    new SIP.Transport(this, server);\n\t  } else if(this.status === C.STATUS_USER_CLOSED) {\n\t    this.logger.log('resuming');\n\t    this.status = C.STATUS_READY;\n\t    this.transport.connect();\n\t  } else if (this.status === C.STATUS_STARTING) {\n\t    this.logger.log('UA is in STARTING status, not opening new connection');\n\t  } else if (this.status === C.STATUS_READY) {\n\t    this.logger.log('UA is in READY status, not resuming');\n\t  } else {\n\t    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Normalize a string into a valid SIP request URI\n\t *\n\t * @param {String} target\n\t *\n\t * @returns {SIP.URI|undefined}\n\t */\n\tUA.prototype.normalizeTarget = function(target) {\n\t  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n\t};\n\t\n\t\n\t//===============================\n\t//  Private (For internal use)\n\t//===============================\n\t\n\tUA.prototype.saveCredentials = function(credentials) {\n\t  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n\t  this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n\t\n\t  return this;\n\t};\n\t\n\tUA.prototype.getCredentials = function(request) {\n\t  var realm, credentials;\n\t\n\t  realm = request.ruri.host;\n\t\n\t  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n\t    credentials = this.cache.credentials[realm][request.ruri];\n\t    credentials.method = request.method;\n\t  }\n\t\n\t  return credentials;\n\t};\n\t\n\tUA.prototype.getLogger = function(category, label) {\n\t  return this.log.getLogger(category, label);\n\t};\n\t\n\t\n\t//==============================\n\t// Event Handlers\n\t//==============================\n\t\n\t/**\n\t * Transport Close event\n\t * @private\n\t * @event\n\t * @param {SIP.Transport} transport.\n\t */\n\tUA.prototype.onTransportClosed = function(transport) {\n\t  // Run _onTransportError_ callback on every client transaction using _transport_\n\t  var type, idx, length,\n\t    client_transactions = ['nict', 'ict', 'nist', 'ist'];\n\t\n\t  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;\n\t  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);\n\t\n\t  length = client_transactions.length;\n\t  for (type = 0; type < length; type++) {\n\t    for(idx in this.transactions[client_transactions[type]]) {\n\t      this.transactions[client_transactions[type]][idx].onTransportError();\n\t    }\n\t  }\n\t\n\t  // Close sessions if GRUU is not being used\n\t  if (!this.contact.pub_gruu) {\n\t    this.closeSessionsOnTransportError();\n\t  }\n\t\n\t};\n\t\n\t/**\n\t * Unrecoverable transport event.\n\t * Connection reattempt logic has been done and didn't success.\n\t * @private\n\t * @event\n\t * @param {SIP.Transport} transport.\n\t */\n\tUA.prototype.onTransportError = function(transport) {\n\t  var server;\n\t\n\t  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);\n\t\n\t  // Close sessions.\n\t  //Mark this transport as 'down'\n\t  transport.server.status = SIP.Transport.C.STATUS_ERROR;\n\t\n\t  this.emit('disconnected', {\n\t    transport: transport\n\t  });\n\t\n\t  // try the next transport if the UA isn't closed\n\t  if(this.status === C.STATUS_USER_CLOSED) {\n\t    return;\n\t  }\n\t\n\t  server = this.getNextWsServer();\n\t\n\t  if(server) {\n\t    new SIP.Transport(this, server);\n\t  }else {\n\t    this.closeSessionsOnTransportError();\n\t    if (!this.error || this.error !== C.NETWORK_ERROR) {\n\t      this.status = C.STATUS_NOT_READY;\n\t      this.error = C.NETWORK_ERROR;\n\t    }\n\t    // Transport Recovery process\n\t    this.recoverTransport();\n\t  }\n\t};\n\t\n\t/**\n\t * Transport connection event.\n\t * @private\n\t * @event\n\t * @param {SIP.Transport} transport.\n\t */\n\tUA.prototype.onTransportConnected = function(transport) {\n\t  this.transport = transport;\n\t\n\t  // Reset transport recovery counter\n\t  this.transportRecoverAttempts = 0;\n\t\n\t  transport.server.status = SIP.Transport.C.STATUS_READY;\n\t  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);\n\t\n\t  if(this.status === C.STATUS_USER_CLOSED) {\n\t    return;\n\t  }\n\t\n\t  this.status = C.STATUS_READY;\n\t  this.error = null;\n\t\n\t  if(this.configuration.register) {\n\t    this.configuration.authenticationFactory.initialize().then(function () {\n\t      this.registerContext.onTransportConnected();\n\t    }.bind(this));\n\t  }\n\t\n\t  this.emit('connected', {\n\t    transport: transport\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Transport connecting event\n\t * @private\n\t * @param {SIP.Transport} transport.\n\t * #param {Integer} attempts.\n\t */\n\t  UA.prototype.onTransportConnecting = function(transport, attempts) {\n\t    this.emit('connecting', {\n\t      transport: transport,\n\t      attempts: attempts\n\t    });\n\t  };\n\t\n\t\n\t/**\n\t * new Transaction\n\t * @private\n\t * @param {SIP.Transaction} transaction.\n\t */\n\tUA.prototype.newTransaction = function(transaction) {\n\t  this.transactions[transaction.type][transaction.id] = transaction;\n\t  this.emit('newTransaction', {transaction: transaction});\n\t};\n\t\n\t\n\t/**\n\t * destroy Transaction\n\t * @private\n\t * @param {SIP.Transaction} transaction.\n\t */\n\tUA.prototype.destroyTransaction = function(transaction) {\n\t  delete this.transactions[transaction.type][transaction.id];\n\t  this.emit('transactionDestroyed', {\n\t    transaction: transaction\n\t  });\n\t};\n\t\n\t\n\t//=========================\n\t// receiveRequest\n\t//=========================\n\t\n\t/**\n\t * Request reception\n\t * @private\n\t * @param {SIP.IncomingRequest} request.\n\t */\n\tUA.prototype.receiveRequest = function(request) {\n\t  var dialog, session, message,\n\t    method = request.method,\n\t    transaction,\n\t    replaces,\n\t    replacedDialog,\n\t    self = this;\n\t\n\t  function ruriMatches (uri) {\n\t    return uri && uri.user === request.ruri.user;\n\t  }\n\t\n\t  // Check that request URI points to us\n\t  if(!(ruriMatches(this.configuration.uri) ||\n\t       ruriMatches(this.contact.uri) ||\n\t       ruriMatches(this.contact.pub_gruu) ||\n\t       ruriMatches(this.contact.temp_gruu))) {\n\t    this.logger.warn('Request-URI does not point to us');\n\t    if (request.method !== SIP.C.ACK) {\n\t      request.reply_sl(404);\n\t    }\n\t    return;\n\t  }\n\t\n\t  // Check request URI scheme\n\t  if(request.ruri.scheme === SIP.C.SIPS) {\n\t    request.reply_sl(416);\n\t    return;\n\t  }\n\t\n\t  // Check transaction\n\t  if(SIP.Transactions.checkTransaction(this, request)) {\n\t    return;\n\t  }\n\t\n\t  /* RFC3261 12.2.2\n\t   * Requests that do not change in any way the state of a dialog may be\n\t   * received within a dialog (for example, an OPTIONS request).\n\t   * They are processed as if they had been received outside the dialog.\n\t   */\n\t  if(method === SIP.C.OPTIONS) {\n\t    new SIP.Transactions.NonInviteServerTransaction(request, this);\n\t    request.reply(200, null, [\n\t      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),\n\t      'Accept: '+ C.ACCEPTED_BODY_TYPES\n\t    ]);\n\t  } else if (method === SIP.C.MESSAGE) {\n\t    message = new SIP.ServerContext(this, request);\n\t    message.body = request.body;\n\t    message.content_type = request.getHeader('Content-Type') || 'text/plain';\n\t\n\t    request.reply(200, null);\n\t    this.emit('message', message);\n\t  } else if (method !== SIP.C.INVITE &&\n\t             method !== SIP.C.ACK) {\n\t    // Let those methods pass through to normal processing for now.\n\t    transaction = new SIP.ServerContext(this, request);\n\t  }\n\t\n\t  // Initial Request\n\t  if(!request.to_tag) {\n\t    switch(method) {\n\t      case SIP.C.INVITE:\n\t        replaces =\n\t          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&\n\t          request.parseHeader('replaces');\n\t\n\t        if (replaces) {\n\t          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];\n\t\n\t          if (!replacedDialog) {\n\t            //Replaced header without a matching dialog, reject\n\t            request.reply_sl(481, null);\n\t            return;\n\t          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {\n\t            request.reply_sl(603, null);\n\t            return;\n\t          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {\n\t            request.reply_sl(486, null);\n\t            return;\n\t          }\n\t        }\n\t\n\t        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;\n\t        if(!isMediaSupported || isMediaSupported()) {\n\t          session = new SIP.InviteServerContext(this, request);\n\t          session.replacee = replacedDialog && replacedDialog.owner;\n\t          session.on('invite', function() {\n\t            self.emit('invite', this);\n\t          });\n\t        } else {\n\t          this.logger.warn('INVITE received but WebRTC is not supported');\n\t          request.reply(488);\n\t        }\n\t        break;\n\t      case SIP.C.BYE:\n\t        // Out of dialog BYE received\n\t        request.reply(481);\n\t        break;\n\t      case SIP.C.CANCEL:\n\t        session = this.findSession(request);\n\t        if(session) {\n\t          session.receiveRequest(request);\n\t        } else {\n\t          this.logger.warn('received CANCEL request for a non existent session');\n\t        }\n\t        break;\n\t      case SIP.C.ACK:\n\t        /* Absorb it.\n\t         * ACK request without a corresponding Invite Transaction\n\t         * and without To tag.\n\t         */\n\t        break;\n\t      default:\n\t        request.reply(405);\n\t        break;\n\t    }\n\t  }\n\t  // In-dialog request\n\t  else {\n\t    dialog = this.findDialog(request);\n\t\n\t    if(dialog) {\n\t      if (method === SIP.C.INVITE) {\n\t        new SIP.Transactions.InviteServerTransaction(request, this);\n\t      }\n\t      dialog.receiveRequest(request);\n\t    } else if (method === SIP.C.NOTIFY) {\n\t      session = this.findSession(request);\n\t      if(session) {\n\t        session.receiveRequest(request);\n\t      } else {\n\t        this.logger.warn('received NOTIFY request for a non existent session');\n\t        request.reply(481, 'Subscription does not exist');\n\t      }\n\t    }\n\t    /* RFC3261 12.2.2\n\t     * Request with to tag, but no matching dialog found.\n\t     * Exception: ACK for an Invite request for which a dialog has not\n\t     * been created.\n\t     */\n\t    else {\n\t      if(method !== SIP.C.ACK) {\n\t        request.reply(481);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t//=================\n\t// Utils\n\t//=================\n\t\n\t/**\n\t * Get the session to which the request belongs to, if any.\n\t * @private\n\t * @param {SIP.IncomingRequest} request.\n\t * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n\t */\n\tUA.prototype.findSession = function(request) {\n\t  return this.sessions[request.call_id + request.from_tag] ||\n\t          this.sessions[request.call_id + request.to_tag] ||\n\t          null;\n\t};\n\t\n\t/**\n\t * Get the dialog to which the request belongs to, if any.\n\t * @private\n\t * @param {SIP.IncomingRequest}\n\t * @returns {SIP.Dialog|null}\n\t */\n\tUA.prototype.findDialog = function(request) {\n\t  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||\n\t          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||\n\t          null;\n\t};\n\t\n\t/**\n\t * Retrieve the next server to which connect.\n\t * @private\n\t * @returns {Object} ws_server\n\t */\n\tUA.prototype.getNextWsServer = function() {\n\t  // Order servers by weight\n\t  var idx, length, ws_server,\n\t    candidates = [];\n\t\n\t  length = this.configuration.wsServers.length;\n\t  for (idx = 0; idx < length; idx++) {\n\t    ws_server = this.configuration.wsServers[idx];\n\t\n\t    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {\n\t      continue;\n\t    } else if (candidates.length === 0) {\n\t      candidates.push(ws_server);\n\t    } else if (ws_server.weight > candidates[0].weight) {\n\t      candidates = [ws_server];\n\t    } else if (ws_server.weight === candidates[0].weight) {\n\t      candidates.push(ws_server);\n\t    }\n\t  }\n\t\n\t  idx = Math.floor(Math.random() * candidates.length);\n\t\n\t  return candidates[idx];\n\t};\n\t\n\t/**\n\t * Close all sessions on transport error.\n\t * @private\n\t */\n\tUA.prototype.closeSessionsOnTransportError = function() {\n\t  var idx;\n\t\n\t  // Run _transportError_ for every Session\n\t  for(idx in this.sessions) {\n\t    this.sessions[idx].onTransportError();\n\t  }\n\t  // Call registerContext _onTransportClosed_\n\t  this.registerContext.onTransportClosed();\n\t};\n\t\n\tUA.prototype.recoverTransport = function(ua) {\n\t  var idx, length, k, nextRetry, count, server;\n\t\n\t  ua = ua || this;\n\t  count = ua.transportRecoverAttempts;\n\t\n\t  length = ua.configuration.wsServers.length;\n\t  for (idx = 0; idx < length; idx++) {\n\t    ua.configuration.wsServers[idx].status = 0;\n\t  }\n\t\n\t  server = ua.getNextWsServer();\n\t\n\t  k = Math.floor((Math.random() * Math.pow(2,count)) +1);\n\t  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;\n\t\n\t  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {\n\t    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');\n\t    nextRetry = ua.configuration.connectionRecoveryMinInterval;\n\t    count = 0;\n\t  }\n\t\n\t  this.logger.log('next connection attempt in '+ nextRetry +' seconds');\n\t\n\t  this.transportRecoveryTimer = SIP.Timers.setTimeout(\n\t    function(){\n\t      ua.transportRecoverAttempts = count + 1;\n\t      new SIP.Transport(ua, server);\n\t    }, nextRetry * 1000);\n\t};\n\t\n\tfunction checkAuthenticationFactory (authenticationFactory) {\n\t  if (!(authenticationFactory instanceof Function)) {\n\t    return;\n\t  }\n\t  if (!authenticationFactory.initialize) {\n\t    authenticationFactory.initialize = function initialize () {\n\t      return SIP.Utils.Promise.resolve();\n\t    };\n\t  }\n\t  return authenticationFactory;\n\t}\n\t\n\t/**\n\t * Configuration load.\n\t * @private\n\t * returns {Boolean}\n\t */\n\tUA.prototype.loadConfig = function(configuration) {\n\t  // Settings and default values\n\t  var parameter, value, checked_value, hostportParams, registrarServer,\n\t    settings = {\n\t      /* Host address\n\t      * Value to be set in Via sent_by and host part of Contact FQDN\n\t      */\n\t      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n\t\n\t      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n\t      wsServers: [{\n\t        scheme: 'WSS',\n\t        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n\t        status: 0,\n\t        weight: 0,\n\t        ws_uri: 'wss://edge.sip.onsip.com'\n\t      }],\n\t\n\t      // Password\n\t      password: null,\n\t\n\t      // Registration parameters\n\t      registerExpires: 600,\n\t      register: true,\n\t      registrarServer: null,\n\t\n\t      // Transport related parameters\n\t      wsServerMaxReconnection: 3,\n\t      wsServerReconnectionTimeout: 4,\n\t\n\t      connectionRecoveryMinInterval: 2,\n\t      connectionRecoveryMaxInterval: 30,\n\t\n\t      keepAliveInterval: 0,\n\t\n\t      extraSupported: [],\n\t\n\t      usePreloadedRoute: false,\n\t\n\t      //string to be inserted into User-Agent request header\n\t      userAgentString: SIP.C.USER_AGENT,\n\t\n\t      // Session parameters\n\t      iceCheckingTimeout: 5000,\n\t      noAnswerTimeout: 60,\n\t      stunServers: ['stun:stun.l.google.com:19302'],\n\t      turnServers: [],\n\t\n\t      // Logging parameters\n\t      traceSip: false,\n\t\n\t      // Hacks\n\t      hackViaTcp: false,\n\t      hackIpInContact: false,\n\t      hackWssInTransport: false,\n\t      hackAllowUnregisteredOptionTags: false,\n\t\n\t      contactTransport: 'ws',\n\t      forceRport: false,\n\t\n\t      //autostarting\n\t      autostart: true,\n\t\n\t      //Reliable Provisional Responses\n\t      rel100: SIP.C.supported.UNSUPPORTED,\n\t\n\t      // Replaces header (RFC 3891)\n\t      // http://tools.ietf.org/html/rfc3891\n\t      replaces: SIP.C.supported.UNSUPPORTED,\n\t\n\t      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,\n\t\n\t      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {\n\t        return new SIP.DigestAuthentication(ua);\n\t      })\n\t    };\n\t\n\t  // Pre-Configuration\n\t  function aliasUnderscored (parameter, logger) {\n\t    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n\t      return m[0] + '_' + m[1].toLowerCase();\n\t    });\n\t\n\t    if (parameter === underscored) {\n\t      return;\n\t    }\n\t\n\t    var hasParameter = configuration.hasOwnProperty(parameter);\n\t    if (configuration.hasOwnProperty(underscored)) {\n\t      logger.warn(underscored + ' is deprecated, please use ' + parameter);\n\t      if (hasParameter) {\n\t        logger.warn(parameter + ' overriding ' + underscored);\n\t      }\n\t    }\n\t\n\t    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n\t  }\n\t\n\t  // Check Mandatory parameters\n\t  for(parameter in UA.configuration_check.mandatory) {\n\t    aliasUnderscored(parameter, this.logger);\n\t    if(!configuration.hasOwnProperty(parameter)) {\n\t      throw new SIP.Exceptions.ConfigurationError(parameter);\n\t    } else {\n\t      value = configuration[parameter];\n\t      checked_value = UA.configuration_check.mandatory[parameter](value);\n\t      if (checked_value !== undefined) {\n\t        settings[parameter] = checked_value;\n\t      } else {\n\t        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n\t      }\n\t    }\n\t  }\n\t\n\t  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);\n\t\n\t  var emptyArraysAllowed = ['stunServers', 'turnServers'];\n\t\n\t  // Check Optional parameters\n\t  for(parameter in UA.configuration_check.optional) {\n\t    aliasUnderscored(parameter, this.logger);\n\t    if(configuration.hasOwnProperty(parameter)) {\n\t      value = configuration[parameter];\n\t\n\t      // If the parameter value is an empty array, but shouldn't be, apply its default value.\n\t      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }\n\t\n\t      // If the parameter value is null, empty string, or undefined then apply its default value.\n\t      if(value === null || value === \"\" || value === undefined) { continue; }\n\t      // If it's a number with NaN value then also apply its default value.\n\t      // NOTE: JS does not allow \"value === NaN\", the following does the work:\n\t      else if(typeof(value) === 'number' && isNaN(value)) { continue; }\n\t\n\t      checked_value = UA.configuration_check.optional[parameter](value);\n\t      if (checked_value !== undefined) {\n\t        settings[parameter] = checked_value;\n\t      } else {\n\t        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Sanity Checks\n\t\n\t  // Connection recovery intervals\n\t  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {\n\t    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);\n\t  }\n\t\n\t  // Post Configuration Process\n\t\n\t  // Allow passing 0 number as displayName.\n\t  if (settings.displayName === 0) {\n\t    settings.displayName = '0';\n\t  }\n\t\n\t  // Instance-id for GRUU\n\t  if (!settings.instanceId) {\n\t    settings.instanceId = SIP.Utils.newUUID();\n\t  }\n\t\n\t  // sipjsId instance parameter. Static random tag of length 5\n\t  settings.sipjsId = SIP.Utils.createRandomToken(5);\n\t\n\t  // String containing settings.uri without scheme and user.\n\t  hostportParams = settings.uri.clone();\n\t  hostportParams.user = null;\n\t  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');\n\t\n\t  /* Check whether authorizationUser is explicitly defined.\n\t   * Take 'settings.uri.user' value if not.\n\t   */\n\t  if (!settings.authorizationUser) {\n\t    settings.authorizationUser = settings.uri.user;\n\t  }\n\t\n\t  /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n\t  if (!settings.registrarServer) {\n\t    registrarServer = settings.uri.clone();\n\t    registrarServer.user = null;\n\t    settings.registrarServer = registrarServer;\n\t  }\n\t\n\t  // User noAnswerTimeout\n\t  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;\n\t\n\t  // Via Host\n\t  if (settings.hackIpInContact) {\n\t    if (typeof settings.hackIpInContact === 'boolean') {\n\t      settings.viaHost = SIP.Utils.getRandomTestNetIP();\n\t    }\n\t    else if (typeof settings.hackIpInContact === 'string') {\n\t      settings.viaHost = settings.hackIpInContact;\n\t    }\n\t  }\n\t\n\t  // Contact transport parameter\n\t  if (settings.hackWssInTransport) {\n\t    settings.contactTransport = 'wss';\n\t  }\n\t\n\t  this.contact = {\n\t    pub_gruu: null,\n\t    temp_gruu: null,\n\t    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),\n\t    toString: function(options){\n\t      options = options || {};\n\t\n\t      var\n\t        anonymous = options.anonymous || null,\n\t        outbound = options.outbound || null,\n\t        contact = '<';\n\t\n\t      if (anonymous) {\n\t        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();\n\t      } else {\n\t        contact += (this.pub_gruu || this.uri).toString();\n\t      }\n\t\n\t      if (outbound) {\n\t        contact += ';ob';\n\t      }\n\t\n\t      contact += '>';\n\t\n\t      return contact;\n\t    }\n\t  };\n\t\n\t  // media overrides mediaConstraints\n\t  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);\n\t\n\t  // Fill the value of the configuration_skeleton\n\t  for(parameter in settings) {\n\t    UA.configuration_skeleton[parameter].value = settings[parameter];\n\t  }\n\t\n\t  Object.defineProperties(this.configuration, UA.configuration_skeleton);\n\t\n\t  // Clean UA.configuration_skeleton\n\t  for(parameter in settings) {\n\t    UA.configuration_skeleton[parameter].value = '';\n\t  }\n\t\n\t  this.logger.log('configuration parameters after validation:');\n\t  for(parameter in settings) {\n\t    switch(parameter) {\n\t      case 'uri':\n\t      case 'registrarServer':\n\t      case 'mediaHandlerFactory':\n\t        this.logger.log(' ' + parameter + ': ' + settings[parameter]);\n\t        break;\n\t      case 'password':\n\t        this.logger.log(' ' + parameter + ': ' + 'NOT SHOWN');\n\t        break;\n\t      default:\n\t        this.logger.log(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n\t    }\n\t  }\n\t\n\t  return;\n\t};\n\t\n\t/**\n\t * Configuration Object skeleton.\n\t * @private\n\t */\n\tUA.configuration_skeleton = (function() {\n\t  var idx,  parameter,\n\t    skeleton = {},\n\t    parameters = [\n\t      // Internal parameters\n\t      \"sipjsId\",\n\t      \"hostportParams\",\n\t\n\t      // Optional user configurable parameters\n\t      \"uri\",\n\t      \"wsServers\",\n\t      \"authorizationUser\",\n\t      \"connectionRecoveryMaxInterval\",\n\t      \"connectionRecoveryMinInterval\",\n\t      \"keepAliveInterval\",\n\t      \"extraSupported\",\n\t      \"displayName\",\n\t      \"hackViaTcp\", // false.\n\t      \"hackIpInContact\", //false\n\t      \"hackWssInTransport\", //false\n\t      \"hackAllowUnregisteredOptionTags\", //false\n\t      \"contactTransport\", // 'ws'\n\t      \"forceRport\", // false\n\t      \"iceCheckingTimeout\",\n\t      \"instanceId\",\n\t      \"noAnswerTimeout\", // 30 seconds.\n\t      \"password\",\n\t      \"registerExpires\", // 600 seconds.\n\t      \"registrarServer\",\n\t      \"reliable\",\n\t      \"rel100\",\n\t      \"replaces\",\n\t      \"userAgentString\", //SIP.C.USER_AGENT\n\t      \"autostart\",\n\t      \"stunServers\",\n\t      \"traceSip\",\n\t      \"turnServers\",\n\t      \"usePreloadedRoute\",\n\t      \"wsServerMaxReconnection\",\n\t      \"wsServerReconnectionTimeout\",\n\t      \"mediaHandlerFactory\",\n\t      \"media\",\n\t      \"mediaConstraints\",\n\t      \"authenticationFactory\",\n\t\n\t      // Post-configuration generated parameters\n\t      \"via_core_value\",\n\t      \"viaHost\"\n\t    ];\n\t\n\t  for(idx in parameters) {\n\t    parameter = parameters[idx];\n\t    skeleton[parameter] = {\n\t      value: '',\n\t      writable: false,\n\t      configurable: false\n\t    };\n\t  }\n\t\n\t  skeleton['register'] = {\n\t    value: '',\n\t    writable: true,\n\t    configurable: false\n\t  };\n\t\n\t  return skeleton;\n\t}());\n\t\n\t/**\n\t * Configuration checker.\n\t * @private\n\t * @return {Boolean}\n\t */\n\tUA.configuration_check = {\n\t  mandatory: {\n\t  },\n\t\n\t  optional: {\n\t\n\t    uri: function(uri) {\n\t      var parsed;\n\t\n\t      if (!(/^sip:/i).test(uri)) {\n\t        uri = SIP.C.SIP + ':' + uri;\n\t      }\n\t      parsed = SIP.URI.parse(uri);\n\t\n\t      if(!parsed) {\n\t        return;\n\t      } else if(!parsed.user) {\n\t        return;\n\t      } else {\n\t        return parsed;\n\t      }\n\t    },\n\t\n\t    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n\t    wsServers: function(wsServers) {\n\t      var idx, length, url;\n\t\n\t      /* Allow defining wsServers parameter as:\n\t       *  String: \"host\"\n\t       *  Array of Strings: [\"host1\", \"host2\"]\n\t       *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n\t       *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n\t       */\n\t      if (typeof wsServers === 'string') {\n\t        wsServers = [{ws_uri: wsServers}];\n\t      } else if (wsServers instanceof Array) {\n\t        length = wsServers.length;\n\t        for (idx = 0; idx < length; idx++) {\n\t          if (typeof wsServers[idx] === 'string'){\n\t            wsServers[idx] = {ws_uri: wsServers[idx]};\n\t          }\n\t        }\n\t      } else {\n\t        return;\n\t      }\n\t\n\t      if (wsServers.length === 0) {\n\t        return false;\n\t      }\n\t\n\t      length = wsServers.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        if (!wsServers[idx].ws_uri) {\n\t          return;\n\t        }\n\t        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {\n\t          return;\n\t        }\n\t\n\t        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');\n\t\n\t        if(url === -1) {\n\t          return;\n\t        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {\n\t          return;\n\t        } else {\n\t          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';\n\t\n\t          if (!wsServers[idx].weight) {\n\t            wsServers[idx].weight = 0;\n\t          }\n\t\n\t          wsServers[idx].status = 0;\n\t          wsServers[idx].scheme = url.scheme.toUpperCase();\n\t        }\n\t      }\n\t      return wsServers;\n\t    },\n\t\n\t    authorizationUser: function(authorizationUser) {\n\t      if(SIP.Grammar.parse('\"'+ authorizationUser +'\"', 'quoted_string') === -1) {\n\t        return;\n\t      } else {\n\t        return authorizationUser;\n\t      }\n\t    },\n\t\n\t    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {\n\t      var value;\n\t      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {\n\t        value = Number(connectionRecoveryMaxInterval);\n\t        if(value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {\n\t      var value;\n\t      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {\n\t        value = Number(connectionRecoveryMinInterval);\n\t        if(value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    displayName: function(displayName) {\n\t      if(SIP.Grammar.parse('\"' + displayName + '\"', 'displayName') === -1) {\n\t        return;\n\t      } else {\n\t        return displayName;\n\t      }\n\t    },\n\t\n\t    hackViaTcp: function(hackViaTcp) {\n\t      if (typeof hackViaTcp === 'boolean') {\n\t        return hackViaTcp;\n\t      }\n\t    },\n\t\n\t    hackIpInContact: function(hackIpInContact) {\n\t      if (typeof hackIpInContact === 'boolean') {\n\t        return hackIpInContact;\n\t      }\n\t      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {\n\t        return hackIpInContact;\n\t      }\n\t    },\n\t\n\t    iceCheckingTimeout: function(iceCheckingTimeout) {\n\t      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {\n\t        return Math.max(500, iceCheckingTimeout);\n\t      }\n\t    },\n\t\n\t    hackWssInTransport: function(hackWssInTransport) {\n\t      if (typeof hackWssInTransport === 'boolean') {\n\t        return hackWssInTransport;\n\t      }\n\t    },\n\t\n\t    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {\n\t      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {\n\t        return hackAllowUnregisteredOptionTags;\n\t      }\n\t    },\n\t\n\t    contactTransport: function(contactTransport) {\n\t      if (typeof contactTransport === 'string') {\n\t        return contactTransport;\n\t      }\n\t    },\n\t\n\t    forceRport: function(forceRport) {\n\t      if (typeof forceRport === 'boolean') {\n\t        return forceRport;\n\t      }\n\t    },\n\t\n\t    instanceId: function(instanceId) {\n\t      if(typeof instanceId !== 'string') {\n\t        return;\n\t      }\n\t\n\t      if ((/^uuid:/i.test(instanceId))) {\n\t        instanceId = instanceId.substr(5);\n\t      }\n\t\n\t      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {\n\t        return;\n\t      } else {\n\t        return instanceId;\n\t      }\n\t    },\n\t\n\t    keepAliveInterval: function(keepAliveInterval) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(keepAliveInterval)) {\n\t        value = Number(keepAliveInterval);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    extraSupported: function(optionTags) {\n\t      var idx, length;\n\t\n\t      if (!(optionTags instanceof Array)) {\n\t        return;\n\t      }\n\t\n\t      length = optionTags.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        if (typeof optionTags[idx] !== 'string') {\n\t          return;\n\t        }\n\t      }\n\t\n\t      return optionTags;\n\t    },\n\t\n\t    noAnswerTimeout: function(noAnswerTimeout) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(noAnswerTimeout)) {\n\t        value = Number(noAnswerTimeout);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    password: function(password) {\n\t      return String(password);\n\t    },\n\t\n\t    rel100: function(rel100) {\n\t      if(rel100 === SIP.C.supported.REQUIRED) {\n\t        return SIP.C.supported.REQUIRED;\n\t      } else if (rel100 === SIP.C.supported.SUPPORTED) {\n\t        return SIP.C.supported.SUPPORTED;\n\t      } else  {\n\t        return SIP.C.supported.UNSUPPORTED;\n\t      }\n\t    },\n\t\n\t    replaces: function(replaces) {\n\t      if(replaces === SIP.C.supported.REQUIRED) {\n\t        return SIP.C.supported.REQUIRED;\n\t      } else if (replaces === SIP.C.supported.SUPPORTED) {\n\t        return SIP.C.supported.SUPPORTED;\n\t      } else  {\n\t        return SIP.C.supported.UNSUPPORTED;\n\t      }\n\t    },\n\t\n\t    register: function(register) {\n\t      if (typeof register === 'boolean') {\n\t        return register;\n\t      }\n\t    },\n\t\n\t    registerExpires: function(registerExpires) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(registerExpires)) {\n\t        value = Number(registerExpires);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    registrarServer: function(registrarServer) {\n\t      var parsed;\n\t\n\t      if(typeof registrarServer !== 'string') {\n\t        return;\n\t      }\n\t\n\t      if (!/^sip:/i.test(registrarServer)) {\n\t        registrarServer = SIP.C.SIP + ':' + registrarServer;\n\t      }\n\t      parsed = SIP.URI.parse(registrarServer);\n\t\n\t      if(!parsed) {\n\t        return;\n\t      } else if(parsed.user) {\n\t        return;\n\t      } else {\n\t        return parsed;\n\t      }\n\t    },\n\t\n\t    stunServers: function(stunServers) {\n\t      var idx, length, stun_server;\n\t\n\t      if (typeof stunServers === 'string') {\n\t        stunServers = [stunServers];\n\t      } else if (!(stunServers instanceof Array)) {\n\t        return;\n\t      }\n\t\n\t      length = stunServers.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        stun_server = stunServers[idx];\n\t        if (!(/^stuns?:/.test(stun_server))) {\n\t          stun_server = 'stun:' + stun_server;\n\t        }\n\t\n\t        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {\n\t          return;\n\t        } else {\n\t          stunServers[idx] = stun_server;\n\t        }\n\t      }\n\t      return stunServers;\n\t    },\n\t\n\t    traceSip: function(traceSip) {\n\t      if (typeof traceSip === 'boolean') {\n\t        return traceSip;\n\t      }\n\t    },\n\t\n\t    turnServers: function(turnServers) {\n\t      var idx, jdx, length, turn_server, num_turn_server_urls, url;\n\t\n\t      if (turnServers instanceof Array) {\n\t        // Do nothing\n\t      } else {\n\t        turnServers = [turnServers];\n\t      }\n\t\n\t      length = turnServers.length;\n\t      for (idx = 0; idx < length; idx++) {\n\t        turn_server = turnServers[idx];\n\t        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.\n\t        if (turn_server.server) {\n\t          turn_server.urls = [turn_server.server];\n\t        }\n\t\n\t        if (!turn_server.urls || !turn_server.username || !turn_server.password) {\n\t          return;\n\t        }\n\t\n\t        if (turn_server.urls instanceof Array) {\n\t          num_turn_server_urls = turn_server.urls.length;\n\t        } else {\n\t          turn_server.urls = [turn_server.urls];\n\t          num_turn_server_urls = 1;\n\t        }\n\t\n\t        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {\n\t          url = turn_server.urls[jdx];\n\t\n\t          if (!(/^turns?:/.test(url))) {\n\t            url = 'turn:' + url;\n\t          }\n\t\n\t          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {\n\t            return;\n\t          }\n\t        }\n\t      }\n\t      return turnServers;\n\t    },\n\t\n\t    userAgentString: function(userAgentString) {\n\t      if (typeof userAgentString === 'string') {\n\t        return userAgentString;\n\t      }\n\t    },\n\t\n\t    usePreloadedRoute: function(usePreloadedRoute) {\n\t      if (typeof usePreloadedRoute === 'boolean') {\n\t        return usePreloadedRoute;\n\t      }\n\t    },\n\t\n\t    wsServerMaxReconnection: function(wsServerMaxReconnection) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {\n\t        value = Number(wsServerMaxReconnection);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {\n\t      var value;\n\t      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {\n\t        value = Number(wsServerReconnectionTimeout);\n\t        if (value > 0) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    autostart: function(autostart) {\n\t      if (typeof autostart === 'boolean') {\n\t        return autostart;\n\t      }\n\t    },\n\t\n\t    mediaHandlerFactory: function(mediaHandlerFactory) {\n\t      if (mediaHandlerFactory instanceof Function) {\n\t        var promisifiedFactory = function promisifiedFactory () {\n\t          var mediaHandler = mediaHandlerFactory.apply(this, arguments);\n\t\n\t          function patchMethod (methodName) {\n\t            var method = mediaHandler[methodName];\n\t            if (method.length > 1) {\n\t              var callbacksFirst = methodName === 'getDescription';\n\t              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);\n\t            }\n\t          }\n\t\n\t          patchMethod('getDescription');\n\t          patchMethod('setDescription');\n\t\n\t          return mediaHandler;\n\t        };\n\t\n\t        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;\n\t        return promisifiedFactory;\n\t      }\n\t    },\n\t\n\t    authenticationFactory: checkAuthenticationFactory\n\t  }\n\t};\n\t\n\tUA.C = C;\n\tSIP.UA = UA;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Hacks - This file contains all of the things we\n\t * wish we didn't have to do, just for interop.  It is similar to\n\t * Utils, which provides actually useful and relevant functions for\n\t * a SIP library. Methods in this file are grouped by vendor, so\n\t * as to most easily track when particular hacks may not be necessary anymore.\n\t */\n\t\n\tmodule.exports = function (SIP) {\n\t\n\t//keep to quiet jshint, and remain consistent with other files\n\tSIP = SIP;\n\t\n\tvar Hacks = {\n\t  AllBrowsers: {\n\t    maskDtls: function (message) {\n\t      if (message.body) {\n\t        message.body = message.body.replace(/ UDP\\/TLS\\/RTP\\/SAVP/gmi, \" RTP/SAVP\");\n\t      }\n\t    },\n\t    unmaskDtls: function (sdp) {\n\t      /**\n\t       * Chrome does not handle DTLS correctly (Canaray does, but not production)\n\t       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)\n\t       *\n\t       * UPDATE: May 21, 2014\n\t       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES\n\t       *\n\t       * UPDATE: 2014-09-24\n\t       * Opera now supports DTLS by default as well.\n\t       *\n\t       **/\n\t      return sdp.replace(/ RTP\\/SAVP/gmi, \" UDP/TLS/RTP/SAVP\");\n\t    }\n\t  },\n\t  Firefox: {\n\t    /* Condition to detect if hacks are applicable */\n\t    isFirefox: function () {\n\t      return typeof mozRTCPeerConnection !== 'undefined';\n\t    },\n\t\n\t    cannotHandleExtraWhitespace: function (message) {\n\t      if (this.isFirefox() && message.body) {\n\t        message.body = message.body.replace(/ \\r\\n/g, \"\\r\\n\");\n\t      }\n\t    },\n\t\n\t    hasMissingCLineInSDP: function (sdp) {\n\t      /*\n\t       * This is a Firefox hack to insert valid sdp when getDescription is\n\t       * called with the constraint offerToReceiveVideo = false.\n\t       * We search for either a c-line at the top of the sdp above all\n\t       * m-lines. If that does not exist then we search for a c-line\n\t       * beneath each m-line. If it is missing a c-line, we insert\n\t       * a fake c-line with the ip address 0.0.0.0. This is then valid\n\t       * sdp and no media will be sent for that m-line.\n\t       *\n\t       * Valid SDP is:\n\t       * m=\n\t       * i=\n\t       * c=\n\t       */\n\t      var insertAt, mlines;\n\t      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {\n\t\n\t        // Find all m= lines\n\t        mlines = sdp.match(/m=.*\\r\\n.*/g);\n\t        for (var i=0; i<mlines.length; i++) {\n\t\n\t          // If it has an i= line, check if the next line is the c= line\n\t          if (mlines[i].toString().search(/i=.*/) >= 0) {\n\t            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;\n\t            if (sdp.substr(insertAt,2)!=='c=') {\n\t              sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n\t            }\n\t\n\t          // else add the C line if it's missing\n\t          } else if (mlines[i].toString().search(/c=.*/) < 0) {\n\t            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;\n\t            sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n\t          }\n\t        }\n\t      }\n\t      return sdp;\n\t    },\n\t  },\n\t\n\t  Chrome: {\n\t    needsExplicitlyInactiveSDP: function (sdp) {\n\t      var sub, index;\n\t\n\t      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending\n\t        index = sdp.indexOf('m=video 0');\n\t        if (index !== -1) {\n\t          sub = sdp.substr(index);\n\t          sub = sub.replace(/\\r\\nc=IN IP4.*\\r\\n$/,\n\t                            '\\r\\nc=IN IP4 0.0.0.0\\r\\na=inactive\\r\\n');\n\t          return sdp.substr(0, index) + sub;\n\t        }\n\t      }\n\t      return sdp;\n\t    },\n\t\n\t    getsConfusedAboutGUM: function (session) {\n\t      if (session.mediaHandler) {\n\t        session.mediaHandler.close();\n\t      }\n\t    }\n\t  }\n\t};\n\treturn Hacks;\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Incoming SIP Message Sanity Check\n\t */\n\t\n\t/**\n\t * SIP message sanity check.\n\t * @augments SIP\n\t * @function\n\t * @param {SIP.IncomingMessage} message\n\t * @param {SIP.UA} ua\n\t * @param {SIP.Transport} transport\n\t * @returns {Boolean}\n\t */\n\tmodule.exports = function (SIP) {\n\tvar sanityCheck,\n\t logger,\n\t message, ua, transport,\n\t requests = [],\n\t responses = [],\n\t all = [];\n\t\n\t// Reply\n\tfunction reply(status_code) {\n\t  var to,\n\t    response = SIP.Utils.buildStatusLine(status_code),\n\t    vias = message.getHeaders('via'),\n\t    length = vias.length,\n\t    idx = 0;\n\t\n\t  for(idx; idx < length; idx++) {\n\t    response += \"Via: \" + vias[idx] + \"\\r\\n\";\n\t  }\n\t\n\t  to = message.getHeader('To');\n\t\n\t  if(!message.to_tag) {\n\t    to += ';tag=' + SIP.Utils.newTag();\n\t  }\n\t\n\t  response += \"To: \" + to + \"\\r\\n\";\n\t  response += \"From: \" + message.getHeader('From') + \"\\r\\n\";\n\t  response += \"Call-ID: \" + message.call_id + \"\\r\\n\";\n\t  response += \"CSeq: \" + message.cseq + \" \" + message.method + \"\\r\\n\";\n\t  response += \"\\r\\n\";\n\t\n\t  transport.send(response);\n\t}\n\t\n\t/*\n\t * Sanity Check for incoming Messages\n\t *\n\t * Requests:\n\t *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n\t *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n\t *   Does not look at via sent-by but at sipjsId, which is inserted as\n\t *   a prefix in all initial requests generated by the ua\n\t *  - _rfc3261_18_3_request_ Body Content-Length\n\t *  - _rfc3261_8_2_2_2_ Merged Requests\n\t *\n\t * Responses:\n\t *  - _rfc3261_8_1_3_3_ Multiple Via headers\n\t *  - _rfc3261_18_1_2_ sent-by mismatch\n\t *  - _rfc3261_18_3_response_ Body Content-Length\n\t *\n\t * All:\n\t *  - Minimum headers in a SIP message\n\t */\n\t\n\t// Sanity Check functions for requests\n\tfunction rfc3261_8_2_2_1() {\n\t  if(!message.ruri || message.ruri.scheme !== 'sip') {\n\t    reply(416);\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_16_3_4() {\n\t  if(!message.to_tag) {\n\t    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {\n\t      reply(482);\n\t      return false;\n\t    }\n\t  }\n\t}\n\t\n\tfunction rfc3261_18_3_request() {\n\t  var len = SIP.Utils.str_utf8_length(message.body),\n\t  contentLength = message.getHeader('content-length');\n\t\n\t  if(len < contentLength) {\n\t    reply(400);\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_8_2_2_2() {\n\t  var tr, idx,\n\t    fromTag = message.from_tag,\n\t    call_id = message.call_id,\n\t    cseq = message.cseq;\n\t\n\t  if(!message.to_tag) {\n\t    if(message.method === SIP.C.INVITE) {\n\t      tr = ua.transactions.ist[message.via_branch];\n\t      if(tr) {\n\t        return;\n\t      } else {\n\t        for(idx in ua.transactions.ist) {\n\t          tr = ua.transactions.ist[idx];\n\t          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n\t            reply(482);\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t    } else {\n\t      tr = ua.transactions.nist[message.via_branch];\n\t      if(tr) {\n\t        return;\n\t      } else {\n\t        for(idx in ua.transactions.nist) {\n\t          tr = ua.transactions.nist[idx];\n\t          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n\t            reply(482);\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// Sanity Check functions for responses\n\tfunction rfc3261_8_1_3_3() {\n\t  if(message.getHeaders('via').length > 1) {\n\t    logger.warn('More than one Via header field present in the response. Dropping the response');\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_18_1_2() {\n\t  var viaHost = ua.configuration.viaHost;\n\t  if(message.via.host !== viaHost || message.via.port !== undefined) {\n\t    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');\n\t    return false;\n\t  }\n\t}\n\t\n\tfunction rfc3261_18_3_response() {\n\t  var\n\t    len = SIP.Utils.str_utf8_length(message.body),\n\t    contentLength = message.getHeader('content-length');\n\t\n\t    if(len < contentLength) {\n\t      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');\n\t      return false;\n\t    }\n\t}\n\t\n\t// Sanity Check functions for requests and responses\n\tfunction minimumHeaders() {\n\t  var\n\t    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],\n\t    idx = mandatoryHeaders.length;\n\t\n\t  while(idx--) {\n\t    if(!message.hasHeader(mandatoryHeaders[idx])) {\n\t      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');\n\t      return false;\n\t    }\n\t  }\n\t}\n\t\n\trequests.push(rfc3261_8_2_2_1);\n\trequests.push(rfc3261_16_3_4);\n\trequests.push(rfc3261_18_3_request);\n\trequests.push(rfc3261_8_2_2_2);\n\t\n\tresponses.push(rfc3261_8_1_3_3);\n\tresponses.push(rfc3261_18_1_2);\n\tresponses.push(rfc3261_18_3_response);\n\t\n\tall.push(minimumHeaders);\n\t\n\tsanityCheck = function(m, u, t) {\n\t  var len, pass;\n\t\n\t  message = m;\n\t  ua = u;\n\t  transport = t;\n\t\n\t  logger = ua.getLogger('sip.sanitycheck');\n\t\n\t  len = all.length;\n\t  while(len--) {\n\t    pass = all[len](message);\n\t    if(pass === false) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  if(message instanceof SIP.IncomingRequest) {\n\t    len = requests.length;\n\t    while(len--) {\n\t      pass = requests[len](message);\n\t      if(pass === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  else if(message instanceof SIP.IncomingResponse) {\n\t    len = responses.length;\n\t    while(len--) {\n\t      pass = responses[len](message);\n\t      if(pass === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  //Everything is OK\n\t  return true;\n\t};\n\t\n\tSIP.sanityCheck = sanityCheck;\n\t};\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * @fileoverview SIP Digest Authentication\n\t */\n\t\n\t/**\n\t * SIP Digest Authentication.\n\t * @augments SIP.\n\t * @function Digest Authentication\n\t * @param {SIP.UA} ua\n\t */\n\tmodule.exports = function (Utils) {\n\tvar DigestAuthentication;\n\t\n\tDigestAuthentication = function(ua) {\n\t  this.logger = ua.getLogger('sipjs.digestauthentication');\n\t  this.username = ua.configuration.authorizationUser;\n\t  this.password = ua.configuration.password;\n\t  this.cnonce = null;\n\t  this.nc = 0;\n\t  this.ncHex = '00000000';\n\t  this.response = null;\n\t};\n\t\n\t\n\t/**\n\t* Performs Digest authentication given a SIP request and the challenge\n\t* received in a response to that request.\n\t* Returns true if credentials were successfully generated, false otherwise.\n\t*\n\t* @param {SIP.OutgoingRequest} request\n\t* @param {Object} challenge\n\t*/\n\tDigestAuthentication.prototype.authenticate = function(request, challenge) {\n\t  // Inspect and validate the challenge.\n\t\n\t  this.algorithm = challenge.algorithm;\n\t  this.realm = challenge.realm;\n\t  this.nonce = challenge.nonce;\n\t  this.opaque = challenge.opaque;\n\t  this.stale = challenge.stale;\n\t\n\t  if (this.algorithm) {\n\t    if (this.algorithm !== 'MD5') {\n\t      this.logger.warn('challenge with Digest algorithm different than \"MD5\", authentication aborted');\n\t      return false;\n\t    }\n\t  } else {\n\t    this.algorithm = 'MD5';\n\t  }\n\t\n\t  if (! this.realm) {\n\t    this.logger.warn('challenge without Digest realm, authentication aborted');\n\t    return false;\n\t  }\n\t\n\t  if (! this.nonce) {\n\t    this.logger.warn('challenge without Digest nonce, authentication aborted');\n\t    return false;\n\t  }\n\t\n\t  // 'qop' can contain a list of values (Array). Let's choose just one.\n\t  if (challenge.qop) {\n\t    if (challenge.qop.indexOf('auth') > -1) {\n\t      this.qop = 'auth';\n\t    } else if (challenge.qop.indexOf('auth-int') > -1) {\n\t      this.qop = 'auth-int';\n\t    } else {\n\t      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n\t      this.logger.warn('challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n\t      return false;\n\t    }\n\t  } else {\n\t    this.qop = null;\n\t  }\n\t\n\t  // Fill other attributes.\n\t\n\t  this.method = request.method;\n\t  this.uri = request.ruri;\n\t  this.cnonce = Utils.createRandomToken(12);\n\t  this.nc += 1;\n\t  this.updateNcHex();\n\t\n\t  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n\t  if (this.nc === 4294967296) {\n\t    this.nc = 1;\n\t    this.ncHex = '00000001';\n\t  }\n\t\n\t  // Calculate the Digest \"response\" value.\n\t  this.calculateResponse();\n\t\n\t  return true;\n\t};\n\t\n\t\n\t/**\n\t* Generate Digest 'response' value.\n\t* @private\n\t*/\n\tDigestAuthentication.prototype.calculateResponse = function() {\n\t  var ha1, ha2;\n\t\n\t  // HA1 = MD5(A1) = MD5(username:realm:password)\n\t  ha1 = Utils.calculateMD5(this.username + \":\" + this.realm + \":\" + this.password);\n\t\n\t  if (this.qop === 'auth') {\n\t    // HA2 = MD5(A2) = MD5(method:digestURI)\n\t    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n\t    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n\t    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n\t\n\t  } else if (this.qop === 'auth-int') {\n\t    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n\t    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri + \":\" + Utils.calculateMD5(this.body ? this.body : \"\"));\n\t    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n\t    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n\t\n\t  } else if (this.qop === null) {\n\t    // HA2 = MD5(A2) = MD5(method:digestURI)\n\t    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n\t    // response = MD5(HA1:nonce:HA2)\n\t    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t* Return the Proxy-Authorization or WWW-Authorization header value.\n\t*/\n\tDigestAuthentication.prototype.toString = function() {\n\t  var auth_params = [];\n\t\n\t  if (! this.response) {\n\t    throw new Error('response field does not exist, cannot generate Authorization header');\n\t  }\n\t\n\t  auth_params.push('algorithm=' + this.algorithm);\n\t  auth_params.push('username=\"' + this.username + '\"');\n\t  auth_params.push('realm=\"' + this.realm + '\"');\n\t  auth_params.push('nonce=\"' + this.nonce + '\"');\n\t  auth_params.push('uri=\"' + this.uri + '\"');\n\t  auth_params.push('response=\"' + this.response + '\"');\n\t  if (this.opaque) {\n\t    auth_params.push('opaque=\"' + this.opaque + '\"');\n\t  }\n\t  if (this.qop) {\n\t    auth_params.push('qop=' + this.qop);\n\t    auth_params.push('cnonce=\"' + this.cnonce + '\"');\n\t    auth_params.push('nc=' + this.ncHex);\n\t  }\n\t\n\t  return 'Digest ' + auth_params.join(', ');\n\t};\n\t\n\t\n\t/**\n\t* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n\t* @private\n\t*/\n\tDigestAuthentication.prototype.updateNcHex = function() {\n\t  var hex = Number(this.nc).toString(16);\n\t  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;\n\t};\n\t\n\treturn DigestAuthentication;\n\t};\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Grammar = __webpack_require__(48);\n\t\n\tmodule.exports = function (SIP) {\n\t\n\treturn {\n\t  parse: function parseCustom (input, startRule) {\n\t    var options = {startRule: startRule, SIP: SIP};\n\t    try {\n\t      Grammar.parse(input, options);\n\t    } catch (e) {\n\t      options.data = -1;\n\t    }\n\t    return options.data;\n\t  }\n\t};\n\t\n\t};\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\tmodule.exports = (function() {\n\t  /*\n\t   * Generated by PEG.js 0.8.0.\n\t   *\n\t   * http://pegjs.majda.cz/\n\t   */\n\t\n\t  function peg$subclass(child, parent) {\n\t    function ctor() { this.constructor = child; }\n\t    ctor.prototype = parent.prototype;\n\t    child.prototype = new ctor();\n\t  }\n\t\n\t  function SyntaxError(message, expected, found, offset, line, column) {\n\t    this.message  = message;\n\t    this.expected = expected;\n\t    this.found    = found;\n\t    this.offset   = offset;\n\t    this.line     = line;\n\t    this.column   = column;\n\t\n\t    this.name     = \"SyntaxError\";\n\t  }\n\t\n\t  peg$subclass(SyntaxError, Error);\n\t\n\t  function parse(input) {\n\t    var options = arguments.length > 1 ? arguments[1] : {},\n\t\n\t        peg$FAILED = {},\n\t\n\t        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },\n\t        peg$startRuleIndex   = 118,\n\t\n\t        peg$consts = [\n\t          \"\\r\\n\",\n\t          { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n\t          /^[0-9]/,\n\t          { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n\t          /^[a-zA-Z]/,\n\t          { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n\t          /^[0-9a-fA-F]/,\n\t          { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n\t          /^[\\0-\\xFF]/,\n\t          { type: \"class\", value: \"[\\\\0-\\\\xFF]\", description: \"[\\\\0-\\\\xFF]\" },\n\t          /^[\"]/,\n\t          { type: \"class\", value: \"[\\\"]\", description: \"[\\\"]\" },\n\t          \" \",\n\t          { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n\t          \"\\t\",\n\t          { type: \"literal\", value: \"\\t\", description: \"\\\"\\\\t\\\"\" },\n\t          /^[a-zA-Z0-9]/,\n\t          { type: \"class\", value: \"[a-zA-Z0-9]\", description: \"[a-zA-Z0-9]\" },\n\t          \";\",\n\t          { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n\t          \"/\",\n\t          { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n\t          \"?\",\n\t          { type: \"literal\", value: \"?\", description: \"\\\"?\\\"\" },\n\t          \":\",\n\t          { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n\t          \"@\",\n\t          { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n\t          \"&\",\n\t          { type: \"literal\", value: \"&\", description: \"\\\"&\\\"\" },\n\t          \"=\",\n\t          { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n\t          \"+\",\n\t          { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n\t          \"$\",\n\t          { type: \"literal\", value: \"$\", description: \"\\\"$\\\"\" },\n\t          \",\",\n\t          { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n\t          \"-\",\n\t          { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n\t          \"_\",\n\t          { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n\t          \".\",\n\t          { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n\t          \"!\",\n\t          { type: \"literal\", value: \"!\", description: \"\\\"!\\\"\" },\n\t          \"~\",\n\t          { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n\t          \"*\",\n\t          { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n\t          \"'\",\n\t          { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\n\t          \"(\",\n\t          { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n\t          \")\",\n\t          { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n\t          peg$FAILED,\n\t          \"%\",\n\t          { type: \"literal\", value: \"%\", description: \"\\\"%\\\"\" },\n\t          null,\n\t          [],\n\t          function() {return \" \"; },\n\t          function() {return ':'; },\n\t          /^[!-~]/,\n\t          { type: \"class\", value: \"[!-~]\", description: \"[!-~]\" },\n\t          /^[\\x80-\\uFFFF]/,\n\t          { type: \"class\", value: \"[\\\\x80-\\\\uFFFF]\", description: \"[\\\\x80-\\\\uFFFF]\" },\n\t          /^[\\x80-\\xBF]/,\n\t          { type: \"class\", value: \"[\\\\x80-\\\\xBF]\", description: \"[\\\\x80-\\\\xBF]\" },\n\t          /^[a-f]/,\n\t          { type: \"class\", value: \"[a-f]\", description: \"[a-f]\" },\n\t          \"`\",\n\t          { type: \"literal\", value: \"`\", description: \"\\\"`\\\"\" },\n\t          \"<\",\n\t          { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n\t          \">\",\n\t          { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n\t          \"\\\\\",\n\t          { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n\t          \"[\",\n\t          { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n\t          \"]\",\n\t          { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n\t          \"{\",\n\t          { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n\t          \"}\",\n\t          { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n\t          function() {return \"*\"; },\n\t          function() {return \"/\"; },\n\t          function() {return \"=\"; },\n\t          function() {return \"(\"; },\n\t          function() {return \")\"; },\n\t          function() {return \">\"; },\n\t          function() {return \"<\"; },\n\t          function() {return \",\"; },\n\t          function() {return \";\"; },\n\t          function() {return \":\"; },\n\t          function() {return \"\\\"\"; },\n\t          /^[!-']/,\n\t          { type: \"class\", value: \"[!-']\", description: \"[!-']\" },\n\t          /^[*-[]/,\n\t          { type: \"class\", value: \"[*-[]\", description: \"[*-[]\" },\n\t          /^[\\]-~]/,\n\t          { type: \"class\", value: \"[\\\\]-~]\", description: \"[\\\\]-~]\" },\n\t          function(contents) {\n\t                                  return contents; },\n\t          /^[#-[]/,\n\t          { type: \"class\", value: \"[#-[]\", description: \"[#-[]\" },\n\t          /^[\\0-\\t]/,\n\t          { type: \"class\", value: \"[\\\\0-\\\\t]\", description: \"[\\\\0-\\\\t]\" },\n\t          /^[\\x0B-\\f]/,\n\t          { type: \"class\", value: \"[\\\\x0B-\\\\f]\", description: \"[\\\\x0B-\\\\f]\" },\n\t          /^[\\x0E-]/,\n\t          { type: \"class\", value: \"[\\\\x0E-]\", description: \"[\\\\x0E-]\" },\n\t          function() {\n\t                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);\n\t                                  delete options.data.scheme;\n\t                                  delete options.data.user;\n\t                                  delete options.data.host;\n\t                                  delete options.data.host_type;\n\t                                  delete options.data.port;\n\t                                },\n\t          function() {\n\t                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n\t                                  delete options.data.scheme;\n\t                                  delete options.data.user;\n\t                                  delete options.data.host;\n\t                                  delete options.data.host_type;\n\t                                  delete options.data.port;\n\t                                  delete options.data.uri_params;\n\t\n\t                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}\n\t                                },\n\t          \"sips\",\n\t          { type: \"literal\", value: \"sips\", description: \"\\\"sips\\\"\" },\n\t          \"sip\",\n\t          { type: \"literal\", value: \"sip\", description: \"\\\"sip\\\"\" },\n\t          function(uri_scheme) {\n\t                              options.data.scheme = uri_scheme; },\n\t          function() {\n\t                              options.data.user = decodeURIComponent(text().slice(0, -1));},\n\t          function() {\n\t                              options.data.password = text(); },\n\t          function() {\n\t                              options.data.host = text();\n\t                              return options.data.host; },\n\t          function() {\n\t                            options.data.host_type = 'domain';\n\t                            return text(); },\n\t          /^[a-zA-Z0-9_\\-]/,\n\t          { type: \"class\", value: \"[a-zA-Z0-9_\\\\-]\", description: \"[a-zA-Z0-9_\\\\-]\" },\n\t          /^[a-zA-Z0-9\\-]/,\n\t          { type: \"class\", value: \"[a-zA-Z0-9\\\\-]\", description: \"[a-zA-Z0-9\\\\-]\" },\n\t          function() {\n\t                              options.data.host_type = 'IPv6';\n\t                              return text(); },\n\t          \"::\",\n\t          { type: \"literal\", value: \"::\", description: \"\\\"::\\\"\" },\n\t          function() {\n\t                            options.data.host_type = 'IPv6';\n\t                            return text(); },\n\t          function() {\n\t                              options.data.host_type = 'IPv4';\n\t                              return text(); },\n\t          \"25\",\n\t          { type: \"literal\", value: \"25\", description: \"\\\"25\\\"\" },\n\t          /^[0-5]/,\n\t          { type: \"class\", value: \"[0-5]\", description: \"[0-5]\" },\n\t          \"2\",\n\t          { type: \"literal\", value: \"2\", description: \"\\\"2\\\"\" },\n\t          /^[0-4]/,\n\t          { type: \"class\", value: \"[0-4]\", description: \"[0-4]\" },\n\t          \"1\",\n\t          { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n\t          /^[1-9]/,\n\t          { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n\t          function(port) {\n\t                              port = parseInt(port.join(''));\n\t                              options.data.port = port;\n\t                              return port; },\n\t          \"transport=\",\n\t          { type: \"literal\", value: \"transport=\", description: \"\\\"transport=\\\"\" },\n\t          \"udp\",\n\t          { type: \"literal\", value: \"udp\", description: \"\\\"udp\\\"\" },\n\t          \"tcp\",\n\t          { type: \"literal\", value: \"tcp\", description: \"\\\"tcp\\\"\" },\n\t          \"sctp\",\n\t          { type: \"literal\", value: \"sctp\", description: \"\\\"sctp\\\"\" },\n\t          \"tls\",\n\t          { type: \"literal\", value: \"tls\", description: \"\\\"tls\\\"\" },\n\t          function(transport) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['transport'] = transport.toLowerCase(); },\n\t          \"user=\",\n\t          { type: \"literal\", value: \"user=\", description: \"\\\"user=\\\"\" },\n\t          \"phone\",\n\t          { type: \"literal\", value: \"phone\", description: \"\\\"phone\\\"\" },\n\t          \"ip\",\n\t          { type: \"literal\", value: \"ip\", description: \"\\\"ip\\\"\" },\n\t          function(user) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['user'] = user.toLowerCase(); },\n\t          \"method=\",\n\t          { type: \"literal\", value: \"method=\", description: \"\\\"method=\\\"\" },\n\t          function(method) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['method'] = method; },\n\t          \"ttl=\",\n\t          { type: \"literal\", value: \"ttl=\", description: \"\\\"ttl=\\\"\" },\n\t          function(ttl) {\n\t                                if(!options.data.params) options.data.params={};\n\t                                options.data.params['ttl'] = ttl; },\n\t          \"maddr=\",\n\t          { type: \"literal\", value: \"maddr=\", description: \"\\\"maddr=\\\"\" },\n\t          function(maddr) {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['maddr'] = maddr; },\n\t          \"lr\",\n\t          { type: \"literal\", value: \"lr\", description: \"\\\"lr\\\"\" },\n\t          function() {\n\t                                if(!options.data.uri_params) options.data.uri_params={};\n\t                                options.data.uri_params['lr'] = undefined; },\n\t          function(param, value) {\n\t                                if(!options.data.uri_params) options.data.uri_params = {};\n\t                                if (value === null){\n\t                                  value = undefined;\n\t                                }\n\t                                else {\n\t                                  value = value[1];\n\t                                }\n\t                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},\n\t          function(hname, hvalue) {\n\t                                hname = hname.join('').toLowerCase();\n\t                                hvalue = hvalue.join('');\n\t                                if(!options.data.uri_headers) options.data.uri_headers = {};\n\t                                if (!options.data.uri_headers[hname]) {\n\t                                  options.data.uri_headers[hname] = [hvalue];\n\t                                } else {\n\t                                  options.data.uri_headers[hname].push(hvalue);\n\t                                }},\n\t          function() {\n\t                                // lots of tests fail if this isn't guarded...\n\t                                if (options.startRule === 'Refer_To') {\n\t                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n\t                                  delete options.data.scheme;\n\t                                  delete options.data.user;\n\t                                  delete options.data.host;\n\t                                  delete options.data.host_type;\n\t                                  delete options.data.port;\n\t                                  delete options.data.uri_params;\n\t                                }\n\t                              },\n\t          \"//\",\n\t          { type: \"literal\", value: \"//\", description: \"\\\"//\\\"\" },\n\t          function() {\n\t                              options.data.scheme= text(); },\n\t          { type: \"literal\", value: \"SIP\", description: \"\\\"SIP\\\"\" },\n\t          function() {\n\t                              options.data.sip_version = text(); },\n\t          \"INVITE\",\n\t          { type: \"literal\", value: \"INVITE\", description: \"\\\"INVITE\\\"\" },\n\t          \"ACK\",\n\t          { type: \"literal\", value: \"ACK\", description: \"\\\"ACK\\\"\" },\n\t          \"VXACH\",\n\t          { type: \"literal\", value: \"VXACH\", description: \"\\\"VXACH\\\"\" },\n\t          \"OPTIONS\",\n\t          { type: \"literal\", value: \"OPTIONS\", description: \"\\\"OPTIONS\\\"\" },\n\t          \"BYE\",\n\t          { type: \"literal\", value: \"BYE\", description: \"\\\"BYE\\\"\" },\n\t          \"CANCEL\",\n\t          { type: \"literal\", value: \"CANCEL\", description: \"\\\"CANCEL\\\"\" },\n\t          \"REGISTER\",\n\t          { type: \"literal\", value: \"REGISTER\", description: \"\\\"REGISTER\\\"\" },\n\t          \"SUBSCRIBE\",\n\t          { type: \"literal\", value: \"SUBSCRIBE\", description: \"\\\"SUBSCRIBE\\\"\" },\n\t          \"NOTIFY\",\n\t          { type: \"literal\", value: \"NOTIFY\", description: \"\\\"NOTIFY\\\"\" },\n\t          \"REFER\",\n\t          { type: \"literal\", value: \"REFER\", description: \"\\\"REFER\\\"\" },\n\t          function() {\n\t\n\t                              options.data.method = text();\n\t                              return options.data.method; },\n\t          function(status_code) {\n\t                            options.data.status_code = parseInt(status_code.join('')); },\n\t          function() {\n\t                            options.data.reason_phrase = text(); },\n\t          function() {\n\t                        options.data = text(); },\n\t          function() {\n\t                                  var idx, length;\n\t                                  length = options.data.multi_header.length;\n\t                                  for (idx = 0; idx < length; idx++) {\n\t                                    if (options.data.multi_header[idx].parsed === null) {\n\t                                      options.data = null;\n\t                                      break;\n\t                                    }\n\t                                  }\n\t                                  if (options.data !== null) {\n\t                                    options.data = options.data.multi_header;\n\t                                  } else {\n\t                                    options.data = -1;\n\t                                  }},\n\t          function() {\n\t                                  var header;\n\t                                  if(!options.data.multi_header) options.data.multi_header = [];\n\t                                  try {\n\t                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                                    delete options.data.uri;\n\t                                    delete options.data.displayName;\n\t                                    delete options.data.params;\n\t                                  } catch(e) {\n\t                                    header = null;\n\t                                  }\n\t                                  options.data.multi_header.push( { 'position': peg$currPos,\n\t                                                            'offset': offset(),\n\t                                                            'parsed': header\n\t                                                          });},\n\t          function(displayName) {\n\t                                  displayName = text().trim();\n\t                                  if (displayName[0] === '\\\"') {\n\t                                    displayName = displayName.substring(1, displayName.length-1);\n\t                                  }\n\t                                  options.data.displayName = displayName; },\n\t          \"q\",\n\t          { type: \"literal\", value: \"q\", description: \"\\\"q\\\"\" },\n\t          function(q) {\n\t                                  if(!options.data.params) options.data.params = {};\n\t                                  options.data.params['q'] = q; },\n\t          \"expires\",\n\t          { type: \"literal\", value: \"expires\", description: \"\\\"expires\\\"\" },\n\t          function(expires) {\n\t                                  if(!options.data.params) options.data.params = {};\n\t                                  options.data.params['expires'] = expires; },\n\t          function(delta_seconds) {\n\t                                  return parseInt(delta_seconds.join('')); },\n\t          \"0\",\n\t          { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n\t          function() {\n\t                                  return parseFloat(text()); },\n\t          function(param, value) {\n\t                                  if(!options.data.params) options.data.params = {};\n\t                                  if (value === null){\n\t                                    value = undefined;\n\t                                  }\n\t                                  else {\n\t                                    value = value[1];\n\t                                  }\n\t                                  options.data.params[param.toLowerCase()] = value;},\n\t          \"render\",\n\t          { type: \"literal\", value: \"render\", description: \"\\\"render\\\"\" },\n\t          \"session\",\n\t          { type: \"literal\", value: \"session\", description: \"\\\"session\\\"\" },\n\t          \"icon\",\n\t          { type: \"literal\", value: \"icon\", description: \"\\\"icon\\\"\" },\n\t          \"alert\",\n\t          { type: \"literal\", value: \"alert\", description: \"\\\"alert\\\"\" },\n\t          function() {\n\t                                      if (options.startRule === 'Content_Disposition') {\n\t                                        options.data.type = text().toLowerCase();\n\t                                      }\n\t                                    },\n\t          \"handling\",\n\t          { type: \"literal\", value: \"handling\", description: \"\\\"handling\\\"\" },\n\t          \"optional\",\n\t          { type: \"literal\", value: \"optional\", description: \"\\\"optional\\\"\" },\n\t          \"required\",\n\t          { type: \"literal\", value: \"required\", description: \"\\\"required\\\"\" },\n\t          function(length) {\n\t                                  options.data = parseInt(length.join('')); },\n\t          function() {\n\t                                  options.data = text(); },\n\t          \"text\",\n\t          { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n\t          \"image\",\n\t          { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n\t          \"audio\",\n\t          { type: \"literal\", value: \"audio\", description: \"\\\"audio\\\"\" },\n\t          \"video\",\n\t          { type: \"literal\", value: \"video\", description: \"\\\"video\\\"\" },\n\t          \"application\",\n\t          { type: \"literal\", value: \"application\", description: \"\\\"application\\\"\" },\n\t          \"message\",\n\t          { type: \"literal\", value: \"message\", description: \"\\\"message\\\"\" },\n\t          \"multipart\",\n\t          { type: \"literal\", value: \"multipart\", description: \"\\\"multipart\\\"\" },\n\t          \"x-\",\n\t          { type: \"literal\", value: \"x-\", description: \"\\\"x-\\\"\" },\n\t          function(cseq_value) {\n\t                            options.data.value=parseInt(cseq_value.join('')); },\n\t          function(expires) {options.data = expires; },\n\t          function(event_type) {\n\t                                 options.data.event = event_type.toLowerCase(); },\n\t          function() {\n\t                          var tag = options.data.tag;\n\t                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                            if (tag) {options.data.setParam('tag',tag)}\n\t                          },\n\t          \"tag\",\n\t          { type: \"literal\", value: \"tag\", description: \"\\\"tag\\\"\" },\n\t          function(tag) {options.data.tag = tag; },\n\t          function(forwards) {\n\t                            options.data = parseInt(forwards.join('')); },\n\t          function(min_expires) {options.data = min_expires; },\n\t          function() {\n\t                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                                },\n\t          \"digest\",\n\t          { type: \"literal\", value: \"Digest\", description: \"\\\"Digest\\\"\" },\n\t          \"realm\",\n\t          { type: \"literal\", value: \"realm\", description: \"\\\"realm\\\"\" },\n\t          function(realm) { options.data.realm = realm; },\n\t          \"domain\",\n\t          { type: \"literal\", value: \"domain\", description: \"\\\"domain\\\"\" },\n\t          \"nonce\",\n\t          { type: \"literal\", value: \"nonce\", description: \"\\\"nonce\\\"\" },\n\t          function(nonce) { options.data.nonce=nonce; },\n\t          \"opaque\",\n\t          { type: \"literal\", value: \"opaque\", description: \"\\\"opaque\\\"\" },\n\t          function(opaque) { options.data.opaque=opaque; },\n\t          \"stale\",\n\t          { type: \"literal\", value: \"stale\", description: \"\\\"stale\\\"\" },\n\t          \"true\",\n\t          { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\n\t          function() { options.data.stale=true; },\n\t          \"false\",\n\t          { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\n\t          function() { options.data.stale=false; },\n\t          \"algorithm\",\n\t          { type: \"literal\", value: \"algorithm\", description: \"\\\"algorithm\\\"\" },\n\t          \"md5\",\n\t          { type: \"literal\", value: \"MD5\", description: \"\\\"MD5\\\"\" },\n\t          \"md5-sess\",\n\t          { type: \"literal\", value: \"MD5-sess\", description: \"\\\"MD5-sess\\\"\" },\n\t          function(algorithm) {\n\t                                options.data.algorithm=algorithm.toUpperCase(); },\n\t          \"qop\",\n\t          { type: \"literal\", value: \"qop\", description: \"\\\"qop\\\"\" },\n\t          \"auth-int\",\n\t          { type: \"literal\", value: \"auth-int\", description: \"\\\"auth-int\\\"\" },\n\t          \"auth\",\n\t          { type: \"literal\", value: \"auth\", description: \"\\\"auth\\\"\" },\n\t          function(qop_value) {\n\t                                  options.data.qop || (options.data.qop=[]);\n\t                                  options.data.qop.push(qop_value.toLowerCase()); },\n\t          function(rack_value) {\n\t                            options.data.value=parseInt(rack_value.join('')); },\n\t          function() {\n\t                            var idx, length;\n\t                            length = options.data.multi_header.length;\n\t                            for (idx = 0; idx < length; idx++) {\n\t                              if (options.data.multi_header[idx].parsed === null) {\n\t                                options.data = null;\n\t                                break;\n\t                              }\n\t                            }\n\t                            if (options.data !== null) {\n\t                              options.data = options.data.multi_header;\n\t                            } else {\n\t                              options.data = -1;\n\t                            }},\n\t          function() {\n\t                            var header;\n\t                            if(!options.data.multi_header) options.data.multi_header = [];\n\t                            try {\n\t                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                              delete options.data.uri;\n\t                              delete options.data.displayName;\n\t                              delete options.data.params;\n\t                            } catch(e) {\n\t                              header = null;\n\t                            }\n\t                            options.data.multi_header.push( { 'position': peg$currPos,\n\t                                                      'offset': offset(),\n\t                                                      'parsed': header\n\t                                                    });},\n\t          function() {\n\t                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                      },\n\t          function() {\n\t                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {\n\t                                  options.data = -1;\n\t                                }\n\t                              },\n\t          function() {\n\t                                options.data = {\n\t                                  call_id: options.data\n\t                                };\n\t                              },\n\t          \"from-tag\",\n\t          { type: \"literal\", value: \"from-tag\", description: \"\\\"from-tag\\\"\" },\n\t          function(from_tag) {\n\t                                options.data.replaces_from_tag = from_tag;\n\t                              },\n\t          \"to-tag\",\n\t          { type: \"literal\", value: \"to-tag\", description: \"\\\"to-tag\\\"\" },\n\t          function(to_tag) {\n\t                                options.data.replaces_to_tag = to_tag;\n\t                              },\n\t          \"early-only\",\n\t          { type: \"literal\", value: \"early-only\", description: \"\\\"early-only\\\"\" },\n\t          function() {\n\t                                options.data.early_only = true;\n\t                              },\n\t          function(r) {return r;},\n\t          function(first, rest) { return list(first, rest); },\n\t          function(value) {\n\t                          if (options.startRule === 'Require') {\n\t                            options.data = value || [];\n\t                          }\n\t                        },\n\t          function(rseq_value) {\n\t                            options.data.value=parseInt(rseq_value.join('')); },\n\t          \"active\",\n\t          { type: \"literal\", value: \"active\", description: \"\\\"active\\\"\" },\n\t          \"pending\",\n\t          { type: \"literal\", value: \"pending\", description: \"\\\"pending\\\"\" },\n\t          \"terminated\",\n\t          { type: \"literal\", value: \"terminated\", description: \"\\\"terminated\\\"\" },\n\t          function() {\n\t                                  options.data.state = text(); },\n\t          \"reason\",\n\t          { type: \"literal\", value: \"reason\", description: \"\\\"reason\\\"\" },\n\t          function(reason) {\n\t                                  if (typeof reason !== 'undefined') options.data.reason = reason; },\n\t          function(expires) {\n\t                                  if (typeof expires !== 'undefined') options.data.expires = expires; },\n\t          \"retry_after\",\n\t          { type: \"literal\", value: \"retry_after\", description: \"\\\"retry_after\\\"\" },\n\t          function(retry_after) {\n\t                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },\n\t          \"deactivated\",\n\t          { type: \"literal\", value: \"deactivated\", description: \"\\\"deactivated\\\"\" },\n\t          \"probation\",\n\t          { type: \"literal\", value: \"probation\", description: \"\\\"probation\\\"\" },\n\t          \"rejected\",\n\t          { type: \"literal\", value: \"rejected\", description: \"\\\"rejected\\\"\" },\n\t          \"timeout\",\n\t          { type: \"literal\", value: \"timeout\", description: \"\\\"timeout\\\"\" },\n\t          \"giveup\",\n\t          { type: \"literal\", value: \"giveup\", description: \"\\\"giveup\\\"\" },\n\t          \"noresource\",\n\t          { type: \"literal\", value: \"noresource\", description: \"\\\"noresource\\\"\" },\n\t          \"invariant\",\n\t          { type: \"literal\", value: \"invariant\", description: \"\\\"invariant\\\"\" },\n\t          function(value) {\n\t                          if (options.startRule === 'Supported') {\n\t                            options.data = value || [];\n\t                          }\n\t                        },\n\t          function() {\n\t                        var tag = options.data.tag;\n\t                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n\t                          if (tag) {options.data.setParam('tag',tag)}\n\t                        },\n\t          \"ttl\",\n\t          { type: \"literal\", value: \"ttl\", description: \"\\\"ttl\\\"\" },\n\t          function(via_ttl_value) {\n\t                                options.data.ttl = via_ttl_value; },\n\t          \"maddr\",\n\t          { type: \"literal\", value: \"maddr\", description: \"\\\"maddr\\\"\" },\n\t          function(via_maddr) {\n\t                                options.data.maddr = via_maddr; },\n\t          \"received\",\n\t          { type: \"literal\", value: \"received\", description: \"\\\"received\\\"\" },\n\t          function(via_received) {\n\t                                options.data.received = via_received; },\n\t          \"branch\",\n\t          { type: \"literal\", value: \"branch\", description: \"\\\"branch\\\"\" },\n\t          function(via_branch) {\n\t                                options.data.branch = via_branch; },\n\t          \"rport\",\n\t          { type: \"literal\", value: \"rport\", description: \"\\\"rport\\\"\" },\n\t          function() {\n\t                                if(typeof response_port !== 'undefined')\n\t                                  options.data.rport = response_port.join(''); },\n\t          function(via_protocol) {\n\t                                options.data.protocol = via_protocol; },\n\t          { type: \"literal\", value: \"UDP\", description: \"\\\"UDP\\\"\" },\n\t          { type: \"literal\", value: \"TCP\", description: \"\\\"TCP\\\"\" },\n\t          { type: \"literal\", value: \"TLS\", description: \"\\\"TLS\\\"\" },\n\t          { type: \"literal\", value: \"SCTP\", description: \"\\\"SCTP\\\"\" },\n\t          function(via_transport) {\n\t                                options.data.transport = via_transport; },\n\t          function() {\n\t                                options.data.host = text(); },\n\t          function(via_sent_by_port) {\n\t                                options.data.port = parseInt(via_sent_by_port.join('')); },\n\t          function(ttl) {\n\t                                return parseInt(ttl.join('')); },\n\t          function(deltaSeconds) {\n\t                                if (options.startRule === 'Session_Expires') {\n\t                                  options.data.deltaSeconds = deltaSeconds;\n\t                                }\n\t                              },\n\t          \"refresher\",\n\t          { type: \"literal\", value: \"refresher\", description: \"\\\"refresher\\\"\" },\n\t          \"uas\",\n\t          { type: \"literal\", value: \"uas\", description: \"\\\"uas\\\"\" },\n\t          \"uac\",\n\t          { type: \"literal\", value: \"uac\", description: \"\\\"uac\\\"\" },\n\t          function(endpoint) {\n\t                                if (options.startRule === 'Session_Expires') {\n\t                                  options.data.refresher = endpoint;\n\t                                }\n\t                              },\n\t          function(deltaSeconds) {\n\t                                if (options.startRule === 'Min_SE') {\n\t                                  options.data = deltaSeconds;\n\t                                }\n\t                              },\n\t          \"stuns\",\n\t          { type: \"literal\", value: \"stuns\", description: \"\\\"stuns\\\"\" },\n\t          \"stun\",\n\t          { type: \"literal\", value: \"stun\", description: \"\\\"stun\\\"\" },\n\t          function(scheme) {\n\t                                options.data.scheme = scheme; },\n\t          function(host) {\n\t                                options.data.host = host; },\n\t          \"?transport=\",\n\t          { type: \"literal\", value: \"?transport=\", description: \"\\\"?transport=\\\"\" },\n\t          \"turns\",\n\t          { type: \"literal\", value: \"turns\", description: \"\\\"turns\\\"\" },\n\t          \"turn\",\n\t          { type: \"literal\", value: \"turn\", description: \"\\\"turn\\\"\" },\n\t          function() {\n\t                                options.data.transport = transport; },\n\t          function() {\n\t                            options.data = text(); }\n\t        ],\n\t\n\t        peg$bytecode = [\n\t          peg$decode(\". \\\"\\\"2 3!\"),\n\t          peg$decode(\"0\\\"\\\"\\\"1!3#\"),\n\t          peg$decode(\"0$\\\"\\\"1!3%\"),\n\t          peg$decode(\"0&\\\"\\\"1!3'\"),\n\t          peg$decode(\"7'*# \\\"7(\"),\n\t          peg$decode(\"0(\\\"\\\"1!3)\"),\n\t          peg$decode(\"0*\\\"\\\"1!3+\"),\n\t          peg$decode(\".,\\\"\\\"2,3-\"),\n\t          peg$decode(\"..\\\"\\\"2.3/\"),\n\t          peg$decode(\"00\\\"\\\"1!31\"),\n\t          peg$decode(\".2\\\"\\\"2233*\\x89 \\\".4\\\"\\\"2435*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n\t          peg$decode(\"7)*# \\\"7,\"),\n\t          peg$decode(\".F\\\"\\\"2F3G*} \\\".H\\\"\\\"2H3I*q \\\".J\\\"\\\"2J3K*e \\\".L\\\"\\\"2L3M*Y \\\".N\\\"\\\"2N3O*M \\\".P\\\"\\\"2P3Q*A \\\".R\\\"\\\"2R3S*5 \\\".T\\\"\\\"2T3U*) \\\".V\\\"\\\"2V3W\"),\n\t          peg$decode(\"!!.Y\\\"\\\"2Y3Z+7$7#+-%7#+#%'#%$## X$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"!! \\\\7$,#&7$\\\"+-$7 +#%'\\\"%$\\\"# X\\\"# X*# \\\" [+@$ \\\\7$+&$,#&7$\\\"\\\"\\\" X+'%4\\\"6]\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7.*# \\\" [\"),\n\t          peg$decode(\"! \\\\7'*# \\\"7(,)&7'*# \\\"7(\\\"+A$.8\\\"\\\"2839+1%7/+'%4#6^# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!! \\\\72+&$,#&72\\\"\\\"\\\" X+o$ \\\\! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X,@&! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"0_\\\"\\\"1!3`*# \\\"73\"),\n\t          peg$decode(\"0a\\\"\\\"1!3b\"),\n\t          peg$decode(\"0c\\\"\\\"1!3d\"),\n\t          peg$decode(\"7!*) \\\"0e\\\"\\\"1!3f\"),\n\t          peg$decode(\"! \\\\7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x9E$,\\x9B&7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"! \\\\7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x92$,\\x8F&7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\".T\\\"\\\"2T3U*\\xE3 \\\".V\\\"\\\"2V3W*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".k\\\"\\\"2k3l*\\xBF \\\".:\\\"\\\"2:3;*\\xB3 \\\".D\\\"\\\"2D3E*\\xA7 \\\".2\\\"\\\"2233*\\x9B \\\".8\\\"\\\"2839*\\x8F \\\".m\\\"\\\"2m3n*\\x83 \\\"7&*} \\\".4\\\"\\\"2435*q \\\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".6\\\"\\\"2637*M \\\".>\\\"\\\"2>3?*A \\\".s\\\"\\\"2s3t*5 \\\".u\\\"\\\"2u3v*) \\\"7'*# \\\"7(\"),\n\t          peg$decode(\"! \\\\7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v+\\u0134$,\\u0131&7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"!7/+A$.P\\\"\\\"2P3Q+1%7/+'%4#6w# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.4\\\"\\\"2435+1%7/+'%4#6x# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.>\\\"\\\"2>3?+1%7/+'%4#6y# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.T\\\"\\\"2T3U+1%7/+'%4#6z# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.V\\\"\\\"2V3W+1%7/+'%4#6{# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.k\\\"\\\"2k3l+1$7/+'%4\\\"6|\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+7$.i\\\"\\\"2i3j+'%4\\\"6}\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.D\\\"\\\"2D3E+1%7/+'%4#6~# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.2\\\"\\\"2233+1%7/+'%4#6# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+A$.8\\\"\\\"2839+1%7/+'%4#6\\x80# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7/+1$7&+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7&+1$7/+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7=+W$ \\\\7G*) \\\"7K*# \\\"7F,/&7G*) \\\"7K*# \\\"7F\\\"+-%7>+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"0\\x82\\\"\\\"1!3\\x83*A \\\"0\\x84\\\"\\\"1!3\\x85*5 \\\"0\\x86\\\"\\\"1!3\\x87*) \\\"73*# \\\"7.\"),\n\t          peg$decode(\"!!7/+U$7&+K% \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+-%7&+#%'$%$$# X$## X$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"!7/+`$7&+V%! \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+! (%+2%7&+(%4$6\\x88$!!%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7.*G \\\".L\\\"\\\"2L3M*; \\\"0\\x89\\\"\\\"1!3\\x8A*/ \\\"0\\x86\\\"\\\"1!3\\x87*# \\\"73\"),\n\t          peg$decode(\"!.m\\\"\\\"2m3n+K$0\\x8B\\\"\\\"1!3\\x8C*5 \\\"0\\x8D\\\"\\\"1!3\\x8E*) \\\"0\\x8F\\\"\\\"1!3\\x90+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7N+Q$.8\\\"\\\"2839+A%7O*# \\\" [+1%7S+'%4$6\\x91$ %$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7N+k$.8\\\"\\\"2839+[%7O*# \\\" [+K%7S+A%7_+7%7l*# \\\" [+'%4&6\\x92& %$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\x93\\\"\\\"1$3\\x94*) \\\"/\\x95\\\"\\\"1#3\\x96+' 4!6\\x97!! %\"),\n\t          peg$decode(\"!7P+b$!.8\\\"\\\"2839+-$7R+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+7%.:\\\"\\\"2:3;+'%4#6\\x98# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\7+*) \\\"7-*# \\\"7Q+2$,/&7+*) \\\"7-*# \\\"7Q\\\"\\\"\\\" X\"),\n\t          peg$decode(\".<\\\"\\\"2<3=*q \\\".>\\\"\\\"2>3?*e \\\".@\\\"\\\"2@3A*Y \\\".B\\\"\\\"2B3C*M \\\".D\\\"\\\"2D3E*A \\\".2\\\"\\\"2233*5 \\\".6\\\"\\\"2637*) \\\".4\\\"\\\"2435\"),\n\t          peg$decode(\"! \\\\7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E,e&7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\\\"+& 4!6\\x99! %\"),\n\t          peg$decode(\"!7T+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\x9A! %\"),\n\t          peg$decode(\"! \\\\!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X,>&!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X\\\"+G$7W+=%.J\\\"\\\"2J3K*# \\\" [+'%4#6\\x9B# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\0\\x9C\\\"\\\"1!3\\x9D+,$,)&0\\x9C\\\"\\\"1!3\\x9D\\\"\\\"\\\" X\"),\n\t          peg$decode(\"!0$\\\"\\\"1!3%+A$ \\\\0\\x9E\\\"\\\"1!3\\x9F,)&0\\x9E\\\"\\\"1!3\\x9F\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.o\\\"\\\"2o3p+A$7Y+7%.q\\\"\\\"2q3r+'%4#6\\xA0# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!!7Z+\\xBF$.8\\\"\\\"2839+\\xAF%7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0838 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\xAF$7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0795 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95$7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u070C \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+{$7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u069D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+a$7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0648 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+G$7Z+=%.8\\\"\\\"2839+-%7[+#%'$%$$# X$## X$\\\"# X\\\"# X*\\u060D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7[+#%'\\\"%$\\\"# X\\\"# X*\\u05EC \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7Z+#%'\\\"%$\\\"# X\\\"# X*\\u05CB \\\"!7Z+\\xA5$.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0538 \\\"!7Z+\\xB6$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x8B%.\\xA1\\\"\\\"2\\xA13\\xA2+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0494 \\\"!7Z+\\xC7$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x9C%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+q%.\\xA1\\\"\\\"2\\xA13\\xA2+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u03DF \\\"!7Z+\\xD8$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xAD%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x82%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+W%.\\xA1\\\"\\\"2\\xA13\\xA2+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0319 \\\"!7Z+\\xE9$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0242 \\\"!7Z+\\u0114$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xE9%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0140 \\\"!7Z+\\u0135$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\u010A%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xDF%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xB4%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x89%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+^%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+3%.\\xA1\\\"\\\"2\\xA13\\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X+& 4!6\\xA3! %\"),\n\t          peg$decode(\"!7#+S$7#*# \\\" [+C%7#*# \\\" [+3%7#*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7Z+=$.8\\\"\\\"2839+-%7Z+#%'#%$## X$\\\"# X\\\"# X*# \\\"7\\\\\"),\n\t          peg$decode(\"!7]+u$.J\\\"\\\"2J3K+e%7]+[%.J\\\"\\\"2J3K+K%7]+A%.J\\\"\\\"2J3K+1%7]+'%4'6\\xA4' %$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.\\xA5\\\"\\\"2\\xA53\\xA6+3$0\\xA7\\\"\\\"1!3\\xA8+#%'\\\"%$\\\"# X\\\"# X*\\xA0 \\\"!.\\xA9\\\"\\\"2\\xA93\\xAA+=$0\\xAB\\\"\\\"1!3\\xAC+-%7!+#%'#%$## X$\\\"# X\\\"# X*o \\\"!.\\xAD\\\"\\\"2\\xAD3\\xAE+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X*D \\\"!0\\xAF\\\"\\\"1!3\\xB0+-$7!+#%'\\\"%$\\\"# X\\\"# X*# \\\"7!\"),\n\t          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\xB1!! %\"),\n\t          peg$decode(\" \\\\!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X\\\"\"),\n\t          peg$decode(\"7a*A \\\"7b*; \\\"7c*5 \\\"7d*/ \\\"7e*) \\\"7f*# \\\"7g\"),\n\t          peg$decode(\"!/\\xB2\\\"\\\"1*3\\xB3+b$/\\xB4\\\"\\\"1#3\\xB5*G \\\"/\\xB6\\\"\\\"1#3\\xB7*; \\\"/\\xB8\\\"\\\"1$3\\xB9*/ \\\"/\\xBA\\\"\\\"1#3\\xBB*# \\\"76+(%4\\\"6\\xBC\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xBD\\\"\\\"1%3\\xBE+J$/\\xBF\\\"\\\"1%3\\xC0*/ \\\"/\\xC1\\\"\\\"1\\\"3\\xC2*# \\\"76+(%4\\\"6\\xC3\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xC4\\\"\\\"1'3\\xC5+2$7\\x8F+(%4\\\"6\\xC6\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xC7\\\"\\\"1$3\\xC8+2$7\\xEF+(%4\\\"6\\xC9\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xCA\\\"\\\"1&3\\xCB+2$7T+(%4\\\"6\\xCC\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xCD\\\"\\\"1\\\"3\\xCE+R$!.>\\\"\\\"2>3?+-$76+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xCF\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7h+T$!.>\\\"\\\"2>3?+-$7i+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xD0\\\"\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n\t          peg$decode(\"7k*) \\\"7+*# \\\"7-\"),\n\t          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".8\\\"\\\"2839*A \\\".<\\\"\\\"2<3=*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n\t          peg$decode(\"!.6\\\"\\\"2637+u$7m+k% \\\\!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X,>&!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7n+C$.>\\\"\\\"2>3?+3%7o+)%4#6\\xD1#\\\"\\\" %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-+2$,/&7p*) \\\"7+*# \\\"7-\\\"\\\"\\\" X\"),\n\t          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-,/&7p*) \\\"7+*# \\\"7-\\\"\"),\n\t          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".6\\\"\\\"2637*A \\\".8\\\"\\\"2839*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n\t          peg$decode(\"7\\x90*# \\\"7r\"),\n\t          peg$decode(\"!7\\x8F+K$7'+A%7s+7%7'+-%7\\x84+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7M*# \\\"7t\"),\n\t          peg$decode(\"!7+G$.8\\\"\\\"2839+7%7u*# \\\"7x+'%4#6\\xD2# %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7v*# \\\"7w+N$!.6\\\"\\\"2637+-$7\\x83+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.\\xD3\\\"\\\"2\\xD33\\xD4+=$7\\x80+3%7w*# \\\" [+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!.4\\\"\\\"2435+-$7{+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7z+5$ \\\\7y,#&7y\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7**) \\\"7+*# \\\"7-\"),\n\t          peg$decode(\"7+*\\x8F \\\"7-*\\x89 \\\".2\\\"\\\"2233*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n\t          peg$decode(\"!7|+k$ \\\\!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X,>&!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7~,#&7~\\\"+k$ \\\\!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\7~,#&7~\\\"\"),\n\t          peg$decode(\"7+*w \\\"7-*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n\t          peg$decode(\"!7\\\"+\\x8D$ \\\\7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K,M&7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K\\\"+'%4\\\"6\\xD5\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\x81*# \\\"7\\x82\"),\n\t          peg$decode(\"!!7O+3$.:\\\"\\\"2:3;+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+-$7S+#%'\\\"%$\\\"# X\\\"# X*# \\\" [\"),\n\t          peg$decode(\" \\\\7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A+\\x8C$,\\x89&7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A\\\"\\\"\\\" X\"),\n\t          peg$decode(\" \\\\7y,#&7y\\\"\"),\n\t          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6+y$.4\\\"\\\"2435+i% \\\\7!+&$,#&7!\\\"\\\"\\\" X+P%.J\\\"\\\"2J3K+@% \\\\7!+&$,#&7!\\\"\\\"\\\" X+'%4%6\\xD7% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\".\\xD8\\\"\\\"2\\xD83\\xD9\"),\n\t          peg$decode(\".\\xDA\\\"\\\"2\\xDA3\\xDB\"),\n\t          peg$decode(\".\\xDC\\\"\\\"2\\xDC3\\xDD\"),\n\t          peg$decode(\".\\xDE\\\"\\\"2\\xDE3\\xDF\"),\n\t          peg$decode(\".\\xE0\\\"\\\"2\\xE03\\xE1\"),\n\t          peg$decode(\".\\xE2\\\"\\\"2\\xE23\\xE3\"),\n\t          peg$decode(\".\\xE4\\\"\\\"2\\xE43\\xE5\"),\n\t          peg$decode(\".\\xE6\\\"\\\"2\\xE63\\xE7\"),\n\t          peg$decode(\".\\xE8\\\"\\\"2\\xE83\\xE9\"),\n\t          peg$decode(\".\\xEA\\\"\\\"2\\xEA3\\xEB\"),\n\t          peg$decode(\"!7\\x85*S \\\"7\\x86*M \\\"7\\x88*G \\\"7\\x89*A \\\"7\\x8A*; \\\"7\\x8B*5 \\\"7\\x8C*/ \\\"7\\x8D*) \\\"7\\x8E*# \\\"76+& 4!6\\xEC! %\"),\n\t          peg$decode(\"!7\\x84+K$7'+A%7\\x91+7%7'+-%7\\x93+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x92+' 4!6\\xED!! %\"),\n\t          peg$decode(\"!7!+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(,G&7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(\\\"+& 4!6\\xEE! %\"),\n\t          peg$decode(\"!7\\xB5+_$ \\\\!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!79+R$!.:\\\"\\\"2:3;+-$79+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xEF\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7:*j \\\"!7\\x97+_$ \\\\!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+& 4!6\\xF0! %\"),\n\t          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\xF1\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x99*# \\\" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!!76+_$ \\\\!7.+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7.+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\"7H+' 4!6\\xF2!! %\"),\n\t          peg$decode(\"7\\x9B*) \\\"7\\x9C*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\xF3\\\"\\\"1!3\\xF4+<$7<+2%7\\x9E+(%4#6\\xF5#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\xF8#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\xF9!! %\"),\n\t          peg$decode(\"!.\\xFA\\\"\\\"2\\xFA3\\xFB+x$!.J\\\"\\\"2J3K+S$7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xFC\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+N$!7<+-$7\\xA0+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xFD\\\"\\\"! %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"76*) \\\"7T*# \\\"7H\"),\n\t          peg$decode(\"!7\\xA2+_$ \\\\!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\xFE\\\"\\\"1&3\\xFF*G \\\"/\\u0100\\\"\\\"1'3\\u0101*; \\\"/\\u0102\\\"\\\"1$3\\u0103*/ \\\"/\\u0104\\\"\\\"1%3\\u0105*# \\\"76+& 4!6\\u0106! %\"),\n\t          peg$decode(\"7\\xA4*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\u0107\\\"\\\"1(3\\u0108+O$7<+E%/\\u0109\\\"\\\"1(3\\u010A*/ \\\"/\\u010B\\\"\\\"1(3\\u010C*# \\\"76+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u010D!! %\"),\n\t          peg$decode(\"!7\\xA8+& 4!6\\u010E! %\"),\n\t          peg$decode(\"!7\\xA9+s$7;+i%7\\xAE+_% \\\\!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xAA*# \\\"7\\xAB\"),\n\t          peg$decode(\"/\\u010F\\\"\\\"1$3\\u0110*S \\\"/\\u0111\\\"\\\"1%3\\u0112*G \\\"/\\u0113\\\"\\\"1%3\\u0114*; \\\"/\\u0115\\\"\\\"1%3\\u0116*/ \\\"/\\u0117\\\"\\\"1+3\\u0118*# \\\"7\\xAC\"),\n\t          peg$decode(\"/\\u0119\\\"\\\"1'3\\u011A*/ \\\"/\\u011B\\\"\\\"1)3\\u011C*# \\\"7\\xAC\"),\n\t          peg$decode(\"76*# \\\"7\\xAD\"),\n\t          peg$decode(\"!/\\u011D\\\"\\\"1\\\"3\\u011E+-$76+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xAC*# \\\"76\"),\n\t          peg$decode(\"!76+7$7<+-%7\\xB0+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"76*# \\\"7H\"),\n\t          peg$decode(\"!7\\xB2+7$7.+-%7\\x8F+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u011F!! %\"),\n\t          peg$decode(\"!7\\x9D+' 4!6\\u0120!! %\"),\n\t          peg$decode(\"!7\\xB5+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0121\\\"!!%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!!77+k$ \\\\!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X,>&!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n\t          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0122\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\u0123\\\"\\\"1#3\\u0124+<$7<+2%76+(%4#6\\u0125#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0126!! %\"),\n\t          peg$decode(\"!7\\x9D+' 4!6\\u0127!! %\"),\n\t          peg$decode(\"! \\\\7\\x99,#&7\\x99\\\"+\\x81$7@+w%7M+m%7?+c% \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4%6\\u0128% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xBD\"),\n\t          peg$decode(\"!/\\u0129\\\"\\\"1&3\\u012A+s$7.+i%7\\xC0+_% \\\\!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\"7\\xBE\"),\n\t          peg$decode(\"!76+s$7.+i%7\\xBF+_% \\\\!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+=$7<+3%76*# \\\"7H+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xC1*G \\\"7\\xC3*A \\\"7\\xC5*; \\\"7\\xC7*5 \\\"7\\xC8*/ \\\"7\\xC9*) \\\"7\\xCA*# \\\"7\\xBF\"),\n\t          peg$decode(\"!/\\u012B\\\"\\\"1%3\\u012C+7$7<+-%7\\xC2+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7I+' 4!6\\u012D!! %\"),\n\t          peg$decode(\"!/\\u012E\\\"\\\"1&3\\u012F+\\xA5$7<+\\x9B%7D+\\x91%7\\xC4+\\x87% \\\\! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X,G&! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X\\\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7t*# \\\"7w\"),\n\t          peg$decode(\"!/\\u0130\\\"\\\"1%3\\u0131+7$7<+-%7\\xC6+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7I+' 4!6\\u0132!! %\"),\n\t          peg$decode(\"!/\\u0133\\\"\\\"1&3\\u0134+<$7<+2%7I+(%4#6\\u0135#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0136\\\"\\\"1%3\\u0137+_$7<+U%!/\\u0138\\\"\\\"1$3\\u0139+& 4!6\\u013A! %*4 \\\"!/\\u013B\\\"\\\"1%3\\u013C+& 4!6\\u013D! %+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u013E\\\"\\\"1)3\\u013F+T$7<+J%/\\u0140\\\"\\\"1#3\\u0141*/ \\\"/\\u0142\\\"\\\"1(3\\u0143*# \\\"76+(%4#6\\u0144#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0145\\\"\\\"1#3\\u0146+\\x9E$7<+\\x94%7D+\\x8A%!7\\xCB+k$ \\\\!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X,>&!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+-%7E+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0147\\\"\\\"1(3\\u0148*/ \\\"/\\u0149\\\"\\\"1$3\\u014A*# \\\"76+' 4!6\\u014B!! %\"),\n\t          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xCE+K$7.+A%7\\xCE+7%7.+-%7\\x8F+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u014C!! %\"),\n\t          peg$decode(\"!7\\xD0+c$ \\\\!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014D\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x98+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014E\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7L*T \\\"7\\x98*N \\\"!7@*# \\\" [+=$7t+3%7?*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014F\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xD3+c$ \\\\!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0150\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x95+& 4!6\\u0151! %\"),\n\t          peg$decode(\"!/\\u0152\\\"\\\"1(3\\u0153+<$7<+2%76+(%4#6\\u0154#! %$## X$\\\"# X\\\"# X*j \\\"!/\\u0155\\\"\\\"1&3\\u0156+<$7<+2%76+(%4#6\\u0157#! %$## X$\\\"# X\\\"# X*: \\\"!/\\u0158\\\"\\\"1*3\\u0159+& 4!6\\u015A! %*# \\\"7\\x9F\"),\n\t          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u015D!! %\"),\n\t          peg$decode(\"!7\\xD7+_$ \\\\!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x98+_$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u015E!! %\"),\n\t          peg$decode(\"!7\\xDA+_$ \\\\!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u015F\\\"\\\"1&3\\u0160*; \\\"/\\u0161\\\"\\\"1'3\\u0162*/ \\\"/\\u0163\\\"\\\"1*3\\u0164*# \\\"76+& 4!6\\u0165! %\"),\n\t          peg$decode(\"!/\\u0166\\\"\\\"1&3\\u0167+<$7<+2%7\\xDC+(%4#6\\u0168#! %$## X$\\\"# X\\\"# X*\\x83 \\\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\u0169#! %$## X$\\\"# X\\\"# X*S \\\"!/\\u016A\\\"\\\"1+3\\u016B+<$7<+2%7\\x9D+(%4#6\\u016C#! %$## X$\\\"# X\\\"# X*# \\\"7\\x9F\"),\n\t          peg$decode(\"/\\u016D\\\"\\\"1+3\\u016E*k \\\"/\\u016F\\\"\\\"1)3\\u0170*_ \\\"/\\u0171\\\"\\\"1(3\\u0172*S \\\"/\\u0173\\\"\\\"1'3\\u0174*G \\\"/\\u0175\\\"\\\"1&3\\u0176*; \\\"/\\u0177\\\"\\\"1*3\\u0178*/ \\\"/\\u0179\\\"\\\"1)3\\u017A*# \\\"76\"),\n\t          peg$decode(\"71*# \\\" [\"),\n\t          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u017B!! %\"),\n\t          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u017C\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n\t          peg$decode(\"!7\\xE2+_$ \\\\!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xE9+s$7.+i%7\\xEC+_% \\\\!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xE4*; \\\"7\\xE5*5 \\\"7\\xE6*/ \\\"7\\xE7*) \\\"7\\xE8*# \\\"7\\x9F\"),\n\t          peg$decode(\"!/\\u017D\\\"\\\"1#3\\u017E+<$7<+2%7\\xEF+(%4#6\\u017F#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0180\\\"\\\"1%3\\u0181+<$7<+2%7T+(%4#6\\u0182#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0183\\\"\\\"1(3\\u0184+B$7<+8%7\\\\*# \\\"7Y+(%4#6\\u0185#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0186\\\"\\\"1&3\\u0187+<$7<+2%76+(%4#6\\u0188#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u0189\\\"\\\"1%3\\u018A+T$!7<+5$ \\\\7!,#&7!\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\u018B\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\xEA+K$7;+A%76+7%7;+-%7\\xEB+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6*# \\\"76+' 4!6\\u018C!! %\"),\n\t          peg$decode(\"!/\\xB4\\\"\\\"1#3\\u018D*G \\\"/\\xB6\\\"\\\"1#3\\u018E*; \\\"/\\xBA\\\"\\\"1#3\\u018F*/ \\\"/\\xB8\\\"\\\"1$3\\u0190*# \\\"76+' 4!6\\u0191!! %\"),\n\t          peg$decode(\"!7\\xED+H$!7C+-$7\\xEE+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\u0192! %\"),\n\t          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\u0193!! %\"),\n\t          peg$decode(\"!!7!+C$7!*# \\\" [+3%7!*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+' 4!6\\u0194!! %\"),\n\t          peg$decode(\"7\\xBD\"),\n\t          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0195\\\"!!%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"7\\xF3*# \\\"7\\x9F\"),\n\t          peg$decode(\"!.\\u0196\\\"\\\"2\\u01963\\u0197+N$7<+D%.\\u0198\\\"\\\"2\\u01983\\u0199*) \\\".\\u019A\\\"\\\"2\\u019A3\\u019B+(%4#6\\u019C#! %$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u019D\\\"!!%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!76+7$70+-%7\\xF6+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\" \\\\72*) \\\"74*# \\\"7.,/&72*) \\\"74*# \\\"7.\\\"\"),\n\t          peg$decode(\" \\\\7%,#&7%\\\"\"),\n\t          peg$decode(\"!7\\xF9+=$.8\\\"\\\"2839+-%7\\xFA+#%'#%$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u019E\\\"\\\"1%3\\u019F*) \\\"/\\u01A0\\\"\\\"1$3\\u01A1+' 4!6\\u01A2!! %\"),\n\t          peg$decode(\"!7\\xFB+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\\\*) \\\"7X*# \\\"7\\x82+' 4!6\\u01A3!! %\"),\n\t          peg$decode(\"! \\\\7\\xFD*) \\\"7-*# \\\"7\\xFE,/&7\\xFD*) \\\"7-*# \\\"7\\xFE\\\"+! (%\"),\n\t          peg$decode(\"7\\\"*S \\\"7!*M \\\".F\\\"\\\"2F3G*A \\\".J\\\"\\\"2J3K*5 \\\".H\\\"\\\"2H3I*) \\\".N\\\"\\\"2N3O\"),\n\t          peg$decode(\".L\\\"\\\"2L3M*\\x95 \\\".B\\\"\\\"2B3C*\\x89 \\\".<\\\"\\\"2<3=*} \\\".R\\\"\\\"2R3S*q \\\".T\\\"\\\"2T3U*e \\\".V\\\"\\\"2V3W*Y \\\".P\\\"\\\"2P3Q*M \\\".@\\\"\\\"2@3A*A \\\".D\\\"\\\"2D3E*5 \\\".2\\\"\\\"2233*) \\\".>\\\"\\\"2>3?\"),\n\t          peg$decode(\"!7\\u0100+h$.8\\\"\\\"2839+X%7\\xFA+N%!.\\u01A4\\\"\\\"2\\u01A43\\u01A5+-$7\\xEB+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!/\\u01A6\\\"\\\"1%3\\u01A7*) \\\"/\\u01A8\\\"\\\"1$3\\u01A9+' 4!6\\u01A2!! %\"),\n\t          peg$decode(\"!7\\xEB+Q$/\\xB4\\\"\\\"1#3\\xB5*7 \\\"/\\xB6\\\"\\\"1#3\\xB7*+ \\\" \\\\7+,#&7+\\\"+'%4\\\"6\\u01AA\\\" %$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\u0104+\\x8F$.F\\\"\\\"2F3G+%7\\u0103+u%.F\\\"\\\"2F3G+e%7\\u0103+[%.F\\\"\\\"2F3G+K%7\\u0103+A%.F\\\"\\\"2F3G+1%7\\u0105+'%4)6\\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\u0103+-$7\\u0103+#%'\\\"%$\\\"# X\\\"# X\"),\n\t          peg$decode(\"!7\\u0103+7$7\\u0103+-%7\\u0103+#%'#%$## X$\\\"# X\\\"# X\")\n\t        ],\n\t\n\t        peg$currPos          = 0,\n\t        peg$reportedPos      = 0,\n\t        peg$cachedPos        = 0,\n\t        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n\t        peg$maxFailPos       = 0,\n\t        peg$maxFailExpected  = [],\n\t        peg$silentFails      = 0,\n\t\n\t        peg$result;\n\t\n\t    if (\"startRule\" in options) {\n\t      if (!(options.startRule in peg$startRuleIndices)) {\n\t        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n\t      }\n\t\n\t      peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n\t    }\n\t\n\t    function text() {\n\t      return input.substring(peg$reportedPos, peg$currPos);\n\t    }\n\t\n\t    function offset() {\n\t      return peg$reportedPos;\n\t    }\n\t\n\t    function line() {\n\t      return peg$computePosDetails(peg$reportedPos).line;\n\t    }\n\t\n\t    function column() {\n\t      return peg$computePosDetails(peg$reportedPos).column;\n\t    }\n\t\n\t    function expected(description) {\n\t      throw peg$buildException(\n\t        null,\n\t        [{ type: \"other\", description: description }],\n\t        peg$reportedPos\n\t      );\n\t    }\n\t\n\t    function error(message) {\n\t      throw peg$buildException(message, null, peg$reportedPos);\n\t    }\n\t\n\t    function peg$computePosDetails(pos) {\n\t      function advance(details, startPos, endPos) {\n\t        var p, ch;\n\t\n\t        for (p = startPos; p < endPos; p++) {\n\t          ch = input.charAt(p);\n\t          if (ch === \"\\n\") {\n\t            if (!details.seenCR) { details.line++; }\n\t            details.column = 1;\n\t            details.seenCR = false;\n\t          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n\t            details.line++;\n\t            details.column = 1;\n\t            details.seenCR = true;\n\t          } else {\n\t            details.column++;\n\t            details.seenCR = false;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (peg$cachedPos !== pos) {\n\t        if (peg$cachedPos > pos) {\n\t          peg$cachedPos = 0;\n\t          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n\t        }\n\t        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n\t        peg$cachedPos = pos;\n\t      }\n\t\n\t      return peg$cachedPosDetails;\n\t    }\n\t\n\t    function peg$fail(expected) {\n\t      if (peg$currPos < peg$maxFailPos) { return; }\n\t\n\t      if (peg$currPos > peg$maxFailPos) {\n\t        peg$maxFailPos = peg$currPos;\n\t        peg$maxFailExpected = [];\n\t      }\n\t\n\t      peg$maxFailExpected.push(expected);\n\t    }\n\t\n\t    function peg$buildException(message, expected, pos) {\n\t      function cleanupExpected(expected) {\n\t        var i = 1;\n\t\n\t        expected.sort(function(a, b) {\n\t          if (a.description < b.description) {\n\t            return -1;\n\t          } else if (a.description > b.description) {\n\t            return 1;\n\t          } else {\n\t            return 0;\n\t          }\n\t        });\n\t\n\t        while (i < expected.length) {\n\t          if (expected[i - 1] === expected[i]) {\n\t            expected.splice(i, 1);\n\t          } else {\n\t            i++;\n\t          }\n\t        }\n\t      }\n\t\n\t      function buildMessage(expected, found) {\n\t        function stringEscape(s) {\n\t          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\t\n\t          return s\n\t            .replace(/\\\\/g,   '\\\\\\\\')\n\t            .replace(/\"/g,    '\\\\\"')\n\t            .replace(/\\x08/g, '\\\\b')\n\t            .replace(/\\t/g,   '\\\\t')\n\t            .replace(/\\n/g,   '\\\\n')\n\t            .replace(/\\f/g,   '\\\\f')\n\t            .replace(/\\r/g,   '\\\\r')\n\t            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n\t            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n\t            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n\t            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n\t        }\n\t\n\t        var expectedDescs = new Array(expected.length),\n\t            expectedDesc, foundDesc, i;\n\t\n\t        for (i = 0; i < expected.length; i++) {\n\t          expectedDescs[i] = expected[i].description;\n\t        }\n\t\n\t        expectedDesc = expected.length > 1\n\t          ? expectedDescs.slice(0, -1).join(\", \")\n\t              + \" or \"\n\t              + expectedDescs[expected.length - 1]\n\t          : expectedDescs[0];\n\t\n\t        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\t\n\t        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n\t      }\n\t\n\t      var posDetails = peg$computePosDetails(pos),\n\t          found      = pos < input.length ? input.charAt(pos) : null;\n\t\n\t      if (expected !== null) {\n\t        cleanupExpected(expected);\n\t      }\n\t\n\t      return new SyntaxError(\n\t        message !== null ? message : buildMessage(expected, found),\n\t        expected,\n\t        found,\n\t        pos,\n\t        posDetails.line,\n\t        posDetails.column\n\t      );\n\t    }\n\t\n\t    function peg$decode(s) {\n\t      var bc = new Array(s.length), i;\n\t\n\t      for (i = 0; i < s.length; i++) {\n\t        bc[i] = s.charCodeAt(i) - 32;\n\t      }\n\t\n\t      return bc;\n\t    }\n\t\n\t    function peg$parseRule(index) {\n\t      var bc    = peg$bytecode[index],\n\t          ip    = 0,\n\t          ips   = [],\n\t          end   = bc.length,\n\t          ends  = [],\n\t          stack = [],\n\t          params, i;\n\t\n\t      function protect(object) {\n\t        return Object.prototype.toString.apply(object) === \"[object Array]\" ? [] : object;\n\t      }\n\t\n\t      while (true) {\n\t        while (ip < end) {\n\t          switch (bc[ip]) {\n\t            case 0:\n\t              stack.push(protect(peg$consts[bc[ip + 1]]));\n\t              ip += 2;\n\t              break;\n\t\n\t            case 1:\n\t              stack.push(peg$currPos);\n\t              ip++;\n\t              break;\n\t\n\t            case 2:\n\t              stack.pop();\n\t              ip++;\n\t              break;\n\t\n\t            case 3:\n\t              peg$currPos = stack.pop();\n\t              ip++;\n\t              break;\n\t\n\t            case 4:\n\t              stack.length -= bc[ip + 1];\n\t              ip += 2;\n\t              break;\n\t\n\t            case 5:\n\t              stack.splice(-2, 1);\n\t              ip++;\n\t              break;\n\t\n\t            case 6:\n\t              stack[stack.length - 2].push(stack.pop());\n\t              ip++;\n\t              break;\n\t\n\t            case 7:\n\t              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n\t              ip += 2;\n\t              break;\n\t\n\t            case 8:\n\t              stack.pop();\n\t              stack.push(input.substring(stack[stack.length - 1], peg$currPos));\n\t              ip++;\n\t              break;\n\t\n\t            case 9:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (stack[stack.length - 1]) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 10:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (stack[stack.length - 1] === peg$FAILED) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 11:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (stack[stack.length - 1] !== peg$FAILED) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 12:\n\t              if (stack[stack.length - 1] !== peg$FAILED) {\n\t                ends.push(end);\n\t                ips.push(ip);\n\t\n\t                end = ip + 2 + bc[ip + 1];\n\t                ip += 2;\n\t              } else {\n\t                ip += 2 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 13:\n\t              ends.push(end);\n\t              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\t\n\t              if (input.length > peg$currPos) {\n\t                end = ip + 3 + bc[ip + 1];\n\t                ip += 3;\n\t              } else {\n\t                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n\t                ip += 3 + bc[ip + 1];\n\t              }\n\t\n\t              break;\n\t\n\t            case 14:\n\t              ends.push(end);\n\t              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\t\n\t              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n\t                end = ip + 4 + bc[ip + 2];\n\t                ip += 4;\n\t              } else {\n\t                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n\t                ip += 4 + bc[ip + 2];\n\t              }\n\t\n\t              break;\n\t\n\t            case 15:\n\t              ends.push(end);\n\t              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\t\n\t              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n\t                end = ip + 4 + bc[ip + 2];\n\t                ip += 4;\n\t              } else {\n\t                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n\t                ip += 4 + bc[ip + 2];\n\t              }\n\t\n\t              break;\n\t\n\t            case 16:\n\t              ends.push(end);\n\t              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\t\n\t              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n\t                end = ip + 4 + bc[ip + 2];\n\t                ip += 4;\n\t              } else {\n\t                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n\t                ip += 4 + bc[ip + 2];\n\t              }\n\t\n\t              break;\n\t\n\t            case 17:\n\t              stack.push(input.substr(peg$currPos, bc[ip + 1]));\n\t              peg$currPos += bc[ip + 1];\n\t              ip += 2;\n\t              break;\n\t\n\t            case 18:\n\t              stack.push(peg$consts[bc[ip + 1]]);\n\t              peg$currPos += peg$consts[bc[ip + 1]].length;\n\t              ip += 2;\n\t              break;\n\t\n\t            case 19:\n\t              stack.push(peg$FAILED);\n\t              if (peg$silentFails === 0) {\n\t                peg$fail(peg$consts[bc[ip + 1]]);\n\t              }\n\t              ip += 2;\n\t              break;\n\t\n\t            case 20:\n\t              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];\n\t              ip += 2;\n\t              break;\n\t\n\t            case 21:\n\t              peg$reportedPos = peg$currPos;\n\t              ip++;\n\t              break;\n\t\n\t            case 22:\n\t              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n\t              for (i = 0; i < bc[ip + 3]; i++) {\n\t                params[i] = stack[stack.length - 1 - params[i]];\n\t              }\n\t\n\t              stack.splice(\n\t                stack.length - bc[ip + 2],\n\t                bc[ip + 2],\n\t                peg$consts[bc[ip + 1]].apply(null, params)\n\t              );\n\t\n\t              ip += 4 + bc[ip + 3];\n\t              break;\n\t\n\t            case 23:\n\t              stack.push(peg$parseRule(bc[ip + 1]));\n\t              ip += 2;\n\t              break;\n\t\n\t            case 24:\n\t              peg$silentFails++;\n\t              ip++;\n\t              break;\n\t\n\t            case 25:\n\t              peg$silentFails--;\n\t              ip++;\n\t              break;\n\t\n\t            default:\n\t              throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n\t          }\n\t        }\n\t\n\t        if (ends.length > 0) {\n\t          end = ends.pop();\n\t          ip = ips.pop();\n\t        } else {\n\t          break;\n\t        }\n\t      }\n\t\n\t      return stack[0];\n\t    }\n\t\n\t\n\t      options.data = {}; // Object to which header attributes will be assigned during parsing\n\t\n\t      function list (first, rest) {\n\t        return [first].concat(rest);\n\t      }\n\t\n\t\n\t    peg$result = peg$parseRule(peg$startRuleIndex);\n\t\n\t    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n\t      return peg$result;\n\t    } else {\n\t      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n\t        peg$fail({ type: \"end\", description: \"end of input\" });\n\t      }\n\t\n\t      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n\t    }\n\t  }\n\t\n\t  return {\n\t    SyntaxError: SyntaxError,\n\t    parse:       parse\n\t  };\n\t})();\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\tvar toplevel = global.window || global;\n\t\n\tfunction getPrefixedProperty (object, name) {\n\t  if (object == null) {\n\t    return;\n\t  }\n\t  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n\t  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n\t  for (var i in prefixedNames) {\n\t    var property = object[prefixedNames[i]];\n\t    if (property) {\n\t      return property.bind(object);\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = {\n\t  WebSocket: toplevel.WebSocket,\n\t  Transport: __webpack_require__(50),\n\t  open: toplevel.open,\n\t  Promise: toplevel.Promise,\n\t  timers: toplevel,\n\t\n\t  // Console is not defined in ECMAScript, so just in case...\n\t  console: toplevel.console || {\n\t    debug: function () {},\n\t    log: function () {},\n\t    warn: function () {},\n\t    error: function () {}\n\t  },\n\t\n\t  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),\n\t  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),\n\t  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),\n\t  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),\n\t\n\t  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),\n\t  HTMLMediaElement: toplevel.HTMLMediaElement,\n\t\n\t  attachMediaStream: toplevel.attachMediaStream,\n\t  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,\n\t  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @fileoverview Transport\n\t */\n\t\n\t/**\n\t * @augments SIP\n\t * @class Transport\n\t * @param {SIP.UA} ua\n\t * @param {Object} server ws_server Object\n\t */\n\tmodule.exports = function (SIP, WebSocket) {\n\tvar Transport,\n\t  C = {\n\t    // Transport status codes\n\t    STATUS_READY:        0,\n\t    STATUS_DISCONNECTED: 1,\n\t    STATUS_ERROR:        2\n\t  };\n\t\n\t/**\n\t * Compute an amount of time in seconds to wait before sending another\n\t * keep-alive.\n\t * @returns {Number}\n\t */\n\tfunction computeKeepAliveTimeout(upperBound) {\n\t  var lowerBound = upperBound * 0.8;\n\t  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n\t}\n\t\n\tTransport = function(ua, server) {\n\t\n\t  this.logger = ua.getLogger('sip.transport');\n\t  this.ua = ua;\n\t  this.ws = null;\n\t  this.server = server;\n\t  this.reconnection_attempts = 0;\n\t  this.closed = false;\n\t  this.connected = false;\n\t  this.reconnectTimer = null;\n\t  this.lastTransportError = {};\n\t\n\t  this.keepAliveInterval = ua.configuration.keepAliveInterval;\n\t  this.keepAliveTimeout = null;\n\t  this.keepAliveTimer = null;\n\t\n\t  this.ua.transport = this;\n\t\n\t  // Connect\n\t  this.connect();\n\t};\n\t\n\tTransport.prototype = {\n\t  /**\n\t   * Send a message.\n\t   * @param {SIP.OutgoingRequest|String} msg\n\t   * @returns {Boolean}\n\t   */\n\t  send: function(msg) {\n\t    var message = msg.toString();\n\t\n\t    if(this.ws && this.ws.readyState === WebSocket.OPEN) {\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n\t      }\n\t      this.ws.send(message);\n\t      return true;\n\t    } else {\n\t      this.logger.warn('unable to send message, WebSocket is not open');\n\t      return false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Send a keep-alive (a double-CRLF sequence).\n\t   * @private\n\t   * @returns {Boolean}\n\t   */\n\t  sendKeepAlive: function() {\n\t    if(this.keepAliveTimeout) { return; }\n\t\n\t    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {\n\t      this.ua.emit('keepAliveTimeout');\n\t    }.bind(this), 10000);\n\t\n\t    return this.send('\\r\\n\\r\\n');\n\t  },\n\t\n\t  /**\n\t   * Start sending keep-alives.\n\t   * @private\n\t   */\n\t  startSendingKeepAlives: function() {\n\t    if (this.keepAliveInterval && !this.keepAliveTimer) {\n\t      this.keepAliveTimer = SIP.Timers.setTimeout(function() {\n\t        this.sendKeepAlive();\n\t        this.keepAliveTimer = null;\n\t        this.startSendingKeepAlives();\n\t      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Stop sending keep-alives.\n\t   * @private\n\t   */\n\t  stopSendingKeepAlives: function() {\n\t    SIP.Timers.clearTimeout(this.keepAliveTimer);\n\t    SIP.Timers.clearTimeout(this.keepAliveTimeout);\n\t    this.keepAliveTimer = null;\n\t    this.keepAliveTimeout = null;\n\t  },\n\t\n\t  /**\n\t  * Disconnect socket.\n\t  */\n\t  disconnect: function() {\n\t    if(this.ws) {\n\t      // Clear reconnectTimer\n\t      SIP.Timers.clearTimeout(this.reconnectTimer);\n\t\n\t      this.stopSendingKeepAlives();\n\t\n\t      this.closed = true;\n\t      this.logger.log('closing WebSocket ' + this.server.ws_uri);\n\t      this.ws.close();\n\t    }\n\t\n\t    if (this.reconnectTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.reconnectTimer);\n\t      this.reconnectTimer = null;\n\t      this.ua.emit('disconnected', {\n\t        transport: this,\n\t        code: this.lastTransportError.code,\n\t        reason: this.lastTransportError.reason\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t  * Connect socket.\n\t  */\n\t  connect: function() {\n\t    var transport = this;\n\t\n\t    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n\t      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');\n\t      return false;\n\t    }\n\t\n\t    if(this.ws) {\n\t      this.ws.close();\n\t    }\n\t\n\t    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n\t    this.ua.onTransportConnecting(this,\n\t      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);\n\t\n\t    try {\n\t      this.ws = new WebSocket(this.server.ws_uri, 'sip');\n\t    } catch(e) {\n\t      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);\n\t    }\n\t\n\t    this.ws.binaryType = 'arraybuffer';\n\t\n\t    this.ws.onopen = function() {\n\t      transport.onOpen();\n\t    };\n\t\n\t    this.ws.onclose = function(e) {\n\t      transport.onClose(e);\n\t    };\n\t\n\t    this.ws.onmessage = function(e) {\n\t      transport.onMessage(e);\n\t    };\n\t\n\t    this.ws.onerror = function(e) {\n\t      transport.onError(e);\n\t    };\n\t  },\n\t\n\t  // Transport Event Handlers\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onOpen: function() {\n\t    this.connected = true;\n\t\n\t    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');\n\t    // Clear reconnectTimer since we are not disconnected\n\t    if (this.reconnectTimer !== null) {\n\t      SIP.Timers.clearTimeout(this.reconnectTimer);\n\t      this.reconnectTimer = null;\n\t    }\n\t    // Reset reconnection_attempts\n\t    this.reconnection_attempts = 0;\n\t    // Disable closed\n\t    this.closed = false;\n\t    // Trigger onTransportConnected callback\n\t    this.ua.onTransportConnected(this);\n\t    // Start sending keep-alives\n\t    this.startSendingKeepAlives();\n\t  },\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onClose: function(e) {\n\t    var connected_before = this.connected;\n\t\n\t    this.lastTransportError.code = e.code;\n\t    this.lastTransportError.reason = e.reason;\n\t\n\t    this.stopSendingKeepAlives();\n\t\n\t    if (this.reconnection_attempts > 0) {\n\t      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n\t      this.reconnect();\n\t    } else {\n\t      this.connected = false;\n\t      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n\t\n\t      if(e.wasClean === false) {\n\t        this.logger.warn('WebSocket abrupt disconnection');\n\t      }\n\t      // Transport was connected\n\t      if(connected_before === true) {\n\t        this.ua.onTransportClosed(this);\n\t        // Check whether the user requested to close.\n\t        if(!this.closed) {\n\t          this.reconnect();\n\t        } else {\n\t          this.ua.emit('disconnected', {\n\t            transport: this,\n\t            code: this.lastTransportError.code,\n\t            reason: this.lastTransportError.reason\n\t          });\n\t\n\t        }\n\t      } else {\n\t        // This is the first connection attempt\n\t        //Network error\n\t        this.ua.onTransportError(this);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onMessage: function(e) {\n\t    var message, transaction,\n\t      data = e.data;\n\t\n\t    // CRLF Keep Alive response from server. Ignore it.\n\t    if(data === '\\r\\n') {\n\t      SIP.Timers.clearTimeout(this.keepAliveTimeout);\n\t      this.keepAliveTimeout = null;\n\t\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('received WebSocket message with CRLF Keep Alive response');\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    // WebSocket binary message.\n\t    else if (typeof data !== 'string') {\n\t      try {\n\t        data = String.fromCharCode.apply(null, new Uint8Array(data));\n\t      } catch(evt) {\n\t        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n\t        return;\n\t      }\n\t\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n\t      }\n\t    }\n\t\n\t    // WebSocket text message.\n\t    else {\n\t      if (this.ua.configuration.traceSip === true) {\n\t        this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n\t      }\n\t    }\n\t\n\t    message = SIP.Parser.parseMessage(data, this.ua);\n\t\n\t    if (!message) {\n\t      return;\n\t    }\n\t\n\t    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n\t      return;\n\t    }\n\t\n\t    // Do some sanity check\n\t    if(SIP.sanityCheck(message, this.ua, this)) {\n\t      if(message instanceof SIP.IncomingRequest) {\n\t        message.transport = this;\n\t        this.ua.receiveRequest(message);\n\t      } else if(message instanceof SIP.IncomingResponse) {\n\t        /* Unike stated in 18.1.2, if a response does not match\n\t        * any transaction, it is discarded here and no passed to the core\n\t        * in order to be discarded there.\n\t        */\n\t        switch(message.method) {\n\t          case SIP.C.INVITE:\n\t            transaction = this.ua.transactions.ict[message.via_branch];\n\t            if(transaction) {\n\t              transaction.receiveResponse(message);\n\t            }\n\t            break;\n\t          case SIP.C.ACK:\n\t            // Just in case ;-)\n\t            break;\n\t          default:\n\t            transaction = this.ua.transactions.nict[message.via_branch];\n\t            if(transaction) {\n\t              transaction.receiveResponse(message);\n\t            }\n\t            break;\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @event\n\t  * @param {event} e\n\t  */\n\t  onError: function(e) {\n\t    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));\n\t  },\n\t\n\t  /**\n\t  * Reconnection attempt logic.\n\t  * @private\n\t  */\n\t  reconnect: function() {\n\t    var transport = this;\n\t\n\t    this.reconnection_attempts += 1;\n\t\n\t    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {\n\t      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n\t      this.ua.onTransportError(this);\n\t    } else if (this.reconnection_attempts === 1) {\n\t      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');\n\t      transport.connect();\n\t    } else {\n\t      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');\n\t\n\t      this.reconnectTimer = SIP.Timers.setTimeout(function() {\n\t        transport.connect();\n\t        transport.reconnectTimer = null;\n\t      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);\n\t    }\n\t  }\n\t};\n\t\n\tTransport.C = C;\n\treturn Transport;\n\t};\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar LoginService = function (sdk) {\n\t    var onLoginHandler = [];\n\t    return {\n\t        login: function login(username, extension, password) {\n\t            return _rcSdk.RC.sdk.platform().login({\n\t                'username': username,\n\t                'extension': extension,\n\t                'password': password\n\t            });\n\t        },\n\t        logout: function logout() {\n\t            return _rcSdk.RC.sdk.platform().logout();\n\t        },\n\t        checkLoginStatus: function checkLoginStatus() {\n\t            return _rcSdk.RC.sdk.platform().loggedIn().then(function (isLoggedIn) {\n\t                if (isLoggedIn) {\n\t                    onLoginHandler.forEach(function (handler) {\n\t                        return handler();\n\t                    });\n\t                }\n\t                return isLoggedIn;\n\t            });\n\t        },\n\t        oauth: function oauth() {\n\t            return new Promise(function (resolve, reject) {\n\t                var redirectUri = 'https://ringcentral.github.io/ringcentral-js-widget/page/redirect.html';\n\t                var url = _rcSdk.RC.sdk.platform().authUrl({\n\t                    redirectUri: redirectUri\n\t                });\n\t                var oauthWindow = window.open(url, 'rc-iframe-2', 'width=400, height=600');\n\t                var interval = setInterval(check, 500);\n\t                function check() {\n\t                    if (!oauthWindow) {\n\t                        return;\n\t                    }\n\t                    if (oauthWindow.closed) {\n\t                        reject(new Error(''));\n\t                        window.removeEventListener('message', oauthChannel);\n\t                        clearInterval(interval);\n\t                    }\n\t                }\n\t                window.addEventListener('message', oauthChannel);\n\t                function oauthChannel(e) {\n\t                    if (e.data.type === 'oauth') {\n\t                        var qs = _rcSdk.RC.sdk.platform().parseAuthRedirectUrl(e.data.value);\n\t                        qs.redirectUri = redirectUri;\n\t                        window.removeEventListener('message', oauthChannel);\n\t                        clearInterval(interval);\n\t                        resolve(_rcSdk.RC.sdk.platform().login(qs));\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    };\n\t}();\n\texports.default = LoginService;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _rcSubscriptionService = __webpack_require__(53);\n\t\n\tvar _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar CallLogService = function (sdk) {\n\t    var period = 7 * 24 * 3600 * 1000;\n\t    var dateFrom = new Date(Date.now() - period);\n\t    return {\n\t        getCallLogs: function getCallLogs() {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', { dateFrom: dateFrom.toISOString() }).then(function (response) {\n\t                return response.json().records;\n\t            });\n\t        },\n\t        getCallLogsByNumber: function getCallLogsByNumber(phoneNumber, hourFrom, hourTo) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', {\n\t                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n\t                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n\t                phoneNumber: phoneNumber\n\t            }).then(function (response) {\n\t                return response.json();\n\t            }).then(function (data) {\n\t                return data.records;\n\t            }).then(function (records) {\n\t                return records.reverse();\n\t            });\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = CallLogService;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar rcSubscription = function () {\n\t    var _init = false;\n\t    var cacheKey = 'ringcentral-subscription';\n\t    var subscription;\n\t    var handlers = {};\n\t    function init() {\n\t        _init = true;\n\t        subscription = _rcSdk.RC.sdk.createCachedSubscription(cacheKey).restore();\n\t        subscription.on(subscription.events.notification, function (msg) {\n\t            for (var key in handlers) {\n\t                if (handlers.hasOwnProperty(key)) {\n\t                    if (msg.event.indexOf(key) > -1) {\n\t                        handlers[key].forEach(function (h) {\n\t                            try {\n\t                                h(msg);\n\t                            } catch (e) {\n\t                                console.error('Error occurs when invoking subscription notification handler for \"' + msg.event + '\": ' + e);\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    return {\n\t        subscribe: function subscribe(suffix, event, handler) {\n\t            if (!_init) init();\n\t            if (event && suffix) {\n\t                if (!handlers[suffix]) {\n\t                    handlers[suffix] = [];\n\t                }\n\t                handlers[suffix].push(handler);\n\t                subscription.addEventFilters(event).register();\n\t            }\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcSubscription;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar accountService = function (RC) {\n\t    var info;\n\t    var numbers;\n\t    var fetchNumbers = null;\n\t\n\t    function getNumbersByType(numbers, type) {\n\t        if (!numbers) return Error('Need to fetch numbers first using accountService.getPhoneNumber');\n\t        return numbers.filter(function (number) {\n\t            return number.type === type;\n\t        });\n\t    }\n\t\n\t    function getNumbersByFeatures(numbers, features) {\n\t        if (!Array.isArray(features)) features = [features];\n\t        // if has duplicate features\n\t        return numbers.filter(function (number) {\n\t            return features.filter(function (f) {\n\t                return number.features.indexOf(f) > -1;\n\t            }).length > 0;\n\t        });\n\t    }\n\t\n\t    return {\n\t        getAccountInfo: function getAccountInfo() {\n\t            return RC.sdk.platform().get('/account/~/extension/~').then(function (response) {\n\t                info = response.json();\n\t                return info;\n\t            }).catch(function (e) {\n\t                return console.error('Recent Calls Error: ' + e.message);\n\t            });\n\t        },\n\t\n\t        getPhoneNumber: function getPhoneNumber() {\n\t            fetchNumbers = RC.sdk.platform().get('/account/~/extension/~/phone-number').then(function (response) {\n\t                var data = response.json();\n\t                numbers = data.records;\n\t                fetchNumbers = null;\n\t                return data.records;\n\t            }).catch(function (e) {\n\t                return console.error('Recent Calls Error: ' + e.message);\n\t            });\n\t            return fetchNumbers;\n\t        },\n\t\n\t        hasServiceFeature: function hasServiceFeature(name) {\n\t            if (!info) return Error('Need to fetch account info by accountService.getAccountInfo');\n\t            return info.serviceFeatures.filter(function (feature) {\n\t                return feature.featureName.toLowerCase() === name.toLowerCase();\n\t            }).length > 0;\n\t        },\n\t\n\t        listNumber: function listNumber(type) {\n\t            var features = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t            if (fetchNumbers) {\n\t                return fetchNumbers.then(function () {\n\t                    return getNumbersByFeatures(getNumbersByType(numbers, type), features).map(function (number) {\n\t                        return number.phoneNumber;\n\t                    });\n\t                });\n\t            } else {\n\t                return getNumbersByFeatures(getNumbersByType(numbers, type), features).sort(function (number1, number2) {\n\t                    if (number2.usageType === 'DirectNumber') return 1;\n\t                    return -1;\n\t                }).map(function (number) {\n\t                    return number.phoneNumber;\n\t                });\n\t            }\n\t        }\n\t    };\n\t}(_rcSdk.RC);\n\t\n\texports.default = accountService;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _lzString = __webpack_require__(56);\n\t\n\tvar _lzString2 = _interopRequireDefault(_lzString);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcContactService = function () {\n\t    var companyContacts = [];\n\t    var completeCompanyContacts = null;\n\t\n\t    var fetchingCompanyContacts = null;\n\t    var fetchingCompleteCompanyContacts = null;\n\t\n\t    function Contact() {\n\t        this.firstName = null;\n\t        this.lastName = null;\n\t        this.displayName = null;\n\t        this.extension = null;\n\t        this.email = null;\n\t        this.type = null;\n\t        this.id = null;\n\t        this.phoneNumber = [];\n\t    }\n\t\n\t    function createContact(extension) {\n\t        var contact = new Contact();\n\t        contact.extension = extension.extensionNumber;\n\t        contact.firstName = extension.contact.firstName;\n\t        contact.lastName = extension.contact.lastName;\n\t        contact.displayName = contact.firstName + ' ' + contact.lastName;\n\t        contact.email = extension.contact.email;\n\t        contact.type = 'rc';\n\t        contact.id = extension.id;\n\t        contact.profileImage = extension.profileImage.uri;\n\t        return contact;\n\t    }\n\t\n\t    function addToCompanyContact(response) {\n\t        var records = response.json().records.filter(function (extension) {\n\t            return extension.status === 'Enabled' && ['DigitalUser', 'User'].indexOf(extension.type) >= 0;\n\t        }).map(function (extension) {\n\t            return createContact(extension);\n\t        });\n\t        companyContacts.push.apply(companyContacts, records);\n\t    }\n\t\n\t    function fetchCompanyContactByPage(page) {\n\t        return _rcSdk.RC.sdk.platform().get('/account/~/extension/', { perPage: 250, page: page });\n\t    }\n\t\n\t    function fetchCompanyDirectNumbersByPage(page) {\n\t        return _rcSdk.RC.sdk.platform().get('/account/~/phone-number', { perPage: 250, page: page });\n\t    }\n\t\n\t    function fetchCompanyContacts() {\n\t        var page = 1;\n\t        fetchingCompanyContacts = fetchCompanyContactByPage(page).then(function (response) {\n\t            var respObj = response.json();\n\t            if (respObj.paging && respObj.paging.totalPages > page) {\n\t                var promises = [];\n\t                while (respObj.paging.totalPages > page) {\n\t                    page++;\n\t                    promises.push(fetchCompanyContactByPage(page));\n\t                }\n\t\n\t                return Promise.all(promises).then(function (responses) {\n\t                    responses.forEach(function (response) {\n\t                        addToCompanyContact(response);\n\t                    });\n\t                    fetchingCompanyContacts = null;\n\t                    return companyContacts;\n\t                });\n\t            } else {\n\t                addToCompanyContact(response);\n\t                return companyContacts;\n\t            }\n\t        }).catch(function (e) {\n\t            console.error(e);\n\t        });\n\t        return fetchingCompanyContacts;\n\t    }\n\t\n\t    function fetchCompanyDirectNumbers() {\n\t        var page = 1;\n\t        return fetchCompanyDirectNumbersByPage(page).then(function (response) {\n\t            var respObj = response.json();\n\t            if (respObj.paging && respObj.paging.totalPages > page) {\n\t                var promises = [];\n\t                while (respObj.paging.totalPages > page) {\n\t                    page++;\n\t                    promises.push(fetchCompanyDirectNumbersByPage(page));\n\t                }\n\t\n\t                return Promise.all(promises).then(function (responses) {\n\t                    var numbers = {};\n\t                    responses.forEach(function (response) {\n\t                        var resp = response.json();\n\t                        resp.records.forEach(function (el) {\n\t                            if (el.extension && el.extension.extensionNumber) {\n\t                                if (!numbers[el.extension.extensionNumber]) {\n\t                                    numbers[el.extension.extensionNumber] = [];\n\t                                }\n\t\n\t                                numbers[el.extension.extensionNumber].push(el);\n\t                            }\n\t                        });\n\t                    });\n\t                    companyContacts.forEach(function (contact) {\n\t                        var phones = numbers[contact.extension];\n\t                        if (phones) {\n\t                            phones.forEach(function (phone) {\n\t                                contact.phoneNumber.push(phone.phoneNumber);\n\t                            });\n\t                        }\n\t                    });\n\t                });\n\t            }\n\t        });\n\t    }\n\t\n\t    return {\n\t        get companyContacts() {\n\t            return companyContacts;\n\t        },\n\t        accessToken: function accessToken() {\n\t            return _rcSdk.RC.sdk.platform().auth().accessToken();\n\t        },\n\t        asyncGetCompanyContact: function asyncGetCompanyContact() {\n\t            if (fetchingCompanyContacts) {\n\t                return fetchingCompanyContacts;\n\t            } else {\n\t                return Promise.resolve(companyContacts);\n\t            }\n\t        },\n\t        syncCompanyContact: function syncCompanyContact() {\n\t            companyContacts.length = 0;\n\t            fetchCompanyContacts();\n\t            fetchCompanyDirectNumbers();\n\t        },\n\t        completeCompanyContact: function completeCompanyContact() {\n\t            if (completeCompanyContacts) return Promise.resolve(completeCompanyContacts);\n\t            if (fetchingCompleteCompanyContacts) return fetchingCompleteCompanyContacts;\n\t            fetchingCompleteCompanyContacts = fetchCompanyContacts().then(fetchCompanyDirectNumbers);\n\t            return fetchingCompleteCompanyContacts.then(function () {\n\t                completeCompanyContacts = companyContacts;\n\t                fetchingCompleteCompanyContacts = null;\n\t                return companyContacts;\n\t            });\n\t        },\n\t        cacheContacts: function () {\n\t            var contact = null;\n\t            var data = localStorage.getItem('rc-contacts');\n\t            return function () {\n\t                if (contact) {\n\t                    contact.then(function (value) {\n\t                        completeCompanyContacts = companyContacts = value;\n\t                    });\n\t                    return contact;\n\t                }\n\t                // For test\n\t                if (window.location.href.indexOf('127.0.0.11') === -1) {\n\t                    var fetch = new Promise(function (resolve, reject) {\n\t                        // Hack for delay the refreshing request\n\t                        setTimeout(function () {\n\t                            rcContactService.completeCompanyContact().then(function (data) {\n\t                                if (data) {\n\t                                    completeCompanyContacts = companyContacts = data;\n\t                                    localStorage.setItem('rc-contacts', _lzString2.default.compressToUTF16(JSON.stringify(data)));\n\t                                }\n\t                                return resolve(data);\n\t                            });\n\t                        }, 100);\n\t                    });\n\t                } else {\n\t                    var fetch;\n\t                }\n\t                if (data) {\n\t                    var fetchedContact = JSON.parse(_lzString2.default.decompressFromUTF16(data));\n\t                    completeCompanyContacts = companyContacts = fetchedContact;\n\t                    contact = Promise.resolve(fetchedContact);\n\t                } else {\n\t                    contact = fetch;\n\t                }\n\t                return contact;\n\t            };\n\t        }()\n\t    };\n\t}();\n\t\n\texports.default = rcContactService;\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n\t// This work is free. You can redistribute it and/or modify it\n\t// under the terms of the WTFPL, Version 2\n\t// For more information see LICENSE.txt or http://www.wtfpl.net/\n\t//\n\t// For more information, the home page:\n\t// http://pieroxy.net/blog/pages/lz-string/testing.html\n\t//\n\t// LZ-based compression algorithm, version 1.4.4\n\tvar LZString = (function() {\n\t\n\t// private property\n\tvar f = String.fromCharCode;\n\tvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\tvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n\tvar baseReverseDic = {};\n\t\n\tfunction getBaseValue(alphabet, character) {\n\t  if (!baseReverseDic[alphabet]) {\n\t    baseReverseDic[alphabet] = {};\n\t    for (var i=0 ; i<alphabet.length ; i++) {\n\t      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n\t    }\n\t  }\n\t  return baseReverseDic[alphabet][character];\n\t}\n\t\n\tvar LZString = {\n\t  compressToBase64 : function (input) {\n\t    if (input == null) return \"\";\n\t    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n\t    switch (res.length % 4) { // To produce valid Base64\n\t    default: // When could this happen ?\n\t    case 0 : return res;\n\t    case 1 : return res+\"===\";\n\t    case 2 : return res+\"==\";\n\t    case 3 : return res+\"=\";\n\t    }\n\t  },\n\t\n\t  decompressFromBase64 : function (input) {\n\t    if (input == null) return \"\";\n\t    if (input == \"\") return null;\n\t    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n\t  },\n\t\n\t  compressToUTF16 : function (input) {\n\t    if (input == null) return \"\";\n\t    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n\t  },\n\t\n\t  decompressFromUTF16: function (compressed) {\n\t    if (compressed == null) return \"\";\n\t    if (compressed == \"\") return null;\n\t    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n\t  },\n\t\n\t  //compress into uint8array (UCS-2 big endian format)\n\t  compressToUint8Array: function (uncompressed) {\n\t    var compressed = LZString.compress(uncompressed);\n\t    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\t\n\t    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n\t      var current_value = compressed.charCodeAt(i);\n\t      buf[i*2] = current_value >>> 8;\n\t      buf[i*2+1] = current_value % 256;\n\t    }\n\t    return buf;\n\t  },\n\t\n\t  //decompress from uint8array (UCS-2 big endian format)\n\t  decompressFromUint8Array:function (compressed) {\n\t    if (compressed===null || compressed===undefined){\n\t        return LZString.decompress(compressed);\n\t    } else {\n\t        var buf=new Array(compressed.length/2); // 2 bytes per character\n\t        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n\t          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n\t        }\n\t\n\t        var result = [];\n\t        buf.forEach(function (c) {\n\t          result.push(f(c));\n\t        });\n\t        return LZString.decompress(result.join(''));\n\t\n\t    }\n\t\n\t  },\n\t\n\t\n\t  //compress into a string that is already URI encoded\n\t  compressToEncodedURIComponent: function (input) {\n\t    if (input == null) return \"\";\n\t    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n\t  },\n\t\n\t  //decompress from an output of compressToEncodedURIComponent\n\t  decompressFromEncodedURIComponent:function (input) {\n\t    if (input == null) return \"\";\n\t    if (input == \"\") return null;\n\t    input = input.replace(/ /g, \"+\");\n\t    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n\t  },\n\t\n\t  compress: function (uncompressed) {\n\t    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n\t  },\n\t  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n\t    if (uncompressed == null) return \"\";\n\t    var i, value,\n\t        context_dictionary= {},\n\t        context_dictionaryToCreate= {},\n\t        context_c=\"\",\n\t        context_wc=\"\",\n\t        context_w=\"\",\n\t        context_enlargeIn= 2, // Compensate for the first entry which should not count\n\t        context_dictSize= 3,\n\t        context_numBits= 2,\n\t        context_data=[],\n\t        context_data_val=0,\n\t        context_data_position=0,\n\t        ii;\n\t\n\t    for (ii = 0; ii < uncompressed.length; ii += 1) {\n\t      context_c = uncompressed.charAt(ii);\n\t      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n\t        context_dictionary[context_c] = context_dictSize++;\n\t        context_dictionaryToCreate[context_c] = true;\n\t      }\n\t\n\t      context_wc = context_w + context_c;\n\t      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n\t        context_w = context_wc;\n\t      } else {\n\t        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n\t          if (context_w.charCodeAt(0)<256) {\n\t            for (i=0 ; i<context_numBits ; i++) {\n\t              context_data_val = (context_data_val << 1);\n\t              if (context_data_position == bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t            }\n\t            value = context_w.charCodeAt(0);\n\t            for (i=0 ; i<8 ; i++) {\n\t              context_data_val = (context_data_val << 1) | (value&1);\n\t              if (context_data_position == bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t              value = value >> 1;\n\t            }\n\t          } else {\n\t            value = 1;\n\t            for (i=0 ; i<context_numBits ; i++) {\n\t              context_data_val = (context_data_val << 1) | value;\n\t              if (context_data_position ==bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t              value = 0;\n\t            }\n\t            value = context_w.charCodeAt(0);\n\t            for (i=0 ; i<16 ; i++) {\n\t              context_data_val = (context_data_val << 1) | (value&1);\n\t              if (context_data_position == bitsPerChar-1) {\n\t                context_data_position = 0;\n\t                context_data.push(getCharFromInt(context_data_val));\n\t                context_data_val = 0;\n\t              } else {\n\t                context_data_position++;\n\t              }\n\t              value = value >> 1;\n\t            }\n\t          }\n\t          context_enlargeIn--;\n\t          if (context_enlargeIn == 0) {\n\t            context_enlargeIn = Math.pow(2, context_numBits);\n\t            context_numBits++;\n\t          }\n\t          delete context_dictionaryToCreate[context_w];\n\t        } else {\n\t          value = context_dictionary[context_w];\n\t          for (i=0 ; i<context_numBits ; i++) {\n\t            context_data_val = (context_data_val << 1) | (value&1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = value >> 1;\n\t          }\n\t\n\t\n\t        }\n\t        context_enlargeIn--;\n\t        if (context_enlargeIn == 0) {\n\t          context_enlargeIn = Math.pow(2, context_numBits);\n\t          context_numBits++;\n\t        }\n\t        // Add wc to the dictionary.\n\t        context_dictionary[context_wc] = context_dictSize++;\n\t        context_w = String(context_c);\n\t      }\n\t    }\n\t\n\t    // Output the code for w.\n\t    if (context_w !== \"\") {\n\t      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n\t        if (context_w.charCodeAt(0)<256) {\n\t          for (i=0 ; i<context_numBits ; i++) {\n\t            context_data_val = (context_data_val << 1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t          }\n\t          value = context_w.charCodeAt(0);\n\t          for (i=0 ; i<8 ; i++) {\n\t            context_data_val = (context_data_val << 1) | (value&1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = value >> 1;\n\t          }\n\t        } else {\n\t          value = 1;\n\t          for (i=0 ; i<context_numBits ; i++) {\n\t            context_data_val = (context_data_val << 1) | value;\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = 0;\n\t          }\n\t          value = context_w.charCodeAt(0);\n\t          for (i=0 ; i<16 ; i++) {\n\t            context_data_val = (context_data_val << 1) | (value&1);\n\t            if (context_data_position == bitsPerChar-1) {\n\t              context_data_position = 0;\n\t              context_data.push(getCharFromInt(context_data_val));\n\t              context_data_val = 0;\n\t            } else {\n\t              context_data_position++;\n\t            }\n\t            value = value >> 1;\n\t          }\n\t        }\n\t        context_enlargeIn--;\n\t        if (context_enlargeIn == 0) {\n\t          context_enlargeIn = Math.pow(2, context_numBits);\n\t          context_numBits++;\n\t        }\n\t        delete context_dictionaryToCreate[context_w];\n\t      } else {\n\t        value = context_dictionary[context_w];\n\t        for (i=0 ; i<context_numBits ; i++) {\n\t          context_data_val = (context_data_val << 1) | (value&1);\n\t          if (context_data_position == bitsPerChar-1) {\n\t            context_data_position = 0;\n\t            context_data.push(getCharFromInt(context_data_val));\n\t            context_data_val = 0;\n\t          } else {\n\t            context_data_position++;\n\t          }\n\t          value = value >> 1;\n\t        }\n\t\n\t\n\t      }\n\t      context_enlargeIn--;\n\t      if (context_enlargeIn == 0) {\n\t        context_enlargeIn = Math.pow(2, context_numBits);\n\t        context_numBits++;\n\t      }\n\t    }\n\t\n\t    // Mark the end of the stream\n\t    value = 2;\n\t    for (i=0 ; i<context_numBits ; i++) {\n\t      context_data_val = (context_data_val << 1) | (value&1);\n\t      if (context_data_position == bitsPerChar-1) {\n\t        context_data_position = 0;\n\t        context_data.push(getCharFromInt(context_data_val));\n\t        context_data_val = 0;\n\t      } else {\n\t        context_data_position++;\n\t      }\n\t      value = value >> 1;\n\t    }\n\t\n\t    // Flush the last char\n\t    while (true) {\n\t      context_data_val = (context_data_val << 1);\n\t      if (context_data_position == bitsPerChar-1) {\n\t        context_data.push(getCharFromInt(context_data_val));\n\t        break;\n\t      }\n\t      else context_data_position++;\n\t    }\n\t    return context_data.join('');\n\t  },\n\t\n\t  decompress: function (compressed) {\n\t    if (compressed == null) return \"\";\n\t    if (compressed == \"\") return null;\n\t    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n\t  },\n\t\n\t  _decompress: function (length, resetValue, getNextValue) {\n\t    var dictionary = [],\n\t        next,\n\t        enlargeIn = 4,\n\t        dictSize = 4,\n\t        numBits = 3,\n\t        entry = \"\",\n\t        result = [],\n\t        i,\n\t        w,\n\t        bits, resb, maxpower, power,\n\t        c,\n\t        data = {val:getNextValue(0), position:resetValue, index:1};\n\t\n\t    for (i = 0; i < 3; i += 1) {\n\t      dictionary[i] = i;\n\t    }\n\t\n\t    bits = 0;\n\t    maxpower = Math.pow(2,2);\n\t    power=1;\n\t    while (power!=maxpower) {\n\t      resb = data.val & data.position;\n\t      data.position >>= 1;\n\t      if (data.position == 0) {\n\t        data.position = resetValue;\n\t        data.val = getNextValue(data.index++);\n\t      }\n\t      bits |= (resb>0 ? 1 : 0) * power;\n\t      power <<= 1;\n\t    }\n\t\n\t    switch (next = bits) {\n\t      case 0:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,8);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t        c = f(bits);\n\t        break;\n\t      case 1:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,16);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t        c = f(bits);\n\t        break;\n\t      case 2:\n\t        return \"\";\n\t    }\n\t    dictionary[3] = c;\n\t    w = c;\n\t    result.push(c);\n\t    while (true) {\n\t      if (data.index > length) {\n\t        return \"\";\n\t      }\n\t\n\t      bits = 0;\n\t      maxpower = Math.pow(2,numBits);\n\t      power=1;\n\t      while (power!=maxpower) {\n\t        resb = data.val & data.position;\n\t        data.position >>= 1;\n\t        if (data.position == 0) {\n\t          data.position = resetValue;\n\t          data.val = getNextValue(data.index++);\n\t        }\n\t        bits |= (resb>0 ? 1 : 0) * power;\n\t        power <<= 1;\n\t      }\n\t\n\t      switch (c = bits) {\n\t        case 0:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,8);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t\n\t          dictionary[dictSize++] = f(bits);\n\t          c = dictSize-1;\n\t          enlargeIn--;\n\t          break;\n\t        case 1:\n\t          bits = 0;\n\t          maxpower = Math.pow(2,16);\n\t          power=1;\n\t          while (power!=maxpower) {\n\t            resb = data.val & data.position;\n\t            data.position >>= 1;\n\t            if (data.position == 0) {\n\t              data.position = resetValue;\n\t              data.val = getNextValue(data.index++);\n\t            }\n\t            bits |= (resb>0 ? 1 : 0) * power;\n\t            power <<= 1;\n\t          }\n\t          dictionary[dictSize++] = f(bits);\n\t          c = dictSize-1;\n\t          enlargeIn--;\n\t          break;\n\t        case 2:\n\t          return result.join('');\n\t      }\n\t\n\t      if (enlargeIn == 0) {\n\t        enlargeIn = Math.pow(2, numBits);\n\t        numBits++;\n\t      }\n\t\n\t      if (dictionary[c]) {\n\t        entry = dictionary[c];\n\t      } else {\n\t        if (c === dictSize) {\n\t          entry = w + w.charAt(0);\n\t        } else {\n\t          return null;\n\t        }\n\t      }\n\t      result.push(entry);\n\t\n\t      // Add w+entry[0] to the dictionary.\n\t      dictionary[dictSize++] = w + entry.charAt(0);\n\t      enlargeIn--;\n\t\n\t      w = entry;\n\t\n\t      if (enlargeIn == 0) {\n\t        enlargeIn = Math.pow(2, numBits);\n\t        numBits++;\n\t      }\n\t\n\t    }\n\t  }\n\t};\n\t  return LZString;\n\t})();\n\t\n\tif (true) {\n\t  !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return LZString; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if( typeof module !== 'undefined' && module != null ) {\n\t  module.exports = LZString\n\t}\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar contactSearchService = function () {\n\t    var searchProviders = [];\n\t    var queryCompletedHandlers = [];\n\t\n\t    function createResult(item) {\n\t        return {\n\t            name: item.name,\n\t            value: item.value,\n\t            type: item.type,\n\t            id: item.id\n\t        };\n\t    }\n\t    return {\n\t        query: function query(searchFunctions, filter) {\n\t            return Promise.all(searchFunctions).then(function (results) {\n\t                var searchResultsKeys = {};\n\t                var searchResults = [];\n\t                results.forEach(function (result) {\n\t                    result.forEach(function (item) {\n\t                        if (filter) {\n\t                            if (filter(item)) {\n\t                                var key = item.name + item.value;\n\t                                if (!searchResultsKeys[key]) {\n\t                                    var toAddItem = createResult(item);\n\t                                    searchResultsKeys[key] = toAddItem;\n\t                                    searchResults.push(toAddItem);\n\t                                }\n\t                            }\n\t                        } else {\n\t                            var key = item.name + item.value;\n\t                            if (!searchResultsKeys[key]) {\n\t                                var toAddItem = createResult(item);\n\t                                searchResultsKeys[key] = toAddItem;\n\t                                searchResults.push(toAddItem);\n\t                            }\n\t                        }\n\t                    });\n\t                });\n\t                return searchResults;\n\t            });\n\t        }\n\t    };\n\t}();\n\texports.default = contactSearchService;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcContactService = __webpack_require__(55);\n\t\n\tvar _rcContactService2 = _interopRequireDefault(_rcContactService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcContactSearchProvider = function () {\n\t    return {\n\t        search: function search(text) {\n\t            var results = [];\n\t            if (text) {\n\t                text = text.toLowerCase();\n\t                _rcContactService2.default.companyContacts.map(function (contact) {\n\t                    if (contact.displayName && contact.displayName.toLowerCase().indexOf(text) >= 0) {\n\t                        results.push({\n\t                            name: contact.displayName,\n\t                            value: contact.extension,\n\t                            type: 'rc',\n\t                            id: contact.id\n\t                        });\n\t                        contact.phoneNumber.forEach(function (phone) {\n\t                            results.push({\n\t                                name: contact.displayName,\n\t                                value: phone,\n\t                                type: 'rc',\n\t                                id: contact.id\n\t                            });\n\t                        });\n\t                    } else {\n\t                        if (contact.extension && contact.extension.indexOf(text) >= 0) {\n\t                            results.push({\n\t                                name: contact.displayName,\n\t                                value: contact.extension,\n\t                                type: 'rc',\n\t                                id: contact.id\n\t                            });\n\t                        }\n\t\n\t                        contact.phoneNumber.forEach(function (phone) {\n\t                            if (phone.indexOf(text) >= 0) {\n\t                                results.push({\n\t                                    name: contact.displayName,\n\t                                    value: phone,\n\t                                    type: 'rc',\n\t                                    id: contact.id\n\t                                });\n\t                            }\n\t                        });\n\t                    }\n\t                });\n\t            }\n\t\n\t            return results;\n\t        },\n\t        searchAll: function searchAll() {\n\t            return _rcContactService2.default.completeCompanyContact().then(function (companyContacts) {\n\t                return companyContacts.map(function (contact) {\n\t                    return {\n\t                        name: contact.displayName,\n\t                        type: 'rc',\n\t                        id: contact.id\n\t                    };\n\t                });\n\t            }).catch(function (e) {\n\t                return console.error(e);\n\t            });\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcContactSearchProvider;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar _rcSubscriptionService = __webpack_require__(53);\n\t\n\tvar _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcMessageService = function () {\n\t    var messages = {};\n\t    var fetchingPromise = null;\n\t    var syncToken = null;\n\t    var messageUpdateHandlers = [];\n\t\n\t    function fullSyncMessages(hour) {\n\t        return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n\t            dateFrom: new Date(Date.now() - hour * 3600 * 1000).toISOString(),\n\t            syncType: 'FSync'\n\t        }).then(function (responses) {\n\t            var jsonResponse = responses.json();\n\t            syncToken = jsonResponse.syncInfo.syncToken;\n\t            var results = jsonResponse.records;\n\t            addMessageToList(results);\n\t            fetchingPromise = null;\n\t            return results;\n\t        });\n\t    }\n\t\n\t    function incrementalSyncMessages() {\n\t        if (syncToken) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n\t                syncType: 'ISync',\n\t                syncToken: syncToken\n\t            }).then(function (responses) {\n\t                var jsonResponse = responses.json();\n\t                var results = jsonResponse.records;\n\t                syncToken = jsonResponse.syncInfo.syncToken;\n\t                updateMessageList(results);\n\t                messageUpdateHandlers.forEach(function (h) {\n\t                    return h(results);\n\t                });\n\t            });\n\t        }\n\t    }\n\t\n\t    function concatMessages() {\n\t        var results = [];\n\t        for (var key in messages) {\n\t            if (messages.hasOwnProperty(key)) {\n\t                results = results.concat(messages[key]);\n\t            }\n\t        }\n\t        return results;\n\t    }\n\t\n\t    function addMessageToList(results) {\n\t        results.forEach(function (message) {\n\t            if (!messages[message.type]) {\n\t                messages[message.type] = [];\n\t            }\n\t            messages[message.type].push(message);\n\t        });\n\t    }\n\t\n\t    function updateMessageList(results) {\n\t        results.forEach(function (message) {\n\t            var messageList = messages[message.type];\n\t            if (!messageList) {\n\t                if (message.availability === 'Alive') {\n\t                    messages[message.type] = [];\n\t                    messages[message.type].splice(0, 0, message);\n\t                }\n\t            } else {\n\t                var index = 0;\n\t                for (; index < messageList.length; index++) {\n\t                    if (messageList[index].id === message.id) {\n\t                        if (message.availability === 'Alive') {\n\t                            messageList[index] = message;\n\t                        } else {\n\t                            messageList.splice(index, 1);\n\t                        }\n\t                        break;\n\t                    }\n\t                }\n\t                if (index === messageList.length) {\n\t                    if (message.availability === 'Alive') {\n\t                        messageList.splice(0, 0, message);\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    return {\n\t        syncMessages: function syncMessages(hour) {\n\t            fetchingPromise = fullSyncMessages(hour);\n\t            return fetchingPromise;\n\t        },\n\t        getMessagesByType: function getMessagesByType(type) {\n\t            if (!fetchingPromise) {\n\t                if (messages[type]) {\n\t                    return messages[type];\n\t                } else {\n\t                    return [];\n\t                }\n\t            } else {\n\t                return fetchingPromise.then(function () {\n\t                    return messages[type];\n\t                });\n\t            }\n\t        },\n\t        getAllMessages: function getAllMessages() {\n\t            return !fetchingPromise ? concatMessages() : fetchingPromise.then(concatMessages);\n\t        },\n\t        subscribeToMessageUpdate: function subscribeToMessageUpdate() {\n\t            _rcSubscriptionService2.default.subscribe('message-store', '/restapi/v1.0/account/~/extension/~/message-store', incrementalSyncMessages);\n\t        },\n\t        onMessageUpdated: function onMessageUpdated(handler) {\n\t            if (handler) {\n\t                messageUpdateHandlers.push(handler);\n\t            }\n\t        },\n\t        sendSMSMessage: function sendSMSMessage(text, fromNumber, toNumber) {\n\t            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/sms/', {\n\t                from: { phoneNumber: fromNumber },\n\t                to: [{ phoneNumber: toNumber }],\n\t                text: text\n\t            }).then(function (response) {\n\t                return response.json();\n\t            });\n\t        },\n\t        sendPagerMessage: function sendPagerMessage(text, fromNumber, toNumber) {\n\t            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/company-pager/', {\n\t                from: { extensionNumber: fromNumber },\n\t                to: [{ extensionNumber: toNumber }],\n\t                text: text\n\t            }).then(function (response) {\n\t                return response.json();\n\t            });\n\t        },\n\t        sendFax: function sendFax(files, toNumber) {\n\t            var body = {\n\t                to: [{ phoneNumber: toNumber }],\n\t                faxResolution: 'High'\n\t            };\n\t            var formData = new FormData();\n\t            formData.append('json', new File([JSON.stringify(body)], 'request.json', { type: 'application/json' }));\n\t            Array.from(files).forEach(function (file) {\n\t                formData.append('attachment', file);\n\t            });\n\t            // fax need have text thus can be sent\n\t            // formData.append(\n\t            //     'attachment',\n\t            //     new File(\n\t            //         [''],\n\t            //         'text.txt',\n\t            //         { type: 'application/octet-stream' })\n\t            // )\n\t            // Send the fax\n\t            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/fax', formData);\n\t        },\n\t        getConversation: function getConversation(conversationId, hourFrom, hourTo) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n\t                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n\t                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n\t                conversationId: conversationId\n\t            }).then(function (response) {\n\t                return response.json();\n\t            }).then(function (data) {\n\t                return data.records;\n\t            }).then(function (records) {\n\t                return records.reverse();\n\t            });\n\t        },\n\t        getMessagesByNumber: function getMessagesByNumber(phoneNumber, hourFrom, hourTo) {\n\t            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n\t                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n\t                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n\t                phoneNumber: phoneNumber\n\t            }).then(function (response) {\n\t                return response.json();\n\t            }).then(function (data) {\n\t                return data.records;\n\t            }).then(function (records) {\n\t                return records.reverse();\n\t            });\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcMessageService;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcMessageService = __webpack_require__(59);\n\t\n\tvar _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar rcMessageProvider = function () {\n\t    var messageUpdatedHandlers = [];\n\t    var conversations = {};\n\t    var cachedHour = 0;\n\t\n\t    _rcMessageService2.default.onMessageUpdated(function (results) {\n\t        messageUpdatedHandlers.forEach(function (h) {\n\t            try {\n\t                h(results.slice());\n\t            } catch (e) {\n\t                console.error(e);\n\t            }\n\t        });\n\t    });\n\t\n\t    function createResult(message) {\n\t        return {\n\t            id: message.id,\n\t            time: message.lastModifiedTime,\n\t            readStatus: message.readStatus,\n\t            type: getType(message),\n\t            contact: getNumber(message.type, getDirection(message, 'Outbound')),\n\t            subject: message.subject || null,\n\t            convId: message.conversation ? message.conversation.id : null,\n\t            author: getNumber(message, getDirection(message, 'Inbound'))\n\t        };\n\t\n\t        function getDirection(message, dir) {\n\t            return message.direction === dir ? message.to[0] : message.from;\n\t        }\n\t\n\t        function getNumber(message, info) {\n\t            return message.type === 'Pager' ? info.extensionNumber : info.phoneNumber;\n\t        }\n\t\n\t        function getType(message) {\n\t            return message.type === 'Fax' || message.type === 'VoiceMail' ? 'Text' : message.type;\n\t        }\n\t    }\n\t\n\t    return {\n\t        getTextMessages: function getTextMessages() {\n\t            return Promise.resolve(_rcMessageService2.default.getMessagesByType('SMS')).then(function (messages) {\n\t                var results = [];\n\t                messages.forEach(function (message) {\n\t                    results.push(createResult(message));\n\t                });\n\t                return results;\n\t            });\n\t        },\n\t\n\t        getLastMessagesOfAllType: function getLastMessagesOfAllType() {\n\t            var results = [];\n\t            return this.getMessagesOfAllType().then(function (msgs) {\n\t                for (var key in msgs) {\n\t                    if (msgs.hasOwnProperty(key)) {\n\t                        if (key === 'anonymous') results = results.concat(msgs.anonymous[0]);else results.push(msgs[key][0]);\n\t                    }\n\t                }\n\t                return results;\n\t            });\n\t        },\n\t        // Return all messages of type 'VoiceMail' and 'Fax'. For SMS and Pager, only last message in a conversation\n\t        // will be returned.\n\t        getMessagesOfAllType: function getMessagesOfAllType() {\n\t            return Promise.resolve(_rcMessageService2.default.getAllMessages()).then(function (messages) {\n\t                var results = [];\n\t                var target = {};\n\t                messages.forEach(function (message) {\n\t                    var result = createResult(message);\n\t                    //Combine SMS/Pager messages in conversation\n\t                    if (message.conversation && message.conversation.id) {\n\t                        target[message.conversation.id] = target[message.conversation.id] || [];\n\t                        target[message.conversation.id].push(result);\n\t                        conversations[message.conversation.id] = conversations[message.conversation.id] || [];\n\t                        conversations[message.conversation.id].push(message);\n\t                    } else {\n\t                        target['anonymous'] = target['anonymous'] || [];\n\t                        target['anonymous'].push(result);\n\t                    }\n\t                });\n\t                return target;\n\t            });\n\t        },\n\t\n\t        getConversation: function getConversation(convId, hourFrom) {\n\t            if (conversations[convId] && (!hourFrom || hourFrom < cachedHour)) {\n\t                return Promise.resolve(conversations[convId].reverse());\n\t            } else {\n\t                return _rcMessageService2.default.getConversation(convId, hourFrom, cachedHour).then(function (result) {\n\t                    cachedHour = hourFrom;\n\t                    return result;\n\t                });\n\t            }\n\t        },\n\t\n\t        onMessageUpdated: function onMessageUpdated(handler) {\n\t            messageUpdatedHandlers.push(handler);\n\t        }\n\t    };\n\t}();\n\texports.default = rcMessageProvider;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _rcSdk = __webpack_require__(4);\n\t\n\tvar rcConferenceSerivce = function () {\n\t    var fetchingConferenceInfo = null;\n\t\n\t    function fetchConferenceInfo() {\n\t        fetchingConferenceInfo = _rcSdk.RC.sdk.platform().get('/account/~/extension/~/conferencing').then(function (responses) {\n\t            var jsonResponse = responses.json();\n\t            var conferenceInfo = {};\n\t            conferenceInfo.hostCode = jsonResponse.hostCode;\n\t            conferenceInfo.phoneNumber = jsonResponse.phoneNumber;\n\t            conferenceInfo.participantCode = jsonResponse.participantCode;\n\t            fetchingConferenceInfo = null;\n\t            return conferenceInfo;\n\t        });\n\t        return fetchingConferenceInfo;\n\t    }\n\t\n\t    return {\n\t        getConferenceInfo: function getConferenceInfo() {\n\t            if (fetchingConferenceInfo) {\n\t                return fetchingConferenceInfo;\n\t            } else {\n\t                return fetchConferenceInfo();\n\t            }\n\t        }\n\t    };\n\t}();\n\t\n\texports.default = rcConferenceSerivce;\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _callLogService = __webpack_require__(52);\n\t\n\tvar _callLogService2 = _interopRequireDefault(_callLogService);\n\t\n\tvar _rcMessageService = __webpack_require__(59);\n\t\n\tvar _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar conversationService = function () {\n\t    var cachedHour = 24 * 7;\n\t    function groupMessageToContact(msgs, contacts) {\n\t        var relatedContacts = contacts.filter(function (contact) {\n\t            var knownContactsIndex = [];\n\t            var contactNums = contact.phoneNumber.concat(contact.extension);\n\t            var contactMsgs = msgs.filter(function (msg, index) {\n\t                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t                var contain = contactNums.indexOf(msgNumber) > -1;\n\t                contact.msg = contact.msg || [];\n\t                var alreadyExist = contact.msg.find(function (contactMsg) {\n\t                    return contactMsg.id == msg.id;\n\t                });\n\t                if (contain && !alreadyExist) {\n\t\n\t                    contact.msg.push(msg);\n\t                    knownContactsIndex.push(index);\n\t                }\n\t                return contain;\n\t            });\n\t            knownContactsIndex.reverse().forEach(function (index) {\n\t                return msgs.splice(index, 1);\n\t            });\n\t            return contactMsgs.length > 0;\n\t        });\n\t        msgs.forEach(function (msg) {\n\t            var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t            var contact = relatedContacts.filter(function (contact) {\n\t                return contact.id === msgNumber;\n\t            })[0];\n\t            if (contact) {\n\t                contact.msg.push(msg);\n\t            } else {\n\t                relatedContacts.push(fakeContact(msg));\n\t            }\n\t        });\n\t        return relatedContacts;\n\t    }\n\t\n\t    function groupContactToMessage(msgs, contacts) {\n\t        return msgs.map(function (msg) {\n\t            var unknownContact = true;\n\t            contacts.forEach(function (contact) {\n\t                var contactNums = contact.phoneNumber.concat(contact.extension);\n\t                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t                var contain = contactNums.indexOf(msgNumber) > -1;\n\t                if (contain) {\n\t                    msg.contact = contact;\n\t                    unknownContact = false;\n\t                }\n\t            });\n\t            // if (unknownContact) {\n\t            //     console.log(msg);\n\t            //     var fake = fakeContact(msg)\n\t            //     msg.contact = fake\n\t            //     contacts.push(fake)\n\t            // }\n\t            return msg;\n\t        });\n\t    }\n\t\n\t    function combineAdjacentMessage(contents) {\n\t        // group related SMS message\n\t        var savedContent;\n\t        var result = [];\n\t        for (var i = contents.length - 1; i > 0; --i) {\n\t            var content = contents[i];\n\t            // if (content.type !== 'SMS') {\n\t            //     if (savedContent) {\n\t            //         result.push(savedContent)\n\t            //         savedContent = null\n\t            //     }\n\t            //     result.push(content)\n\t            //     continue\n\t            // }\n\t            if (savedContent && (content.type === 'SMS' || content.type === 'Pager') && savedContent.type === content.type && savedContent.contact.id === content.contact.id) {\n\t                savedContent.others.push(content);\n\t            } else {\n\t                savedContent && result.push(savedContent);\n\t                content.others = [];\n\t                savedContent = content;\n\t            }\n\t        }\n\t        savedContent && result.push(savedContent);\n\t        return result;\n\t    }\n\t\n\t    function combine() {\n\t        for (var _len = arguments.length, targets = Array(_len), _key = 0; _key < _len; _key++) {\n\t            targets[_key] = arguments[_key];\n\t        }\n\t\n\t        return targets.reduce(function (result, target) {\n\t            return result.concat(target);\n\t        }, []);\n\t    }\n\t\n\t    function sortTime(target) {\n\t        return target.slice().sort(function (a, b) {\n\t            return Date.parse(a.time) - Date.parse(b.time);\n\t        });\n\t    }\n\t    function containSameVal(array1, array2) {\n\t        return array1.filter(function (n) {\n\t            return array2.indexOf(n) != -1;\n\t        }).length > 0;\n\t    }\n\t    function uniqueArray(target) {\n\t        var seen = {};\n\t        return target.filter(function (item) {\n\t            return seen.hasOwnProperty(item) ? false : seen[item] = true;\n\t        });\n\t    }\n\t\n\t    function fakeContact(msg) {\n\t        var phoneNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n\t        return {\n\t            displayName: phoneNumber,\n\t            id: phoneNumber,\n\t            phoneNumber: [phoneNumber],\n\t            extension: null,\n\t            msg: [msg]\n\t        };\n\t    }\n\t\n\t    function adaptMessage(msg) {\n\t        return {\n\t            id: msg.id,\n\t            from: !msg.from && 'anonymous' || // For fax\n\t            msg.from.extensionNumber || msg.from.phoneNumber,\n\t            to: !msg.to && 'anonymous' || // For fax\n\t            msg.to.phoneNumber || msg.to.extensionNumber || msg.to[0].extensionNumber || msg.to[0].phoneNumber,\n\t            direction: msg.direction,\n\t            type: msg.type,\n\t            time: msg.creationTime || msg.startTime,\n\t            lastModifiedTime: msg.lastModifiedTime || msg.startTime,\n\t            subject: msg.recording || msg.subject || msg.action || msg.attachments[0],\n\t            status: {\n\t                sendConfirmed: false,\n\t                receiveConfirmed: false\n\t            }\n\t        };\n\t    }\n\t    function getMessagesByNumber(contact, offset) {\n\t        return Promise.all(contact.phoneNumber.map(function (number) {\n\t            return _rcMessageService2.default.getMessagesByNumber(\n\t            // FIXME\n\t            number, cachedHour + offset, cachedHour);\n\t        })).then(function (result) {\n\t            return combine.apply(undefined, _toConsumableArray(result));\n\t        });\n\t    }\n\t    function getCallLogsByNumber(contact, offset) {\n\t        return Promise.all(contact.phoneNumber.map(function (number) {\n\t            return _callLogService2.default.getCallLogsByNumber(number, cachedHour + offset, cachedHour);\n\t        })).then(function (result) {\n\t            return combine.apply(undefined, _toConsumableArray(result));\n\t        });\n\t    }\n\t    function uniqId(target) {\n\t        var seen = {};\n\t        return target.filter(function (item) {\n\t            return seen.hasOwnProperty(item.id) ? false : seen[item.id] = true;\n\t        });\n\t    }\n\t    function combineContent() {\n\t        for (var _len2 = arguments.length, sources = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t            sources[_key2] = arguments[_key2];\n\t        }\n\t\n\t        return sortTime(combine.apply(undefined, _toConsumableArray(sources.map(function (source) {\n\t            return source.map(adaptMessage);\n\t        }))));\n\t    }\n\t    return {\n\t        get cachedHour() {\n\t            return cachedHour;\n\t        },\n\t        syncContent: function syncContent(contacts) {\n\t            for (var _len3 = arguments.length, sources = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n\t                sources[_key3 - 1] = arguments[_key3];\n\t            }\n\t\n\t            var contents = combineContent.apply(undefined, sources);\n\t            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n\t            contents = groupContactToMessage(contents, relatedContacts);\n\t            return contents;\n\t        },\n\t        organizeContent: function organizeContent(contacts) {\n\t            for (var _len4 = arguments.length, sources = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t                sources[_key4 - 1] = arguments[_key4];\n\t            }\n\t\n\t            var contents = combineContent.apply(undefined, sources);\n\t            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n\t            contents = groupContactToMessage(contents, relatedContacts);\n\t            contents = combineAdjacentMessage(contents);\n\t            return contents;\n\t        },\n\t        getConversations: function getConversations(contacts) {\n\t            for (var _len5 = arguments.length, sources = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n\t                sources[_key5 - 1] = arguments[_key5];\n\t            }\n\t\n\t            var contents = combineContent.apply(undefined, sources);\n\t            var relatedContacts = groupMessageToContact(contents, contacts).map(function (contact) {\n\t                contact.syncHour = cachedHour;\n\t                return contact;\n\t            }).map(function (contact) {\n\t                contact.phoneNumber = uniqueArray(contact.phoneNumber.concat(contact.extension));\n\t                return contact;\n\t            }).reduce(function (map, contact) {\n\t                map[contact.id] = contact;\n\t                return map;\n\t            }, {});\n\t            return relatedContacts;\n\t        },\n\t        loadContent: function loadContent(contact, offset) {\n\t            return Promise.all([getCallLogsByNumber(contact, offset), getMessagesByNumber(contact, offset)]).then(function (result) {\n\t                return combineContent.apply(undefined, _toConsumableArray(result));\n\t            }).then(function (contents) {\n\t                contact.msg = contents.concat(contact.msg);\n\t                cachedHour += offset;\n\t                return contents;\n\t            });\n\t        },\n\t        onConversationUpdate: function onConversationUpdate(handler) {\n\t            _rcMessageService2.default.onMessageUpdated(function (msgs) {\n\t                try {\n\t                    var msgs = sortTime(msgs.map(adaptMessage));\n\t                    handler(msgs);\n\t                } catch (e) {\n\t                    console.error(e);\n\t                    throw e;\n\t                }\n\t            });\n\t        },\n\t        adaptMessage: adaptMessage\n\t    };\n\t}();\n\t\n\texports.default = conversationService;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*\n\t * JavaScript MD5\n\t * https://github.com/blueimp/JavaScript-MD5\n\t *\n\t * Copyright 2011, Sebastian Tschan\n\t * https://blueimp.net\n\t *\n\t * Licensed under the MIT license:\n\t * http://www.opensource.org/licenses/MIT\n\t *\n\t * Based on\n\t * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n\t * Digest Algorithm, as defined in RFC 1321.\n\t * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n\t * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n\t * Distributed under the BSD License\n\t * See http://pajhome.org.uk/crypt/md5 for more info.\n\t */\n\t\n\t/*global unescape, define, module */\n\t\n\t;(function ($) {\n\t  'use strict'\n\t\n\t  /*\n\t  * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n\t  * to work around bugs in some JS interpreters.\n\t  */\n\t  function safe_add (x, y) {\n\t    var lsw = (x & 0xFFFF) + (y & 0xFFFF)\n\t    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n\t    return (msw << 16) | (lsw & 0xFFFF)\n\t  }\n\t\n\t  /*\n\t  * Bitwise rotate a 32-bit number to the left.\n\t  */\n\t  function bit_rol (num, cnt) {\n\t    return (num << cnt) | (num >>> (32 - cnt))\n\t  }\n\t\n\t  /*\n\t  * These functions implement the four basic operations the algorithm uses.\n\t  */\n\t  function md5_cmn (q, a, b, x, s, t) {\n\t    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)\n\t  }\n\t  function md5_ff (a, b, c, d, x, s, t) {\n\t    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)\n\t  }\n\t  function md5_gg (a, b, c, d, x, s, t) {\n\t    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)\n\t  }\n\t  function md5_hh (a, b, c, d, x, s, t) {\n\t    return md5_cmn(b ^ c ^ d, a, b, x, s, t)\n\t  }\n\t  function md5_ii (a, b, c, d, x, s, t) {\n\t    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)\n\t  }\n\t\n\t  /*\n\t  * Calculate the MD5 of an array of little-endian words, and a bit length.\n\t  */\n\t  function binl_md5 (x, len) {\n\t    /* append padding */\n\t    x[len >> 5] |= 0x80 << (len % 32)\n\t    x[(((len + 64) >>> 9) << 4) + 14] = len\n\t\n\t    var i\n\t    var olda\n\t    var oldb\n\t    var oldc\n\t    var oldd\n\t    var a = 1732584193\n\t    var b = -271733879\n\t    var c = -1732584194\n\t    var d = 271733878\n\t\n\t    for (i = 0; i < x.length; i += 16) {\n\t      olda = a\n\t      oldb = b\n\t      oldc = c\n\t      oldd = d\n\t\n\t      a = md5_ff(a, b, c, d, x[i], 7, -680876936)\n\t      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)\n\t      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)\n\t      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)\n\t      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)\n\t      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)\n\t      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)\n\t      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)\n\t      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)\n\t      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)\n\t      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)\n\t      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)\n\t      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)\n\t      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)\n\t      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)\n\t      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\t\n\t      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)\n\t      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)\n\t      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)\n\t      b = md5_gg(b, c, d, a, x[i], 20, -373897302)\n\t      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)\n\t      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)\n\t      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)\n\t      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)\n\t      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)\n\t      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)\n\t      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)\n\t      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)\n\t      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)\n\t      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)\n\t      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)\n\t      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\t\n\t      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)\n\t      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)\n\t      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)\n\t      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)\n\t      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)\n\t      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)\n\t      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)\n\t      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)\n\t      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)\n\t      d = md5_hh(d, a, b, c, x[i], 11, -358537222)\n\t      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)\n\t      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)\n\t      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)\n\t      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)\n\t      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)\n\t      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)\n\t\n\t      a = md5_ii(a, b, c, d, x[i], 6, -198630844)\n\t      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)\n\t      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)\n\t      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)\n\t      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)\n\t      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)\n\t      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)\n\t      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)\n\t      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)\n\t      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)\n\t      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)\n\t      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)\n\t      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)\n\t      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)\n\t      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)\n\t      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)\n\t\n\t      a = safe_add(a, olda)\n\t      b = safe_add(b, oldb)\n\t      c = safe_add(c, oldc)\n\t      d = safe_add(d, oldd)\n\t    }\n\t    return [a, b, c, d]\n\t  }\n\t\n\t  /*\n\t  * Convert an array of little-endian words to a string\n\t  */\n\t  function binl2rstr (input) {\n\t    var i\n\t    var output = ''\n\t    for (i = 0; i < input.length * 32; i += 8) {\n\t      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)\n\t    }\n\t    return output\n\t  }\n\t\n\t  /*\n\t  * Convert a raw string to an array of little-endian words\n\t  * Characters >255 have their high-byte silently ignored.\n\t  */\n\t  function rstr2binl (input) {\n\t    var i\n\t    var output = []\n\t    output[(input.length >> 2) - 1] = undefined\n\t    for (i = 0; i < output.length; i += 1) {\n\t      output[i] = 0\n\t    }\n\t    for (i = 0; i < input.length * 8; i += 8) {\n\t      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)\n\t    }\n\t    return output\n\t  }\n\t\n\t  /*\n\t  * Calculate the MD5 of a raw string\n\t  */\n\t  function rstr_md5 (s) {\n\t    return binl2rstr(binl_md5(rstr2binl(s), s.length * 8))\n\t  }\n\t\n\t  /*\n\t  * Calculate the HMAC-MD5, of a key and some data (raw strings)\n\t  */\n\t  function rstr_hmac_md5 (key, data) {\n\t    var i\n\t    var bkey = rstr2binl(key)\n\t    var ipad = []\n\t    var opad = []\n\t    var hash\n\t    ipad[15] = opad[15] = undefined\n\t    if (bkey.length > 16) {\n\t      bkey = binl_md5(bkey, key.length * 8)\n\t    }\n\t    for (i = 0; i < 16; i += 1) {\n\t      ipad[i] = bkey[i] ^ 0x36363636\n\t      opad[i] = bkey[i] ^ 0x5C5C5C5C\n\t    }\n\t    hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n\t    return binl2rstr(binl_md5(opad.concat(hash), 512 + 128))\n\t  }\n\t\n\t  /*\n\t  * Convert a raw string to a hex string\n\t  */\n\t  function rstr2hex (input) {\n\t    var hex_tab = '0123456789abcdef'\n\t    var output = ''\n\t    var x\n\t    var i\n\t    for (i = 0; i < input.length; i += 1) {\n\t      x = input.charCodeAt(i)\n\t      output += hex_tab.charAt((x >>> 4) & 0x0F) +\n\t      hex_tab.charAt(x & 0x0F)\n\t    }\n\t    return output\n\t  }\n\t\n\t  /*\n\t  * Encode a string as utf-8\n\t  */\n\t  function str2rstr_utf8 (input) {\n\t    return unescape(encodeURIComponent(input))\n\t  }\n\t\n\t  /*\n\t  * Take string arguments and return either raw or hex encoded strings\n\t  */\n\t  function raw_md5 (s) {\n\t    return rstr_md5(str2rstr_utf8(s))\n\t  }\n\t  function hex_md5 (s) {\n\t    return rstr2hex(raw_md5(s))\n\t  }\n\t  function raw_hmac_md5 (k, d) {\n\t    return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))\n\t  }\n\t  function hex_hmac_md5 (k, d) {\n\t    return rstr2hex(raw_hmac_md5(k, d))\n\t  }\n\t\n\t  function md5 (string, key, raw) {\n\t    if (!key) {\n\t      if (!raw) {\n\t        return hex_md5(string)\n\t      }\n\t      return raw_md5(string)\n\t    }\n\t    if (!raw) {\n\t      return hex_hmac_md5(key, string)\n\t    }\n\t    return raw_hmac_md5(key, string)\n\t  }\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return md5\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    module.exports = md5\n\t  } else {\n\t    $.md5 = md5\n\t  }\n\t}(this))\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*!\n\t * EventEmitter v5.0.0 - git.io/ee\n\t * Unlicense - http://unlicense.org/\n\t * Oliver Caldwell - http://oli.me.uk/\n\t * @preserve\n\t */\n\t\n\t/**\n\t * Class for managing events.\n\t * Can be extended to provide event functionality in other classes.\n\t *\n\t * @class EventEmitter Manages event registering and emitting.\n\t */\n\tfunction EventEmitter() {}\n\t\n\t// Shortcuts to improve speed and size\n\tvar proto = EventEmitter.prototype;\n\t\n\t/**\n\t * Finds the index of the listener for the event in its storage array.\n\t *\n\t * @param {Function[]} listeners Array of listeners to search through.\n\t * @param {Function} listener Method to look for.\n\t * @return {Number} Index of the specified listener, -1 if not found\n\t * @api private\n\t */\n\tfunction indexOfListener(listeners, listener) {\n\t    var i = listeners.length;\n\t    while (i--) {\n\t        if (listeners[i].listener === listener) {\n\t            return i;\n\t        }\n\t    }\n\t\n\t    return -1;\n\t}\n\t\n\t/**\n\t * Alias a method while keeping the context correct, to allow for overwriting of target method.\n\t *\n\t * @param {String} name The name of the target method.\n\t * @return {Function} The aliased method\n\t * @api private\n\t */\n\tfunction alias(name) {\n\t    return function aliasClosure() {\n\t        return this[name].apply(this, arguments);\n\t    };\n\t}\n\t\n\t/**\n\t * Returns the listener array for the specified event.\n\t * Will initialise the event object and listener arrays if required.\n\t * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n\t * Each property in the object response is an array of listener functions.\n\t *\n\t * @param {String|RegExp} evt Name of the event to return the listeners from.\n\t * @return {Function[]|Object} All listener functions for the event.\n\t */\n\tproto.getListeners = function getListeners(evt) {\n\t    var events = this._getEvents();\n\t    var response;\n\t    var key;\n\t\n\t    // Return a concatenated array of all matching events if\n\t    // the selector is a regular expression.\n\t    if (evt instanceof RegExp) {\n\t        response = {};\n\t        for (key in events) {\n\t            if (events.hasOwnProperty(key) && evt.test(key)) {\n\t                response[key] = events[key];\n\t            }\n\t        }\n\t    } else {\n\t        response = events[evt] || (events[evt] = []);\n\t    }\n\t\n\t    return response;\n\t};\n\t\n\t/**\n\t * Takes a list of listener objects and flattens it into a list of listener functions.\n\t *\n\t * @param {Object[]} listeners Raw listener objects.\n\t * @return {Function[]} Just the listener functions.\n\t */\n\tproto.flattenListeners = function flattenListeners(listeners) {\n\t    var flatListeners = [];\n\t    var i;\n\t\n\t    for (i = 0; i < listeners.length; i += 1) {\n\t        flatListeners.push(listeners[i].listener);\n\t    }\n\t\n\t    return flatListeners;\n\t};\n\t\n\t/**\n\t * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n\t *\n\t * @param {String|RegExp} evt Name of the event to return the listeners from.\n\t * @return {Object} All listener functions for an event in an object.\n\t */\n\tproto.getListenersAsObject = function getListenersAsObject(evt) {\n\t    var listeners = this.getListeners(evt);\n\t    var response;\n\t\n\t    if (listeners instanceof Array) {\n\t        response = {};\n\t        response[evt] = listeners;\n\t    }\n\t\n\t    return response || listeners;\n\t};\n\t\n\t/**\n\t * Adds a listener function to the specified event.\n\t * The listener will not be added if it is a duplicate.\n\t * If the listener returns true then it will be removed after it is called.\n\t * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to attach the listener to.\n\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addListener = function addListener(evt, listener) {\n\t    var listeners = this.getListenersAsObject(evt);\n\t    var listenerIsWrapped = (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object';\n\t    var key;\n\t\n\t    for (key in listeners) {\n\t        if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n\t            listeners[key].push(listenerIsWrapped ? listener : {\n\t                listener: listener,\n\t                once: false\n\t            });\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of addListener\n\t */\n\tproto.on = alias('addListener');\n\t\n\t/**\n\t * Semi-alias of addListener. It will add a listener that will be\n\t * automatically removed after its first execution.\n\t *\n\t * @param {String|RegExp} evt Name of the event to attach the listener to.\n\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addOnceListener = function addOnceListener(evt, listener) {\n\t    return this.addListener(evt, {\n\t        listener: listener,\n\t        once: true\n\t    });\n\t};\n\t\n\t/**\n\t * Alias of addOnceListener.\n\t */\n\tproto.once = alias('addOnceListener');\n\t\n\t/**\n\t * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n\t * You need to tell it what event names should be matched by a regex.\n\t *\n\t * @param {String} evt Name of the event to create.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.defineEvent = function defineEvent(evt) {\n\t    this.getListeners(evt);\n\t    return this;\n\t};\n\t\n\t/**\n\t * Uses defineEvent to define multiple events.\n\t *\n\t * @param {String[]} evts An array of event names to define.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.defineEvents = function defineEvents(evts) {\n\t    for (var i = 0; i < evts.length; i += 1) {\n\t        this.defineEvent(evts[i]);\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a listener function from the specified event.\n\t * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to remove the listener from.\n\t * @param {Function} listener Method to remove from the event.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeListener = function removeListener(evt, listener) {\n\t    var listeners = this.getListenersAsObject(evt);\n\t    var index;\n\t    var key;\n\t\n\t    for (key in listeners) {\n\t        if (listeners.hasOwnProperty(key)) {\n\t            index = indexOfListener(listeners[key], listener);\n\t\n\t            if (index !== -1) {\n\t                listeners[key].splice(index, 1);\n\t            }\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of removeListener\n\t */\n\tproto.off = alias('removeListener');\n\t\n\t/**\n\t * Adds listeners in bulk using the manipulateListeners method.\n\t * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n\t * You can also pass it a regular expression to add the array of listeners to all events that match it.\n\t * Yeah, this function does quite a bit. That's probably a bad thing.\n\t *\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to add.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addListeners = function addListeners(evt, listeners) {\n\t    // Pass through to manipulateListeners\n\t    return this.manipulateListeners(false, evt, listeners);\n\t};\n\t\n\t/**\n\t * Removes listeners in bulk using the manipulateListeners method.\n\t * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n\t * You can also pass it an event name and an array of listeners to be removed.\n\t * You can also pass it a regular expression to remove the listeners from all events that match it.\n\t *\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to remove.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeListeners = function removeListeners(evt, listeners) {\n\t    // Pass through to manipulateListeners\n\t    return this.manipulateListeners(true, evt, listeners);\n\t};\n\t\n\t/**\n\t * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n\t * The first argument will determine if the listeners are removed (true) or added (false).\n\t * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n\t * You can also pass it an event name and an array of listeners to be added/removed.\n\t * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n\t *\n\t * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n\t    var i;\n\t    var value;\n\t    var single = remove ? this.removeListener : this.addListener;\n\t    var multiple = remove ? this.removeListeners : this.addListeners;\n\t\n\t    // If evt is an object then pass each of its properties to this method\n\t    if ((typeof evt === 'undefined' ? 'undefined' : _typeof(evt)) === 'object' && !(evt instanceof RegExp)) {\n\t        for (i in evt) {\n\t            if (evt.hasOwnProperty(i) && (value = evt[i])) {\n\t                // Pass the single listener straight through to the singular method\n\t                if (typeof value === 'function') {\n\t                    single.call(this, i, value);\n\t                } else {\n\t                    // Otherwise pass back to the multiple function\n\t                    multiple.call(this, i, value);\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        // So evt must be a string\n\t        // And listeners must be an array of listeners\n\t        // Loop over it and pass each one to the multiple method\n\t        i = listeners.length;\n\t        while (i--) {\n\t            single.call(this, evt, listeners[i]);\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes all listeners from a specified event.\n\t * If you do not specify an event then all listeners will be removed.\n\t * That means every event will be emptied.\n\t * You can also pass a regex to remove all events that match it.\n\t *\n\t * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeEvent = function removeEvent(evt) {\n\t    var type = typeof evt === 'undefined' ? 'undefined' : _typeof(evt);\n\t    var events = this._getEvents();\n\t    var key;\n\t\n\t    // Remove different things depending on the state of evt\n\t    if (type === 'string') {\n\t        // Remove all listeners for the specified event\n\t        delete events[evt];\n\t    } else if (evt instanceof RegExp) {\n\t        // Remove all events matching the regex.\n\t        for (key in events) {\n\t            if (events.hasOwnProperty(key) && evt.test(key)) {\n\t                delete events[key];\n\t            }\n\t        }\n\t    } else {\n\t        // Remove all listeners in all events\n\t        delete this._events;\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of removeEvent.\n\t *\n\t * Added to mirror the node API.\n\t */\n\tproto.removeAllListeners = alias('removeEvent');\n\t\n\t/**\n\t * Emits an event of your choice.\n\t * When emitted, every listener attached to that event will be executed.\n\t * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n\t * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n\t * So they will not arrive within the array on the other side, they will be separate.\n\t * You can also pass a regular expression to emit to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n\t * @param {Array} [args] Optional array of arguments to be passed to each listener.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.emitEvent = function emitEvent(evt, args) {\n\t    var listenersMap = this.getListenersAsObject(evt);\n\t    var listeners;\n\t    var listener;\n\t    var i;\n\t    var key;\n\t    var response;\n\t\n\t    for (key in listenersMap) {\n\t        if (listenersMap.hasOwnProperty(key)) {\n\t            listeners = listenersMap[key].slice(0);\n\t\n\t            for (i = 0; i < listeners.length; i++) {\n\t                // If the listener returns true then it shall be removed from the event\n\t                // The function is executed either with a basic call or an apply if there is an args array\n\t                listener = listeners[i];\n\t\n\t                if (listener.once === true) {\n\t                    this.removeListener(evt, listener.listener);\n\t                }\n\t\n\t                response = listener.listener.apply(this, args || []);\n\t\n\t                if (response === this._getOnceReturnValue()) {\n\t                    this.removeListener(evt, listener.listener);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Alias of emitEvent\n\t */\n\tproto.trigger = alias('emitEvent');\n\t\n\t/**\n\t * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n\t * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n\t * @param {...*} Optional additional arguments to be passed to each listener.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.emit = function emit(evt) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return this.emitEvent(evt, args);\n\t};\n\t\n\t/**\n\t * Sets the current value to check against when executing listeners. If a\n\t * listeners return value matches the one set here then it will be removed\n\t * after execution. This value defaults to true.\n\t *\n\t * @param {*} value The new value to check for when executing listeners.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.setOnceReturnValue = function setOnceReturnValue(value) {\n\t    this._onceReturnValue = value;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Fetches the current value to check against when executing listeners. If\n\t * the listeners return value matches this one then it should be removed\n\t * automatically. It will return true by default.\n\t *\n\t * @return {*|Boolean} The current value to check for or the default, true.\n\t * @api private\n\t */\n\tproto._getOnceReturnValue = function _getOnceReturnValue() {\n\t    if (this.hasOwnProperty('_onceReturnValue')) {\n\t        return this._onceReturnValue;\n\t    } else {\n\t        return true;\n\t    }\n\t};\n\t\n\t/**\n\t * Fetches the events object and creates one if required.\n\t *\n\t * @return {Object} The events storage object.\n\t * @api private\n\t */\n\tproto._getEvents = function _getEvents() {\n\t    return this._events || (this._events = {});\n\t};\n\t\n\texports.default = EventEmitter;\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div>\n    <div class=window>\n        <span data-info=remove class=\"icon-RC_close2 window__button window__button--remove\"></span>\n        <span data-info=resize class=\"icon-RC_status window__button window__button--resize\"></span>\n    </div>\n    \n    <div data-info=phone id=phone class=rc-phone>\n        <div class=\"window window--right\">\n            <span data-info=logout class=\"icon-RC_Logout window__button window__button--logout\"></span>\n        </div>\n        <div data-info=auth-panel id=auth-panel class=auth-panel></div>\n        <div data-info=toolbar id=toolbar></div>\n        <div class=phone-container data-info=container>\n        </div>\n        <div data-info=conversation class=\"panel panel--extra\" id=conversation></div>\n        <div data-info=call-panel class=\"panel panel--extra\" id=call-panel></div>\n        <div data-info=call-panel-incoming class=\"panel panel--extra\" id=call-panel-incoming></div>\n        <div data-info=contact-detail class=\"panel panel--extra\" id=contact-detail></div>\n        <div data-info=notification class=\"panel panel--extra\" id=notification></div>\n    </div>\n</div>","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-phone {\n    position: relative;\n    width: 250px;\n    height: 100%;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    margin: 0 auto;\n    -webkit-transition: height .150s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: height .150s cubic-bezier(0.4, 0.0, 0.2, 1);\n}\n\n.rc-phone > .phone-container {\n    width: 3000px;\n    -webkit-transition: -webkit-transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: -webkit-transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: transform .1s cubic-bezier(0.4, 0.0, 0.2, 1), -webkit-transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n}\n.rc-phone .panel {\n    min-height: 1px;\n}\n.rc-phone .panel--extra {\n    position: absolute;\n    /* extra panel should have the highest z-index */\n    /*z-index: 10;*/\n    left: 0;\n}\n.rc-phone .auth-panel {\n    position: absolute;\n    /* overlap with container */\n    z-index: 5;\n}\n.window {\n    position: absolute;\n    z-index: 5;\n    top: 12px;\n    left: 12px;\n    /* need some space to fit the icon font */\n    padding-right: 2px\n}\n.window__button {\n    width: 12px;\n    height: 12px;\n    cursor: pointer;\n}\n.window__button--remove {\n    color: #E57373;\n}\n.window__button--resize {\n    color: #FFD740;\n}\n.window__button--logout {}\n.window--right {\n    left: auto;\n    right: 3px;\n    z-index: 2;\n}\n","imports":{"scripts":["https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['time-line-item'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction _interopRequireDefault(t) {\n\t  return t && t.__esModule ? t : { default: t };\n\t}function _pad(t) {\n\t  return t < 100 ? \"0\" + t : t;\n\t}function _ignoreLeadingPlus(t) {\n\t  return 0 === t.indexOf(\"+\") ? t.substring(1) : t;\n\t}var _moment = __webpack_require__(2),\n\t    _moment2 = _interopRequireDefault(_moment);w.register(function () {\n\t  this.actions = { init: { after: function after() {\n\t        this.props.selectedMessage = null, this.props.content = null, this.props.contact = null, this.props.time = null, this.props.subject = null, this.props.count = 0, this.fillData(this.data), this.root.firstChild.style.opacity = 0, this.root.firstChild.style.transform = \"translateY(20px)\", this.root.firstChild.style[\"transition-delay\"] = \".\" + _pad(this.data.showingDelay || 0) + \"s\";\n\t      } }, mount: { after: function after() {\n\t        var t = this;setTimeout(function () {\n\t          t.root.firstChild.style.opacity = 1, t.root.firstChild.style.transform = \"translateY(0px)\";\n\t        }, 17);\n\t      } }, fillData: { before: function before() {\n\t        this.root.style[\"background-color\"] = \"#eee\";\n\t      }, method: function method(t, e) {\n\t        var i = this;this.props.content = e, this.props.subject = e.subject;new Date(e.time);if (\"SMS\" === e.type ? this.dom.icon.classList.add(\"icon-uni2487\") : \"Voice\" === e.type ? (\"Outbound\" === e.direction ? this.dom.icon.classList.add(\"icon-uniC5\") : this.dom.icon.classList.add(\"icon-uniC4\"), this.dom.subject.classList.add(\"display-none\"), !this.props.subject || \"Automatic\" !== this.props.subject.type && \"OnDemand\" !== this.props.subject.type || (this.props.subject = \"Call recording\")) : \"Pager\" === e.type ? this.dom.icon.classList.add(\"icon-uniCB\") : \"VoiceMail\" === e.type ? (this.dom.icon.classList.add(\"icon-uniA7\"), this.props.subject = \"Call recording\", this.dom.subject.classList.add(\"display-none\")) : \"Fax\" === e.type && (this.dom.icon.classList.add(\"icon-uniCB\"), this.props.subject = \"Fax\", this.dom.subject.classList.add(\"display-none\")), this.dom.subject.textContent = this.props.subject, e.contact && (this.dom.contact.textContent = this.props.contact = _ignoreLeadingPlus(e.contact.displayName)), (0, _moment2.default)().diff((0, _moment2.default)(e.time), \"days\") < 1 ? this.dom.time.textContent = this.props.time = (0, _moment2.default)(e.time).fromNow() : (0, _moment2.default)().diff((0, _moment2.default)(e.time), \"days\") < 2 ? this.dom.time.textContent = this.props.time = (0, _moment2.default)(e.time).calendar() : this.dom.time.textContent = this.props.time = (0, _moment2.default)(e.time).format(\"LLL\"), e.others && e.others.length > 0) {\n\t          this.dom[\"count-wrapper\"].classList.remove(\"display-none\");for (var s; this.dom.collapse.firstChild;) {\n\t            this.dom.collapse.removeChild(this.dom.collapse.firstChild);\n\t          }e.others.forEach(function (t) {\n\t            var e = new Date(t.time),\n\t                o = document.createElement(\"div\"),\n\t                n = e.getMonth() + 1,\n\t                a = e.getDate(),\n\t                c = \"\",\n\t                r = a > s ? n + \"/\" + a + \",\" : \"\";\"SMS\" === t.type ? c = t.subject : \"Voice\" === t.type ? c = !t.subject || \"Automatic\" !== t.subject.type && \"OnDemand\" !== t.subject.type ? t.subject : \"Call recording\" : \"Pager\" === t.type ? c = t.subject : \"VoiceMail\" === t.type ? c = \"Call recording\" : \"Fax\" === t.type && (c = \"Fax\"), o.innerHTML = \"<div class='timeline-extra clearfix'>\\n                            <div class='timeline-extra__content'>\" + c + \"</div>\\n                            <div class='rc-timeline-item__time'>\\n                                \" + r + \" \\n                                \" + e.getHours() + \":\" + e.getMinutes() + \":\" + e.getSeconds() + \"\\n                            </div>\\n                        </div>\", o.firstChild.addEventListener(\"click\", function (e) {\n\t              e.stopPropagation(), i.enter(t);\n\t            }), s = a, i.dom.collapse.appendChild(o.firstChild);\n\t          });\n\t        }\n\t      }, after: function after(t) {\n\t        var e = this;setTimeout(function () {\n\t          return e.root.style[\"background-color\"] = \"#fff\";\n\t        }, 1e3);\n\t      } }, collapse: { after: function after() {\n\t        var t = this.dom.collapse;if (!t.classList.contains(\"--collapsing\")) if (t.classList.contains(\"--active\")) t.style.height = getComputedStyle(t).height, t.offsetWidth, t.style.height = \"0px\", t.classList.remove(\"--active\"), t.classList.add(\"--collapsing\"), t.addEventListener(\"transitionend\", function e(i) {\n\t          \"height\" == i.propertyName && (t.classList.remove(\"--collapsing\"), t.removeEventListener(\"transitionend\", e, !1));\n\t        }, !1);else {\n\t          var e = t.style.height;t.style.height = \"auto\";var i = getComputedStyle(t).height;t.style.height = e, t.offsetWidth, t.style.height = i, t.classList.add(\"--collapsing\"), t.addEventListener(\"transitionend\", function e(i) {\n\t            \"height\" == i.propertyName && (t.style.transition = \"\", t.style.height = \"auto\", t.classList.remove(\"--collapsing\"), t.removeEventListener(\"transitionend\", e, !1));\n\t          }, !1), t.classList.add(\"--active\");\n\t        }\n\t      } }, enter: { method: function method(t, e) {\n\t        e && (this.props.selectedMessage = e);\n\t      } } }, this.on(\"click\", function (t) {\n\t    this.enter();\n\t  });\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {//! moment.js\n\t//! version : 2.14.1\n\t//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n\t//! license : MIT\n\t//! momentjs.com\n\t\n\t;(function (global, factory) {\n\t     true ? module.exports = factory() :\n\t    typeof define === 'function' && define.amd ? define(factory) :\n\t    global.moment = factory()\n\t}(this, function () { 'use strict';\n\t\n\t    var hookCallback;\n\t\n\t    function utils_hooks__hooks () {\n\t        return hookCallback.apply(null, arguments);\n\t    }\n\t\n\t    // This is done to register the method called with moment()\n\t    // without creating circular dependencies.\n\t    function setHookCallback (callback) {\n\t        hookCallback = callback;\n\t    }\n\t\n\t    function isArray(input) {\n\t        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n\t    }\n\t\n\t    function isObject(input) {\n\t        return Object.prototype.toString.call(input) === '[object Object]';\n\t    }\n\t\n\t    function isObjectEmpty(obj) {\n\t        var k;\n\t        for (k in obj) {\n\t            // even if its not own property I'd still call it non-empty\n\t            return false;\n\t        }\n\t        return true;\n\t    }\n\t\n\t    function isDate(input) {\n\t        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n\t    }\n\t\n\t    function map(arr, fn) {\n\t        var res = [], i;\n\t        for (i = 0; i < arr.length; ++i) {\n\t            res.push(fn(arr[i], i));\n\t        }\n\t        return res;\n\t    }\n\t\n\t    function hasOwnProp(a, b) {\n\t        return Object.prototype.hasOwnProperty.call(a, b);\n\t    }\n\t\n\t    function extend(a, b) {\n\t        for (var i in b) {\n\t            if (hasOwnProp(b, i)) {\n\t                a[i] = b[i];\n\t            }\n\t        }\n\t\n\t        if (hasOwnProp(b, 'toString')) {\n\t            a.toString = b.toString;\n\t        }\n\t\n\t        if (hasOwnProp(b, 'valueOf')) {\n\t            a.valueOf = b.valueOf;\n\t        }\n\t\n\t        return a;\n\t    }\n\t\n\t    function create_utc__createUTC (input, format, locale, strict) {\n\t        return createLocalOrUTC(input, format, locale, strict, true).utc();\n\t    }\n\t\n\t    function defaultParsingFlags() {\n\t        // We need to deep clone this object.\n\t        return {\n\t            empty           : false,\n\t            unusedTokens    : [],\n\t            unusedInput     : [],\n\t            overflow        : -2,\n\t            charsLeftOver   : 0,\n\t            nullInput       : false,\n\t            invalidMonth    : null,\n\t            invalidFormat   : false,\n\t            userInvalidated : false,\n\t            iso             : false,\n\t            parsedDateParts : [],\n\t            meridiem        : null\n\t        };\n\t    }\n\t\n\t    function getParsingFlags(m) {\n\t        if (m._pf == null) {\n\t            m._pf = defaultParsingFlags();\n\t        }\n\t        return m._pf;\n\t    }\n\t\n\t    var some;\n\t    if (Array.prototype.some) {\n\t        some = Array.prototype.some;\n\t    } else {\n\t        some = function (fun) {\n\t            var t = Object(this);\n\t            var len = t.length >>> 0;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                if (i in t && fun.call(this, t[i], i, t)) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            return false;\n\t        };\n\t    }\n\t\n\t    function valid__isValid(m) {\n\t        if (m._isValid == null) {\n\t            var flags = getParsingFlags(m);\n\t            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n\t                return i != null;\n\t            });\n\t            m._isValid = !isNaN(m._d.getTime()) &&\n\t                flags.overflow < 0 &&\n\t                !flags.empty &&\n\t                !flags.invalidMonth &&\n\t                !flags.invalidWeekday &&\n\t                !flags.nullInput &&\n\t                !flags.invalidFormat &&\n\t                !flags.userInvalidated &&\n\t                (!flags.meridiem || (flags.meridiem && parsedParts));\n\t\n\t            if (m._strict) {\n\t                m._isValid = m._isValid &&\n\t                    flags.charsLeftOver === 0 &&\n\t                    flags.unusedTokens.length === 0 &&\n\t                    flags.bigHour === undefined;\n\t            }\n\t        }\n\t        return m._isValid;\n\t    }\n\t\n\t    function valid__createInvalid (flags) {\n\t        var m = create_utc__createUTC(NaN);\n\t        if (flags != null) {\n\t            extend(getParsingFlags(m), flags);\n\t        }\n\t        else {\n\t            getParsingFlags(m).userInvalidated = true;\n\t        }\n\t\n\t        return m;\n\t    }\n\t\n\t    function isUndefined(input) {\n\t        return input === void 0;\n\t    }\n\t\n\t    // Plugins that add properties should also add the key here (null value),\n\t    // so we can properly clone ourselves.\n\t    var momentProperties = utils_hooks__hooks.momentProperties = [];\n\t\n\t    function copyConfig(to, from) {\n\t        var i, prop, val;\n\t\n\t        if (!isUndefined(from._isAMomentObject)) {\n\t            to._isAMomentObject = from._isAMomentObject;\n\t        }\n\t        if (!isUndefined(from._i)) {\n\t            to._i = from._i;\n\t        }\n\t        if (!isUndefined(from._f)) {\n\t            to._f = from._f;\n\t        }\n\t        if (!isUndefined(from._l)) {\n\t            to._l = from._l;\n\t        }\n\t        if (!isUndefined(from._strict)) {\n\t            to._strict = from._strict;\n\t        }\n\t        if (!isUndefined(from._tzm)) {\n\t            to._tzm = from._tzm;\n\t        }\n\t        if (!isUndefined(from._isUTC)) {\n\t            to._isUTC = from._isUTC;\n\t        }\n\t        if (!isUndefined(from._offset)) {\n\t            to._offset = from._offset;\n\t        }\n\t        if (!isUndefined(from._pf)) {\n\t            to._pf = getParsingFlags(from);\n\t        }\n\t        if (!isUndefined(from._locale)) {\n\t            to._locale = from._locale;\n\t        }\n\t\n\t        if (momentProperties.length > 0) {\n\t            for (i in momentProperties) {\n\t                prop = momentProperties[i];\n\t                val = from[prop];\n\t                if (!isUndefined(val)) {\n\t                    to[prop] = val;\n\t                }\n\t            }\n\t        }\n\t\n\t        return to;\n\t    }\n\t\n\t    var updateInProgress = false;\n\t\n\t    // Moment prototype object\n\t    function Moment(config) {\n\t        copyConfig(this, config);\n\t        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n\t        // Prevent infinite loop in case updateOffset creates new moment\n\t        // objects.\n\t        if (updateInProgress === false) {\n\t            updateInProgress = true;\n\t            utils_hooks__hooks.updateOffset(this);\n\t            updateInProgress = false;\n\t        }\n\t    }\n\t\n\t    function isMoment (obj) {\n\t        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n\t    }\n\t\n\t    function absFloor (number) {\n\t        if (number < 0) {\n\t            // -0 -> 0\n\t            return Math.ceil(number) || 0;\n\t        } else {\n\t            return Math.floor(number);\n\t        }\n\t    }\n\t\n\t    function toInt(argumentForCoercion) {\n\t        var coercedNumber = +argumentForCoercion,\n\t            value = 0;\n\t\n\t        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n\t            value = absFloor(coercedNumber);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    // compare two arrays, return the number of differences\n\t    function compareArrays(array1, array2, dontConvert) {\n\t        var len = Math.min(array1.length, array2.length),\n\t            lengthDiff = Math.abs(array1.length - array2.length),\n\t            diffs = 0,\n\t            i;\n\t        for (i = 0; i < len; i++) {\n\t            if ((dontConvert && array1[i] !== array2[i]) ||\n\t                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n\t                diffs++;\n\t            }\n\t        }\n\t        return diffs + lengthDiff;\n\t    }\n\t\n\t    function warn(msg) {\n\t        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&\n\t                (typeof console !==  'undefined') && console.warn) {\n\t            console.warn('Deprecation warning: ' + msg);\n\t        }\n\t    }\n\t\n\t    function deprecate(msg, fn) {\n\t        var firstTime = true;\n\t\n\t        return extend(function () {\n\t            if (utils_hooks__hooks.deprecationHandler != null) {\n\t                utils_hooks__hooks.deprecationHandler(null, msg);\n\t            }\n\t            if (firstTime) {\n\t                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\\n' + (new Error()).stack);\n\t                firstTime = false;\n\t            }\n\t            return fn.apply(this, arguments);\n\t        }, fn);\n\t    }\n\t\n\t    var deprecations = {};\n\t\n\t    function deprecateSimple(name, msg) {\n\t        if (utils_hooks__hooks.deprecationHandler != null) {\n\t            utils_hooks__hooks.deprecationHandler(name, msg);\n\t        }\n\t        if (!deprecations[name]) {\n\t            warn(msg);\n\t            deprecations[name] = true;\n\t        }\n\t    }\n\t\n\t    utils_hooks__hooks.suppressDeprecationWarnings = false;\n\t    utils_hooks__hooks.deprecationHandler = null;\n\t\n\t    function isFunction(input) {\n\t        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n\t    }\n\t\n\t    function locale_set__set (config) {\n\t        var prop, i;\n\t        for (i in config) {\n\t            prop = config[i];\n\t            if (isFunction(prop)) {\n\t                this[i] = prop;\n\t            } else {\n\t                this['_' + i] = prop;\n\t            }\n\t        }\n\t        this._config = config;\n\t        // Lenient ordinal parsing accepts just a number in addition to\n\t        // number + (possibly) stuff coming from _ordinalParseLenient.\n\t        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\\d{1,2}/).source);\n\t    }\n\t\n\t    function mergeConfigs(parentConfig, childConfig) {\n\t        var res = extend({}, parentConfig), prop;\n\t        for (prop in childConfig) {\n\t            if (hasOwnProp(childConfig, prop)) {\n\t                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n\t                    res[prop] = {};\n\t                    extend(res[prop], parentConfig[prop]);\n\t                    extend(res[prop], childConfig[prop]);\n\t                } else if (childConfig[prop] != null) {\n\t                    res[prop] = childConfig[prop];\n\t                } else {\n\t                    delete res[prop];\n\t                }\n\t            }\n\t        }\n\t        for (prop in parentConfig) {\n\t            if (hasOwnProp(parentConfig, prop) &&\n\t                    !hasOwnProp(childConfig, prop) &&\n\t                    isObject(parentConfig[prop])) {\n\t                // make sure changes to properties don't modify parent config\n\t                res[prop] = extend({}, res[prop]);\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t\n\t    function Locale(config) {\n\t        if (config != null) {\n\t            this.set(config);\n\t        }\n\t    }\n\t\n\t    var keys;\n\t\n\t    if (Object.keys) {\n\t        keys = Object.keys;\n\t    } else {\n\t        keys = function (obj) {\n\t            var i, res = [];\n\t            for (i in obj) {\n\t                if (hasOwnProp(obj, i)) {\n\t                    res.push(i);\n\t                }\n\t            }\n\t            return res;\n\t        };\n\t    }\n\t\n\t    var defaultCalendar = {\n\t        sameDay : '[Today at] LT',\n\t        nextDay : '[Tomorrow at] LT',\n\t        nextWeek : 'dddd [at] LT',\n\t        lastDay : '[Yesterday at] LT',\n\t        lastWeek : '[Last] dddd [at] LT',\n\t        sameElse : 'L'\n\t    };\n\t\n\t    function locale_calendar__calendar (key, mom, now) {\n\t        var output = this._calendar[key] || this._calendar['sameElse'];\n\t        return isFunction(output) ? output.call(mom, now) : output;\n\t    }\n\t\n\t    var defaultLongDateFormat = {\n\t        LTS  : 'h:mm:ss A',\n\t        LT   : 'h:mm A',\n\t        L    : 'MM/DD/YYYY',\n\t        LL   : 'MMMM D, YYYY',\n\t        LLL  : 'MMMM D, YYYY h:mm A',\n\t        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n\t    };\n\t\n\t    function longDateFormat (key) {\n\t        var format = this._longDateFormat[key],\n\t            formatUpper = this._longDateFormat[key.toUpperCase()];\n\t\n\t        if (format || !formatUpper) {\n\t            return format;\n\t        }\n\t\n\t        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n\t            return val.slice(1);\n\t        });\n\t\n\t        return this._longDateFormat[key];\n\t    }\n\t\n\t    var defaultInvalidDate = 'Invalid date';\n\t\n\t    function invalidDate () {\n\t        return this._invalidDate;\n\t    }\n\t\n\t    var defaultOrdinal = '%d';\n\t    var defaultOrdinalParse = /\\d{1,2}/;\n\t\n\t    function ordinal (number) {\n\t        return this._ordinal.replace('%d', number);\n\t    }\n\t\n\t    var defaultRelativeTime = {\n\t        future : 'in %s',\n\t        past   : '%s ago',\n\t        s  : 'a few seconds',\n\t        m  : 'a minute',\n\t        mm : '%d minutes',\n\t        h  : 'an hour',\n\t        hh : '%d hours',\n\t        d  : 'a day',\n\t        dd : '%d days',\n\t        M  : 'a month',\n\t        MM : '%d months',\n\t        y  : 'a year',\n\t        yy : '%d years'\n\t    };\n\t\n\t    function relative__relativeTime (number, withoutSuffix, string, isFuture) {\n\t        var output = this._relativeTime[string];\n\t        return (isFunction(output)) ?\n\t            output(number, withoutSuffix, string, isFuture) :\n\t            output.replace(/%d/i, number);\n\t    }\n\t\n\t    function pastFuture (diff, output) {\n\t        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n\t        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n\t    }\n\t\n\t    var aliases = {};\n\t\n\t    function addUnitAlias (unit, shorthand) {\n\t        var lowerCase = unit.toLowerCase();\n\t        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n\t    }\n\t\n\t    function normalizeUnits(units) {\n\t        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n\t    }\n\t\n\t    function normalizeObjectUnits(inputObject) {\n\t        var normalizedInput = {},\n\t            normalizedProp,\n\t            prop;\n\t\n\t        for (prop in inputObject) {\n\t            if (hasOwnProp(inputObject, prop)) {\n\t                normalizedProp = normalizeUnits(prop);\n\t                if (normalizedProp) {\n\t                    normalizedInput[normalizedProp] = inputObject[prop];\n\t                }\n\t            }\n\t        }\n\t\n\t        return normalizedInput;\n\t    }\n\t\n\t    var priorities = {};\n\t\n\t    function addUnitPriority(unit, priority) {\n\t        priorities[unit] = priority;\n\t    }\n\t\n\t    function getPrioritizedUnits(unitsObj) {\n\t        var units = [];\n\t        for (var u in unitsObj) {\n\t            units.push({unit: u, priority: priorities[u]});\n\t        }\n\t        units.sort(function (a, b) {\n\t            return a.priority - b.priority;\n\t        });\n\t        return units;\n\t    }\n\t\n\t    function makeGetSet (unit, keepTime) {\n\t        return function (value) {\n\t            if (value != null) {\n\t                get_set__set(this, unit, value);\n\t                utils_hooks__hooks.updateOffset(this, keepTime);\n\t                return this;\n\t            } else {\n\t                return get_set__get(this, unit);\n\t            }\n\t        };\n\t    }\n\t\n\t    function get_set__get (mom, unit) {\n\t        return mom.isValid() ?\n\t            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n\t    }\n\t\n\t    function get_set__set (mom, unit, value) {\n\t        if (mom.isValid()) {\n\t            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n\t        }\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function stringGet (units) {\n\t        units = normalizeUnits(units);\n\t        if (isFunction(this[units])) {\n\t            return this[units]();\n\t        }\n\t        return this;\n\t    }\n\t\n\t\n\t    function stringSet (units, value) {\n\t        if (typeof units === 'object') {\n\t            units = normalizeObjectUnits(units);\n\t            var prioritized = getPrioritizedUnits(units);\n\t            for (var i = 0; i < prioritized.length; i++) {\n\t                this[prioritized[i].unit](units[prioritized[i].unit]);\n\t            }\n\t        } else {\n\t            units = normalizeUnits(units);\n\t            if (isFunction(this[units])) {\n\t                return this[units](value);\n\t            }\n\t        }\n\t        return this;\n\t    }\n\t\n\t    function zeroFill(number, targetLength, forceSign) {\n\t        var absNumber = '' + Math.abs(number),\n\t            zerosToFill = targetLength - absNumber.length,\n\t            sign = number >= 0;\n\t        return (sign ? (forceSign ? '+' : '') : '-') +\n\t            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n\t    }\n\t\n\t    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\t\n\t    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\t\n\t    var formatFunctions = {};\n\t\n\t    var formatTokenFunctions = {};\n\t\n\t    // token:    'M'\n\t    // padded:   ['MM', 2]\n\t    // ordinal:  'Mo'\n\t    // callback: function () { this.month() + 1 }\n\t    function addFormatToken (token, padded, ordinal, callback) {\n\t        var func = callback;\n\t        if (typeof callback === 'string') {\n\t            func = function () {\n\t                return this[callback]();\n\t            };\n\t        }\n\t        if (token) {\n\t            formatTokenFunctions[token] = func;\n\t        }\n\t        if (padded) {\n\t            formatTokenFunctions[padded[0]] = function () {\n\t                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n\t            };\n\t        }\n\t        if (ordinal) {\n\t            formatTokenFunctions[ordinal] = function () {\n\t                return this.localeData().ordinal(func.apply(this, arguments), token);\n\t            };\n\t        }\n\t    }\n\t\n\t    function removeFormattingTokens(input) {\n\t        if (input.match(/\\[[\\s\\S]/)) {\n\t            return input.replace(/^\\[|\\]$/g, '');\n\t        }\n\t        return input.replace(/\\\\/g, '');\n\t    }\n\t\n\t    function makeFormatFunction(format) {\n\t        var array = format.match(formattingTokens), i, length;\n\t\n\t        for (i = 0, length = array.length; i < length; i++) {\n\t            if (formatTokenFunctions[array[i]]) {\n\t                array[i] = formatTokenFunctions[array[i]];\n\t            } else {\n\t                array[i] = removeFormattingTokens(array[i]);\n\t            }\n\t        }\n\t\n\t        return function (mom) {\n\t            var output = '', i;\n\t            for (i = 0; i < length; i++) {\n\t                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\n\t            }\n\t            return output;\n\t        };\n\t    }\n\t\n\t    // format date using native date object\n\t    function formatMoment(m, format) {\n\t        if (!m.isValid()) {\n\t            return m.localeData().invalidDate();\n\t        }\n\t\n\t        format = expandFormat(format, m.localeData());\n\t        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\t\n\t        return formatFunctions[format](m);\n\t    }\n\t\n\t    function expandFormat(format, locale) {\n\t        var i = 5;\n\t\n\t        function replaceLongDateFormatTokens(input) {\n\t            return locale.longDateFormat(input) || input;\n\t        }\n\t\n\t        localFormattingTokens.lastIndex = 0;\n\t        while (i >= 0 && localFormattingTokens.test(format)) {\n\t            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n\t            localFormattingTokens.lastIndex = 0;\n\t            i -= 1;\n\t        }\n\t\n\t        return format;\n\t    }\n\t\n\t    var match1         = /\\d/;            //       0 - 9\n\t    var match2         = /\\d\\d/;          //      00 - 99\n\t    var match3         = /\\d{3}/;         //     000 - 999\n\t    var match4         = /\\d{4}/;         //    0000 - 9999\n\t    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n\t    var match1to2      = /\\d\\d?/;         //       0 - 99\n\t    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n\t    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n\t    var match1to3      = /\\d{1,3}/;       //       0 - 999\n\t    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n\t    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\t\n\t    var matchUnsigned  = /\\d+/;           //       0 - inf\n\t    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\t\n\t    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n\t    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\t\n\t    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\t\n\t    // any word (or two) characters or numbers including two/three word month in arabic.\n\t    // includes scottish gaelic two word and hyphenated months\n\t    var matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\t\n\t\n\t    var regexes = {};\n\t\n\t    function addRegexToken (token, regex, strictRegex) {\n\t        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n\t            return (isStrict && strictRegex) ? strictRegex : regex;\n\t        };\n\t    }\n\t\n\t    function getParseRegexForToken (token, config) {\n\t        if (!hasOwnProp(regexes, token)) {\n\t            return new RegExp(unescapeFormat(token));\n\t        }\n\t\n\t        return regexes[token](config._strict, config._locale);\n\t    }\n\t\n\t    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n\t    function unescapeFormat(s) {\n\t        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n\t            return p1 || p2 || p3 || p4;\n\t        }));\n\t    }\n\t\n\t    function regexEscape(s) {\n\t        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\t    }\n\t\n\t    var tokens = {};\n\t\n\t    function addParseToken (token, callback) {\n\t        var i, func = callback;\n\t        if (typeof token === 'string') {\n\t            token = [token];\n\t        }\n\t        if (typeof callback === 'number') {\n\t            func = function (input, array) {\n\t                array[callback] = toInt(input);\n\t            };\n\t        }\n\t        for (i = 0; i < token.length; i++) {\n\t            tokens[token[i]] = func;\n\t        }\n\t    }\n\t\n\t    function addWeekParseToken (token, callback) {\n\t        addParseToken(token, function (input, array, config, token) {\n\t            config._w = config._w || {};\n\t            callback(input, config._w, config, token);\n\t        });\n\t    }\n\t\n\t    function addTimeToArrayFromToken(token, input, config) {\n\t        if (input != null && hasOwnProp(tokens, token)) {\n\t            tokens[token](input, config._a, config, token);\n\t        }\n\t    }\n\t\n\t    var YEAR = 0;\n\t    var MONTH = 1;\n\t    var DATE = 2;\n\t    var HOUR = 3;\n\t    var MINUTE = 4;\n\t    var SECOND = 5;\n\t    var MILLISECOND = 6;\n\t    var WEEK = 7;\n\t    var WEEKDAY = 8;\n\t\n\t    var indexOf;\n\t\n\t    if (Array.prototype.indexOf) {\n\t        indexOf = Array.prototype.indexOf;\n\t    } else {\n\t        indexOf = function (o) {\n\t            // I know\n\t            var i;\n\t            for (i = 0; i < this.length; ++i) {\n\t                if (this[i] === o) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t    }\n\t\n\t    function daysInMonth(year, month) {\n\t        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('M', ['MM', 2], 'Mo', function () {\n\t        return this.month() + 1;\n\t    });\n\t\n\t    addFormatToken('MMM', 0, 0, function (format) {\n\t        return this.localeData().monthsShort(this, format);\n\t    });\n\t\n\t    addFormatToken('MMMM', 0, 0, function (format) {\n\t        return this.localeData().months(this, format);\n\t    });\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('month', 'M');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('month', 8);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('M',    match1to2);\n\t    addRegexToken('MM',   match1to2, match2);\n\t    addRegexToken('MMM',  function (isStrict, locale) {\n\t        return locale.monthsShortRegex(isStrict);\n\t    });\n\t    addRegexToken('MMMM', function (isStrict, locale) {\n\t        return locale.monthsRegex(isStrict);\n\t    });\n\t\n\t    addParseToken(['M', 'MM'], function (input, array) {\n\t        array[MONTH] = toInt(input) - 1;\n\t    });\n\t\n\t    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n\t        var month = config._locale.monthsParse(input, token, config._strict);\n\t        // if we didn't find a month name, mark the date as invalid.\n\t        if (month != null) {\n\t            array[MONTH] = month;\n\t        } else {\n\t            getParsingFlags(config).invalidMonth = input;\n\t        }\n\t    });\n\t\n\t    // LOCALES\n\t\n\t    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?/;\n\t    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n\t    function localeMonths (m, format) {\n\t        return isArray(this._months) ? this._months[m.month()] :\n\t            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n\t    }\n\t\n\t    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n\t    function localeMonthsShort (m, format) {\n\t        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n\t            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n\t    }\n\t\n\t    function units_month__handleStrictParse(monthName, format, strict) {\n\t        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n\t        if (!this._monthsParse) {\n\t            // this is not used\n\t            this._monthsParse = [];\n\t            this._longMonthsParse = [];\n\t            this._shortMonthsParse = [];\n\t            for (i = 0; i < 12; ++i) {\n\t                mom = create_utc__createUTC([2000, i]);\n\t                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n\t                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n\t            }\n\t        }\n\t\n\t        if (strict) {\n\t            if (format === 'MMM') {\n\t                ii = indexOf.call(this._shortMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._longMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        } else {\n\t            if (format === 'MMM') {\n\t                ii = indexOf.call(this._shortMonthsParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._longMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._longMonthsParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._shortMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        }\n\t    }\n\t\n\t    function localeMonthsParse (monthName, format, strict) {\n\t        var i, mom, regex;\n\t\n\t        if (this._monthsParseExact) {\n\t            return units_month__handleStrictParse.call(this, monthName, format, strict);\n\t        }\n\t\n\t        if (!this._monthsParse) {\n\t            this._monthsParse = [];\n\t            this._longMonthsParse = [];\n\t            this._shortMonthsParse = [];\n\t        }\n\t\n\t        // TODO: add sorting\n\t        // Sorting makes sure if one month (or abbr) is a prefix of another\n\t        // see sorting in computeMonthsParse\n\t        for (i = 0; i < 12; i++) {\n\t            // make the regex if we don't have it already\n\t            mom = create_utc__createUTC([2000, i]);\n\t            if (strict && !this._longMonthsParse[i]) {\n\t                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n\t                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n\t            }\n\t            if (!strict && !this._monthsParse[i]) {\n\t                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n\t                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n\t            }\n\t            // test the regex\n\t            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n\t                return i;\n\t            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n\t                return i;\n\t            } else if (!strict && this._monthsParse[i].test(monthName)) {\n\t                return i;\n\t            }\n\t        }\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function setMonth (mom, value) {\n\t        var dayOfMonth;\n\t\n\t        if (!mom.isValid()) {\n\t            // No op\n\t            return mom;\n\t        }\n\t\n\t        if (typeof value === 'string') {\n\t            if (/^\\d+$/.test(value)) {\n\t                value = toInt(value);\n\t            } else {\n\t                value = mom.localeData().monthsParse(value);\n\t                // TODO: Another silent failure?\n\t                if (typeof value !== 'number') {\n\t                    return mom;\n\t                }\n\t            }\n\t        }\n\t\n\t        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n\t        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n\t        return mom;\n\t    }\n\t\n\t    function getSetMonth (value) {\n\t        if (value != null) {\n\t            setMonth(this, value);\n\t            utils_hooks__hooks.updateOffset(this, true);\n\t            return this;\n\t        } else {\n\t            return get_set__get(this, 'Month');\n\t        }\n\t    }\n\t\n\t    function getDaysInMonth () {\n\t        return daysInMonth(this.year(), this.month());\n\t    }\n\t\n\t    var defaultMonthsShortRegex = matchWord;\n\t    function monthsShortRegex (isStrict) {\n\t        if (this._monthsParseExact) {\n\t            if (!hasOwnProp(this, '_monthsRegex')) {\n\t                computeMonthsParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._monthsShortStrictRegex;\n\t            } else {\n\t                return this._monthsShortRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_monthsShortRegex')) {\n\t                this._monthsShortRegex = defaultMonthsShortRegex;\n\t            }\n\t            return this._monthsShortStrictRegex && isStrict ?\n\t                this._monthsShortStrictRegex : this._monthsShortRegex;\n\t        }\n\t    }\n\t\n\t    var defaultMonthsRegex = matchWord;\n\t    function monthsRegex (isStrict) {\n\t        if (this._monthsParseExact) {\n\t            if (!hasOwnProp(this, '_monthsRegex')) {\n\t                computeMonthsParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._monthsStrictRegex;\n\t            } else {\n\t                return this._monthsRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_monthsRegex')) {\n\t                this._monthsRegex = defaultMonthsRegex;\n\t            }\n\t            return this._monthsStrictRegex && isStrict ?\n\t                this._monthsStrictRegex : this._monthsRegex;\n\t        }\n\t    }\n\t\n\t    function computeMonthsParse () {\n\t        function cmpLenRev(a, b) {\n\t            return b.length - a.length;\n\t        }\n\t\n\t        var shortPieces = [], longPieces = [], mixedPieces = [],\n\t            i, mom;\n\t        for (i = 0; i < 12; i++) {\n\t            // make the regex if we don't have it already\n\t            mom = create_utc__createUTC([2000, i]);\n\t            shortPieces.push(this.monthsShort(mom, ''));\n\t            longPieces.push(this.months(mom, ''));\n\t            mixedPieces.push(this.months(mom, ''));\n\t            mixedPieces.push(this.monthsShort(mom, ''));\n\t        }\n\t        // Sorting makes sure if one month (or abbr) is a prefix of another it\n\t        // will match the longer piece.\n\t        shortPieces.sort(cmpLenRev);\n\t        longPieces.sort(cmpLenRev);\n\t        mixedPieces.sort(cmpLenRev);\n\t        for (i = 0; i < 12; i++) {\n\t            shortPieces[i] = regexEscape(shortPieces[i]);\n\t            longPieces[i] = regexEscape(longPieces[i]);\n\t        }\n\t        for (i = 0; i < 24; i++) {\n\t            mixedPieces[i] = regexEscape(mixedPieces[i]);\n\t        }\n\t\n\t        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n\t        this._monthsShortRegex = this._monthsRegex;\n\t        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n\t        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('Y', 0, 0, function () {\n\t        var y = this.year();\n\t        return y <= 9999 ? '' + y : '+' + y;\n\t    });\n\t\n\t    addFormatToken(0, ['YY', 2], 0, function () {\n\t        return this.year() % 100;\n\t    });\n\t\n\t    addFormatToken(0, ['YYYY',   4],       0, 'year');\n\t    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n\t    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('year', 'y');\n\t\n\t    // PRIORITIES\n\t\n\t    addUnitPriority('year', 1);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('Y',      matchSigned);\n\t    addRegexToken('YY',     match1to2, match2);\n\t    addRegexToken('YYYY',   match1to4, match4);\n\t    addRegexToken('YYYYY',  match1to6, match6);\n\t    addRegexToken('YYYYYY', match1to6, match6);\n\t\n\t    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n\t    addParseToken('YYYY', function (input, array) {\n\t        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);\n\t    });\n\t    addParseToken('YY', function (input, array) {\n\t        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);\n\t    });\n\t    addParseToken('Y', function (input, array) {\n\t        array[YEAR] = parseInt(input, 10);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    function daysInYear(year) {\n\t        return isLeapYear(year) ? 366 : 365;\n\t    }\n\t\n\t    function isLeapYear(year) {\n\t        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n\t    }\n\t\n\t    // HOOKS\n\t\n\t    utils_hooks__hooks.parseTwoDigitYear = function (input) {\n\t        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n\t    };\n\t\n\t    // MOMENTS\n\t\n\t    var getSetYear = makeGetSet('FullYear', true);\n\t\n\t    function getIsLeapYear () {\n\t        return isLeapYear(this.year());\n\t    }\n\t\n\t    function createDate (y, m, d, h, M, s, ms) {\n\t        //can't just apply() to create a date:\n\t        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\n\t        var date = new Date(y, m, d, h, M, s, ms);\n\t\n\t        //the date constructor remaps years 0-99 to 1900-1999\n\t        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n\t            date.setFullYear(y);\n\t        }\n\t        return date;\n\t    }\n\t\n\t    function createUTCDate (y) {\n\t        var date = new Date(Date.UTC.apply(null, arguments));\n\t\n\t        //the Date.UTC function remaps years 0-99 to 1900-1999\n\t        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n\t            date.setUTCFullYear(y);\n\t        }\n\t        return date;\n\t    }\n\t\n\t    // start-of-first-week - start-of-year\n\t    function firstWeekOffset(year, dow, doy) {\n\t        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n\t            fwd = 7 + dow - doy,\n\t            // first-week day local weekday -- which local weekday is fwd\n\t            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\t\n\t        return -fwdlw + fwd - 1;\n\t    }\n\t\n\t    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n\t    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n\t        var localWeekday = (7 + weekday - dow) % 7,\n\t            weekOffset = firstWeekOffset(year, dow, doy),\n\t            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n\t            resYear, resDayOfYear;\n\t\n\t        if (dayOfYear <= 0) {\n\t            resYear = year - 1;\n\t            resDayOfYear = daysInYear(resYear) + dayOfYear;\n\t        } else if (dayOfYear > daysInYear(year)) {\n\t            resYear = year + 1;\n\t            resDayOfYear = dayOfYear - daysInYear(year);\n\t        } else {\n\t            resYear = year;\n\t            resDayOfYear = dayOfYear;\n\t        }\n\t\n\t        return {\n\t            year: resYear,\n\t            dayOfYear: resDayOfYear\n\t        };\n\t    }\n\t\n\t    function weekOfYear(mom, dow, doy) {\n\t        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n\t            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n\t            resWeek, resYear;\n\t\n\t        if (week < 1) {\n\t            resYear = mom.year() - 1;\n\t            resWeek = week + weeksInYear(resYear, dow, doy);\n\t        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n\t            resWeek = week - weeksInYear(mom.year(), dow, doy);\n\t            resYear = mom.year() + 1;\n\t        } else {\n\t            resYear = mom.year();\n\t            resWeek = week;\n\t        }\n\t\n\t        return {\n\t            week: resWeek,\n\t            year: resYear\n\t        };\n\t    }\n\t\n\t    function weeksInYear(year, dow, doy) {\n\t        var weekOffset = firstWeekOffset(year, dow, doy),\n\t            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n\t        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('w', ['ww', 2], 'wo', 'week');\n\t    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('week', 'w');\n\t    addUnitAlias('isoWeek', 'W');\n\t\n\t    // PRIORITIES\n\t\n\t    addUnitPriority('week', 5);\n\t    addUnitPriority('isoWeek', 5);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('w',  match1to2);\n\t    addRegexToken('ww', match1to2, match2);\n\t    addRegexToken('W',  match1to2);\n\t    addRegexToken('WW', match1to2, match2);\n\t\n\t    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n\t        week[token.substr(0, 1)] = toInt(input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    // LOCALES\n\t\n\t    function localeWeek (mom) {\n\t        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n\t    }\n\t\n\t    var defaultLocaleWeek = {\n\t        dow : 0, // Sunday is the first day of the week.\n\t        doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t    };\n\t\n\t    function localeFirstDayOfWeek () {\n\t        return this._week.dow;\n\t    }\n\t\n\t    function localeFirstDayOfYear () {\n\t        return this._week.doy;\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function getSetWeek (input) {\n\t        var week = this.localeData().week(this);\n\t        return input == null ? week : this.add((input - week) * 7, 'd');\n\t    }\n\t\n\t    function getSetISOWeek (input) {\n\t        var week = weekOfYear(this, 1, 4).week;\n\t        return input == null ? week : this.add((input - week) * 7, 'd');\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('d', 0, 'do', 'day');\n\t\n\t    addFormatToken('dd', 0, 0, function (format) {\n\t        return this.localeData().weekdaysMin(this, format);\n\t    });\n\t\n\t    addFormatToken('ddd', 0, 0, function (format) {\n\t        return this.localeData().weekdaysShort(this, format);\n\t    });\n\t\n\t    addFormatToken('dddd', 0, 0, function (format) {\n\t        return this.localeData().weekdays(this, format);\n\t    });\n\t\n\t    addFormatToken('e', 0, 0, 'weekday');\n\t    addFormatToken('E', 0, 0, 'isoWeekday');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('day', 'd');\n\t    addUnitAlias('weekday', 'e');\n\t    addUnitAlias('isoWeekday', 'E');\n\t\n\t    // PRIORITY\n\t    addUnitPriority('day', 11);\n\t    addUnitPriority('weekday', 11);\n\t    addUnitPriority('isoWeekday', 11);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('d',    match1to2);\n\t    addRegexToken('e',    match1to2);\n\t    addRegexToken('E',    match1to2);\n\t    addRegexToken('dd',   function (isStrict, locale) {\n\t        return locale.weekdaysMinRegex(isStrict);\n\t    });\n\t    addRegexToken('ddd',   function (isStrict, locale) {\n\t        return locale.weekdaysShortRegex(isStrict);\n\t    });\n\t    addRegexToken('dddd',   function (isStrict, locale) {\n\t        return locale.weekdaysRegex(isStrict);\n\t    });\n\t\n\t    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n\t        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n\t        // if we didn't get a weekday name, mark the date as invalid\n\t        if (weekday != null) {\n\t            week.d = weekday;\n\t        } else {\n\t            getParsingFlags(config).invalidWeekday = input;\n\t        }\n\t    });\n\t\n\t    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n\t        week[token] = toInt(input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    function parseWeekday(input, locale) {\n\t        if (typeof input !== 'string') {\n\t            return input;\n\t        }\n\t\n\t        if (!isNaN(input)) {\n\t            return parseInt(input, 10);\n\t        }\n\t\n\t        input = locale.weekdaysParse(input);\n\t        if (typeof input === 'number') {\n\t            return input;\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    function parseIsoWeekday(input, locale) {\n\t        if (typeof input === 'string') {\n\t            return locale.weekdaysParse(input) % 7 || 7;\n\t        }\n\t        return isNaN(input) ? null : input;\n\t    }\n\t\n\t    // LOCALES\n\t\n\t    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n\t    function localeWeekdays (m, format) {\n\t        return isArray(this._weekdays) ? this._weekdays[m.day()] :\n\t            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n\t    }\n\t\n\t    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n\t    function localeWeekdaysShort (m) {\n\t        return this._weekdaysShort[m.day()];\n\t    }\n\t\n\t    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n\t    function localeWeekdaysMin (m) {\n\t        return this._weekdaysMin[m.day()];\n\t    }\n\t\n\t    function day_of_week__handleStrictParse(weekdayName, format, strict) {\n\t        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n\t        if (!this._weekdaysParse) {\n\t            this._weekdaysParse = [];\n\t            this._shortWeekdaysParse = [];\n\t            this._minWeekdaysParse = [];\n\t\n\t            for (i = 0; i < 7; ++i) {\n\t                mom = create_utc__createUTC([2000, 1]).day(i);\n\t                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n\t                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n\t                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n\t            }\n\t        }\n\t\n\t        if (strict) {\n\t            if (format === 'dddd') {\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else if (format === 'ddd') {\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        } else {\n\t            if (format === 'dddd') {\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else if (format === 'ddd') {\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        }\n\t    }\n\t\n\t    function localeWeekdaysParse (weekdayName, format, strict) {\n\t        var i, mom, regex;\n\t\n\t        if (this._weekdaysParseExact) {\n\t            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);\n\t        }\n\t\n\t        if (!this._weekdaysParse) {\n\t            this._weekdaysParse = [];\n\t            this._minWeekdaysParse = [];\n\t            this._shortWeekdaysParse = [];\n\t            this._fullWeekdaysParse = [];\n\t        }\n\t\n\t        for (i = 0; i < 7; i++) {\n\t            // make the regex if we don't have it already\n\t\n\t            mom = create_utc__createUTC([2000, 1]).day(i);\n\t            if (strict && !this._fullWeekdaysParse[i]) {\n\t                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n\t                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n\t                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n\t            }\n\t            if (!this._weekdaysParse[i]) {\n\t                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n\t                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n\t            }\n\t            // test the regex\n\t            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            }\n\t        }\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function getSetDayOfWeek (input) {\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n\t        if (input != null) {\n\t            input = parseWeekday(input, this.localeData());\n\t            return this.add(input - day, 'd');\n\t        } else {\n\t            return day;\n\t        }\n\t    }\n\t\n\t    function getSetLocaleDayOfWeek (input) {\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n\t        return input == null ? weekday : this.add(input - weekday, 'd');\n\t    }\n\t\n\t    function getSetISODayOfWeek (input) {\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t\n\t        // behaves the same as moment#day except\n\t        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n\t        // as a setter, sunday should belong to the previous week.\n\t\n\t        if (input != null) {\n\t            var weekday = parseIsoWeekday(input, this.localeData());\n\t            return this.day(this.day() % 7 ? weekday : weekday - 7);\n\t        } else {\n\t            return this.day() || 7;\n\t        }\n\t    }\n\t\n\t    var defaultWeekdaysRegex = matchWord;\n\t    function weekdaysRegex (isStrict) {\n\t        if (this._weekdaysParseExact) {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                computeWeekdaysParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._weekdaysStrictRegex;\n\t            } else {\n\t                return this._weekdaysRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                this._weekdaysRegex = defaultWeekdaysRegex;\n\t            }\n\t            return this._weekdaysStrictRegex && isStrict ?\n\t                this._weekdaysStrictRegex : this._weekdaysRegex;\n\t        }\n\t    }\n\t\n\t    var defaultWeekdaysShortRegex = matchWord;\n\t    function weekdaysShortRegex (isStrict) {\n\t        if (this._weekdaysParseExact) {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                computeWeekdaysParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._weekdaysShortStrictRegex;\n\t            } else {\n\t                return this._weekdaysShortRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n\t                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n\t            }\n\t            return this._weekdaysShortStrictRegex && isStrict ?\n\t                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n\t        }\n\t    }\n\t\n\t    var defaultWeekdaysMinRegex = matchWord;\n\t    function weekdaysMinRegex (isStrict) {\n\t        if (this._weekdaysParseExact) {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                computeWeekdaysParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._weekdaysMinStrictRegex;\n\t            } else {\n\t                return this._weekdaysMinRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n\t                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n\t            }\n\t            return this._weekdaysMinStrictRegex && isStrict ?\n\t                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n\t        }\n\t    }\n\t\n\t\n\t    function computeWeekdaysParse () {\n\t        function cmpLenRev(a, b) {\n\t            return b.length - a.length;\n\t        }\n\t\n\t        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n\t            i, mom, minp, shortp, longp;\n\t        for (i = 0; i < 7; i++) {\n\t            // make the regex if we don't have it already\n\t            mom = create_utc__createUTC([2000, 1]).day(i);\n\t            minp = this.weekdaysMin(mom, '');\n\t            shortp = this.weekdaysShort(mom, '');\n\t            longp = this.weekdays(mom, '');\n\t            minPieces.push(minp);\n\t            shortPieces.push(shortp);\n\t            longPieces.push(longp);\n\t            mixedPieces.push(minp);\n\t            mixedPieces.push(shortp);\n\t            mixedPieces.push(longp);\n\t        }\n\t        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n\t        // will match the longer piece.\n\t        minPieces.sort(cmpLenRev);\n\t        shortPieces.sort(cmpLenRev);\n\t        longPieces.sort(cmpLenRev);\n\t        mixedPieces.sort(cmpLenRev);\n\t        for (i = 0; i < 7; i++) {\n\t            shortPieces[i] = regexEscape(shortPieces[i]);\n\t            longPieces[i] = regexEscape(longPieces[i]);\n\t            mixedPieces[i] = regexEscape(mixedPieces[i]);\n\t        }\n\t\n\t        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n\t        this._weekdaysShortRegex = this._weekdaysRegex;\n\t        this._weekdaysMinRegex = this._weekdaysRegex;\n\t\n\t        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n\t        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n\t        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    function hFormat() {\n\t        return this.hours() % 12 || 12;\n\t    }\n\t\n\t    function kFormat() {\n\t        return this.hours() || 24;\n\t    }\n\t\n\t    addFormatToken('H', ['HH', 2], 0, 'hour');\n\t    addFormatToken('h', ['hh', 2], 0, hFormat);\n\t    addFormatToken('k', ['kk', 2], 0, kFormat);\n\t\n\t    addFormatToken('hmm', 0, 0, function () {\n\t        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n\t    });\n\t\n\t    addFormatToken('hmmss', 0, 0, function () {\n\t        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n\t            zeroFill(this.seconds(), 2);\n\t    });\n\t\n\t    addFormatToken('Hmm', 0, 0, function () {\n\t        return '' + this.hours() + zeroFill(this.minutes(), 2);\n\t    });\n\t\n\t    addFormatToken('Hmmss', 0, 0, function () {\n\t        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n\t            zeroFill(this.seconds(), 2);\n\t    });\n\t\n\t    function meridiem (token, lowercase) {\n\t        addFormatToken(token, 0, 0, function () {\n\t            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n\t        });\n\t    }\n\t\n\t    meridiem('a', true);\n\t    meridiem('A', false);\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('hour', 'h');\n\t\n\t    // PRIORITY\n\t    addUnitPriority('hour', 13);\n\t\n\t    // PARSING\n\t\n\t    function matchMeridiem (isStrict, locale) {\n\t        return locale._meridiemParse;\n\t    }\n\t\n\t    addRegexToken('a',  matchMeridiem);\n\t    addRegexToken('A',  matchMeridiem);\n\t    addRegexToken('H',  match1to2);\n\t    addRegexToken('h',  match1to2);\n\t    addRegexToken('HH', match1to2, match2);\n\t    addRegexToken('hh', match1to2, match2);\n\t\n\t    addRegexToken('hmm', match3to4);\n\t    addRegexToken('hmmss', match5to6);\n\t    addRegexToken('Hmm', match3to4);\n\t    addRegexToken('Hmmss', match5to6);\n\t\n\t    addParseToken(['H', 'HH'], HOUR);\n\t    addParseToken(['a', 'A'], function (input, array, config) {\n\t        config._isPm = config._locale.isPM(input);\n\t        config._meridiem = input;\n\t    });\n\t    addParseToken(['h', 'hh'], function (input, array, config) {\n\t        array[HOUR] = toInt(input);\n\t        getParsingFlags(config).bigHour = true;\n\t    });\n\t    addParseToken('hmm', function (input, array, config) {\n\t        var pos = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos));\n\t        array[MINUTE] = toInt(input.substr(pos));\n\t        getParsingFlags(config).bigHour = true;\n\t    });\n\t    addParseToken('hmmss', function (input, array, config) {\n\t        var pos1 = input.length - 4;\n\t        var pos2 = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos1));\n\t        array[MINUTE] = toInt(input.substr(pos1, 2));\n\t        array[SECOND] = toInt(input.substr(pos2));\n\t        getParsingFlags(config).bigHour = true;\n\t    });\n\t    addParseToken('Hmm', function (input, array, config) {\n\t        var pos = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos));\n\t        array[MINUTE] = toInt(input.substr(pos));\n\t    });\n\t    addParseToken('Hmmss', function (input, array, config) {\n\t        var pos1 = input.length - 4;\n\t        var pos2 = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos1));\n\t        array[MINUTE] = toInt(input.substr(pos1, 2));\n\t        array[SECOND] = toInt(input.substr(pos2));\n\t    });\n\t\n\t    // LOCALES\n\t\n\t    function localeIsPM (input) {\n\t        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n\t        // Using charAt should be more compatible.\n\t        return ((input + '').toLowerCase().charAt(0) === 'p');\n\t    }\n\t\n\t    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n\t    function localeMeridiem (hours, minutes, isLower) {\n\t        if (hours > 11) {\n\t            return isLower ? 'pm' : 'PM';\n\t        } else {\n\t            return isLower ? 'am' : 'AM';\n\t        }\n\t    }\n\t\n\t\n\t    // MOMENTS\n\t\n\t    // Setting the hour should keep the time, because the user explicitly\n\t    // specified which hour he wants. So trying to maintain the same hour (in\n\t    // a new timezone) makes sense. Adding/subtracting hours does not follow\n\t    // this rule.\n\t    var getSetHour = makeGetSet('Hours', true);\n\t\n\t    var baseConfig = {\n\t        calendar: defaultCalendar,\n\t        longDateFormat: defaultLongDateFormat,\n\t        invalidDate: defaultInvalidDate,\n\t        ordinal: defaultOrdinal,\n\t        ordinalParse: defaultOrdinalParse,\n\t        relativeTime: defaultRelativeTime,\n\t\n\t        months: defaultLocaleMonths,\n\t        monthsShort: defaultLocaleMonthsShort,\n\t\n\t        week: defaultLocaleWeek,\n\t\n\t        weekdays: defaultLocaleWeekdays,\n\t        weekdaysMin: defaultLocaleWeekdaysMin,\n\t        weekdaysShort: defaultLocaleWeekdaysShort,\n\t\n\t        meridiemParse: defaultLocaleMeridiemParse\n\t    };\n\t\n\t    // internal storage for locale config files\n\t    var locales = {};\n\t    var globalLocale;\n\t\n\t    function normalizeLocale(key) {\n\t        return key ? key.toLowerCase().replace('_', '-') : key;\n\t    }\n\t\n\t    // pick the locale from the array\n\t    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n\t    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n\t    function chooseLocale(names) {\n\t        var i = 0, j, next, locale, split;\n\t\n\t        while (i < names.length) {\n\t            split = normalizeLocale(names[i]).split('-');\n\t            j = split.length;\n\t            next = normalizeLocale(names[i + 1]);\n\t            next = next ? next.split('-') : null;\n\t            while (j > 0) {\n\t                locale = loadLocale(split.slice(0, j).join('-'));\n\t                if (locale) {\n\t                    return locale;\n\t                }\n\t                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n\t                    //the next array item is better than a shallower substring of this one\n\t                    break;\n\t                }\n\t                j--;\n\t            }\n\t            i++;\n\t        }\n\t        return null;\n\t    }\n\t\n\t    function loadLocale(name) {\n\t        var oldLocale = null;\n\t        // TODO: Find a better way to register and load all the locales in Node\n\t        if (!locales[name] && (typeof module !== 'undefined') &&\n\t                module && module.exports) {\n\t            try {\n\t                oldLocale = globalLocale._abbr;\n\t                __webpack_require__(4)(\"./\" + name);\n\t                // because defineLocale currently also sets the global locale, we\n\t                // want to undo that for lazy loaded locales\n\t                locale_locales__getSetGlobalLocale(oldLocale);\n\t            } catch (e) { }\n\t        }\n\t        return locales[name];\n\t    }\n\t\n\t    // This function will load locale and then set the global locale.  If\n\t    // no arguments are passed in, it will simply return the current global\n\t    // locale key.\n\t    function locale_locales__getSetGlobalLocale (key, values) {\n\t        var data;\n\t        if (key) {\n\t            if (isUndefined(values)) {\n\t                data = locale_locales__getLocale(key);\n\t            }\n\t            else {\n\t                data = defineLocale(key, values);\n\t            }\n\t\n\t            if (data) {\n\t                // moment.duration._locale = moment._locale = data;\n\t                globalLocale = data;\n\t            }\n\t        }\n\t\n\t        return globalLocale._abbr;\n\t    }\n\t\n\t    function defineLocale (name, config) {\n\t        if (config !== null) {\n\t            var parentConfig = baseConfig;\n\t            config.abbr = name;\n\t            if (locales[name] != null) {\n\t                deprecateSimple('defineLocaleOverride',\n\t                        'use moment.updateLocale(localeName, config) to change ' +\n\t                        'an existing locale. moment.defineLocale(localeName, ' +\n\t                        'config) should only be used for creating a new locale ' +\n\t                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n\t                parentConfig = locales[name]._config;\n\t            } else if (config.parentLocale != null) {\n\t                if (locales[config.parentLocale] != null) {\n\t                    parentConfig = locales[config.parentLocale]._config;\n\t                } else {\n\t                    // treat as if there is no base config\n\t                    deprecateSimple('parentLocaleUndefined',\n\t                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');\n\t                }\n\t            }\n\t            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\t\n\t            // backwards compat for now: also set the locale\n\t            locale_locales__getSetGlobalLocale(name);\n\t\n\t            return locales[name];\n\t        } else {\n\t            // useful for testing\n\t            delete locales[name];\n\t            return null;\n\t        }\n\t    }\n\t\n\t    function updateLocale(name, config) {\n\t        if (config != null) {\n\t            var locale, parentConfig = baseConfig;\n\t            // MERGE\n\t            if (locales[name] != null) {\n\t                parentConfig = locales[name]._config;\n\t            }\n\t            config = mergeConfigs(parentConfig, config);\n\t            locale = new Locale(config);\n\t            locale.parentLocale = locales[name];\n\t            locales[name] = locale;\n\t\n\t            // backwards compat for now: also set the locale\n\t            locale_locales__getSetGlobalLocale(name);\n\t        } else {\n\t            // pass null for config to unupdate, useful for tests\n\t            if (locales[name] != null) {\n\t                if (locales[name].parentLocale != null) {\n\t                    locales[name] = locales[name].parentLocale;\n\t                } else if (locales[name] != null) {\n\t                    delete locales[name];\n\t                }\n\t            }\n\t        }\n\t        return locales[name];\n\t    }\n\t\n\t    // returns locale data\n\t    function locale_locales__getLocale (key) {\n\t        var locale;\n\t\n\t        if (key && key._locale && key._locale._abbr) {\n\t            key = key._locale._abbr;\n\t        }\n\t\n\t        if (!key) {\n\t            return globalLocale;\n\t        }\n\t\n\t        if (!isArray(key)) {\n\t            //short-circuit everything else\n\t            locale = loadLocale(key);\n\t            if (locale) {\n\t                return locale;\n\t            }\n\t            key = [key];\n\t        }\n\t\n\t        return chooseLocale(key);\n\t    }\n\t\n\t    function locale_locales__listLocales() {\n\t        return keys(locales);\n\t    }\n\t\n\t    function checkOverflow (m) {\n\t        var overflow;\n\t        var a = m._a;\n\t\n\t        if (a && getParsingFlags(m).overflow === -2) {\n\t            overflow =\n\t                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n\t                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n\t                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n\t                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n\t                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n\t                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n\t                -1;\n\t\n\t            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n\t                overflow = DATE;\n\t            }\n\t            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n\t                overflow = WEEK;\n\t            }\n\t            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n\t                overflow = WEEKDAY;\n\t            }\n\t\n\t            getParsingFlags(m).overflow = overflow;\n\t        }\n\t\n\t        return m;\n\t    }\n\t\n\t    // iso 8601 regex\n\t    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n\t    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n\t    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n\t\n\t    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\t\n\t    var isoDates = [\n\t        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n\t        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n\t        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n\t        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n\t        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n\t        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n\t        ['YYYYYYMMDD', /[+-]\\d{10}/],\n\t        ['YYYYMMDD', /\\d{8}/],\n\t        // YYYYMM is NOT allowed by the standard\n\t        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n\t        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n\t        ['YYYYDDD', /\\d{7}/]\n\t    ];\n\t\n\t    // iso time formats and regexes\n\t    var isoTimes = [\n\t        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n\t        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n\t        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n\t        ['HH:mm', /\\d\\d:\\d\\d/],\n\t        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n\t        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n\t        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n\t        ['HHmm', /\\d\\d\\d\\d/],\n\t        ['HH', /\\d\\d/]\n\t    ];\n\t\n\t    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\t\n\t    // date from iso format\n\t    function configFromISO(config) {\n\t        var i, l,\n\t            string = config._i,\n\t            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n\t            allowTime, dateFormat, timeFormat, tzFormat;\n\t\n\t        if (match) {\n\t            getParsingFlags(config).iso = true;\n\t\n\t            for (i = 0, l = isoDates.length; i < l; i++) {\n\t                if (isoDates[i][1].exec(match[1])) {\n\t                    dateFormat = isoDates[i][0];\n\t                    allowTime = isoDates[i][2] !== false;\n\t                    break;\n\t                }\n\t            }\n\t            if (dateFormat == null) {\n\t                config._isValid = false;\n\t                return;\n\t            }\n\t            if (match[3]) {\n\t                for (i = 0, l = isoTimes.length; i < l; i++) {\n\t                    if (isoTimes[i][1].exec(match[3])) {\n\t                        // match[2] should be 'T' or space\n\t                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n\t                        break;\n\t                    }\n\t                }\n\t                if (timeFormat == null) {\n\t                    config._isValid = false;\n\t                    return;\n\t                }\n\t            }\n\t            if (!allowTime && timeFormat != null) {\n\t                config._isValid = false;\n\t                return;\n\t            }\n\t            if (match[4]) {\n\t                if (tzRegex.exec(match[4])) {\n\t                    tzFormat = 'Z';\n\t                } else {\n\t                    config._isValid = false;\n\t                    return;\n\t                }\n\t            }\n\t            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n\t            configFromStringAndFormat(config);\n\t        } else {\n\t            config._isValid = false;\n\t        }\n\t    }\n\t\n\t    // date from iso format or fallback\n\t    function configFromString(config) {\n\t        var matched = aspNetJsonRegex.exec(config._i);\n\t\n\t        if (matched !== null) {\n\t            config._d = new Date(+matched[1]);\n\t            return;\n\t        }\n\t\n\t        configFromISO(config);\n\t        if (config._isValid === false) {\n\t            delete config._isValid;\n\t            utils_hooks__hooks.createFromInputFallback(config);\n\t        }\n\t    }\n\t\n\t    utils_hooks__hooks.createFromInputFallback = deprecate(\n\t        'moment construction falls back to js Date. This is ' +\n\t        'discouraged and will be removed in upcoming major ' +\n\t        'release. Please refer to ' +\n\t        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n\t        function (config) {\n\t            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n\t        }\n\t    );\n\t\n\t    // Pick the first defined of two or three arguments.\n\t    function defaults(a, b, c) {\n\t        if (a != null) {\n\t            return a;\n\t        }\n\t        if (b != null) {\n\t            return b;\n\t        }\n\t        return c;\n\t    }\n\t\n\t    function currentDateArray(config) {\n\t        // hooks is actually the exported moment object\n\t        var nowValue = new Date(utils_hooks__hooks.now());\n\t        if (config._useUTC) {\n\t            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n\t        }\n\t        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n\t    }\n\t\n\t    // convert an array to a date.\n\t    // the array should mirror the parameters below\n\t    // note: all values past the year are optional and will default to the lowest possible value.\n\t    // [year, month, day , hour, minute, second, millisecond]\n\t    function configFromArray (config) {\n\t        var i, date, input = [], currentDate, yearToUse;\n\t\n\t        if (config._d) {\n\t            return;\n\t        }\n\t\n\t        currentDate = currentDateArray(config);\n\t\n\t        //compute day of the year from weeks and weekdays\n\t        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n\t            dayOfYearFromWeekInfo(config);\n\t        }\n\t\n\t        //if the day of the year is set, figure out what it is\n\t        if (config._dayOfYear) {\n\t            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\t\n\t            if (config._dayOfYear > daysInYear(yearToUse)) {\n\t                getParsingFlags(config)._overflowDayOfYear = true;\n\t            }\n\t\n\t            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n\t            config._a[MONTH] = date.getUTCMonth();\n\t            config._a[DATE] = date.getUTCDate();\n\t        }\n\t\n\t        // Default to current date.\n\t        // * if no year, month, day of month are given, default to today\n\t        // * if day of month is given, default month and year\n\t        // * if month is given, default only year\n\t        // * if year is given, don't default anything\n\t        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n\t            config._a[i] = input[i] = currentDate[i];\n\t        }\n\t\n\t        // Zero out whatever was not defaulted, including time\n\t        for (; i < 7; i++) {\n\t            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n\t        }\n\t\n\t        // Check for 24:00:00.000\n\t        if (config._a[HOUR] === 24 &&\n\t                config._a[MINUTE] === 0 &&\n\t                config._a[SECOND] === 0 &&\n\t                config._a[MILLISECOND] === 0) {\n\t            config._nextDay = true;\n\t            config._a[HOUR] = 0;\n\t        }\n\t\n\t        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n\t        // Apply timezone offset from input. The actual utcOffset can be changed\n\t        // with parseZone.\n\t        if (config._tzm != null) {\n\t            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\t        }\n\t\n\t        if (config._nextDay) {\n\t            config._a[HOUR] = 24;\n\t        }\n\t    }\n\t\n\t    function dayOfYearFromWeekInfo(config) {\n\t        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\t\n\t        w = config._w;\n\t        if (w.GG != null || w.W != null || w.E != null) {\n\t            dow = 1;\n\t            doy = 4;\n\t\n\t            // TODO: We need to take the current isoWeekYear, but that depends on\n\t            // how we interpret now (local, utc, fixed offset). So create\n\t            // a now version of current config (take local/utc/offset flags, and\n\t            // create now).\n\t            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);\n\t            week = defaults(w.W, 1);\n\t            weekday = defaults(w.E, 1);\n\t            if (weekday < 1 || weekday > 7) {\n\t                weekdayOverflow = true;\n\t            }\n\t        } else {\n\t            dow = config._locale._week.dow;\n\t            doy = config._locale._week.doy;\n\t\n\t            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);\n\t            week = defaults(w.w, 1);\n\t\n\t            if (w.d != null) {\n\t                // weekday -- low day numbers are considered next week\n\t                weekday = w.d;\n\t                if (weekday < 0 || weekday > 6) {\n\t                    weekdayOverflow = true;\n\t                }\n\t            } else if (w.e != null) {\n\t                // local weekday -- counting starts from begining of week\n\t                weekday = w.e + dow;\n\t                if (w.e < 0 || w.e > 6) {\n\t                    weekdayOverflow = true;\n\t                }\n\t            } else {\n\t                // default to begining of week\n\t                weekday = dow;\n\t            }\n\t        }\n\t        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n\t            getParsingFlags(config)._overflowWeeks = true;\n\t        } else if (weekdayOverflow != null) {\n\t            getParsingFlags(config)._overflowWeekday = true;\n\t        } else {\n\t            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n\t            config._a[YEAR] = temp.year;\n\t            config._dayOfYear = temp.dayOfYear;\n\t        }\n\t    }\n\t\n\t    // constant that refers to the ISO standard\n\t    utils_hooks__hooks.ISO_8601 = function () {};\n\t\n\t    // date from string and format string\n\t    function configFromStringAndFormat(config) {\n\t        // TODO: Move this to another part of the creation flow to prevent circular deps\n\t        if (config._f === utils_hooks__hooks.ISO_8601) {\n\t            configFromISO(config);\n\t            return;\n\t        }\n\t\n\t        config._a = [];\n\t        getParsingFlags(config).empty = true;\n\t\n\t        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\t        var string = '' + config._i,\n\t            i, parsedInput, tokens, token, skipped,\n\t            stringLength = string.length,\n\t            totalParsedInputLength = 0;\n\t\n\t        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\t\n\t        for (i = 0; i < tokens.length; i++) {\n\t            token = tokens[i];\n\t            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n\t            // console.log('token', token, 'parsedInput', parsedInput,\n\t            //         'regex', getParseRegexForToken(token, config));\n\t            if (parsedInput) {\n\t                skipped = string.substr(0, string.indexOf(parsedInput));\n\t                if (skipped.length > 0) {\n\t                    getParsingFlags(config).unusedInput.push(skipped);\n\t                }\n\t                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n\t                totalParsedInputLength += parsedInput.length;\n\t            }\n\t            // don't parse if it's not a known token\n\t            if (formatTokenFunctions[token]) {\n\t                if (parsedInput) {\n\t                    getParsingFlags(config).empty = false;\n\t                }\n\t                else {\n\t                    getParsingFlags(config).unusedTokens.push(token);\n\t                }\n\t                addTimeToArrayFromToken(token, parsedInput, config);\n\t            }\n\t            else if (config._strict && !parsedInput) {\n\t                getParsingFlags(config).unusedTokens.push(token);\n\t            }\n\t        }\n\t\n\t        // add remaining unparsed input length to the string\n\t        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n\t        if (string.length > 0) {\n\t            getParsingFlags(config).unusedInput.push(string);\n\t        }\n\t\n\t        // clear _12h flag if hour is <= 12\n\t        if (config._a[HOUR] <= 12 &&\n\t            getParsingFlags(config).bigHour === true &&\n\t            config._a[HOUR] > 0) {\n\t            getParsingFlags(config).bigHour = undefined;\n\t        }\n\t\n\t        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n\t        getParsingFlags(config).meridiem = config._meridiem;\n\t        // handle meridiem\n\t        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\t\n\t        configFromArray(config);\n\t        checkOverflow(config);\n\t    }\n\t\n\t\n\t    function meridiemFixWrap (locale, hour, meridiem) {\n\t        var isPm;\n\t\n\t        if (meridiem == null) {\n\t            // nothing to do\n\t            return hour;\n\t        }\n\t        if (locale.meridiemHour != null) {\n\t            return locale.meridiemHour(hour, meridiem);\n\t        } else if (locale.isPM != null) {\n\t            // Fallback\n\t            isPm = locale.isPM(meridiem);\n\t            if (isPm && hour < 12) {\n\t                hour += 12;\n\t            }\n\t            if (!isPm && hour === 12) {\n\t                hour = 0;\n\t            }\n\t            return hour;\n\t        } else {\n\t            // this is not supposed to happen\n\t            return hour;\n\t        }\n\t    }\n\t\n\t    // date from string and array of format strings\n\t    function configFromStringAndArray(config) {\n\t        var tempConfig,\n\t            bestMoment,\n\t\n\t            scoreToBeat,\n\t            i,\n\t            currentScore;\n\t\n\t        if (config._f.length === 0) {\n\t            getParsingFlags(config).invalidFormat = true;\n\t            config._d = new Date(NaN);\n\t            return;\n\t        }\n\t\n\t        for (i = 0; i < config._f.length; i++) {\n\t            currentScore = 0;\n\t            tempConfig = copyConfig({}, config);\n\t            if (config._useUTC != null) {\n\t                tempConfig._useUTC = config._useUTC;\n\t            }\n\t            tempConfig._f = config._f[i];\n\t            configFromStringAndFormat(tempConfig);\n\t\n\t            if (!valid__isValid(tempConfig)) {\n\t                continue;\n\t            }\n\t\n\t            // if there is any input that was not parsed add a penalty for that format\n\t            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\t\n\t            //or tokens\n\t            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\t\n\t            getParsingFlags(tempConfig).score = currentScore;\n\t\n\t            if (scoreToBeat == null || currentScore < scoreToBeat) {\n\t                scoreToBeat = currentScore;\n\t                bestMoment = tempConfig;\n\t            }\n\t        }\n\t\n\t        extend(config, bestMoment || tempConfig);\n\t    }\n\t\n\t    function configFromObject(config) {\n\t        if (config._d) {\n\t            return;\n\t        }\n\t\n\t        var i = normalizeObjectUnits(config._i);\n\t        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n\t            return obj && parseInt(obj, 10);\n\t        });\n\t\n\t        configFromArray(config);\n\t    }\n\t\n\t    function createFromConfig (config) {\n\t        var res = new Moment(checkOverflow(prepareConfig(config)));\n\t        if (res._nextDay) {\n\t            // Adding is smart enough around DST\n\t            res.add(1, 'd');\n\t            res._nextDay = undefined;\n\t        }\n\t\n\t        return res;\n\t    }\n\t\n\t    function prepareConfig (config) {\n\t        var input = config._i,\n\t            format = config._f;\n\t\n\t        config._locale = config._locale || locale_locales__getLocale(config._l);\n\t\n\t        if (input === null || (format === undefined && input === '')) {\n\t            return valid__createInvalid({nullInput: true});\n\t        }\n\t\n\t        if (typeof input === 'string') {\n\t            config._i = input = config._locale.preparse(input);\n\t        }\n\t\n\t        if (isMoment(input)) {\n\t            return new Moment(checkOverflow(input));\n\t        } else if (isArray(format)) {\n\t            configFromStringAndArray(config);\n\t        } else if (isDate(input)) {\n\t            config._d = input;\n\t        } else if (format) {\n\t            configFromStringAndFormat(config);\n\t        }  else {\n\t            configFromInput(config);\n\t        }\n\t\n\t        if (!valid__isValid(config)) {\n\t            config._d = null;\n\t        }\n\t\n\t        return config;\n\t    }\n\t\n\t    function configFromInput(config) {\n\t        var input = config._i;\n\t        if (input === undefined) {\n\t            config._d = new Date(utils_hooks__hooks.now());\n\t        } else if (isDate(input)) {\n\t            config._d = new Date(input.valueOf());\n\t        } else if (typeof input === 'string') {\n\t            configFromString(config);\n\t        } else if (isArray(input)) {\n\t            config._a = map(input.slice(0), function (obj) {\n\t                return parseInt(obj, 10);\n\t            });\n\t            configFromArray(config);\n\t        } else if (typeof(input) === 'object') {\n\t            configFromObject(config);\n\t        } else if (typeof(input) === 'number') {\n\t            // from milliseconds\n\t            config._d = new Date(input);\n\t        } else {\n\t            utils_hooks__hooks.createFromInputFallback(config);\n\t        }\n\t    }\n\t\n\t    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n\t        var c = {};\n\t\n\t        if (typeof(locale) === 'boolean') {\n\t            strict = locale;\n\t            locale = undefined;\n\t        }\n\t\n\t        if ((isObject(input) && isObjectEmpty(input)) ||\n\t                (isArray(input) && input.length === 0)) {\n\t            input = undefined;\n\t        }\n\t        // object construction must be done this way.\n\t        // https://github.com/moment/moment/issues/1423\n\t        c._isAMomentObject = true;\n\t        c._useUTC = c._isUTC = isUTC;\n\t        c._l = locale;\n\t        c._i = input;\n\t        c._f = format;\n\t        c._strict = strict;\n\t\n\t        return createFromConfig(c);\n\t    }\n\t\n\t    function local__createLocal (input, format, locale, strict) {\n\t        return createLocalOrUTC(input, format, locale, strict, false);\n\t    }\n\t\n\t    var prototypeMin = deprecate(\n\t        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n\t        function () {\n\t            var other = local__createLocal.apply(null, arguments);\n\t            if (this.isValid() && other.isValid()) {\n\t                return other < this ? this : other;\n\t            } else {\n\t                return valid__createInvalid();\n\t            }\n\t        }\n\t    );\n\t\n\t    var prototypeMax = deprecate(\n\t        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n\t        function () {\n\t            var other = local__createLocal.apply(null, arguments);\n\t            if (this.isValid() && other.isValid()) {\n\t                return other > this ? this : other;\n\t            } else {\n\t                return valid__createInvalid();\n\t            }\n\t        }\n\t    );\n\t\n\t    // Pick a moment m from moments so that m[fn](other) is true for all\n\t    // other. This relies on the function fn to be transitive.\n\t    //\n\t    // moments should either be an array of moment objects or an array, whose\n\t    // first element is an array of moment objects.\n\t    function pickBy(fn, moments) {\n\t        var res, i;\n\t        if (moments.length === 1 && isArray(moments[0])) {\n\t            moments = moments[0];\n\t        }\n\t        if (!moments.length) {\n\t            return local__createLocal();\n\t        }\n\t        res = moments[0];\n\t        for (i = 1; i < moments.length; ++i) {\n\t            if (!moments[i].isValid() || moments[i][fn](res)) {\n\t                res = moments[i];\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t\n\t    // TODO: Use [].sort instead?\n\t    function min () {\n\t        var args = [].slice.call(arguments, 0);\n\t\n\t        return pickBy('isBefore', args);\n\t    }\n\t\n\t    function max () {\n\t        var args = [].slice.call(arguments, 0);\n\t\n\t        return pickBy('isAfter', args);\n\t    }\n\t\n\t    var now = function () {\n\t        return Date.now ? Date.now() : +(new Date());\n\t    };\n\t\n\t    function Duration (duration) {\n\t        var normalizedInput = normalizeObjectUnits(duration),\n\t            years = normalizedInput.year || 0,\n\t            quarters = normalizedInput.quarter || 0,\n\t            months = normalizedInput.month || 0,\n\t            weeks = normalizedInput.week || 0,\n\t            days = normalizedInput.day || 0,\n\t            hours = normalizedInput.hour || 0,\n\t            minutes = normalizedInput.minute || 0,\n\t            seconds = normalizedInput.second || 0,\n\t            milliseconds = normalizedInput.millisecond || 0;\n\t\n\t        // representation for dateAddRemove\n\t        this._milliseconds = +milliseconds +\n\t            seconds * 1e3 + // 1000\n\t            minutes * 6e4 + // 1000 * 60\n\t            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n\t        // Because of dateAddRemove treats 24 hours as different from a\n\t        // day when working around DST, we need to store them separately\n\t        this._days = +days +\n\t            weeks * 7;\n\t        // It is impossible translate months into days without knowing\n\t        // which months you are are talking about, so we have to store\n\t        // it separately.\n\t        this._months = +months +\n\t            quarters * 3 +\n\t            years * 12;\n\t\n\t        this._data = {};\n\t\n\t        this._locale = locale_locales__getLocale();\n\t\n\t        this._bubble();\n\t    }\n\t\n\t    function isDuration (obj) {\n\t        return obj instanceof Duration;\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    function offset (token, separator) {\n\t        addFormatToken(token, 0, 0, function () {\n\t            var offset = this.utcOffset();\n\t            var sign = '+';\n\t            if (offset < 0) {\n\t                offset = -offset;\n\t                sign = '-';\n\t            }\n\t            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n\t        });\n\t    }\n\t\n\t    offset('Z', ':');\n\t    offset('ZZ', '');\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('Z',  matchShortOffset);\n\t    addRegexToken('ZZ', matchShortOffset);\n\t    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n\t        config._useUTC = true;\n\t        config._tzm = offsetFromString(matchShortOffset, input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    // timezone chunker\n\t    // '+10:00' > ['10',  '00']\n\t    // '-1530'  > ['-15', '30']\n\t    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\t\n\t    function offsetFromString(matcher, string) {\n\t        var matches = ((string || '').match(matcher) || []);\n\t        var chunk   = matches[matches.length - 1] || [];\n\t        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n\t        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\t\n\t        return parts[0] === '+' ? minutes : -minutes;\n\t    }\n\t\n\t    // Return a moment from input, that is local/utc/zone equivalent to model.\n\t    function cloneWithOffset(input, model) {\n\t        var res, diff;\n\t        if (model._isUTC) {\n\t            res = model.clone();\n\t            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();\n\t            // Use low-level api, because this fn is low-level api.\n\t            res._d.setTime(res._d.valueOf() + diff);\n\t            utils_hooks__hooks.updateOffset(res, false);\n\t            return res;\n\t        } else {\n\t            return local__createLocal(input).local();\n\t        }\n\t    }\n\t\n\t    function getDateOffset (m) {\n\t        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n\t        // https://github.com/moment/moment/pull/1871\n\t        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n\t    }\n\t\n\t    // HOOKS\n\t\n\t    // This function will be called whenever a moment is mutated.\n\t    // It is intended to keep the offset in sync with the timezone.\n\t    utils_hooks__hooks.updateOffset = function () {};\n\t\n\t    // MOMENTS\n\t\n\t    // keepLocalTime = true means only change the timezone, without\n\t    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n\t    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n\t    // +0200, so we adjust the time as needed, to be valid.\n\t    //\n\t    // Keeping the time actually adds/subtracts (one hour)\n\t    // from the actual represented time. That is why we call updateOffset\n\t    // a second time. In case it wants us to change the offset again\n\t    // _changeInProgress == true case, then we have to adjust, because\n\t    // there is no such time in the given timezone.\n\t    function getSetOffset (input, keepLocalTime) {\n\t        var offset = this._offset || 0,\n\t            localAdjust;\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t        if (input != null) {\n\t            if (typeof input === 'string') {\n\t                input = offsetFromString(matchShortOffset, input);\n\t            } else if (Math.abs(input) < 16) {\n\t                input = input * 60;\n\t            }\n\t            if (!this._isUTC && keepLocalTime) {\n\t                localAdjust = getDateOffset(this);\n\t            }\n\t            this._offset = input;\n\t            this._isUTC = true;\n\t            if (localAdjust != null) {\n\t                this.add(localAdjust, 'm');\n\t            }\n\t            if (offset !== input) {\n\t                if (!keepLocalTime || this._changeInProgress) {\n\t                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);\n\t                } else if (!this._changeInProgress) {\n\t                    this._changeInProgress = true;\n\t                    utils_hooks__hooks.updateOffset(this, true);\n\t                    this._changeInProgress = null;\n\t                }\n\t            }\n\t            return this;\n\t        } else {\n\t            return this._isUTC ? offset : getDateOffset(this);\n\t        }\n\t    }\n\t\n\t    function getSetZone (input, keepLocalTime) {\n\t        if (input != null) {\n\t            if (typeof input !== 'string') {\n\t                input = -input;\n\t            }\n\t\n\t            this.utcOffset(input, keepLocalTime);\n\t\n\t            return this;\n\t        } else {\n\t            return -this.utcOffset();\n\t        }\n\t    }\n\t\n\t    function setOffsetToUTC (keepLocalTime) {\n\t        return this.utcOffset(0, keepLocalTime);\n\t    }\n\t\n\t    function setOffsetToLocal (keepLocalTime) {\n\t        if (this._isUTC) {\n\t            this.utcOffset(0, keepLocalTime);\n\t            this._isUTC = false;\n\t\n\t            if (keepLocalTime) {\n\t                this.subtract(getDateOffset(this), 'm');\n\t            }\n\t        }\n\t        return this;\n\t    }\n\t\n\t    function setOffsetToParsedOffset () {\n\t        if (this._tzm) {\n\t            this.utcOffset(this._tzm);\n\t        } else if (typeof this._i === 'string') {\n\t            this.utcOffset(offsetFromString(matchOffset, this._i));\n\t        }\n\t        return this;\n\t    }\n\t\n\t    function hasAlignedHourOffset (input) {\n\t        if (!this.isValid()) {\n\t            return false;\n\t        }\n\t        input = input ? local__createLocal(input).utcOffset() : 0;\n\t\n\t        return (this.utcOffset() - input) % 60 === 0;\n\t    }\n\t\n\t    function isDaylightSavingTime () {\n\t        return (\n\t            this.utcOffset() > this.clone().month(0).utcOffset() ||\n\t            this.utcOffset() > this.clone().month(5).utcOffset()\n\t        );\n\t    }\n\t\n\t    function isDaylightSavingTimeShifted () {\n\t        if (!isUndefined(this._isDSTShifted)) {\n\t            return this._isDSTShifted;\n\t        }\n\t\n\t        var c = {};\n\t\n\t        copyConfig(c, this);\n\t        c = prepareConfig(c);\n\t\n\t        if (c._a) {\n\t            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);\n\t            this._isDSTShifted = this.isValid() &&\n\t                compareArrays(c._a, other.toArray()) > 0;\n\t        } else {\n\t            this._isDSTShifted = false;\n\t        }\n\t\n\t        return this._isDSTShifted;\n\t    }\n\t\n\t    function isLocal () {\n\t        return this.isValid() ? !this._isUTC : false;\n\t    }\n\t\n\t    function isUtcOffset () {\n\t        return this.isValid() ? this._isUTC : false;\n\t    }\n\t\n\t    function isUtc () {\n\t        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n\t    }\n\t\n\t    // ASP.NET json date format regex\n\t    var aspNetRegex = /^(\\-)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?\\d*)?$/;\n\t\n\t    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n\t    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n\t    // and further modified to allow for strings containing both week and day\n\t    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;\n\t\n\t    function create__createDuration (input, key) {\n\t        var duration = input,\n\t            // matching against regexp is expensive, do it on demand\n\t            match = null,\n\t            sign,\n\t            ret,\n\t            diffRes;\n\t\n\t        if (isDuration(input)) {\n\t            duration = {\n\t                ms : input._milliseconds,\n\t                d  : input._days,\n\t                M  : input._months\n\t            };\n\t        } else if (typeof input === 'number') {\n\t            duration = {};\n\t            if (key) {\n\t                duration[key] = input;\n\t            } else {\n\t                duration.milliseconds = input;\n\t            }\n\t        } else if (!!(match = aspNetRegex.exec(input))) {\n\t            sign = (match[1] === '-') ? -1 : 1;\n\t            duration = {\n\t                y  : 0,\n\t                d  : toInt(match[DATE])        * sign,\n\t                h  : toInt(match[HOUR])        * sign,\n\t                m  : toInt(match[MINUTE])      * sign,\n\t                s  : toInt(match[SECOND])      * sign,\n\t                ms : toInt(match[MILLISECOND]) * sign\n\t            };\n\t        } else if (!!(match = isoRegex.exec(input))) {\n\t            sign = (match[1] === '-') ? -1 : 1;\n\t            duration = {\n\t                y : parseIso(match[2], sign),\n\t                M : parseIso(match[3], sign),\n\t                w : parseIso(match[4], sign),\n\t                d : parseIso(match[5], sign),\n\t                h : parseIso(match[6], sign),\n\t                m : parseIso(match[7], sign),\n\t                s : parseIso(match[8], sign)\n\t            };\n\t        } else if (duration == null) {// checks for null or undefined\n\t            duration = {};\n\t        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n\t            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));\n\t\n\t            duration = {};\n\t            duration.ms = diffRes.milliseconds;\n\t            duration.M = diffRes.months;\n\t        }\n\t\n\t        ret = new Duration(duration);\n\t\n\t        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n\t            ret._locale = input._locale;\n\t        }\n\t\n\t        return ret;\n\t    }\n\t\n\t    create__createDuration.fn = Duration.prototype;\n\t\n\t    function parseIso (inp, sign) {\n\t        // We'd normally use ~~inp for this, but unfortunately it also\n\t        // converts floats to ints.\n\t        // inp may be undefined, so careful calling replace on it.\n\t        var res = inp && parseFloat(inp.replace(',', '.'));\n\t        // apply sign while we're at it\n\t        return (isNaN(res) ? 0 : res) * sign;\n\t    }\n\t\n\t    function positiveMomentsDifference(base, other) {\n\t        var res = {milliseconds: 0, months: 0};\n\t\n\t        res.months = other.month() - base.month() +\n\t            (other.year() - base.year()) * 12;\n\t        if (base.clone().add(res.months, 'M').isAfter(other)) {\n\t            --res.months;\n\t        }\n\t\n\t        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\t\n\t        return res;\n\t    }\n\t\n\t    function momentsDifference(base, other) {\n\t        var res;\n\t        if (!(base.isValid() && other.isValid())) {\n\t            return {milliseconds: 0, months: 0};\n\t        }\n\t\n\t        other = cloneWithOffset(other, base);\n\t        if (base.isBefore(other)) {\n\t            res = positiveMomentsDifference(base, other);\n\t        } else {\n\t            res = positiveMomentsDifference(other, base);\n\t            res.milliseconds = -res.milliseconds;\n\t            res.months = -res.months;\n\t        }\n\t\n\t        return res;\n\t    }\n\t\n\t    function absRound (number) {\n\t        if (number < 0) {\n\t            return Math.round(-1 * number) * -1;\n\t        } else {\n\t            return Math.round(number);\n\t        }\n\t    }\n\t\n\t    // TODO: remove 'name' arg after deprecation is removed\n\t    function createAdder(direction, name) {\n\t        return function (val, period) {\n\t            var dur, tmp;\n\t            //invert the arguments, but complain about it\n\t            if (period !== null && !isNaN(+period)) {\n\t                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n\t                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n\t                tmp = val; val = period; period = tmp;\n\t            }\n\t\n\t            val = typeof val === 'string' ? +val : val;\n\t            dur = create__createDuration(val, period);\n\t            add_subtract__addSubtract(this, dur, direction);\n\t            return this;\n\t        };\n\t    }\n\t\n\t    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {\n\t        var milliseconds = duration._milliseconds,\n\t            days = absRound(duration._days),\n\t            months = absRound(duration._months);\n\t\n\t        if (!mom.isValid()) {\n\t            // No op\n\t            return;\n\t        }\n\t\n\t        updateOffset = updateOffset == null ? true : updateOffset;\n\t\n\t        if (milliseconds) {\n\t            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n\t        }\n\t        if (days) {\n\t            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);\n\t        }\n\t        if (months) {\n\t            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);\n\t        }\n\t        if (updateOffset) {\n\t            utils_hooks__hooks.updateOffset(mom, days || months);\n\t        }\n\t    }\n\t\n\t    var add_subtract__add      = createAdder(1, 'add');\n\t    var add_subtract__subtract = createAdder(-1, 'subtract');\n\t\n\t    function getCalendarFormat(myMoment, now) {\n\t        var diff = myMoment.diff(now, 'days', true);\n\t        return diff < -6 ? 'sameElse' :\n\t                diff < -1 ? 'lastWeek' :\n\t                diff < 0 ? 'lastDay' :\n\t                diff < 1 ? 'sameDay' :\n\t                diff < 2 ? 'nextDay' :\n\t                diff < 7 ? 'nextWeek' : 'sameElse';\n\t    }\n\t\n\t    function moment_calendar__calendar (time, formats) {\n\t        // We want to compare the start of today, vs this.\n\t        // Getting start-of-today depends on whether we're local/utc/offset or not.\n\t        var now = time || local__createLocal(),\n\t            sod = cloneWithOffset(now, this).startOf('day'),\n\t            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';\n\t\n\t        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\t\n\t        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));\n\t    }\n\t\n\t    function clone () {\n\t        return new Moment(this);\n\t    }\n\t\n\t    function isAfter (input, units) {\n\t        var localInput = isMoment(input) ? input : local__createLocal(input);\n\t        if (!(this.isValid() && localInput.isValid())) {\n\t            return false;\n\t        }\n\t        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n\t        if (units === 'millisecond') {\n\t            return this.valueOf() > localInput.valueOf();\n\t        } else {\n\t            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n\t        }\n\t    }\n\t\n\t    function isBefore (input, units) {\n\t        var localInput = isMoment(input) ? input : local__createLocal(input);\n\t        if (!(this.isValid() && localInput.isValid())) {\n\t            return false;\n\t        }\n\t        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n\t        if (units === 'millisecond') {\n\t            return this.valueOf() < localInput.valueOf();\n\t        } else {\n\t            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n\t        }\n\t    }\n\t\n\t    function isBetween (from, to, units, inclusivity) {\n\t        inclusivity = inclusivity || '()';\n\t        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n\t            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n\t    }\n\t\n\t    function isSame (input, units) {\n\t        var localInput = isMoment(input) ? input : local__createLocal(input),\n\t            inputMs;\n\t        if (!(this.isValid() && localInput.isValid())) {\n\t            return false;\n\t        }\n\t        units = normalizeUnits(units || 'millisecond');\n\t        if (units === 'millisecond') {\n\t            return this.valueOf() === localInput.valueOf();\n\t        } else {\n\t            inputMs = localInput.valueOf();\n\t            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n\t        }\n\t    }\n\t\n\t    function isSameOrAfter (input, units) {\n\t        return this.isSame(input, units) || this.isAfter(input,units);\n\t    }\n\t\n\t    function isSameOrBefore (input, units) {\n\t        return this.isSame(input, units) || this.isBefore(input,units);\n\t    }\n\t\n\t    function diff (input, units, asFloat) {\n\t        var that,\n\t            zoneDelta,\n\t            delta, output;\n\t\n\t        if (!this.isValid()) {\n\t            return NaN;\n\t        }\n\t\n\t        that = cloneWithOffset(input, this);\n\t\n\t        if (!that.isValid()) {\n\t            return NaN;\n\t        }\n\t\n\t        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\t\n\t        units = normalizeUnits(units);\n\t\n\t        if (units === 'year' || units === 'month' || units === 'quarter') {\n\t            output = monthDiff(this, that);\n\t            if (units === 'quarter') {\n\t                output = output / 3;\n\t            } else if (units === 'year') {\n\t                output = output / 12;\n\t            }\n\t        } else {\n\t            delta = this - that;\n\t            output = units === 'second' ? delta / 1e3 : // 1000\n\t                units === 'minute' ? delta / 6e4 : // 1000 * 60\n\t                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n\t                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n\t                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n\t                delta;\n\t        }\n\t        return asFloat ? output : absFloor(output);\n\t    }\n\t\n\t    function monthDiff (a, b) {\n\t        // difference in months\n\t        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n\t            // b is in (anchor - 1 month, anchor + 1 month)\n\t            anchor = a.clone().add(wholeMonthDiff, 'months'),\n\t            anchor2, adjust;\n\t\n\t        if (b - anchor < 0) {\n\t            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n\t            // linear across the month\n\t            adjust = (b - anchor) / (anchor - anchor2);\n\t        } else {\n\t            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n\t            // linear across the month\n\t            adjust = (b - anchor) / (anchor2 - anchor);\n\t        }\n\t\n\t        //check for negative zero, return zero if negative zero\n\t        return -(wholeMonthDiff + adjust) || 0;\n\t    }\n\t\n\t    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n\t    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\t\n\t    function toString () {\n\t        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n\t    }\n\t\n\t    function moment_format__toISOString () {\n\t        var m = this.clone().utc();\n\t        if (0 < m.year() && m.year() <= 9999) {\n\t            if (isFunction(Date.prototype.toISOString)) {\n\t                // native implementation is ~50x faster, use it when we can\n\t                return this.toDate().toISOString();\n\t            } else {\n\t                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n\t            }\n\t        } else {\n\t            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n\t        }\n\t    }\n\t\n\t    function format (inputString) {\n\t        if (!inputString) {\n\t            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;\n\t        }\n\t        var output = formatMoment(this, inputString);\n\t        return this.localeData().postformat(output);\n\t    }\n\t\n\t    function from (time, withoutSuffix) {\n\t        if (this.isValid() &&\n\t                ((isMoment(time) && time.isValid()) ||\n\t                 local__createLocal(time).isValid())) {\n\t            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n\t        } else {\n\t            return this.localeData().invalidDate();\n\t        }\n\t    }\n\t\n\t    function fromNow (withoutSuffix) {\n\t        return this.from(local__createLocal(), withoutSuffix);\n\t    }\n\t\n\t    function to (time, withoutSuffix) {\n\t        if (this.isValid() &&\n\t                ((isMoment(time) && time.isValid()) ||\n\t                 local__createLocal(time).isValid())) {\n\t            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n\t        } else {\n\t            return this.localeData().invalidDate();\n\t        }\n\t    }\n\t\n\t    function toNow (withoutSuffix) {\n\t        return this.to(local__createLocal(), withoutSuffix);\n\t    }\n\t\n\t    // If passed a locale key, it will set the locale for this\n\t    // instance.  Otherwise, it will return the locale configuration\n\t    // variables for this instance.\n\t    function locale (key) {\n\t        var newLocaleData;\n\t\n\t        if (key === undefined) {\n\t            return this._locale._abbr;\n\t        } else {\n\t            newLocaleData = locale_locales__getLocale(key);\n\t            if (newLocaleData != null) {\n\t                this._locale = newLocaleData;\n\t            }\n\t            return this;\n\t        }\n\t    }\n\t\n\t    var lang = deprecate(\n\t        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n\t        function (key) {\n\t            if (key === undefined) {\n\t                return this.localeData();\n\t            } else {\n\t                return this.locale(key);\n\t            }\n\t        }\n\t    );\n\t\n\t    function localeData () {\n\t        return this._locale;\n\t    }\n\t\n\t    function startOf (units) {\n\t        units = normalizeUnits(units);\n\t        // the following switch intentionally omits break keywords\n\t        // to utilize falling through the cases.\n\t        switch (units) {\n\t            case 'year':\n\t                this.month(0);\n\t                /* falls through */\n\t            case 'quarter':\n\t            case 'month':\n\t                this.date(1);\n\t                /* falls through */\n\t            case 'week':\n\t            case 'isoWeek':\n\t            case 'day':\n\t            case 'date':\n\t                this.hours(0);\n\t                /* falls through */\n\t            case 'hour':\n\t                this.minutes(0);\n\t                /* falls through */\n\t            case 'minute':\n\t                this.seconds(0);\n\t                /* falls through */\n\t            case 'second':\n\t                this.milliseconds(0);\n\t        }\n\t\n\t        // weeks are a special case\n\t        if (units === 'week') {\n\t            this.weekday(0);\n\t        }\n\t        if (units === 'isoWeek') {\n\t            this.isoWeekday(1);\n\t        }\n\t\n\t        // quarters are also special\n\t        if (units === 'quarter') {\n\t            this.month(Math.floor(this.month() / 3) * 3);\n\t        }\n\t\n\t        return this;\n\t    }\n\t\n\t    function endOf (units) {\n\t        units = normalizeUnits(units);\n\t        if (units === undefined || units === 'millisecond') {\n\t            return this;\n\t        }\n\t\n\t        // 'date' is an alias for 'day', so it should be considered as such.\n\t        if (units === 'date') {\n\t            units = 'day';\n\t        }\n\t\n\t        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n\t    }\n\t\n\t    function to_type__valueOf () {\n\t        return this._d.valueOf() - ((this._offset || 0) * 60000);\n\t    }\n\t\n\t    function unix () {\n\t        return Math.floor(this.valueOf() / 1000);\n\t    }\n\t\n\t    function toDate () {\n\t        return new Date(this.valueOf());\n\t    }\n\t\n\t    function toArray () {\n\t        var m = this;\n\t        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n\t    }\n\t\n\t    function toObject () {\n\t        var m = this;\n\t        return {\n\t            years: m.year(),\n\t            months: m.month(),\n\t            date: m.date(),\n\t            hours: m.hours(),\n\t            minutes: m.minutes(),\n\t            seconds: m.seconds(),\n\t            milliseconds: m.milliseconds()\n\t        };\n\t    }\n\t\n\t    function toJSON () {\n\t        // new Date(NaN).toJSON() === null\n\t        return this.isValid() ? this.toISOString() : null;\n\t    }\n\t\n\t    function moment_valid__isValid () {\n\t        return valid__isValid(this);\n\t    }\n\t\n\t    function parsingFlags () {\n\t        return extend({}, getParsingFlags(this));\n\t    }\n\t\n\t    function invalidAt () {\n\t        return getParsingFlags(this).overflow;\n\t    }\n\t\n\t    function creationData() {\n\t        return {\n\t            input: this._i,\n\t            format: this._f,\n\t            locale: this._locale,\n\t            isUTC: this._isUTC,\n\t            strict: this._strict\n\t        };\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken(0, ['gg', 2], 0, function () {\n\t        return this.weekYear() % 100;\n\t    });\n\t\n\t    addFormatToken(0, ['GG', 2], 0, function () {\n\t        return this.isoWeekYear() % 100;\n\t    });\n\t\n\t    function addWeekYearFormatToken (token, getter) {\n\t        addFormatToken(0, [token, token.length], 0, getter);\n\t    }\n\t\n\t    addWeekYearFormatToken('gggg',     'weekYear');\n\t    addWeekYearFormatToken('ggggg',    'weekYear');\n\t    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n\t    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('weekYear', 'gg');\n\t    addUnitAlias('isoWeekYear', 'GG');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('weekYear', 1);\n\t    addUnitPriority('isoWeekYear', 1);\n\t\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('G',      matchSigned);\n\t    addRegexToken('g',      matchSigned);\n\t    addRegexToken('GG',     match1to2, match2);\n\t    addRegexToken('gg',     match1to2, match2);\n\t    addRegexToken('GGGG',   match1to4, match4);\n\t    addRegexToken('gggg',   match1to4, match4);\n\t    addRegexToken('GGGGG',  match1to6, match6);\n\t    addRegexToken('ggggg',  match1to6, match6);\n\t\n\t    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n\t        week[token.substr(0, 2)] = toInt(input);\n\t    });\n\t\n\t    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n\t        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);\n\t    });\n\t\n\t    // MOMENTS\n\t\n\t    function getSetWeekYear (input) {\n\t        return getSetWeekYearHelper.call(this,\n\t                input,\n\t                this.week(),\n\t                this.weekday(),\n\t                this.localeData()._week.dow,\n\t                this.localeData()._week.doy);\n\t    }\n\t\n\t    function getSetISOWeekYear (input) {\n\t        return getSetWeekYearHelper.call(this,\n\t                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n\t    }\n\t\n\t    function getISOWeeksInYear () {\n\t        return weeksInYear(this.year(), 1, 4);\n\t    }\n\t\n\t    function getWeeksInYear () {\n\t        var weekInfo = this.localeData()._week;\n\t        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n\t    }\n\t\n\t    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n\t        var weeksTarget;\n\t        if (input == null) {\n\t            return weekOfYear(this, dow, doy).year;\n\t        } else {\n\t            weeksTarget = weeksInYear(input, dow, doy);\n\t            if (week > weeksTarget) {\n\t                week = weeksTarget;\n\t            }\n\t            return setWeekAll.call(this, input, week, weekday, dow, doy);\n\t        }\n\t    }\n\t\n\t    function setWeekAll(weekYear, week, weekday, dow, doy) {\n\t        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n\t            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\t\n\t        this.year(date.getUTCFullYear());\n\t        this.month(date.getUTCMonth());\n\t        this.date(date.getUTCDate());\n\t        return this;\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('Q', 0, 'Qo', 'quarter');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('quarter', 'Q');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('quarter', 7);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('Q', match1);\n\t    addParseToken('Q', function (input, array) {\n\t        array[MONTH] = (toInt(input) - 1) * 3;\n\t    });\n\t\n\t    // MOMENTS\n\t\n\t    function getSetQuarter (input) {\n\t        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('date', 'D');\n\t\n\t    // PRIOROITY\n\t    addUnitPriority('date', 9);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('D',  match1to2);\n\t    addRegexToken('DD', match1to2, match2);\n\t    addRegexToken('Do', function (isStrict, locale) {\n\t        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;\n\t    });\n\t\n\t    addParseToken(['D', 'DD'], DATE);\n\t    addParseToken('Do', function (input, array) {\n\t        array[DATE] = toInt(input.match(match1to2)[0], 10);\n\t    });\n\t\n\t    // MOMENTS\n\t\n\t    var getSetDayOfMonth = makeGetSet('Date', true);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('dayOfYear', 'DDD');\n\t\n\t    // PRIORITY\n\t    addUnitPriority('dayOfYear', 4);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('DDD',  match1to3);\n\t    addRegexToken('DDDD', match3);\n\t    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n\t        config._dayOfYear = toInt(input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    // MOMENTS\n\t\n\t    function getSetDayOfYear (input) {\n\t        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n\t        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('m', ['mm', 2], 0, 'minute');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('minute', 'm');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('minute', 14);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('m',  match1to2);\n\t    addRegexToken('mm', match1to2, match2);\n\t    addParseToken(['m', 'mm'], MINUTE);\n\t\n\t    // MOMENTS\n\t\n\t    var getSetMinute = makeGetSet('Minutes', false);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('s', ['ss', 2], 0, 'second');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('second', 's');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('second', 15);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('s',  match1to2);\n\t    addRegexToken('ss', match1to2, match2);\n\t    addParseToken(['s', 'ss'], SECOND);\n\t\n\t    // MOMENTS\n\t\n\t    var getSetSecond = makeGetSet('Seconds', false);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('S', 0, 0, function () {\n\t        return ~~(this.millisecond() / 100);\n\t    });\n\t\n\t    addFormatToken(0, ['SS', 2], 0, function () {\n\t        return ~~(this.millisecond() / 10);\n\t    });\n\t\n\t    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n\t    addFormatToken(0, ['SSSS', 4], 0, function () {\n\t        return this.millisecond() * 10;\n\t    });\n\t    addFormatToken(0, ['SSSSS', 5], 0, function () {\n\t        return this.millisecond() * 100;\n\t    });\n\t    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n\t        return this.millisecond() * 1000;\n\t    });\n\t    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n\t        return this.millisecond() * 10000;\n\t    });\n\t    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n\t        return this.millisecond() * 100000;\n\t    });\n\t    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n\t        return this.millisecond() * 1000000;\n\t    });\n\t\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('millisecond', 'ms');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('millisecond', 16);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('S',    match1to3, match1);\n\t    addRegexToken('SS',   match1to3, match2);\n\t    addRegexToken('SSS',  match1to3, match3);\n\t\n\t    var token;\n\t    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n\t        addRegexToken(token, matchUnsigned);\n\t    }\n\t\n\t    function parseMs(input, array) {\n\t        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n\t    }\n\t\n\t    for (token = 'S'; token.length <= 9; token += 'S') {\n\t        addParseToken(token, parseMs);\n\t    }\n\t    // MOMENTS\n\t\n\t    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('z',  0, 0, 'zoneAbbr');\n\t    addFormatToken('zz', 0, 0, 'zoneName');\n\t\n\t    // MOMENTS\n\t\n\t    function getZoneAbbr () {\n\t        return this._isUTC ? 'UTC' : '';\n\t    }\n\t\n\t    function getZoneName () {\n\t        return this._isUTC ? 'Coordinated Universal Time' : '';\n\t    }\n\t\n\t    var momentPrototype__proto = Moment.prototype;\n\t\n\t    momentPrototype__proto.add               = add_subtract__add;\n\t    momentPrototype__proto.calendar          = moment_calendar__calendar;\n\t    momentPrototype__proto.clone             = clone;\n\t    momentPrototype__proto.diff              = diff;\n\t    momentPrototype__proto.endOf             = endOf;\n\t    momentPrototype__proto.format            = format;\n\t    momentPrototype__proto.from              = from;\n\t    momentPrototype__proto.fromNow           = fromNow;\n\t    momentPrototype__proto.to                = to;\n\t    momentPrototype__proto.toNow             = toNow;\n\t    momentPrototype__proto.get               = stringGet;\n\t    momentPrototype__proto.invalidAt         = invalidAt;\n\t    momentPrototype__proto.isAfter           = isAfter;\n\t    momentPrototype__proto.isBefore          = isBefore;\n\t    momentPrototype__proto.isBetween         = isBetween;\n\t    momentPrototype__proto.isSame            = isSame;\n\t    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;\n\t    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;\n\t    momentPrototype__proto.isValid           = moment_valid__isValid;\n\t    momentPrototype__proto.lang              = lang;\n\t    momentPrototype__proto.locale            = locale;\n\t    momentPrototype__proto.localeData        = localeData;\n\t    momentPrototype__proto.max               = prototypeMax;\n\t    momentPrototype__proto.min               = prototypeMin;\n\t    momentPrototype__proto.parsingFlags      = parsingFlags;\n\t    momentPrototype__proto.set               = stringSet;\n\t    momentPrototype__proto.startOf           = startOf;\n\t    momentPrototype__proto.subtract          = add_subtract__subtract;\n\t    momentPrototype__proto.toArray           = toArray;\n\t    momentPrototype__proto.toObject          = toObject;\n\t    momentPrototype__proto.toDate            = toDate;\n\t    momentPrototype__proto.toISOString       = moment_format__toISOString;\n\t    momentPrototype__proto.toJSON            = toJSON;\n\t    momentPrototype__proto.toString          = toString;\n\t    momentPrototype__proto.unix              = unix;\n\t    momentPrototype__proto.valueOf           = to_type__valueOf;\n\t    momentPrototype__proto.creationData      = creationData;\n\t\n\t    // Year\n\t    momentPrototype__proto.year       = getSetYear;\n\t    momentPrototype__proto.isLeapYear = getIsLeapYear;\n\t\n\t    // Week Year\n\t    momentPrototype__proto.weekYear    = getSetWeekYear;\n\t    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;\n\t\n\t    // Quarter\n\t    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;\n\t\n\t    // Month\n\t    momentPrototype__proto.month       = getSetMonth;\n\t    momentPrototype__proto.daysInMonth = getDaysInMonth;\n\t\n\t    // Week\n\t    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;\n\t    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;\n\t    momentPrototype__proto.weeksInYear    = getWeeksInYear;\n\t    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;\n\t\n\t    // Day\n\t    momentPrototype__proto.date       = getSetDayOfMonth;\n\t    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;\n\t    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;\n\t    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;\n\t    momentPrototype__proto.dayOfYear  = getSetDayOfYear;\n\t\n\t    // Hour\n\t    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;\n\t\n\t    // Minute\n\t    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;\n\t\n\t    // Second\n\t    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;\n\t\n\t    // Millisecond\n\t    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;\n\t\n\t    // Offset\n\t    momentPrototype__proto.utcOffset            = getSetOffset;\n\t    momentPrototype__proto.utc                  = setOffsetToUTC;\n\t    momentPrototype__proto.local                = setOffsetToLocal;\n\t    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;\n\t    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;\n\t    momentPrototype__proto.isDST                = isDaylightSavingTime;\n\t    momentPrototype__proto.isLocal              = isLocal;\n\t    momentPrototype__proto.isUtcOffset          = isUtcOffset;\n\t    momentPrototype__proto.isUtc                = isUtc;\n\t    momentPrototype__proto.isUTC                = isUtc;\n\t\n\t    // Timezone\n\t    momentPrototype__proto.zoneAbbr = getZoneAbbr;\n\t    momentPrototype__proto.zoneName = getZoneName;\n\t\n\t    // Deprecations\n\t    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n\t    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n\t    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n\t    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n\t    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\t\n\t    var momentPrototype = momentPrototype__proto;\n\t\n\t    function moment__createUnix (input) {\n\t        return local__createLocal(input * 1000);\n\t    }\n\t\n\t    function moment__createInZone () {\n\t        return local__createLocal.apply(null, arguments).parseZone();\n\t    }\n\t\n\t    function preParsePostFormat (string) {\n\t        return string;\n\t    }\n\t\n\t    var prototype__proto = Locale.prototype;\n\t\n\t    prototype__proto.calendar        = locale_calendar__calendar;\n\t    prototype__proto.longDateFormat  = longDateFormat;\n\t    prototype__proto.invalidDate     = invalidDate;\n\t    prototype__proto.ordinal         = ordinal;\n\t    prototype__proto.preparse        = preParsePostFormat;\n\t    prototype__proto.postformat      = preParsePostFormat;\n\t    prototype__proto.relativeTime    = relative__relativeTime;\n\t    prototype__proto.pastFuture      = pastFuture;\n\t    prototype__proto.set             = locale_set__set;\n\t\n\t    // Month\n\t    prototype__proto.months            =        localeMonths;\n\t    prototype__proto.monthsShort       =        localeMonthsShort;\n\t    prototype__proto.monthsParse       =        localeMonthsParse;\n\t    prototype__proto.monthsRegex       = monthsRegex;\n\t    prototype__proto.monthsShortRegex  = monthsShortRegex;\n\t\n\t    // Week\n\t    prototype__proto.week = localeWeek;\n\t    prototype__proto.firstDayOfYear = localeFirstDayOfYear;\n\t    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;\n\t\n\t    // Day of Week\n\t    prototype__proto.weekdays       =        localeWeekdays;\n\t    prototype__proto.weekdaysMin    =        localeWeekdaysMin;\n\t    prototype__proto.weekdaysShort  =        localeWeekdaysShort;\n\t    prototype__proto.weekdaysParse  =        localeWeekdaysParse;\n\t\n\t    prototype__proto.weekdaysRegex       =        weekdaysRegex;\n\t    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;\n\t    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;\n\t\n\t    // Hours\n\t    prototype__proto.isPM = localeIsPM;\n\t    prototype__proto.meridiem = localeMeridiem;\n\t\n\t    function lists__get (format, index, field, setter) {\n\t        var locale = locale_locales__getLocale();\n\t        var utc = create_utc__createUTC().set(setter, index);\n\t        return locale[field](utc, format);\n\t    }\n\t\n\t    function listMonthsImpl (format, index, field) {\n\t        if (typeof format === 'number') {\n\t            index = format;\n\t            format = undefined;\n\t        }\n\t\n\t        format = format || '';\n\t\n\t        if (index != null) {\n\t            return lists__get(format, index, field, 'month');\n\t        }\n\t\n\t        var i;\n\t        var out = [];\n\t        for (i = 0; i < 12; i++) {\n\t            out[i] = lists__get(format, i, field, 'month');\n\t        }\n\t        return out;\n\t    }\n\t\n\t    // ()\n\t    // (5)\n\t    // (fmt, 5)\n\t    // (fmt)\n\t    // (true)\n\t    // (true, 5)\n\t    // (true, fmt, 5)\n\t    // (true, fmt)\n\t    function listWeekdaysImpl (localeSorted, format, index, field) {\n\t        if (typeof localeSorted === 'boolean') {\n\t            if (typeof format === 'number') {\n\t                index = format;\n\t                format = undefined;\n\t            }\n\t\n\t            format = format || '';\n\t        } else {\n\t            format = localeSorted;\n\t            index = format;\n\t            localeSorted = false;\n\t\n\t            if (typeof format === 'number') {\n\t                index = format;\n\t                format = undefined;\n\t            }\n\t\n\t            format = format || '';\n\t        }\n\t\n\t        var locale = locale_locales__getLocale(),\n\t            shift = localeSorted ? locale._week.dow : 0;\n\t\n\t        if (index != null) {\n\t            return lists__get(format, (index + shift) % 7, field, 'day');\n\t        }\n\t\n\t        var i;\n\t        var out = [];\n\t        for (i = 0; i < 7; i++) {\n\t            out[i] = lists__get(format, (i + shift) % 7, field, 'day');\n\t        }\n\t        return out;\n\t    }\n\t\n\t    function lists__listMonths (format, index) {\n\t        return listMonthsImpl(format, index, 'months');\n\t    }\n\t\n\t    function lists__listMonthsShort (format, index) {\n\t        return listMonthsImpl(format, index, 'monthsShort');\n\t    }\n\t\n\t    function lists__listWeekdays (localeSorted, format, index) {\n\t        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n\t    }\n\t\n\t    function lists__listWeekdaysShort (localeSorted, format, index) {\n\t        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n\t    }\n\t\n\t    function lists__listWeekdaysMin (localeSorted, format, index) {\n\t        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n\t    }\n\t\n\t    locale_locales__getSetGlobalLocale('en', {\n\t        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        }\n\t    });\n\t\n\t    // Side effect imports\n\t    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);\n\t    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);\n\t\n\t    var mathAbs = Math.abs;\n\t\n\t    function duration_abs__abs () {\n\t        var data           = this._data;\n\t\n\t        this._milliseconds = mathAbs(this._milliseconds);\n\t        this._days         = mathAbs(this._days);\n\t        this._months       = mathAbs(this._months);\n\t\n\t        data.milliseconds  = mathAbs(data.milliseconds);\n\t        data.seconds       = mathAbs(data.seconds);\n\t        data.minutes       = mathAbs(data.minutes);\n\t        data.hours         = mathAbs(data.hours);\n\t        data.months        = mathAbs(data.months);\n\t        data.years         = mathAbs(data.years);\n\t\n\t        return this;\n\t    }\n\t\n\t    function duration_add_subtract__addSubtract (duration, input, value, direction) {\n\t        var other = create__createDuration(input, value);\n\t\n\t        duration._milliseconds += direction * other._milliseconds;\n\t        duration._days         += direction * other._days;\n\t        duration._months       += direction * other._months;\n\t\n\t        return duration._bubble();\n\t    }\n\t\n\t    // supports only 2.0-style add(1, 's') or add(duration)\n\t    function duration_add_subtract__add (input, value) {\n\t        return duration_add_subtract__addSubtract(this, input, value, 1);\n\t    }\n\t\n\t    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n\t    function duration_add_subtract__subtract (input, value) {\n\t        return duration_add_subtract__addSubtract(this, input, value, -1);\n\t    }\n\t\n\t    function absCeil (number) {\n\t        if (number < 0) {\n\t            return Math.floor(number);\n\t        } else {\n\t            return Math.ceil(number);\n\t        }\n\t    }\n\t\n\t    function bubble () {\n\t        var milliseconds = this._milliseconds;\n\t        var days         = this._days;\n\t        var months       = this._months;\n\t        var data         = this._data;\n\t        var seconds, minutes, hours, years, monthsFromDays;\n\t\n\t        // if we have a mix of positive and negative values, bubble down first\n\t        // check: https://github.com/moment/moment/issues/2166\n\t        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n\t                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n\t            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n\t            days = 0;\n\t            months = 0;\n\t        }\n\t\n\t        // The following code bubbles up values, see the tests for\n\t        // examples of what that means.\n\t        data.milliseconds = milliseconds % 1000;\n\t\n\t        seconds           = absFloor(milliseconds / 1000);\n\t        data.seconds      = seconds % 60;\n\t\n\t        minutes           = absFloor(seconds / 60);\n\t        data.minutes      = minutes % 60;\n\t\n\t        hours             = absFloor(minutes / 60);\n\t        data.hours        = hours % 24;\n\t\n\t        days += absFloor(hours / 24);\n\t\n\t        // convert days to months\n\t        monthsFromDays = absFloor(daysToMonths(days));\n\t        months += monthsFromDays;\n\t        days -= absCeil(monthsToDays(monthsFromDays));\n\t\n\t        // 12 months -> 1 year\n\t        years = absFloor(months / 12);\n\t        months %= 12;\n\t\n\t        data.days   = days;\n\t        data.months = months;\n\t        data.years  = years;\n\t\n\t        return this;\n\t    }\n\t\n\t    function daysToMonths (days) {\n\t        // 400 years have 146097 days (taking into account leap year rules)\n\t        // 400 years have 12 months === 4800\n\t        return days * 4800 / 146097;\n\t    }\n\t\n\t    function monthsToDays (months) {\n\t        // the reverse of daysToMonths\n\t        return months * 146097 / 4800;\n\t    }\n\t\n\t    function as (units) {\n\t        var days;\n\t        var months;\n\t        var milliseconds = this._milliseconds;\n\t\n\t        units = normalizeUnits(units);\n\t\n\t        if (units === 'month' || units === 'year') {\n\t            days   = this._days   + milliseconds / 864e5;\n\t            months = this._months + daysToMonths(days);\n\t            return units === 'month' ? months : months / 12;\n\t        } else {\n\t            // handle milliseconds separately because of floating point math errors (issue #1867)\n\t            days = this._days + Math.round(monthsToDays(this._months));\n\t            switch (units) {\n\t                case 'week'   : return days / 7     + milliseconds / 6048e5;\n\t                case 'day'    : return days         + milliseconds / 864e5;\n\t                case 'hour'   : return days * 24    + milliseconds / 36e5;\n\t                case 'minute' : return days * 1440  + milliseconds / 6e4;\n\t                case 'second' : return days * 86400 + milliseconds / 1000;\n\t                // Math.floor prevents floating point math errors here\n\t                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n\t                default: throw new Error('Unknown unit ' + units);\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO: Use this.as('ms')?\n\t    function duration_as__valueOf () {\n\t        return (\n\t            this._milliseconds +\n\t            this._days * 864e5 +\n\t            (this._months % 12) * 2592e6 +\n\t            toInt(this._months / 12) * 31536e6\n\t        );\n\t    }\n\t\n\t    function makeAs (alias) {\n\t        return function () {\n\t            return this.as(alias);\n\t        };\n\t    }\n\t\n\t    var asMilliseconds = makeAs('ms');\n\t    var asSeconds      = makeAs('s');\n\t    var asMinutes      = makeAs('m');\n\t    var asHours        = makeAs('h');\n\t    var asDays         = makeAs('d');\n\t    var asWeeks        = makeAs('w');\n\t    var asMonths       = makeAs('M');\n\t    var asYears        = makeAs('y');\n\t\n\t    function duration_get__get (units) {\n\t        units = normalizeUnits(units);\n\t        return this[units + 's']();\n\t    }\n\t\n\t    function makeGetter(name) {\n\t        return function () {\n\t            return this._data[name];\n\t        };\n\t    }\n\t\n\t    var milliseconds = makeGetter('milliseconds');\n\t    var seconds      = makeGetter('seconds');\n\t    var minutes      = makeGetter('minutes');\n\t    var hours        = makeGetter('hours');\n\t    var days         = makeGetter('days');\n\t    var months       = makeGetter('months');\n\t    var years        = makeGetter('years');\n\t\n\t    function weeks () {\n\t        return absFloor(this.days() / 7);\n\t    }\n\t\n\t    var round = Math.round;\n\t    var thresholds = {\n\t        s: 45,  // seconds to minute\n\t        m: 45,  // minutes to hour\n\t        h: 22,  // hours to day\n\t        d: 26,  // days to month\n\t        M: 11   // months to year\n\t    };\n\t\n\t    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n\t    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n\t        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n\t    }\n\t\n\t    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {\n\t        var duration = create__createDuration(posNegDuration).abs();\n\t        var seconds  = round(duration.as('s'));\n\t        var minutes  = round(duration.as('m'));\n\t        var hours    = round(duration.as('h'));\n\t        var days     = round(duration.as('d'));\n\t        var months   = round(duration.as('M'));\n\t        var years    = round(duration.as('y'));\n\t\n\t        var a = seconds < thresholds.s && ['s', seconds]  ||\n\t                minutes <= 1           && ['m']           ||\n\t                minutes < thresholds.m && ['mm', minutes] ||\n\t                hours   <= 1           && ['h']           ||\n\t                hours   < thresholds.h && ['hh', hours]   ||\n\t                days    <= 1           && ['d']           ||\n\t                days    < thresholds.d && ['dd', days]    ||\n\t                months  <= 1           && ['M']           ||\n\t                months  < thresholds.M && ['MM', months]  ||\n\t                years   <= 1           && ['y']           || ['yy', years];\n\t\n\t        a[2] = withoutSuffix;\n\t        a[3] = +posNegDuration > 0;\n\t        a[4] = locale;\n\t        return substituteTimeAgo.apply(null, a);\n\t    }\n\t\n\t    // This function allows you to set the rounding function for relative time strings\n\t    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {\n\t        if (roundingFunction === undefined) {\n\t            return round;\n\t        }\n\t        if (typeof(roundingFunction) === 'function') {\n\t            round = roundingFunction;\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    // This function allows you to set a threshold for relative time strings\n\t    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {\n\t        if (thresholds[threshold] === undefined) {\n\t            return false;\n\t        }\n\t        if (limit === undefined) {\n\t            return thresholds[threshold];\n\t        }\n\t        thresholds[threshold] = limit;\n\t        return true;\n\t    }\n\t\n\t    function humanize (withSuffix) {\n\t        var locale = this.localeData();\n\t        var output = duration_humanize__relativeTime(this, !withSuffix, locale);\n\t\n\t        if (withSuffix) {\n\t            output = locale.pastFuture(+this, output);\n\t        }\n\t\n\t        return locale.postformat(output);\n\t    }\n\t\n\t    var iso_string__abs = Math.abs;\n\t\n\t    function iso_string__toISOString() {\n\t        // for ISO strings we do not use the normal bubbling rules:\n\t        //  * milliseconds bubble up until they become hours\n\t        //  * days do not bubble at all\n\t        //  * months bubble up until they become years\n\t        // This is because there is no context-free conversion between hours and days\n\t        // (think of clock changes)\n\t        // and also not between days and months (28-31 days per month)\n\t        var seconds = iso_string__abs(this._milliseconds) / 1000;\n\t        var days         = iso_string__abs(this._days);\n\t        var months       = iso_string__abs(this._months);\n\t        var minutes, hours, years;\n\t\n\t        // 3600 seconds -> 60 minutes -> 1 hour\n\t        minutes           = absFloor(seconds / 60);\n\t        hours             = absFloor(minutes / 60);\n\t        seconds %= 60;\n\t        minutes %= 60;\n\t\n\t        // 12 months -> 1 year\n\t        years  = absFloor(months / 12);\n\t        months %= 12;\n\t\n\t\n\t        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n\t        var Y = years;\n\t        var M = months;\n\t        var D = days;\n\t        var h = hours;\n\t        var m = minutes;\n\t        var s = seconds;\n\t        var total = this.asSeconds();\n\t\n\t        if (!total) {\n\t            // this is the same as C#'s (Noda) and python (isodate)...\n\t            // but not other JS (goog.date)\n\t            return 'P0D';\n\t        }\n\t\n\t        return (total < 0 ? '-' : '') +\n\t            'P' +\n\t            (Y ? Y + 'Y' : '') +\n\t            (M ? M + 'M' : '') +\n\t            (D ? D + 'D' : '') +\n\t            ((h || m || s) ? 'T' : '') +\n\t            (h ? h + 'H' : '') +\n\t            (m ? m + 'M' : '') +\n\t            (s ? s + 'S' : '');\n\t    }\n\t\n\t    var duration_prototype__proto = Duration.prototype;\n\t\n\t    duration_prototype__proto.abs            = duration_abs__abs;\n\t    duration_prototype__proto.add            = duration_add_subtract__add;\n\t    duration_prototype__proto.subtract       = duration_add_subtract__subtract;\n\t    duration_prototype__proto.as             = as;\n\t    duration_prototype__proto.asMilliseconds = asMilliseconds;\n\t    duration_prototype__proto.asSeconds      = asSeconds;\n\t    duration_prototype__proto.asMinutes      = asMinutes;\n\t    duration_prototype__proto.asHours        = asHours;\n\t    duration_prototype__proto.asDays         = asDays;\n\t    duration_prototype__proto.asWeeks        = asWeeks;\n\t    duration_prototype__proto.asMonths       = asMonths;\n\t    duration_prototype__proto.asYears        = asYears;\n\t    duration_prototype__proto.valueOf        = duration_as__valueOf;\n\t    duration_prototype__proto._bubble        = bubble;\n\t    duration_prototype__proto.get            = duration_get__get;\n\t    duration_prototype__proto.milliseconds   = milliseconds;\n\t    duration_prototype__proto.seconds        = seconds;\n\t    duration_prototype__proto.minutes        = minutes;\n\t    duration_prototype__proto.hours          = hours;\n\t    duration_prototype__proto.days           = days;\n\t    duration_prototype__proto.weeks          = weeks;\n\t    duration_prototype__proto.months         = months;\n\t    duration_prototype__proto.years          = years;\n\t    duration_prototype__proto.humanize       = humanize;\n\t    duration_prototype__proto.toISOString    = iso_string__toISOString;\n\t    duration_prototype__proto.toString       = iso_string__toISOString;\n\t    duration_prototype__proto.toJSON         = iso_string__toISOString;\n\t    duration_prototype__proto.locale         = locale;\n\t    duration_prototype__proto.localeData     = localeData;\n\t\n\t    // Deprecations\n\t    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);\n\t    duration_prototype__proto.lang = lang;\n\t\n\t    // Side effect imports\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('X', 0, 0, 'unix');\n\t    addFormatToken('x', 0, 0, 'valueOf');\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('x', matchSigned);\n\t    addRegexToken('X', matchTimestamp);\n\t    addParseToken('X', function (input, array, config) {\n\t        config._d = new Date(parseFloat(input, 10) * 1000);\n\t    });\n\t    addParseToken('x', function (input, array, config) {\n\t        config._d = new Date(toInt(input));\n\t    });\n\t\n\t    // Side effect imports\n\t\n\t\n\t    utils_hooks__hooks.version = '2.14.1';\n\t\n\t    setHookCallback(local__createLocal);\n\t\n\t    utils_hooks__hooks.fn                    = momentPrototype;\n\t    utils_hooks__hooks.min                   = min;\n\t    utils_hooks__hooks.max                   = max;\n\t    utils_hooks__hooks.now                   = now;\n\t    utils_hooks__hooks.utc                   = create_utc__createUTC;\n\t    utils_hooks__hooks.unix                  = moment__createUnix;\n\t    utils_hooks__hooks.months                = lists__listMonths;\n\t    utils_hooks__hooks.isDate                = isDate;\n\t    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;\n\t    utils_hooks__hooks.invalid               = valid__createInvalid;\n\t    utils_hooks__hooks.duration              = create__createDuration;\n\t    utils_hooks__hooks.isMoment              = isMoment;\n\t    utils_hooks__hooks.weekdays              = lists__listWeekdays;\n\t    utils_hooks__hooks.parseZone             = moment__createInZone;\n\t    utils_hooks__hooks.localeData            = locale_locales__getLocale;\n\t    utils_hooks__hooks.isDuration            = isDuration;\n\t    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;\n\t    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;\n\t    utils_hooks__hooks.defineLocale          = defineLocale;\n\t    utils_hooks__hooks.updateLocale          = updateLocale;\n\t    utils_hooks__hooks.locales               = locale_locales__listLocales;\n\t    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;\n\t    utils_hooks__hooks.normalizeUnits        = normalizeUnits;\n\t    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;\n\t    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;\n\t    utils_hooks__hooks.calendarFormat        = getCalendarFormat;\n\t    utils_hooks__hooks.prototype             = momentPrototype;\n\t\n\t    var _moment = utils_hooks__hooks;\n\t\n\t    return _moment;\n\t\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./af\": 5,\n\t\t\"./af.js\": 5,\n\t\t\"./ar\": 6,\n\t\t\"./ar-ma\": 7,\n\t\t\"./ar-ma.js\": 7,\n\t\t\"./ar-sa\": 8,\n\t\t\"./ar-sa.js\": 8,\n\t\t\"./ar-tn\": 9,\n\t\t\"./ar-tn.js\": 9,\n\t\t\"./ar.js\": 6,\n\t\t\"./az\": 10,\n\t\t\"./az.js\": 10,\n\t\t\"./be\": 11,\n\t\t\"./be.js\": 11,\n\t\t\"./bg\": 12,\n\t\t\"./bg.js\": 12,\n\t\t\"./bn\": 13,\n\t\t\"./bn.js\": 13,\n\t\t\"./bo\": 14,\n\t\t\"./bo.js\": 14,\n\t\t\"./br\": 15,\n\t\t\"./br.js\": 15,\n\t\t\"./bs\": 16,\n\t\t\"./bs.js\": 16,\n\t\t\"./ca\": 17,\n\t\t\"./ca.js\": 17,\n\t\t\"./cs\": 18,\n\t\t\"./cs.js\": 18,\n\t\t\"./cv\": 19,\n\t\t\"./cv.js\": 19,\n\t\t\"./cy\": 20,\n\t\t\"./cy.js\": 20,\n\t\t\"./da\": 21,\n\t\t\"./da.js\": 21,\n\t\t\"./de\": 22,\n\t\t\"./de-at\": 23,\n\t\t\"./de-at.js\": 23,\n\t\t\"./de.js\": 22,\n\t\t\"./dv\": 24,\n\t\t\"./dv.js\": 24,\n\t\t\"./el\": 25,\n\t\t\"./el.js\": 25,\n\t\t\"./en-au\": 26,\n\t\t\"./en-au.js\": 26,\n\t\t\"./en-ca\": 27,\n\t\t\"./en-ca.js\": 27,\n\t\t\"./en-gb\": 28,\n\t\t\"./en-gb.js\": 28,\n\t\t\"./en-ie\": 29,\n\t\t\"./en-ie.js\": 29,\n\t\t\"./en-nz\": 30,\n\t\t\"./en-nz.js\": 30,\n\t\t\"./eo\": 31,\n\t\t\"./eo.js\": 31,\n\t\t\"./es\": 32,\n\t\t\"./es-do\": 33,\n\t\t\"./es-do.js\": 33,\n\t\t\"./es.js\": 32,\n\t\t\"./et\": 34,\n\t\t\"./et.js\": 34,\n\t\t\"./eu\": 35,\n\t\t\"./eu.js\": 35,\n\t\t\"./fa\": 36,\n\t\t\"./fa.js\": 36,\n\t\t\"./fi\": 37,\n\t\t\"./fi.js\": 37,\n\t\t\"./fo\": 38,\n\t\t\"./fo.js\": 38,\n\t\t\"./fr\": 39,\n\t\t\"./fr-ca\": 40,\n\t\t\"./fr-ca.js\": 40,\n\t\t\"./fr-ch\": 41,\n\t\t\"./fr-ch.js\": 41,\n\t\t\"./fr.js\": 39,\n\t\t\"./fy\": 42,\n\t\t\"./fy.js\": 42,\n\t\t\"./gd\": 43,\n\t\t\"./gd.js\": 43,\n\t\t\"./gl\": 44,\n\t\t\"./gl.js\": 44,\n\t\t\"./he\": 45,\n\t\t\"./he.js\": 45,\n\t\t\"./hi\": 46,\n\t\t\"./hi.js\": 46,\n\t\t\"./hr\": 47,\n\t\t\"./hr.js\": 47,\n\t\t\"./hu\": 48,\n\t\t\"./hu.js\": 48,\n\t\t\"./hy-am\": 49,\n\t\t\"./hy-am.js\": 49,\n\t\t\"./id\": 50,\n\t\t\"./id.js\": 50,\n\t\t\"./is\": 51,\n\t\t\"./is.js\": 51,\n\t\t\"./it\": 52,\n\t\t\"./it.js\": 52,\n\t\t\"./ja\": 53,\n\t\t\"./ja.js\": 53,\n\t\t\"./jv\": 54,\n\t\t\"./jv.js\": 54,\n\t\t\"./ka\": 55,\n\t\t\"./ka.js\": 55,\n\t\t\"./kk\": 56,\n\t\t\"./kk.js\": 56,\n\t\t\"./km\": 57,\n\t\t\"./km.js\": 57,\n\t\t\"./ko\": 58,\n\t\t\"./ko.js\": 58,\n\t\t\"./ky\": 59,\n\t\t\"./ky.js\": 59,\n\t\t\"./lb\": 60,\n\t\t\"./lb.js\": 60,\n\t\t\"./lo\": 61,\n\t\t\"./lo.js\": 61,\n\t\t\"./lt\": 62,\n\t\t\"./lt.js\": 62,\n\t\t\"./lv\": 63,\n\t\t\"./lv.js\": 63,\n\t\t\"./me\": 64,\n\t\t\"./me.js\": 64,\n\t\t\"./mk\": 65,\n\t\t\"./mk.js\": 65,\n\t\t\"./ml\": 66,\n\t\t\"./ml.js\": 66,\n\t\t\"./mr\": 67,\n\t\t\"./mr.js\": 67,\n\t\t\"./ms\": 68,\n\t\t\"./ms-my\": 69,\n\t\t\"./ms-my.js\": 69,\n\t\t\"./ms.js\": 68,\n\t\t\"./my\": 70,\n\t\t\"./my.js\": 70,\n\t\t\"./nb\": 71,\n\t\t\"./nb.js\": 71,\n\t\t\"./ne\": 72,\n\t\t\"./ne.js\": 72,\n\t\t\"./nl\": 73,\n\t\t\"./nl.js\": 73,\n\t\t\"./nn\": 74,\n\t\t\"./nn.js\": 74,\n\t\t\"./pa-in\": 75,\n\t\t\"./pa-in.js\": 75,\n\t\t\"./pl\": 76,\n\t\t\"./pl.js\": 76,\n\t\t\"./pt\": 77,\n\t\t\"./pt-br\": 78,\n\t\t\"./pt-br.js\": 78,\n\t\t\"./pt.js\": 77,\n\t\t\"./ro\": 79,\n\t\t\"./ro.js\": 79,\n\t\t\"./ru\": 80,\n\t\t\"./ru.js\": 80,\n\t\t\"./se\": 81,\n\t\t\"./se.js\": 81,\n\t\t\"./si\": 82,\n\t\t\"./si.js\": 82,\n\t\t\"./sk\": 83,\n\t\t\"./sk.js\": 83,\n\t\t\"./sl\": 84,\n\t\t\"./sl.js\": 84,\n\t\t\"./sq\": 85,\n\t\t\"./sq.js\": 85,\n\t\t\"./sr\": 86,\n\t\t\"./sr-cyrl\": 87,\n\t\t\"./sr-cyrl.js\": 87,\n\t\t\"./sr.js\": 86,\n\t\t\"./ss\": 88,\n\t\t\"./ss.js\": 88,\n\t\t\"./sv\": 89,\n\t\t\"./sv.js\": 89,\n\t\t\"./sw\": 90,\n\t\t\"./sw.js\": 90,\n\t\t\"./ta\": 91,\n\t\t\"./ta.js\": 91,\n\t\t\"./te\": 92,\n\t\t\"./te.js\": 92,\n\t\t\"./th\": 93,\n\t\t\"./th.js\": 93,\n\t\t\"./tl-ph\": 94,\n\t\t\"./tl-ph.js\": 94,\n\t\t\"./tlh\": 95,\n\t\t\"./tlh.js\": 95,\n\t\t\"./tr\": 96,\n\t\t\"./tr.js\": 96,\n\t\t\"./tzl\": 97,\n\t\t\"./tzl.js\": 97,\n\t\t\"./tzm\": 98,\n\t\t\"./tzm-latn\": 99,\n\t\t\"./tzm-latn.js\": 99,\n\t\t\"./tzm.js\": 98,\n\t\t\"./uk\": 100,\n\t\t\"./uk.js\": 100,\n\t\t\"./uz\": 101,\n\t\t\"./uz.js\": 101,\n\t\t\"./vi\": 102,\n\t\t\"./vi.js\": 102,\n\t\t\"./x-pseudo\": 103,\n\t\t\"./x-pseudo.js\": 103,\n\t\t\"./zh-cn\": 104,\n\t\t\"./zh-cn.js\": 104,\n\t\t\"./zh-tw\": 105,\n\t\t\"./zh-tw.js\": 105\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 4;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Afrikaans [af]\n\t//! author : Werner Mollentze : https://github.com/wernerm\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var af = moment.defineLocale('af', {\n\t        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),\n\t        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),\n\t        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),\n\t        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),\n\t        meridiemParse: /vm|nm/i,\n\t        isPM : function (input) {\n\t            return /^nm$/i.test(input);\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 12) {\n\t                return isLower ? 'vm' : 'VM';\n\t            } else {\n\t                return isLower ? 'nm' : 'NM';\n\t            }\n\t        },\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Vandag om] LT',\n\t            nextDay : '[Mre om] LT',\n\t            nextWeek : 'dddd [om] LT',\n\t            lastDay : '[Gister om] LT',\n\t            lastWeek : '[Laas] dddd [om] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'oor %s',\n\t            past : '%s gelede',\n\t            s : '\\'n paar sekondes',\n\t            m : '\\'n minuut',\n\t            mm : '%d minute',\n\t            h : '\\'n uur',\n\t            hh : '%d ure',\n\t            d : '\\'n dag',\n\t            dd : '%d dae',\n\t            M : '\\'n maand',\n\t            MM : '%d maande',\n\t            y : '\\'n jaar',\n\t            yy : '%d jaar'\n\t        },\n\t        ordinalParse: /\\d{1,2}(ste|de)/,\n\t        ordinal : function (number) {\n\t            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter\n\t        },\n\t        week : {\n\t            dow : 1, // Maandag is die eerste dag van die week.\n\t            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.\n\t        }\n\t    });\n\t\n\t    return af;\n\t\n\t}));\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Arabic [ar]\n\t//! author : Abdel Said: https://github.com/abdelsaid\n\t//! changes in months, weekdays: Ahmed Elkhatib\n\t//! Native plural forms: forabi https://github.com/forabi\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    }, numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    }, pluralForm = function (n) {\n\t        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;\n\t    }, plurals = {\n\t        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n\t        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n\t        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n\t        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n\t        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n\t        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']\n\t    }, pluralize = function (u) {\n\t        return function (number, withoutSuffix, string, isFuture) {\n\t            var f = pluralForm(number),\n\t                str = plurals[u][pluralForm(number)];\n\t            if (f === 2) {\n\t                str = str[withoutSuffix ? 0 : 1];\n\t            }\n\t            return str.replace(/%d/i, number);\n\t        };\n\t    }, months = [\n\t        '  ',\n\t        ' ',\n\t        ' ',\n\t        ' ',\n\t        ' ',\n\t        ' ',\n\t        ' ',\n\t        ' ',\n\t        ' ',\n\t        '  ',\n\t        '  ',\n\t        '  '\n\t    ];\n\t\n\t    var ar = moment.defineLocale('ar', {\n\t        months : months,\n\t        monthsShort : months,\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'D/\\u200FM/\\u200FYYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        meridiemParse: /|/,\n\t        isPM : function (input) {\n\t            return '' === input;\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 12) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay: '[  ] LT',\n\t            nextDay: '[  ] LT',\n\t            nextWeek: 'dddd [ ] LT',\n\t            lastDay: '[  ] LT',\n\t            lastWeek: 'dddd [ ] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : ' %s',\n\t            s : pluralize('s'),\n\t            m : pluralize('m'),\n\t            mm : pluralize('m'),\n\t            h : pluralize('h'),\n\t            hh : pluralize('h'),\n\t            d : pluralize('d'),\n\t            dd : pluralize('d'),\n\t            M : pluralize('M'),\n\t            MM : pluralize('M'),\n\t            y : pluralize('y'),\n\t            yy : pluralize('y')\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/\\u200f/g, '').replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            }).replace(//g, ',');\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            }).replace(/,/g, '');\n\t        },\n\t        week : {\n\t            dow : 6, // Saturday is the first day of the week.\n\t            doy : 12  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ar;\n\t\n\t}));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Arabic (Morocco) [ar-ma]\n\t//! author : ElFadili Yassine : https://github.com/ElFadiliY\n\t//! author : Abdel Said : https://github.com/abdelsaid\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ar_ma = moment.defineLocale('ar-ma', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[  ] LT',\n\t            nextDay: '[  ] LT',\n\t            nextWeek: 'dddd [ ] LT',\n\t            lastDay: '[  ] LT',\n\t            lastWeek: 'dddd [ ] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : ' %s',\n\t            s : '',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d ',\n\t            M : '',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        week : {\n\t            dow : 6, // Saturday is the first day of the week.\n\t            doy : 12  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ar_ma;\n\t\n\t}));\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Arabic (Saudi Arabia) [ar-sa]\n\t//! author : Suhail Alkowaileet : https://github.com/xsoh\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    }, numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var ar_sa = moment.defineLocale('ar-sa', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        meridiemParse: /|/,\n\t        isPM : function (input) {\n\t            return '' === input;\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 12) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay: '[  ] LT',\n\t            nextDay: '[  ] LT',\n\t            nextWeek: 'dddd [ ] LT',\n\t            lastDay: '[  ] LT',\n\t            lastWeek: 'dddd [ ] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : ' %s',\n\t            s : '',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d ',\n\t            M : '',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            }).replace(//g, ',');\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            }).replace(/,/g, '');\n\t        },\n\t        week : {\n\t            dow : 6, // Saturday is the first day of the week.\n\t            doy : 12  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ar_sa;\n\t\n\t}));\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale  :  Arabic (Tunisia) [ar-tn]\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ar_tn = moment.defineLocale('ar-tn', {\n\t        months: '___________'.split('_'),\n\t        monthsShort: '___________'.split('_'),\n\t        weekdays: '______'.split('_'),\n\t        weekdaysShort: '______'.split('_'),\n\t        weekdaysMin: '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat: {\n\t            LT: 'HH:mm',\n\t            LTS: 'HH:mm:ss',\n\t            L: 'DD/MM/YYYY',\n\t            LL: 'D MMMM YYYY',\n\t            LLL: 'D MMMM YYYY HH:mm',\n\t            LLLL: 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar: {\n\t            sameDay: '[  ] LT',\n\t            nextDay: '[  ] LT',\n\t            nextWeek: 'dddd [ ] LT',\n\t            lastDay: '[  ] LT',\n\t            lastWeek: 'dddd [ ] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime: {\n\t            future: ' %s',\n\t            past: ' %s',\n\t            s: '',\n\t            m: '',\n\t            mm: '%d ',\n\t            h: '',\n\t            hh: '%d ',\n\t            d: '',\n\t            dd: '%d ',\n\t            M: '',\n\t            MM: '%d ',\n\t            y: '',\n\t            yy: '%d '\n\t        },\n\t        week: {\n\t            dow: 1, // Monday is the first day of the week.\n\t            doy: 4 // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ar_tn;\n\t\n\t}));\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Azerbaijani [az]\n\t//! author : topchiyev : https://github.com/topchiyev\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var suffixes = {\n\t        1: '-inci',\n\t        5: '-inci',\n\t        8: '-inci',\n\t        70: '-inci',\n\t        80: '-inci',\n\t        2: '-nci',\n\t        7: '-nci',\n\t        20: '-nci',\n\t        50: '-nci',\n\t        3: '-nc',\n\t        4: '-nc',\n\t        100: '-nc',\n\t        6: '-nc',\n\t        9: '-uncu',\n\t        10: '-uncu',\n\t        30: '-uncu',\n\t        60: '-nc',\n\t        90: '-nc'\n\t    };\n\t\n\t    var az = moment.defineLocale('az', {\n\t        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),\n\t        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),\n\t        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),\n\t        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),\n\t        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[bugn saat] LT',\n\t            nextDay : '[sabah saat] LT',\n\t            nextWeek : '[gln hft] dddd [saat] LT',\n\t            lastDay : '[dnn] LT',\n\t            lastWeek : '[ken hft] dddd [saat] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s sonra',\n\t            past : '%s vvl',\n\t            s : 'birne saniyy',\n\t            m : 'bir dqiq',\n\t            mm : '%d dqiq',\n\t            h : 'bir saat',\n\t            hh : '%d saat',\n\t            d : 'bir gn',\n\t            dd : '%d gn',\n\t            M : 'bir ay',\n\t            MM : '%d ay',\n\t            y : 'bir il',\n\t            yy : '%d il'\n\t        },\n\t        meridiemParse: /gec|shr|gndz|axam/,\n\t        isPM : function (input) {\n\t            return /^(gndz|axam)$/.test(input);\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return 'gec';\n\t            } else if (hour < 12) {\n\t                return 'shr';\n\t            } else if (hour < 17) {\n\t                return 'gndz';\n\t            } else {\n\t                return 'axam';\n\t            }\n\t        },\n\t        ordinalParse: /\\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,\n\t        ordinal : function (number) {\n\t            if (number === 0) {  // special case for zero\n\t                return number + '-nc';\n\t            }\n\t            var a = number % 10,\n\t                b = number % 100 - a,\n\t                c = number >= 100 ? 100 : null;\n\t            return number + (suffixes[a] || suffixes[b] || suffixes[c]);\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return az;\n\t\n\t}));\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Belarusian [be]\n\t//! author : Dmitry Demidov : https://github.com/demidov91\n\t//! author: Praleska: http://praleska.pro/\n\t//! Author : Menelion Elensle : https://github.com/Oire\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function plural(word, num) {\n\t        var forms = word.split('_');\n\t        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n\t    }\n\t    function relativeTimeWithPlural(number, withoutSuffix, key) {\n\t        var format = {\n\t            'mm': withoutSuffix ? '__' : '__',\n\t            'hh': withoutSuffix ? '__' : '__',\n\t            'dd': '__',\n\t            'MM': '__',\n\t            'yy': '__'\n\t        };\n\t        if (key === 'm') {\n\t            return withoutSuffix ? '' : '';\n\t        }\n\t        else if (key === 'h') {\n\t            return withoutSuffix ? '' : '';\n\t        }\n\t        else {\n\t            return number + ' ' + plural(format[key], +number);\n\t        }\n\t    }\n\t\n\t    var be = moment.defineLocale('be', {\n\t        months : {\n\t            format: '___________'.split('_'),\n\t            standalone: '___________'.split('_')\n\t        },\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : {\n\t            format: '______'.split('_'),\n\t            standalone: '______'.split('_'),\n\t            isFormat: /\\[ ?[] ?(?:|)? ?\\] ?dddd/\n\t        },\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY .',\n\t            LLL : 'D MMMM YYYY ., HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[ ] LT',\n\t            nextDay: '[ ] LT',\n\t            lastDay: '[ ] LT',\n\t            nextWeek: function () {\n\t                return '[] dddd [] LT';\n\t            },\n\t            lastWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                    case 3:\n\t                    case 5:\n\t                    case 6:\n\t                        return '[ ] dddd [] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                        return '[ ] dddd [] LT';\n\t                }\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : relativeTimeWithPlural,\n\t            mm : relativeTimeWithPlural,\n\t            h : relativeTimeWithPlural,\n\t            hh : relativeTimeWithPlural,\n\t            d : '',\n\t            dd : relativeTimeWithPlural,\n\t            M : '',\n\t            MM : relativeTimeWithPlural,\n\t            y : '',\n\t            yy : relativeTimeWithPlural\n\t        },\n\t        meridiemParse: /|||/,\n\t        isPM : function (input) {\n\t            return /^(|)$/.test(input);\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 12) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        ordinalParse: /\\d{1,2}-(||)/,\n\t        ordinal: function (number, period) {\n\t            switch (period) {\n\t                case 'M':\n\t                case 'd':\n\t                case 'DDD':\n\t                case 'w':\n\t                case 'W':\n\t                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';\n\t                case 'D':\n\t                    return number + '-';\n\t                default:\n\t                    return number;\n\t            }\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return be;\n\t\n\t}));\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Bulgarian [bg]\n\t//! author : Krasen Borisov : https://github.com/kraz\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var bg = moment.defineLocale('bg', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'D.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY H:mm',\n\t            LLLL : 'dddd, D MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ] LT',\n\t            nextDay : '[ ] LT',\n\t            nextWeek : 'dddd [] LT',\n\t            lastDay : '[ ] LT',\n\t            lastWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                    case 3:\n\t                    case 6:\n\t                        return '[ ] dddd [] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[ ] dddd [] LT';\n\t                }\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : ' %s',\n\t            s : ' ',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d ',\n\t            M : '',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /\\d{1,2}-(|||||)/,\n\t        ordinal : function (number) {\n\t            var lastDigit = number % 10,\n\t                last2Digits = number % 100;\n\t            if (number === 0) {\n\t                return number + '-';\n\t            } else if (last2Digits === 0) {\n\t                return number + '-';\n\t            } else if (last2Digits > 10 && last2Digits < 20) {\n\t                return number + '-';\n\t            } else if (lastDigit === 1) {\n\t                return number + '-';\n\t            } else if (lastDigit === 2) {\n\t                return number + '-';\n\t            } else if (lastDigit === 7 || lastDigit === 8) {\n\t                return number + '-';\n\t            } else {\n\t                return number + '-';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return bg;\n\t\n\t}));\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Bengali [bn]\n\t//! author : Kaushik Gandhi : https://github.com/kaushikgandhi\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    },\n\t    numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var bn = moment.defineLocale('bn', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h:mm ',\n\t            LTS : 'A h:mm:ss ',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm ',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd, LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        meridiemParse: /||||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if ((meridiem === '' && hour >= 4) ||\n\t                    (meridiem === '' && hour < 5) ||\n\t                    meridiem === '') {\n\t                return hour + 12;\n\t            } else {\n\t                return hour;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 10) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return bn;\n\t\n\t}));\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Tibetan [bo]\n\t//! author : Thupten N. Chakrishar : https://github.com/vajradog\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    },\n\t    numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var bo = moment.defineLocale('bo', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h:mm',\n\t            LTS : 'A h:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : '[], LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : '',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d ',\n\t            M : '',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        meridiemParse: /||||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if ((meridiem === '' && hour >= 4) ||\n\t                    (meridiem === '' && hour < 5) ||\n\t                    meridiem === '') {\n\t                return hour + 12;\n\t            } else {\n\t                return hour;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 10) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return bo;\n\t\n\t}));\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Breton [br]\n\t//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function relativeTimeWithMutation(number, withoutSuffix, key) {\n\t        var format = {\n\t            'mm': 'munutenn',\n\t            'MM': 'miz',\n\t            'dd': 'devezh'\n\t        };\n\t        return number + ' ' + mutation(format[key], number);\n\t    }\n\t    function specialMutationForYears(number) {\n\t        switch (lastNumber(number)) {\n\t            case 1:\n\t            case 3:\n\t            case 4:\n\t            case 5:\n\t            case 9:\n\t                return number + ' bloaz';\n\t            default:\n\t                return number + ' vloaz';\n\t        }\n\t    }\n\t    function lastNumber(number) {\n\t        if (number > 9) {\n\t            return lastNumber(number % 10);\n\t        }\n\t        return number;\n\t    }\n\t    function mutation(text, number) {\n\t        if (number === 2) {\n\t            return softMutation(text);\n\t        }\n\t        return text;\n\t    }\n\t    function softMutation(text) {\n\t        var mutationTable = {\n\t            'm': 'v',\n\t            'b': 'v',\n\t            'd': 'z'\n\t        };\n\t        if (mutationTable[text.charAt(0)] === undefined) {\n\t            return text;\n\t        }\n\t        return mutationTable[text.charAt(0)] + text.substring(1);\n\t    }\n\t\n\t    var br = moment.defineLocale('br', {\n\t        months : 'Genver_C\\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),\n\t        monthsShort : 'Gen_C\\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),\n\t        weekdays : 'Sul_Lun_Meurzh_Merc\\'her_Yaou_Gwener_Sadorn'.split('_'),\n\t        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),\n\t        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'h[e]mm A',\n\t            LTS : 'h[e]mm:ss A',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D [a viz] MMMM YYYY',\n\t            LLL : 'D [a viz] MMMM YYYY h[e]mm A',\n\t            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Hiziv da] LT',\n\t            nextDay : '[Warc\\'hoazh da] LT',\n\t            nextWeek : 'dddd [da] LT',\n\t            lastDay : '[Dec\\'h da] LT',\n\t            lastWeek : 'dddd [paset da] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'a-benn %s',\n\t            past : '%s \\'zo',\n\t            s : 'un nebeud segondenno',\n\t            m : 'ur vunutenn',\n\t            mm : relativeTimeWithMutation,\n\t            h : 'un eur',\n\t            hh : '%d eur',\n\t            d : 'un devezh',\n\t            dd : relativeTimeWithMutation,\n\t            M : 'ur miz',\n\t            MM : relativeTimeWithMutation,\n\t            y : 'ur bloaz',\n\t            yy : specialMutationForYears\n\t        },\n\t        ordinalParse: /\\d{1,2}(a|vet)/,\n\t        ordinal : function (number) {\n\t            var output = (number === 1) ? 'a' : 'vet';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return br;\n\t\n\t}));\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Bosnian [bs]\n\t//! author : Nedim Cholich : https://github.com/frontyard\n\t//! based on (hr) translation by Bojan Markovi\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function translate(number, withoutSuffix, key) {\n\t        var result = number + ' ';\n\t        switch (key) {\n\t            case 'm':\n\t                return withoutSuffix ? 'jedna minuta' : 'jedne minute';\n\t            case 'mm':\n\t                if (number === 1) {\n\t                    result += 'minuta';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'minute';\n\t                } else {\n\t                    result += 'minuta';\n\t                }\n\t                return result;\n\t            case 'h':\n\t                return withoutSuffix ? 'jedan sat' : 'jednog sata';\n\t            case 'hh':\n\t                if (number === 1) {\n\t                    result += 'sat';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'sata';\n\t                } else {\n\t                    result += 'sati';\n\t                }\n\t                return result;\n\t            case 'dd':\n\t                if (number === 1) {\n\t                    result += 'dan';\n\t                } else {\n\t                    result += 'dana';\n\t                }\n\t                return result;\n\t            case 'MM':\n\t                if (number === 1) {\n\t                    result += 'mjesec';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'mjeseca';\n\t                } else {\n\t                    result += 'mjeseci';\n\t                }\n\t                return result;\n\t            case 'yy':\n\t                if (number === 1) {\n\t                    result += 'godina';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'godine';\n\t                } else {\n\t                    result += 'godina';\n\t                }\n\t                return result;\n\t        }\n\t    }\n\t\n\t    var bs = moment.defineLocale('bs', {\n\t        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),\n\t        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n\t        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n\t        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD. MM. YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY H:mm',\n\t            LLLL : 'dddd, D. MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay  : '[danas u] LT',\n\t            nextDay  : '[sutra u] LT',\n\t            nextWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[u] [nedjelju] [u] LT';\n\t                    case 3:\n\t                        return '[u] [srijedu] [u] LT';\n\t                    case 6:\n\t                        return '[u] [subotu] [u] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[u] dddd [u] LT';\n\t                }\n\t            },\n\t            lastDay  : '[juer u] LT',\n\t            lastWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                    case 3:\n\t                        return '[prolu] dddd [u] LT';\n\t                    case 6:\n\t                        return '[prole] [subote] [u] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[proli] dddd [u] LT';\n\t                }\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'za %s',\n\t            past   : 'prije %s',\n\t            s      : 'par sekundi',\n\t            m      : translate,\n\t            mm     : translate,\n\t            h      : translate,\n\t            hh     : translate,\n\t            d      : 'dan',\n\t            dd     : translate,\n\t            M      : 'mjesec',\n\t            MM     : translate,\n\t            y      : 'godinu',\n\t            yy     : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return bs;\n\t\n\t}));\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Catalan [ca]\n\t//! author : Juan G. Hurtado : https://github.com/juanghurtado\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ca = moment.defineLocale('ca', {\n\t        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),\n\t        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),\n\t        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),\n\t        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY H:mm',\n\t            LLLL : 'dddd D MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : function () {\n\t                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n\t            },\n\t            nextDay : function () {\n\t                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n\t            },\n\t            nextWeek : function () {\n\t                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n\t            },\n\t            lastDay : function () {\n\t                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n\t            },\n\t            lastWeek : function () {\n\t                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'en %s',\n\t            past : 'fa %s',\n\t            s : 'uns segons',\n\t            m : 'un minut',\n\t            mm : '%d minuts',\n\t            h : 'una hora',\n\t            hh : '%d hores',\n\t            d : 'un dia',\n\t            dd : '%d dies',\n\t            M : 'un mes',\n\t            MM : '%d mesos',\n\t            y : 'un any',\n\t            yy : '%d anys'\n\t        },\n\t        ordinalParse: /\\d{1,2}(r|n|t||a)/,\n\t        ordinal : function (number, period) {\n\t            var output = (number === 1) ? 'r' :\n\t                (number === 2) ? 'n' :\n\t                (number === 3) ? 'r' :\n\t                (number === 4) ? 't' : '';\n\t            if (period === 'w' || period === 'W') {\n\t                output = 'a';\n\t            }\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ca;\n\t\n\t}));\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Czech [cs]\n\t//! author : petrbela : https://github.com/petrbela\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),\n\t        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');\n\t    function plural(n) {\n\t        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);\n\t    }\n\t    function translate(number, withoutSuffix, key, isFuture) {\n\t        var result = number + ' ';\n\t        switch (key) {\n\t            case 's':  // a few seconds / in a few seconds / a few seconds ago\n\t                return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';\n\t            case 'm':  // a minute / in a minute / a minute ago\n\t                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');\n\t            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'minuty' : 'minut');\n\t                } else {\n\t                    return result + 'minutami';\n\t                }\n\t                break;\n\t            case 'h':  // an hour / in an hour / an hour ago\n\t                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');\n\t            case 'hh': // 9 hours / in 9 hours / 9 hours ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'hodiny' : 'hodin');\n\t                } else {\n\t                    return result + 'hodinami';\n\t                }\n\t                break;\n\t            case 'd':  // a day / in a day / a day ago\n\t                return (withoutSuffix || isFuture) ? 'den' : 'dnem';\n\t            case 'dd': // 9 days / in 9 days / 9 days ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'dny' : 'dn');\n\t                } else {\n\t                    return result + 'dny';\n\t                }\n\t                break;\n\t            case 'M':  // a month / in a month / a month ago\n\t                return (withoutSuffix || isFuture) ? 'msc' : 'mscem';\n\t            case 'MM': // 9 months / in 9 months / 9 months ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'msce' : 'msc');\n\t                } else {\n\t                    return result + 'msci';\n\t                }\n\t                break;\n\t            case 'y':  // a year / in a year / a year ago\n\t                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';\n\t            case 'yy': // 9 years / in 9 years / 9 years ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'roky' : 'let');\n\t                } else {\n\t                    return result + 'lety';\n\t                }\n\t                break;\n\t        }\n\t    }\n\t\n\t    var cs = moment.defineLocale('cs', {\n\t        months : months,\n\t        monthsShort : monthsShort,\n\t        monthsParse : (function (months, monthsShort) {\n\t            var i, _monthsParse = [];\n\t            for (i = 0; i < 12; i++) {\n\t                // use custom parser to solve problem with July (ervenec)\n\t                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');\n\t            }\n\t            return _monthsParse;\n\t        }(months, monthsShort)),\n\t        shortMonthsParse : (function (monthsShort) {\n\t            var i, _shortMonthsParse = [];\n\t            for (i = 0; i < 12; i++) {\n\t                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');\n\t            }\n\t            return _shortMonthsParse;\n\t        }(monthsShort)),\n\t        longMonthsParse : (function (months) {\n\t            var i, _longMonthsParse = [];\n\t            for (i = 0; i < 12; i++) {\n\t                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');\n\t            }\n\t            return _longMonthsParse;\n\t        }(months)),\n\t        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),\n\t        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),\n\t        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),\n\t        longDateFormat : {\n\t            LT: 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY H:mm',\n\t            LLLL : 'dddd D. MMMM YYYY H:mm',\n\t            l : 'D. M. YYYY'\n\t        },\n\t        calendar : {\n\t            sameDay: '[dnes v] LT',\n\t            nextDay: '[ztra v] LT',\n\t            nextWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[v nedli v] LT';\n\t                    case 1:\n\t                    case 2:\n\t                        return '[v] dddd [v] LT';\n\t                    case 3:\n\t                        return '[ve stedu v] LT';\n\t                    case 4:\n\t                        return '[ve tvrtek v] LT';\n\t                    case 5:\n\t                        return '[v ptek v] LT';\n\t                    case 6:\n\t                        return '[v sobotu v] LT';\n\t                }\n\t            },\n\t            lastDay: '[vera v] LT',\n\t            lastWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[minulou nedli v] LT';\n\t                    case 1:\n\t                    case 2:\n\t                        return '[minul] dddd [v] LT';\n\t                    case 3:\n\t                        return '[minulou stedu v] LT';\n\t                    case 4:\n\t                    case 5:\n\t                        return '[minul] dddd [v] LT';\n\t                    case 6:\n\t                        return '[minulou sobotu v] LT';\n\t                }\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'za %s',\n\t            past : 'ped %s',\n\t            s : translate,\n\t            m : translate,\n\t            mm : translate,\n\t            h : translate,\n\t            hh : translate,\n\t            d : translate,\n\t            dd : translate,\n\t            M : translate,\n\t            MM : translate,\n\t            y : translate,\n\t            yy : translate\n\t        },\n\t        ordinalParse : /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return cs;\n\t\n\t}));\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Chuvash [cv]\n\t//! author : Anatoly Mironov : https://github.com/mirontoli\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var cv = moment.defineLocale('cv', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD-MM-YYYY',\n\t            LL : 'YYYY [] MMMM [] D[-]',\n\t            LLL : 'YYYY [] MMMM [] D[-], HH:mm',\n\t            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[] LT []',\n\t            nextDay: '[] LT []',\n\t            lastDay: '[] LT []',\n\t            nextWeek: '[] dddd LT []',\n\t            lastWeek: '[] dddd LT []',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : function (output) {\n\t                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';\n\t                return output + affix;\n\t            },\n\t            past : '%s ',\n\t            s : '- ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /\\d{1,2}-/,\n\t        ordinal : '%d-',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return cv;\n\t\n\t}));\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Welsh [cy]\n\t//! author : Robert Allen\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var cy = moment.defineLocale('cy', {\n\t        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),\n\t        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),\n\t        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),\n\t        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),\n\t        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        // time formats are the same as en-gb\n\t        longDateFormat: {\n\t            LT: 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L: 'DD/MM/YYYY',\n\t            LL: 'D MMMM YYYY',\n\t            LLL: 'D MMMM YYYY HH:mm',\n\t            LLLL: 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar: {\n\t            sameDay: '[Heddiw am] LT',\n\t            nextDay: '[Yfory am] LT',\n\t            nextWeek: 'dddd [am] LT',\n\t            lastDay: '[Ddoe am] LT',\n\t            lastWeek: 'dddd [diwethaf am] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime: {\n\t            future: 'mewn %s',\n\t            past: '%s yn l',\n\t            s: 'ychydig eiliadau',\n\t            m: 'munud',\n\t            mm: '%d munud',\n\t            h: 'awr',\n\t            hh: '%d awr',\n\t            d: 'diwrnod',\n\t            dd: '%d diwrnod',\n\t            M: 'mis',\n\t            MM: '%d mis',\n\t            y: 'blwyddyn',\n\t            yy: '%d flynedd'\n\t        },\n\t        ordinalParse: /\\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,\n\t        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh\n\t        ordinal: function (number) {\n\t            var b = number,\n\t                output = '',\n\t                lookup = [\n\t                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed\n\t                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed\n\t                ];\n\t            if (b > 20) {\n\t                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {\n\t                    output = 'fed'; // not 30ain, 70ain or 90ain\n\t                } else {\n\t                    output = 'ain';\n\t                }\n\t            } else if (b > 0) {\n\t                output = lookup[b];\n\t            }\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return cy;\n\t\n\t}));\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Danish [da]\n\t//! author : Ulrik Nielsen : https://github.com/mrbase\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var da = moment.defineLocale('da', {\n\t        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),\n\t        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),\n\t        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n\t        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),\n\t        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY HH:mm',\n\t            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[I dag kl.] LT',\n\t            nextDay : '[I morgen kl.] LT',\n\t            nextWeek : 'dddd [kl.] LT',\n\t            lastDay : '[I gr kl.] LT',\n\t            lastWeek : '[sidste] dddd [kl] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'om %s',\n\t            past : '%s siden',\n\t            s : 'f sekunder',\n\t            m : 'et minut',\n\t            mm : '%d minutter',\n\t            h : 'en time',\n\t            hh : '%d timer',\n\t            d : 'en dag',\n\t            dd : '%d dage',\n\t            M : 'en mned',\n\t            MM : '%d mneder',\n\t            y : 'et r',\n\t            yy : '%d r'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return da;\n\t\n\t}));\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : German [de]\n\t//! author : lluchs : https://github.com/lluchs\n\t//! author: Menelion Elensle: https://github.com/Oire\n\t//! author : Mikolaj Dadela : https://github.com/mik01aj\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n\t        var format = {\n\t            'm': ['eine Minute', 'einer Minute'],\n\t            'h': ['eine Stunde', 'einer Stunde'],\n\t            'd': ['ein Tag', 'einem Tag'],\n\t            'dd': [number + ' Tage', number + ' Tagen'],\n\t            'M': ['ein Monat', 'einem Monat'],\n\t            'MM': [number + ' Monate', number + ' Monaten'],\n\t            'y': ['ein Jahr', 'einem Jahr'],\n\t            'yy': [number + ' Jahre', number + ' Jahren']\n\t        };\n\t        return withoutSuffix ? format[key][0] : format[key][1];\n\t    }\n\t\n\t    var de = moment.defineLocale('de', {\n\t        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n\t        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n\t        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n\t        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT: 'HH:mm',\n\t            LTS: 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[heute um] LT [Uhr]',\n\t            sameElse: 'L',\n\t            nextDay: '[morgen um] LT [Uhr]',\n\t            nextWeek: 'dddd [um] LT [Uhr]',\n\t            lastDay: '[gestern um] LT [Uhr]',\n\t            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n\t        },\n\t        relativeTime : {\n\t            future : 'in %s',\n\t            past : 'vor %s',\n\t            s : 'ein paar Sekunden',\n\t            m : processRelativeTime,\n\t            mm : '%d Minuten',\n\t            h : processRelativeTime,\n\t            hh : '%d Stunden',\n\t            d : processRelativeTime,\n\t            dd : processRelativeTime,\n\t            M : processRelativeTime,\n\t            MM : processRelativeTime,\n\t            y : processRelativeTime,\n\t            yy : processRelativeTime\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return de;\n\t\n\t}));\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : German (Austria) [de-at]\n\t//! author : lluchs : https://github.com/lluchs\n\t//! author: Menelion Elensle: https://github.com/Oire\n\t//! author : Martin Groller : https://github.com/MadMG\n\t//! author : Mikolaj Dadela : https://github.com/mik01aj\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n\t        var format = {\n\t            'm': ['eine Minute', 'einer Minute'],\n\t            'h': ['eine Stunde', 'einer Stunde'],\n\t            'd': ['ein Tag', 'einem Tag'],\n\t            'dd': [number + ' Tage', number + ' Tagen'],\n\t            'M': ['ein Monat', 'einem Monat'],\n\t            'MM': [number + ' Monate', number + ' Monaten'],\n\t            'y': ['ein Jahr', 'einem Jahr'],\n\t            'yy': [number + ' Jahre', number + ' Jahren']\n\t        };\n\t        return withoutSuffix ? format[key][0] : format[key][1];\n\t    }\n\t\n\t    var de_at = moment.defineLocale('de-at', {\n\t        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n\t        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n\t        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n\t        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT: 'HH:mm',\n\t            LTS: 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[heute um] LT [Uhr]',\n\t            sameElse: 'L',\n\t            nextDay: '[morgen um] LT [Uhr]',\n\t            nextWeek: 'dddd [um] LT [Uhr]',\n\t            lastDay: '[gestern um] LT [Uhr]',\n\t            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n\t        },\n\t        relativeTime : {\n\t            future : 'in %s',\n\t            past : 'vor %s',\n\t            s : 'ein paar Sekunden',\n\t            m : processRelativeTime,\n\t            mm : '%d Minuten',\n\t            h : processRelativeTime,\n\t            hh : '%d Stunden',\n\t            d : processRelativeTime,\n\t            dd : processRelativeTime,\n\t            M : processRelativeTime,\n\t            MM : processRelativeTime,\n\t            y : processRelativeTime,\n\t            yy : processRelativeTime\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return de_at;\n\t\n\t}));\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Maldivian [dv]\n\t//! author : Jawish Hameed : https://github.com/jawish\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var months = [\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        ''\n\t    ], weekdays = [\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        '',\n\t        ''\n\t    ];\n\t\n\t    var dv = moment.defineLocale('dv', {\n\t        months : months,\n\t        monthsShort : months,\n\t        weekdays : weekdays,\n\t        weekdaysShort : weekdays,\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'D/M/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        meridiemParse: /|/,\n\t        isPM : function (input) {\n\t            return '' === input;\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 12) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : ' %s',\n\t            s : '',\n\t            m : '',\n\t            mm : ' %d',\n\t            h : '',\n\t            hh : ' %d',\n\t            d : '',\n\t            dd : ' %d',\n\t            M : '',\n\t            MM : ' %d',\n\t            y : '',\n\t            yy : ' %d'\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(//g, ',');\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/,/g, '');\n\t        },\n\t        week : {\n\t            dow : 7,  // Sunday is the first day of the week.\n\t            doy : 12  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return dv;\n\t\n\t}));\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Greek [el]\n\t//! author : Aggelos Karalias : https://github.com/mehiel\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t    function isFunction(input) {\n\t        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n\t    }\n\t\n\t\n\t    var el = moment.defineLocale('el', {\n\t        monthsNominativeEl : '___________'.split('_'),\n\t        monthsGenitiveEl : '___________'.split('_'),\n\t        months : function (momentToFormat, format) {\n\t            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'\n\t                return this._monthsGenitiveEl[momentToFormat.month()];\n\t            } else {\n\t                return this._monthsNominativeEl[momentToFormat.month()];\n\t            }\n\t        },\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours > 11) {\n\t                return isLower ? '' : '';\n\t            } else {\n\t                return isLower ? '' : '';\n\t            }\n\t        },\n\t        isPM : function (input) {\n\t            return ((input + '').toLowerCase()[0] === '');\n\t        },\n\t        meridiemParse : /[]\\.??\\.?/i,\n\t        longDateFormat : {\n\t            LT : 'h:mm A',\n\t            LTS : 'h:mm:ss A',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY h:mm A',\n\t            LLLL : 'dddd, D MMMM YYYY h:mm A'\n\t        },\n\t        calendarEl : {\n\t            sameDay : '[ {}] LT',\n\t            nextDay : '[ {}] LT',\n\t            nextWeek : 'dddd [{}] LT',\n\t            lastDay : '[ {}] LT',\n\t            lastWeek : function () {\n\t                switch (this.day()) {\n\t                    case 6:\n\t                        return '[ ] dddd [{}] LT';\n\t                    default:\n\t                        return '[ ] dddd [{}] LT';\n\t                }\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        calendar : function (key, mom) {\n\t            var output = this._calendarEl[key],\n\t                hours = mom && mom.hours();\n\t            if (isFunction(output)) {\n\t                output = output.apply(mom);\n\t            }\n\t            return output.replace('{}', (hours % 12 === 1 ? '' : ''));\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal: '%d',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return el;\n\t\n\t}));\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : English (Australia) [en-au]\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var en_au = moment.defineLocale('en-au', {\n\t        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n\t        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n\t        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n\t        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'h:mm A',\n\t            LTS : 'h:mm:ss A',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY h:mm A',\n\t            LLLL : 'dddd, D MMMM YYYY h:mm A'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Today at] LT',\n\t            nextDay : '[Tomorrow at] LT',\n\t            nextWeek : 'dddd [at] LT',\n\t            lastDay : '[Yesterday at] LT',\n\t            lastWeek : '[Last] dddd [at] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'in %s',\n\t            past : '%s ago',\n\t            s : 'a few seconds',\n\t            m : 'a minute',\n\t            mm : '%d minutes',\n\t            h : 'an hour',\n\t            hh : '%d hours',\n\t            d : 'a day',\n\t            dd : '%d days',\n\t            M : 'a month',\n\t            MM : '%d months',\n\t            y : 'a year',\n\t            yy : '%d years'\n\t        },\n\t        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (~~(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return en_au;\n\t\n\t}));\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : English (Canada) [en-ca]\n\t//! author : Jonathan Abourbih : https://github.com/jonbca\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var en_ca = moment.defineLocale('en-ca', {\n\t        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n\t        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n\t        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n\t        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'h:mm A',\n\t            LTS : 'h:mm:ss A',\n\t            L : 'YYYY-MM-DD',\n\t            LL : 'MMMM D, YYYY',\n\t            LLL : 'MMMM D, YYYY h:mm A',\n\t            LLLL : 'dddd, MMMM D, YYYY h:mm A'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Today at] LT',\n\t            nextDay : '[Tomorrow at] LT',\n\t            nextWeek : 'dddd [at] LT',\n\t            lastDay : '[Yesterday at] LT',\n\t            lastWeek : '[Last] dddd [at] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'in %s',\n\t            past : '%s ago',\n\t            s : 'a few seconds',\n\t            m : 'a minute',\n\t            mm : '%d minutes',\n\t            h : 'an hour',\n\t            hh : '%d hours',\n\t            d : 'a day',\n\t            dd : '%d days',\n\t            M : 'a month',\n\t            MM : '%d months',\n\t            y : 'a year',\n\t            yy : '%d years'\n\t        },\n\t        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (~~(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        }\n\t    });\n\t\n\t    return en_ca;\n\t\n\t}));\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : English (United Kingdom) [en-gb]\n\t//! author : Chris Gedrim : https://github.com/chrisgedrim\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var en_gb = moment.defineLocale('en-gb', {\n\t        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n\t        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n\t        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n\t        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Today at] LT',\n\t            nextDay : '[Tomorrow at] LT',\n\t            nextWeek : 'dddd [at] LT',\n\t            lastDay : '[Yesterday at] LT',\n\t            lastWeek : '[Last] dddd [at] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'in %s',\n\t            past : '%s ago',\n\t            s : 'a few seconds',\n\t            m : 'a minute',\n\t            mm : '%d minutes',\n\t            h : 'an hour',\n\t            hh : '%d hours',\n\t            d : 'a day',\n\t            dd : '%d days',\n\t            M : 'a month',\n\t            MM : '%d months',\n\t            y : 'a year',\n\t            yy : '%d years'\n\t        },\n\t        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (~~(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return en_gb;\n\t\n\t}));\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : English (Ireland) [en-ie]\n\t//! author : Chris Cartlidge : https://github.com/chriscartlidge\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var en_ie = moment.defineLocale('en-ie', {\n\t        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n\t        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n\t        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n\t        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD-MM-YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Today at] LT',\n\t            nextDay : '[Tomorrow at] LT',\n\t            nextWeek : 'dddd [at] LT',\n\t            lastDay : '[Yesterday at] LT',\n\t            lastWeek : '[Last] dddd [at] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'in %s',\n\t            past : '%s ago',\n\t            s : 'a few seconds',\n\t            m : 'a minute',\n\t            mm : '%d minutes',\n\t            h : 'an hour',\n\t            hh : '%d hours',\n\t            d : 'a day',\n\t            dd : '%d days',\n\t            M : 'a month',\n\t            MM : '%d months',\n\t            y : 'a year',\n\t            yy : '%d years'\n\t        },\n\t        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (~~(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return en_ie;\n\t\n\t}));\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : English (New Zealand) [en-nz]\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var en_nz = moment.defineLocale('en-nz', {\n\t        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n\t        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n\t        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n\t        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'h:mm A',\n\t            LTS : 'h:mm:ss A',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY h:mm A',\n\t            LLLL : 'dddd, D MMMM YYYY h:mm A'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Today at] LT',\n\t            nextDay : '[Tomorrow at] LT',\n\t            nextWeek : 'dddd [at] LT',\n\t            lastDay : '[Yesterday at] LT',\n\t            lastWeek : '[Last] dddd [at] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'in %s',\n\t            past : '%s ago',\n\t            s : 'a few seconds',\n\t            m : 'a minute',\n\t            mm : '%d minutes',\n\t            h : 'an hour',\n\t            hh : '%d hours',\n\t            d : 'a day',\n\t            dd : '%d days',\n\t            M : 'a month',\n\t            MM : '%d months',\n\t            y : 'a year',\n\t            yy : '%d years'\n\t        },\n\t        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (~~(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return en_nz;\n\t\n\t}));\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Esperanto [eo]\n\t//! author : Colin Dean : https://github.com/colindean\n\t//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.\n\t//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var eo = moment.defineLocale('eo', {\n\t        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),\n\t        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),\n\t        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),\n\t        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),\n\t        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'YYYY-MM-DD',\n\t            LL : 'D[-an de] MMMM, YYYY',\n\t            LLL : 'D[-an de] MMMM, YYYY HH:mm',\n\t            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'\n\t        },\n\t        meridiemParse: /[ap]\\.t\\.m/i,\n\t        isPM: function (input) {\n\t            return input.charAt(0).toLowerCase() === 'p';\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours > 11) {\n\t                return isLower ? 'p.t.m.' : 'P.T.M.';\n\t            } else {\n\t                return isLower ? 'a.t.m.' : 'A.T.M.';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[Hodia je] LT',\n\t            nextDay : '[Morga je] LT',\n\t            nextWeek : 'dddd [je] LT',\n\t            lastDay : '[Hiera je] LT',\n\t            lastWeek : '[pasinta] dddd [je] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'je %s',\n\t            past : 'anta %s',\n\t            s : 'sekundoj',\n\t            m : 'minuto',\n\t            mm : '%d minutoj',\n\t            h : 'horo',\n\t            hh : '%d horoj',\n\t            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo\n\t            dd : '%d tagoj',\n\t            M : 'monato',\n\t            MM : '%d monatoj',\n\t            y : 'jaro',\n\t            yy : '%d jaroj'\n\t        },\n\t        ordinalParse: /\\d{1,2}a/,\n\t        ordinal : '%da',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return eo;\n\t\n\t}));\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Spanish [es]\n\t//! author : Julio Napur : https://github.com/julionc\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),\n\t        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');\n\t\n\t    var es = moment.defineLocale('es', {\n\t        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),\n\t        monthsShort : function (m, format) {\n\t            if (/-MMM-/.test(format)) {\n\t                return monthsShort[m.month()];\n\t            } else {\n\t                return monthsShortDot[m.month()];\n\t            }\n\t        },\n\t        monthsParseExact : true,\n\t        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),\n\t        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),\n\t        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D [de] MMMM [de] YYYY',\n\t            LLL : 'D [de] MMMM [de] YYYY H:mm',\n\t            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : function () {\n\t                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            nextDay : function () {\n\t                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            nextWeek : function () {\n\t                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            lastDay : function () {\n\t                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            lastWeek : function () {\n\t                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'en %s',\n\t            past : 'hace %s',\n\t            s : 'unos segundos',\n\t            m : 'un minuto',\n\t            mm : '%d minutos',\n\t            h : 'una hora',\n\t            hh : '%d horas',\n\t            d : 'un da',\n\t            dd : '%d das',\n\t            M : 'un mes',\n\t            MM : '%d meses',\n\t            y : 'un ao',\n\t            yy : '%d aos'\n\t        },\n\t        ordinalParse : /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return es;\n\t\n\t}));\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Spanish (Dominican Republic) [es-do]\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),\n\t        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');\n\t\n\t    var es_do = moment.defineLocale('es-do', {\n\t        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),\n\t        monthsShort : function (m, format) {\n\t            if (/-MMM-/.test(format)) {\n\t                return monthsShort[m.month()];\n\t            } else {\n\t                return monthsShortDot[m.month()];\n\t            }\n\t        },\n\t        monthsParseExact : true,\n\t        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),\n\t        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),\n\t        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'h:mm A',\n\t            LTS : 'h:mm:ss A',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D [de] MMMM [de] YYYY',\n\t            LLL : 'D [de] MMMM [de] YYYY h:mm A',\n\t            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'\n\t        },\n\t        calendar : {\n\t            sameDay : function () {\n\t                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            nextDay : function () {\n\t                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            nextWeek : function () {\n\t                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            lastDay : function () {\n\t                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            lastWeek : function () {\n\t                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'en %s',\n\t            past : 'hace %s',\n\t            s : 'unos segundos',\n\t            m : 'un minuto',\n\t            mm : '%d minutos',\n\t            h : 'una hora',\n\t            hh : '%d horas',\n\t            d : 'un da',\n\t            dd : '%d das',\n\t            M : 'un mes',\n\t            MM : '%d meses',\n\t            y : 'un ao',\n\t            yy : '%d aos'\n\t        },\n\t        ordinalParse : /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return es_do;\n\t\n\t}));\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Estonian [et]\n\t//! author : Henry Kehlmann : https://github.com/madhenry\n\t//! improvements : Illimar Tambek : https://github.com/ragulka\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n\t        var format = {\n\t            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],\n\t            'm' : ['he minuti', 'ks minut'],\n\t            'mm': [number + ' minuti', number + ' minutit'],\n\t            'h' : ['he tunni', 'tund aega', 'ks tund'],\n\t            'hh': [number + ' tunni', number + ' tundi'],\n\t            'd' : ['he peva', 'ks pev'],\n\t            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],\n\t            'MM': [number + ' kuu', number + ' kuud'],\n\t            'y' : ['he aasta', 'aasta', 'ks aasta'],\n\t            'yy': [number + ' aasta', number + ' aastat']\n\t        };\n\t        if (withoutSuffix) {\n\t            return format[key][2] ? format[key][2] : format[key][1];\n\t        }\n\t        return isFuture ? format[key][0] : format[key][1];\n\t    }\n\t\n\t    var et = moment.defineLocale('et', {\n\t        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),\n\t        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),\n\t        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),\n\t        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),\n\t        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),\n\t        longDateFormat : {\n\t            LT   : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L    : 'DD.MM.YYYY',\n\t            LL   : 'D. MMMM YYYY',\n\t            LLL  : 'D. MMMM YYYY H:mm',\n\t            LLLL : 'dddd, D. MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay  : '[Tna,] LT',\n\t            nextDay  : '[Homme,] LT',\n\t            nextWeek : '[Jrgmine] dddd LT',\n\t            lastDay  : '[Eile,] LT',\n\t            lastWeek : '[Eelmine] dddd LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s prast',\n\t            past   : '%s tagasi',\n\t            s      : processRelativeTime,\n\t            m      : processRelativeTime,\n\t            mm     : processRelativeTime,\n\t            h      : processRelativeTime,\n\t            hh     : processRelativeTime,\n\t            d      : processRelativeTime,\n\t            dd     : '%d peva',\n\t            M      : processRelativeTime,\n\t            MM     : processRelativeTime,\n\t            y      : processRelativeTime,\n\t            yy     : processRelativeTime\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return et;\n\t\n\t}));\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Basque [eu]\n\t//! author : Eneko Illarramendi : https://github.com/eillarra\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var eu = moment.defineLocale('eu', {\n\t        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),\n\t        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),\n\t        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),\n\t        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'YYYY-MM-DD',\n\t            LL : 'YYYY[ko] MMMM[ren] D[a]',\n\t            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',\n\t            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',\n\t            l : 'YYYY-M-D',\n\t            ll : 'YYYY[ko] MMM D[a]',\n\t            lll : 'YYYY[ko] MMM D[a] HH:mm',\n\t            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[gaur] LT[etan]',\n\t            nextDay : '[bihar] LT[etan]',\n\t            nextWeek : 'dddd LT[etan]',\n\t            lastDay : '[atzo] LT[etan]',\n\t            lastWeek : '[aurreko] dddd LT[etan]',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s barru',\n\t            past : 'duela %s',\n\t            s : 'segundo batzuk',\n\t            m : 'minutu bat',\n\t            mm : '%d minutu',\n\t            h : 'ordu bat',\n\t            hh : '%d ordu',\n\t            d : 'egun bat',\n\t            dd : '%d egun',\n\t            M : 'hilabete bat',\n\t            MM : '%d hilabete',\n\t            y : 'urte bat',\n\t            yy : '%d urte'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return eu;\n\t\n\t}));\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Persian [fa]\n\t//! author : Ebrahim Byagowi : https://github.com/ebraminio\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    }, numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var fa = moment.defineLocale('fa', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '\\u200c__\\u200c__\\u200c__'.split('_'),\n\t        weekdaysShort : '\\u200c__\\u200c__\\u200c__'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        meridiemParse: /  |  /,\n\t        isPM: function (input) {\n\t            return /  /.test(input);\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 12) {\n\t                return '  ';\n\t            } else {\n\t                return '  ';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ] LT',\n\t            nextDay : '[ ] LT',\n\t            nextWeek : 'dddd [] LT',\n\t            lastDay : '[ ] LT',\n\t            lastWeek : 'dddd [] [] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[-]/g, function (match) {\n\t                return numberMap[match];\n\t            }).replace(//g, ',');\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            }).replace(/,/g, '');\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        week : {\n\t            dow : 6, // Saturday is the first day of the week.\n\t            doy : 12 // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return fa;\n\t\n\t}));\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Finnish [fi]\n\t//! author : Tarmo Aidantausta : https://github.com/bleadof\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),\n\t        numbersFuture = [\n\t            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',\n\t            numbersPast[7], numbersPast[8], numbersPast[9]\n\t        ];\n\t    function translate(number, withoutSuffix, key, isFuture) {\n\t        var result = '';\n\t        switch (key) {\n\t            case 's':\n\t                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';\n\t            case 'm':\n\t                return isFuture ? 'minuutin' : 'minuutti';\n\t            case 'mm':\n\t                result = isFuture ? 'minuutin' : 'minuuttia';\n\t                break;\n\t            case 'h':\n\t                return isFuture ? 'tunnin' : 'tunti';\n\t            case 'hh':\n\t                result = isFuture ? 'tunnin' : 'tuntia';\n\t                break;\n\t            case 'd':\n\t                return isFuture ? 'pivn' : 'piv';\n\t            case 'dd':\n\t                result = isFuture ? 'pivn' : 'piv';\n\t                break;\n\t            case 'M':\n\t                return isFuture ? 'kuukauden' : 'kuukausi';\n\t            case 'MM':\n\t                result = isFuture ? 'kuukauden' : 'kuukautta';\n\t                break;\n\t            case 'y':\n\t                return isFuture ? 'vuoden' : 'vuosi';\n\t            case 'yy':\n\t                result = isFuture ? 'vuoden' : 'vuotta';\n\t                break;\n\t        }\n\t        result = verbalNumber(number, isFuture) + ' ' + result;\n\t        return result;\n\t    }\n\t    function verbalNumber(number, isFuture) {\n\t        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;\n\t    }\n\t\n\t    var fi = moment.defineLocale('fi', {\n\t        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),\n\t        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),\n\t        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),\n\t        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),\n\t        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH.mm',\n\t            LTS : 'HH.mm.ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'Do MMMM[ta] YYYY',\n\t            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',\n\t            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',\n\t            l : 'D.M.YYYY',\n\t            ll : 'Do MMM YYYY',\n\t            lll : 'Do MMM YYYY, [klo] HH.mm',\n\t            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[tnn] [klo] LT',\n\t            nextDay : '[huomenna] [klo] LT',\n\t            nextWeek : 'dddd [klo] LT',\n\t            lastDay : '[eilen] [klo] LT',\n\t            lastWeek : '[viime] dddd[na] [klo] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s pst',\n\t            past : '%s sitten',\n\t            s : translate,\n\t            m : translate,\n\t            mm : translate,\n\t            h : translate,\n\t            hh : translate,\n\t            d : translate,\n\t            dd : translate,\n\t            M : translate,\n\t            MM : translate,\n\t            y : translate,\n\t            yy : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return fi;\n\t\n\t}));\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Faroese [fo]\n\t//! author : Ragnar Johannesen : https://github.com/ragnar123\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var fo = moment.defineLocale('fo', {\n\t        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n\t        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),\n\t        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),\n\t        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),\n\t        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D. MMMM, YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ dag kl.] LT',\n\t            nextDay : '[ morgin kl.] LT',\n\t            nextWeek : 'dddd [kl.] LT',\n\t            lastDay : '[ gjr kl.] LT',\n\t            lastWeek : '[sstu] dddd [kl] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'um %s',\n\t            past : '%s sani',\n\t            s : 'f sekund',\n\t            m : 'ein minutt',\n\t            mm : '%d minuttir',\n\t            h : 'ein tmi',\n\t            hh : '%d tmar',\n\t            d : 'ein dagur',\n\t            dd : '%d dagar',\n\t            M : 'ein mnai',\n\t            MM : '%d mnair',\n\t            y : 'eitt r',\n\t            yy : '%d r'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return fo;\n\t\n\t}));\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : French [fr]\n\t//! author : John Fischer : https://github.com/jfroffice\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var fr = moment.defineLocale('fr', {\n\t        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n\t        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n\t        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n\t        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Aujourd\\'hui ] LT',\n\t            nextDay: '[Demain ] LT',\n\t            nextWeek: 'dddd [] LT',\n\t            lastDay: '[Hier ] LT',\n\t            lastWeek: 'dddd [dernier ] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'dans %s',\n\t            past : 'il y a %s',\n\t            s : 'quelques secondes',\n\t            m : 'une minute',\n\t            mm : '%d minutes',\n\t            h : 'une heure',\n\t            hh : '%d heures',\n\t            d : 'un jour',\n\t            dd : '%d jours',\n\t            M : 'un mois',\n\t            MM : '%d mois',\n\t            y : 'un an',\n\t            yy : '%d ans'\n\t        },\n\t        ordinalParse: /\\d{1,2}(er|)/,\n\t        ordinal : function (number) {\n\t            return number + (number === 1 ? 'er' : '');\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return fr;\n\t\n\t}));\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : French (Canada) [fr-ca]\n\t//! author : Jonathan Abourbih : https://github.com/jonbca\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var fr_ca = moment.defineLocale('fr-ca', {\n\t        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n\t        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n\t        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n\t        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'YYYY-MM-DD',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Aujourd\\'hui ] LT',\n\t            nextDay: '[Demain ] LT',\n\t            nextWeek: 'dddd [] LT',\n\t            lastDay: '[Hier ] LT',\n\t            lastWeek: 'dddd [dernier ] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'dans %s',\n\t            past : 'il y a %s',\n\t            s : 'quelques secondes',\n\t            m : 'une minute',\n\t            mm : '%d minutes',\n\t            h : 'une heure',\n\t            hh : '%d heures',\n\t            d : 'un jour',\n\t            dd : '%d jours',\n\t            M : 'un mois',\n\t            MM : '%d mois',\n\t            y : 'un an',\n\t            yy : '%d ans'\n\t        },\n\t        ordinalParse: /\\d{1,2}(er|e)/,\n\t        ordinal : function (number) {\n\t            return number + (number === 1 ? 'er' : 'e');\n\t        }\n\t    });\n\t\n\t    return fr_ca;\n\t\n\t}));\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : French (Switzerland) [fr-ch]\n\t//! author : Gaspard Bucher : https://github.com/gaspard\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var fr_ch = moment.defineLocale('fr-ch', {\n\t        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n\t        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n\t        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n\t        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Aujourd\\'hui ] LT',\n\t            nextDay: '[Demain ] LT',\n\t            nextWeek: 'dddd [] LT',\n\t            lastDay: '[Hier ] LT',\n\t            lastWeek: 'dddd [dernier ] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'dans %s',\n\t            past : 'il y a %s',\n\t            s : 'quelques secondes',\n\t            m : 'une minute',\n\t            mm : '%d minutes',\n\t            h : 'une heure',\n\t            hh : '%d heures',\n\t            d : 'un jour',\n\t            dd : '%d jours',\n\t            M : 'un mois',\n\t            MM : '%d mois',\n\t            y : 'un an',\n\t            yy : '%d ans'\n\t        },\n\t        ordinalParse: /\\d{1,2}(er|e)/,\n\t        ordinal : function (number) {\n\t            return number + (number === 1 ? 'er' : 'e');\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return fr_ch;\n\t\n\t}));\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Frisian [fy]\n\t//! author : Robin van der Vliet : https://github.com/robin0van0der0v\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),\n\t        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');\n\t\n\t    var fy = moment.defineLocale('fy', {\n\t        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),\n\t        monthsShort : function (m, format) {\n\t            if (/-MMM-/.test(format)) {\n\t                return monthsShortWithoutDots[m.month()];\n\t            } else {\n\t                return monthsShortWithDots[m.month()];\n\t            }\n\t        },\n\t        monthsParseExact : true,\n\t        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),\n\t        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),\n\t        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD-MM-YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[hjoed om] LT',\n\t            nextDay: '[moarn om] LT',\n\t            nextWeek: 'dddd [om] LT',\n\t            lastDay: '[juster om] LT',\n\t            lastWeek: '[frne] dddd [om] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'oer %s',\n\t            past : '%s lyn',\n\t            s : 'in pear sekonden',\n\t            m : 'ien mint',\n\t            mm : '%d minuten',\n\t            h : 'ien oere',\n\t            hh : '%d oeren',\n\t            d : 'ien dei',\n\t            dd : '%d dagen',\n\t            M : 'ien moanne',\n\t            MM : '%d moannen',\n\t            y : 'ien jier',\n\t            yy : '%d jierren'\n\t        },\n\t        ordinalParse: /\\d{1,2}(ste|de)/,\n\t        ordinal : function (number) {\n\t            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return fy;\n\t\n\t}));\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Scottish Gaelic [gd]\n\t//! author : Jon Ashdown : https://github.com/jonashdown\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var months = [\n\t        'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'\n\t    ];\n\t\n\t    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];\n\t\n\t    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];\n\t\n\t    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];\n\t\n\t    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];\n\t\n\t    var gd = moment.defineLocale('gd', {\n\t        months : months,\n\t        monthsShort : monthsShort,\n\t        monthsParseExact : true,\n\t        weekdays : weekdays,\n\t        weekdaysShort : weekdaysShort,\n\t        weekdaysMin : weekdaysMin,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[An-diugh aig] LT',\n\t            nextDay : '[A-mireach aig] LT',\n\t            nextWeek : 'dddd [aig] LT',\n\t            lastDay : '[An-d aig] LT',\n\t            lastWeek : 'dddd [seo chaidh] [aig] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'ann an %s',\n\t            past : 'bho chionn %s',\n\t            s : 'beagan diogan',\n\t            m : 'mionaid',\n\t            mm : '%d mionaidean',\n\t            h : 'uair',\n\t            hh : '%d uairean',\n\t            d : 'latha',\n\t            dd : '%d latha',\n\t            M : 'mos',\n\t            MM : '%d mosan',\n\t            y : 'bliadhna',\n\t            yy : '%d bliadhna'\n\t        },\n\t        ordinalParse : /\\d{1,2}(d|na|mh)/,\n\t        ordinal : function (number) {\n\t            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return gd;\n\t\n\t}));\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Galician [gl]\n\t//! author : Juan G. Hurtado : https://github.com/juanghurtado\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var gl = moment.defineLocale('gl', {\n\t        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),\n\t        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays : 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),\n\t        weekdaysShort : 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),\n\t        weekdaysMin : 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY H:mm',\n\t            LLLL : 'dddd D MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : function () {\n\t                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            nextDay : function () {\n\t                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n\t            },\n\t            nextWeek : function () {\n\t                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';\n\t            },\n\t            lastDay : function () {\n\t                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';\n\t            },\n\t            lastWeek : function () {\n\t                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : function (str) {\n\t                if (str === 'uns segundos') {\n\t                    return 'nuns segundos';\n\t                }\n\t                return 'en ' + str;\n\t            },\n\t            past : 'hai %s',\n\t            s : 'uns segundos',\n\t            m : 'un minuto',\n\t            mm : '%d minutos',\n\t            h : 'unha hora',\n\t            hh : '%d horas',\n\t            d : 'un da',\n\t            dd : '%d das',\n\t            M : 'un mes',\n\t            MM : '%d meses',\n\t            y : 'un ano',\n\t            yy : '%d anos'\n\t        },\n\t        ordinalParse : /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return gl;\n\t\n\t}));\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Hebrew [he]\n\t//! author : Tomer Cohen : https://github.com/tomer\n\t//! author : Moshe Simantov : https://github.com/DevelopmentIL\n\t//! author : Tal Ater : https://github.com/TalAter\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var he = moment.defineLocale('he', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D []MMMM YYYY',\n\t            LLL : 'D []MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D []MMMM YYYY HH:mm',\n\t            l : 'D/M/YYYY',\n\t            ll : 'D MMM YYYY',\n\t            lll : 'D MMM YYYY HH:mm',\n\t            llll : 'ddd, D MMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ]LT',\n\t            nextDay : '[ ]LT',\n\t            nextWeek : 'dddd [] LT',\n\t            lastDay : '[ ]LT',\n\t            lastWeek : '[] dddd [ ] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : ' %s',\n\t            s : ' ',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : function (number) {\n\t                if (number === 2) {\n\t                    return '';\n\t                }\n\t                return number + ' ';\n\t            },\n\t            d : '',\n\t            dd : function (number) {\n\t                if (number === 2) {\n\t                    return '';\n\t                }\n\t                return number + ' ';\n\t            },\n\t            M : '',\n\t            MM : function (number) {\n\t                if (number === 2) {\n\t                    return '';\n\t                }\n\t                return number + ' ';\n\t            },\n\t            y : '',\n\t            yy : function (number) {\n\t                if (number === 2) {\n\t                    return '';\n\t                } else if (number % 10 === 0 && number !== 10) {\n\t                    return number + ' ';\n\t                }\n\t                return number + ' ';\n\t            }\n\t        },\n\t        meridiemParse: /\"|\"| | | ||/i,\n\t        isPM : function (input) {\n\t            return /^(\"| |)$/.test(input);\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 5) {\n\t                return ' ';\n\t            } else if (hour < 10) {\n\t                return '';\n\t            } else if (hour < 12) {\n\t                return isLower ? '\"' : ' ';\n\t            } else if (hour < 18) {\n\t                return isLower ? '\"' : ' ';\n\t            } else {\n\t                return '';\n\t            }\n\t        }\n\t    });\n\t\n\t    return he;\n\t\n\t}));\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Hindi [hi]\n\t//! author : Mayank Singhal : https://github.com/mayanksinghal\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    },\n\t    numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var hi = moment.defineLocale('hi', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '._.__.___._._._._._.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h:mm ',\n\t            LTS : 'A h:mm:ss ',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm ',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd, LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : '  ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        // Hindi notation for meridiems are quite fuzzy in practice. While there exists\n\t        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.\n\t        meridiemParse: /|||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '') {\n\t                return hour < 4 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '') {\n\t                return hour >= 10 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 10) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return hi;\n\t\n\t}));\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Croatian [hr]\n\t//! author : Bojan Markovi : https://github.com/bmarkovic\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function translate(number, withoutSuffix, key) {\n\t        var result = number + ' ';\n\t        switch (key) {\n\t            case 'm':\n\t                return withoutSuffix ? 'jedna minuta' : 'jedne minute';\n\t            case 'mm':\n\t                if (number === 1) {\n\t                    result += 'minuta';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'minute';\n\t                } else {\n\t                    result += 'minuta';\n\t                }\n\t                return result;\n\t            case 'h':\n\t                return withoutSuffix ? 'jedan sat' : 'jednog sata';\n\t            case 'hh':\n\t                if (number === 1) {\n\t                    result += 'sat';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'sata';\n\t                } else {\n\t                    result += 'sati';\n\t                }\n\t                return result;\n\t            case 'dd':\n\t                if (number === 1) {\n\t                    result += 'dan';\n\t                } else {\n\t                    result += 'dana';\n\t                }\n\t                return result;\n\t            case 'MM':\n\t                if (number === 1) {\n\t                    result += 'mjesec';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'mjeseca';\n\t                } else {\n\t                    result += 'mjeseci';\n\t                }\n\t                return result;\n\t            case 'yy':\n\t                if (number === 1) {\n\t                    result += 'godina';\n\t                } else if (number === 2 || number === 3 || number === 4) {\n\t                    result += 'godine';\n\t                } else {\n\t                    result += 'godina';\n\t                }\n\t                return result;\n\t        }\n\t    }\n\t\n\t    var hr = moment.defineLocale('hr', {\n\t        months : {\n\t            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),\n\t            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')\n\t        },\n\t        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n\t        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n\t        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD. MM. YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY H:mm',\n\t            LLLL : 'dddd, D. MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay  : '[danas u] LT',\n\t            nextDay  : '[sutra u] LT',\n\t            nextWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[u] [nedjelju] [u] LT';\n\t                    case 3:\n\t                        return '[u] [srijedu] [u] LT';\n\t                    case 6:\n\t                        return '[u] [subotu] [u] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[u] dddd [u] LT';\n\t                }\n\t            },\n\t            lastDay  : '[juer u] LT',\n\t            lastWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                    case 3:\n\t                        return '[prolu] dddd [u] LT';\n\t                    case 6:\n\t                        return '[prole] [subote] [u] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[proli] dddd [u] LT';\n\t                }\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'za %s',\n\t            past   : 'prije %s',\n\t            s      : 'par sekundi',\n\t            m      : translate,\n\t            mm     : translate,\n\t            h      : translate,\n\t            hh     : translate,\n\t            d      : 'dan',\n\t            dd     : translate,\n\t            M      : 'mjesec',\n\t            MM     : translate,\n\t            y      : 'godinu',\n\t            yy     : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return hr;\n\t\n\t}));\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Hungarian [hu]\n\t//! author : Adam Brunner : https://github.com/adambrunner\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');\n\t    function translate(number, withoutSuffix, key, isFuture) {\n\t        var num = number,\n\t            suffix;\n\t        switch (key) {\n\t            case 's':\n\t                return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';\n\t            case 'm':\n\t                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');\n\t            case 'mm':\n\t                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');\n\t            case 'h':\n\t                return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');\n\t            case 'hh':\n\t                return num + (isFuture || withoutSuffix ? ' ra' : ' rja');\n\t            case 'd':\n\t                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');\n\t            case 'dd':\n\t                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');\n\t            case 'M':\n\t                return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');\n\t            case 'MM':\n\t                return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');\n\t            case 'y':\n\t                return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');\n\t            case 'yy':\n\t                return num + (isFuture || withoutSuffix ? ' v' : ' ve');\n\t        }\n\t        return '';\n\t    }\n\t    function week(isFuture) {\n\t        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';\n\t    }\n\t\n\t    var hu = moment.defineLocale('hu', {\n\t        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),\n\t        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),\n\t        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),\n\t        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),\n\t        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'YYYY.MM.DD.',\n\t            LL : 'YYYY. MMMM D.',\n\t            LLL : 'YYYY. MMMM D. H:mm',\n\t            LLLL : 'YYYY. MMMM D., dddd H:mm'\n\t        },\n\t        meridiemParse: /de|du/i,\n\t        isPM: function (input) {\n\t            return input.charAt(1).toLowerCase() === 'u';\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 12) {\n\t                return isLower === true ? 'de' : 'DE';\n\t            } else {\n\t                return isLower === true ? 'du' : 'DU';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[ma] LT[-kor]',\n\t            nextDay : '[holnap] LT[-kor]',\n\t            nextWeek : function () {\n\t                return week.call(this, true);\n\t            },\n\t            lastDay : '[tegnap] LT[-kor]',\n\t            lastWeek : function () {\n\t                return week.call(this, false);\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s mlva',\n\t            past : '%s',\n\t            s : translate,\n\t            m : translate,\n\t            mm : translate,\n\t            h : translate,\n\t            hh : translate,\n\t            d : translate,\n\t            dd : translate,\n\t            M : translate,\n\t            MM : translate,\n\t            y : translate,\n\t            yy : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return hu;\n\t\n\t}));\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Armenian [hy-am]\n\t//! author : Armendarabyan : https://github.com/armendarabyan\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var hy_am = moment.defineLocale('hy-am', {\n\t        months : {\n\t            format: '___________'.split('_'),\n\t            standalone: '___________'.split('_')\n\t        },\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY .',\n\t            LLL : 'D MMMM YYYY ., HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[] LT',\n\t            nextDay: '[] LT',\n\t            lastDay: '[] LT',\n\t            nextWeek: function () {\n\t                return 'dddd [ ] LT';\n\t            },\n\t            lastWeek: function () {\n\t                return '[] dddd [ ] LT';\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : '  ',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d ',\n\t            M : '',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        meridiemParse: /|||/,\n\t        isPM: function (input) {\n\t            return /^(|)$/.test(input);\n\t        },\n\t        meridiem : function (hour) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 12) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        ordinalParse: /\\d{1,2}|\\d{1,2}-(|)/,\n\t        ordinal: function (number, period) {\n\t            switch (period) {\n\t                case 'DDD':\n\t                case 'w':\n\t                case 'W':\n\t                case 'DDDo':\n\t                    if (number === 1) {\n\t                        return number + '-';\n\t                    }\n\t                    return number + '-';\n\t                default:\n\t                    return number;\n\t            }\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return hy_am;\n\t\n\t}));\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Indonesian [id]\n\t//! author : Mohammad Satrio Utomo : https://github.com/tyok\n\t//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var id = moment.defineLocale('id', {\n\t        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),\n\t        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),\n\t        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),\n\t        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH.mm',\n\t            LTS : 'HH.mm.ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY [pukul] HH.mm',\n\t            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n\t        },\n\t        meridiemParse: /pagi|siang|sore|malam/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === 'pagi') {\n\t                return hour;\n\t            } else if (meridiem === 'siang') {\n\t                return hour >= 11 ? hour : hour + 12;\n\t            } else if (meridiem === 'sore' || meridiem === 'malam') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 11) {\n\t                return 'pagi';\n\t            } else if (hours < 15) {\n\t                return 'siang';\n\t            } else if (hours < 19) {\n\t                return 'sore';\n\t            } else {\n\t                return 'malam';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[Hari ini pukul] LT',\n\t            nextDay : '[Besok pukul] LT',\n\t            nextWeek : 'dddd [pukul] LT',\n\t            lastDay : '[Kemarin pukul] LT',\n\t            lastWeek : 'dddd [lalu pukul] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'dalam %s',\n\t            past : '%s yang lalu',\n\t            s : 'beberapa detik',\n\t            m : 'semenit',\n\t            mm : '%d menit',\n\t            h : 'sejam',\n\t            hh : '%d jam',\n\t            d : 'sehari',\n\t            dd : '%d hari',\n\t            M : 'sebulan',\n\t            MM : '%d bulan',\n\t            y : 'setahun',\n\t            yy : '%d tahun'\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return id;\n\t\n\t}));\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Icelandic [is]\n\t//! author : Hinrik rn Sigursson : https://github.com/hinrik\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function plural(n) {\n\t        if (n % 100 === 11) {\n\t            return true;\n\t        } else if (n % 10 === 1) {\n\t            return false;\n\t        }\n\t        return true;\n\t    }\n\t    function translate(number, withoutSuffix, key, isFuture) {\n\t        var result = number + ' ';\n\t        switch (key) {\n\t            case 's':\n\t                return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';\n\t            case 'm':\n\t                return withoutSuffix ? 'mnta' : 'mntu';\n\t            case 'mm':\n\t                if (plural(number)) {\n\t                    return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');\n\t                } else if (withoutSuffix) {\n\t                    return result + 'mnta';\n\t                }\n\t                return result + 'mntu';\n\t            case 'hh':\n\t                if (plural(number)) {\n\t                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');\n\t                }\n\t                return result + 'klukkustund';\n\t            case 'd':\n\t                if (withoutSuffix) {\n\t                    return 'dagur';\n\t                }\n\t                return isFuture ? 'dag' : 'degi';\n\t            case 'dd':\n\t                if (plural(number)) {\n\t                    if (withoutSuffix) {\n\t                        return result + 'dagar';\n\t                    }\n\t                    return result + (isFuture ? 'daga' : 'dgum');\n\t                } else if (withoutSuffix) {\n\t                    return result + 'dagur';\n\t                }\n\t                return result + (isFuture ? 'dag' : 'degi');\n\t            case 'M':\n\t                if (withoutSuffix) {\n\t                    return 'mnuur';\n\t                }\n\t                return isFuture ? 'mnu' : 'mnui';\n\t            case 'MM':\n\t                if (plural(number)) {\n\t                    if (withoutSuffix) {\n\t                        return result + 'mnuir';\n\t                    }\n\t                    return result + (isFuture ? 'mnui' : 'mnuum');\n\t                } else if (withoutSuffix) {\n\t                    return result + 'mnuur';\n\t                }\n\t                return result + (isFuture ? 'mnu' : 'mnui');\n\t            case 'y':\n\t                return withoutSuffix || isFuture ? 'r' : 'ri';\n\t            case 'yy':\n\t                if (plural(number)) {\n\t                    return result + (withoutSuffix || isFuture ? 'r' : 'rum');\n\t                }\n\t                return result + (withoutSuffix || isFuture ? 'r' : 'ri');\n\t        }\n\t    }\n\t\n\t    var is = moment.defineLocale('is', {\n\t        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),\n\t        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),\n\t        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),\n\t        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),\n\t        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY [kl.] H:mm',\n\t            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ dag kl.] LT',\n\t            nextDay : '[ morgun kl.] LT',\n\t            nextWeek : 'dddd [kl.] LT',\n\t            lastDay : '[ gr kl.] LT',\n\t            lastWeek : '[sasta] dddd [kl.] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'eftir %s',\n\t            past : 'fyrir %s san',\n\t            s : translate,\n\t            m : translate,\n\t            mm : translate,\n\t            h : 'klukkustund',\n\t            hh : translate,\n\t            d : translate,\n\t            dd : translate,\n\t            M : translate,\n\t            MM : translate,\n\t            y : translate,\n\t            yy : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return is;\n\t\n\t}));\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Italian [it]\n\t//! author : Lorenzo : https://github.com/aliem\n\t//! author: Mattia Larentis: https://github.com/nostalgiaz\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var it = moment.defineLocale('it', {\n\t        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),\n\t        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),\n\t        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),\n\t        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),\n\t        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Oggi alle] LT',\n\t            nextDay: '[Domani alle] LT',\n\t            nextWeek: 'dddd [alle] LT',\n\t            lastDay: '[Ieri alle] LT',\n\t            lastWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[la scorsa] dddd [alle] LT';\n\t                    default:\n\t                        return '[lo scorso] dddd [alle] LT';\n\t                }\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : function (s) {\n\t                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;\n\t            },\n\t            past : '%s fa',\n\t            s : 'alcuni secondi',\n\t            m : 'un minuto',\n\t            mm : '%d minuti',\n\t            h : 'un\\'ora',\n\t            hh : '%d ore',\n\t            d : 'un giorno',\n\t            dd : '%d giorni',\n\t            M : 'un mese',\n\t            MM : '%d mesi',\n\t            y : 'un anno',\n\t            yy : '%d anni'\n\t        },\n\t        ordinalParse : /\\d{1,2}/,\n\t        ordinal: '%d',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return it;\n\t\n\t}));\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Japanese [ja]\n\t//! author : LI Long : https://github.com/baryon\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ja = moment.defineLocale('ja', {\n\t        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n\t        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'Ahm',\n\t            LTS : 'Ahms',\n\t            L : 'YYYY/MM/DD',\n\t            LL : 'YYYYMD',\n\t            LLL : 'YYYYMDAhm',\n\t            LLLL : 'YYYYMDAhm dddd'\n\t        },\n\t        meridiemParse: /|/i,\n\t        isPM : function (input) {\n\t            return input === '';\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 12) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : '[]dddd LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[]dddd LT',\n\t            sameElse : 'L'\n\t        },\n\t        ordinalParse : /\\d{1,2}/,\n\t        ordinal : function (number, period) {\n\t            switch (period) {\n\t                case 'd':\n\t                case 'D':\n\t                case 'DDD':\n\t                    return number + '';\n\t                default:\n\t                    return number;\n\t            }\n\t        },\n\t        relativeTime : {\n\t            future : '%s',\n\t            past : '%s',\n\t            s : '',\n\t            m : '1',\n\t            mm : '%d',\n\t            h : '1',\n\t            hh : '%d',\n\t            d : '1',\n\t            dd : '%d',\n\t            M : '1',\n\t            MM : '%d',\n\t            y : '1',\n\t            yy : '%d'\n\t        }\n\t    });\n\t\n\t    return ja;\n\t\n\t}));\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Japanese [jv]\n\t//! author : Rony Lantip : https://github.com/lantip\n\t//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var jv = moment.defineLocale('jv', {\n\t        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),\n\t        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),\n\t        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),\n\t        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH.mm',\n\t            LTS : 'HH.mm.ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY [pukul] HH.mm',\n\t            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n\t        },\n\t        meridiemParse: /enjing|siyang|sonten|ndalu/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === 'enjing') {\n\t                return hour;\n\t            } else if (meridiem === 'siyang') {\n\t                return hour >= 11 ? hour : hour + 12;\n\t            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 11) {\n\t                return 'enjing';\n\t            } else if (hours < 15) {\n\t                return 'siyang';\n\t            } else if (hours < 19) {\n\t                return 'sonten';\n\t            } else {\n\t                return 'ndalu';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[Dinten puniko pukul] LT',\n\t            nextDay : '[Mbenjang pukul] LT',\n\t            nextWeek : 'dddd [pukul] LT',\n\t            lastDay : '[Kala wingi pukul] LT',\n\t            lastWeek : 'dddd [kepengker pukul] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'wonten ing %s',\n\t            past : '%s ingkang kepengker',\n\t            s : 'sawetawis detik',\n\t            m : 'setunggal menit',\n\t            mm : '%d menit',\n\t            h : 'setunggal jam',\n\t            hh : '%d jam',\n\t            d : 'sedinten',\n\t            dd : '%d dinten',\n\t            M : 'sewulan',\n\t            MM : '%d wulan',\n\t            y : 'setaun',\n\t            yy : '%d taun'\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return jv;\n\t\n\t}));\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Georgian [ka]\n\t//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ka = moment.defineLocale('ka', {\n\t        months : {\n\t            standalone: '___________'.split('_'),\n\t            format: '___________'.split('_')\n\t        },\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : {\n\t            standalone: '______'.split('_'),\n\t            format: '______'.split('_'),\n\t            isFormat: /(|)/\n\t        },\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'h:mm A',\n\t            LTS : 'h:mm:ss A',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY h:mm A',\n\t            LLLL : 'dddd, D MMMM YYYY h:mm A'\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT[-]',\n\t            nextDay : '[] LT[-]',\n\t            lastDay : '[] LT[-]',\n\t            nextWeek : '[] dddd LT[-]',\n\t            lastWeek : '[] dddd LT-',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : function (s) {\n\t                return (/(|||)/).test(s) ?\n\t                    s.replace(/$/, '') :\n\t                    s + '';\n\t            },\n\t            past : function (s) {\n\t                if ((/(||||)/).test(s)) {\n\t                    return s.replace(/(|)$/, ' ');\n\t                }\n\t                if ((//).test(s)) {\n\t                    return s.replace(/$/, ' ');\n\t                }\n\t            },\n\t            s : ' ',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d ',\n\t            M : '',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /0|1-|-\\d{1,2}|\\d{1,2}-/,\n\t        ordinal : function (number) {\n\t            if (number === 0) {\n\t                return number;\n\t            }\n\t            if (number === 1) {\n\t                return number + '-';\n\t            }\n\t            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {\n\t                return '-' + number;\n\t            }\n\t            return number + '-';\n\t        },\n\t        week : {\n\t            dow : 1,\n\t            doy : 7\n\t        }\n\t    });\n\t\n\t    return ka;\n\t\n\t}));\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Kazakh [kk]\n\t//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var suffixes = {\n\t        0: '-',\n\t        1: '-',\n\t        2: '-',\n\t        3: '-',\n\t        4: '-',\n\t        5: '-',\n\t        6: '-',\n\t        7: '-',\n\t        8: '-',\n\t        9: '-',\n\t        10: '-',\n\t        20: '-',\n\t        30: '-',\n\t        40: '-',\n\t        50: '-',\n\t        60: '-',\n\t        70: '-',\n\t        80: '-',\n\t        90: '-',\n\t        100: '-'\n\t    };\n\t\n\t    var kk = moment.defineLocale('kk', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ] LT',\n\t            nextDay : '[ ] LT',\n\t            nextWeek : 'dddd [] LT',\n\t            lastDay : '[ ] LT',\n\t            lastWeek : '[ ] dddd [] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /\\d{1,2}-(|)/,\n\t        ordinal : function (number) {\n\t            var a = number % 10,\n\t                b = number >= 100 ? 100 : null;\n\t            return number + (suffixes[number] || suffixes[a] || suffixes[b]);\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return kk;\n\t\n\t}));\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Cambodian [km]\n\t//! author : Kruy Vanna : https://github.com/kruyvanna\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var km = moment.defineLocale('km', {\n\t        months: '___________'.split('_'),\n\t        monthsShort: '___________'.split('_'),\n\t        weekdays: '______'.split('_'),\n\t        weekdaysShort: '______'.split('_'),\n\t        weekdaysMin: '______'.split('_'),\n\t        longDateFormat: {\n\t            LT: 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L: 'DD/MM/YYYY',\n\t            LL: 'D MMMM YYYY',\n\t            LLL: 'D MMMM YYYY HH:mm',\n\t            LLLL: 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar: {\n\t            sameDay: '[ ] LT',\n\t            nextDay: '[ ] LT',\n\t            nextWeek: 'dddd [] LT',\n\t            lastDay: '[ ] LT',\n\t            lastWeek: 'dddd [] [] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime: {\n\t            future: '%s',\n\t            past: '%s',\n\t            s: '',\n\t            m: '',\n\t            mm: '%d ',\n\t            h: '',\n\t            hh: '%d ',\n\t            d: '',\n\t            dd: '%d ',\n\t            M: '',\n\t            MM: '%d ',\n\t            y: '',\n\t            yy: '%d '\n\t        },\n\t        week: {\n\t            dow: 1, // Monday is the first day of the week.\n\t            doy: 4 // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return km;\n\t\n\t}));\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Korean [ko]\n\t//!\n\t//! authors\n\t//!\n\t//! - Kyungwook, Park : https://github.com/kyungw00k\n\t//! - Jeeeyul Lee <jeeeyul@gmail.com>\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ko = moment.defineLocale('ko', {\n\t        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n\t        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h m',\n\t            LTS : 'A h m s',\n\t            L : 'YYYY.MM.DD',\n\t            LL : 'YYYY MMMM D',\n\t            LLL : 'YYYY MMMM D A h m',\n\t            LLLL : 'YYYY MMMM D dddd A h m'\n\t        },\n\t        calendar : {\n\t            sameDay : ' LT',\n\t            nextDay : ' LT',\n\t            nextWeek : 'dddd LT',\n\t            lastDay : ' LT',\n\t            lastWeek : ' dddd LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : ' ',\n\t            ss : '%d',\n\t            m : '',\n\t            mm : '%d',\n\t            h : ' ',\n\t            hh : '%d',\n\t            d : '',\n\t            dd : '%d',\n\t            M : ' ',\n\t            MM : '%d',\n\t            y : ' ',\n\t            yy : '%d'\n\t        },\n\t        ordinalParse : /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        meridiemParse : /|/,\n\t        isPM : function (token) {\n\t            return token === '';\n\t        },\n\t        meridiem : function (hour, minute, isUpper) {\n\t            return hour < 12 ? '' : '';\n\t        }\n\t    });\n\t\n\t    return ko;\n\t\n\t}));\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Kyrgyz [ky]\n\t//! author : Chyngyz Arystan uulu : https://github.com/chyngyz\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t\n\t    var suffixes = {\n\t        0: '-',\n\t        1: '-',\n\t        2: '-',\n\t        3: '-',\n\t        4: '-',\n\t        5: '-',\n\t        6: '-',\n\t        7: '-',\n\t        8: '-',\n\t        9: '-',\n\t        10: '-',\n\t        20: '-',\n\t        30: '-',\n\t        40: '-',\n\t        50: '-',\n\t        60: '-',\n\t        70: '-',\n\t        80: '-',\n\t        90: '-',\n\t        100: '-'\n\t    };\n\t\n\t    var ky = moment.defineLocale('ky', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ] LT',\n\t            nextDay : '[ ] LT',\n\t            nextWeek : 'dddd [] LT',\n\t            lastDay : '[ ] LT',\n\t            lastWeek : '[ ] dddd [] [] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /\\d{1,2}-(|||)/,\n\t        ordinal : function (number) {\n\t            var a = number % 10,\n\t                b = number >= 100 ? 100 : null;\n\t            return number + (suffixes[number] || suffixes[a] || suffixes[b]);\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ky;\n\t\n\t}));\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Luxembourgish [lb]\n\t//! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n\t        var format = {\n\t            'm': ['eng Minutt', 'enger Minutt'],\n\t            'h': ['eng Stonn', 'enger Stonn'],\n\t            'd': ['een Dag', 'engem Dag'],\n\t            'M': ['ee Mount', 'engem Mount'],\n\t            'y': ['ee Joer', 'engem Joer']\n\t        };\n\t        return withoutSuffix ? format[key][0] : format[key][1];\n\t    }\n\t    function processFutureTime(string) {\n\t        var number = string.substr(0, string.indexOf(' '));\n\t        if (eifelerRegelAppliesToNumber(number)) {\n\t            return 'a ' + string;\n\t        }\n\t        return 'an ' + string;\n\t    }\n\t    function processPastTime(string) {\n\t        var number = string.substr(0, string.indexOf(' '));\n\t        if (eifelerRegelAppliesToNumber(number)) {\n\t            return 'viru ' + string;\n\t        }\n\t        return 'virun ' + string;\n\t    }\n\t    /**\n\t     * Returns true if the word before the given number loses the '-n' ending.\n\t     * e.g. 'an 10 Deeg' but 'a 5 Deeg'\n\t     *\n\t     * @param number {integer}\n\t     * @returns {boolean}\n\t     */\n\t    function eifelerRegelAppliesToNumber(number) {\n\t        number = parseInt(number, 10);\n\t        if (isNaN(number)) {\n\t            return false;\n\t        }\n\t        if (number < 0) {\n\t            // Negative Number --> always true\n\t            return true;\n\t        } else if (number < 10) {\n\t            // Only 1 digit\n\t            if (4 <= number && number <= 7) {\n\t                return true;\n\t            }\n\t            return false;\n\t        } else if (number < 100) {\n\t            // 2 digits\n\t            var lastDigit = number % 10, firstDigit = number / 10;\n\t            if (lastDigit === 0) {\n\t                return eifelerRegelAppliesToNumber(firstDigit);\n\t            }\n\t            return eifelerRegelAppliesToNumber(lastDigit);\n\t        } else if (number < 10000) {\n\t            // 3 or 4 digits --> recursively check first digit\n\t            while (number >= 10) {\n\t                number = number / 10;\n\t            }\n\t            return eifelerRegelAppliesToNumber(number);\n\t        } else {\n\t            // Anything larger than 4 digits: recursively check first n-3 digits\n\t            number = number / 1000;\n\t            return eifelerRegelAppliesToNumber(number);\n\t        }\n\t    }\n\t\n\t    var lb = moment.defineLocale('lb', {\n\t        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n\t        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),\n\t        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),\n\t        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat: {\n\t            LT: 'H:mm [Auer]',\n\t            LTS: 'H:mm:ss [Auer]',\n\t            L: 'DD.MM.YYYY',\n\t            LL: 'D. MMMM YYYY',\n\t            LLL: 'D. MMMM YYYY H:mm [Auer]',\n\t            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'\n\t        },\n\t        calendar: {\n\t            sameDay: '[Haut um] LT',\n\t            sameElse: 'L',\n\t            nextDay: '[Muer um] LT',\n\t            nextWeek: 'dddd [um] LT',\n\t            lastDay: '[Gschter um] LT',\n\t            lastWeek: function () {\n\t                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule\n\t                switch (this.day()) {\n\t                    case 2:\n\t                    case 4:\n\t                        return '[Leschten] dddd [um] LT';\n\t                    default:\n\t                        return '[Leschte] dddd [um] LT';\n\t                }\n\t            }\n\t        },\n\t        relativeTime : {\n\t            future : processFutureTime,\n\t            past : processPastTime,\n\t            s : 'e puer Sekonnen',\n\t            m : processRelativeTime,\n\t            mm : '%d Minutten',\n\t            h : processRelativeTime,\n\t            hh : '%d Stonnen',\n\t            d : processRelativeTime,\n\t            dd : '%d Deeg',\n\t            M : processRelativeTime,\n\t            MM : '%d Mint',\n\t            y : processRelativeTime,\n\t            yy : '%d Joer'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal: '%d.',\n\t        week: {\n\t            dow: 1, // Monday is the first day of the week.\n\t            doy: 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return lb;\n\t\n\t}));\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Lao [lo]\n\t//! author : Ryan Hart : https://github.com/ryanhart2\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var lo = moment.defineLocale('lo', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        meridiemParse: /|/,\n\t        isPM: function (input) {\n\t            return input === '';\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 12) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : '[]dddd[] LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[]dddd[] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : '%s',\n\t            s : '',\n\t            m : '1 ',\n\t            mm : '%d ',\n\t            h : '1 ',\n\t            hh : '%d ',\n\t            d : '1 ',\n\t            dd : '%d ',\n\t            M : '1 ',\n\t            MM : '%d ',\n\t            y : '1 ',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /()\\d{1,2}/,\n\t        ordinal : function (number) {\n\t            return '' + number;\n\t        }\n\t    });\n\t\n\t    return lo;\n\t\n\t}));\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Lithuanian [lt]\n\t//! author : Mindaugas Mozras : https://github.com/mmozuras\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var units = {\n\t        'm' : 'minut_minuts_minut',\n\t        'mm': 'minuts_minui_minutes',\n\t        'h' : 'valanda_valandos_valand',\n\t        'hh': 'valandos_valand_valandas',\n\t        'd' : 'diena_dienos_dien',\n\t        'dd': 'dienos_dien_dienas',\n\t        'M' : 'mnuo_mnesio_mnes',\n\t        'MM': 'mnesiai_mnesi_mnesius',\n\t        'y' : 'metai_met_metus',\n\t        'yy': 'metai_met_metus'\n\t    };\n\t    function translateSeconds(number, withoutSuffix, key, isFuture) {\n\t        if (withoutSuffix) {\n\t            return 'kelios sekunds';\n\t        } else {\n\t            return isFuture ? 'keli sekundi' : 'kelias sekundes';\n\t        }\n\t    }\n\t    function translateSingular(number, withoutSuffix, key, isFuture) {\n\t        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);\n\t    }\n\t    function special(number) {\n\t        return number % 10 === 0 || (number > 10 && number < 20);\n\t    }\n\t    function forms(key) {\n\t        return units[key].split('_');\n\t    }\n\t    function translate(number, withoutSuffix, key, isFuture) {\n\t        var result = number + ' ';\n\t        if (number === 1) {\n\t            return result + translateSingular(number, withoutSuffix, key[0], isFuture);\n\t        } else if (withoutSuffix) {\n\t            return result + (special(number) ? forms(key)[1] : forms(key)[0]);\n\t        } else {\n\t            if (isFuture) {\n\t                return result + forms(key)[1];\n\t            } else {\n\t                return result + (special(number) ? forms(key)[1] : forms(key)[2]);\n\t            }\n\t        }\n\t    }\n\t    var lt = moment.defineLocale('lt', {\n\t        months : {\n\t            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),\n\t            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),\n\t            isFormat: /D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?|MMMM?(\\[[^\\[\\]]*\\]|\\s+)+D[oD]?/\n\t        },\n\t        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),\n\t        weekdays : {\n\t            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),\n\t            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),\n\t            isFormat: /dddd HH:mm/\n\t        },\n\t        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),\n\t        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'YYYY-MM-DD',\n\t            LL : 'YYYY [m.] MMMM D [d.]',\n\t            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',\n\t            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',\n\t            l : 'YYYY-MM-DD',\n\t            ll : 'YYYY [m.] MMMM D [d.]',\n\t            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',\n\t            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'\n\t        },\n\t        calendar : {\n\t            sameDay : '[iandien] LT',\n\t            nextDay : '[Rytoj] LT',\n\t            nextWeek : 'dddd LT',\n\t            lastDay : '[Vakar] LT',\n\t            lastWeek : '[Prajus] dddd LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'po %s',\n\t            past : 'prie %s',\n\t            s : translateSeconds,\n\t            m : translateSingular,\n\t            mm : translate,\n\t            h : translateSingular,\n\t            hh : translate,\n\t            d : translateSingular,\n\t            dd : translate,\n\t            M : translateSingular,\n\t            MM : translate,\n\t            y : translateSingular,\n\t            yy : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}-oji/,\n\t        ordinal : function (number) {\n\t            return number + '-oji';\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return lt;\n\t\n\t}));\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Latvian [lv]\n\t//! author : Kristaps Karlsons : https://github.com/skakri\n\t//! author : Jnis Elmeris : https://github.com/JanisE\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var units = {\n\t        'm': 'mintes_mintm_minte_mintes'.split('_'),\n\t        'mm': 'mintes_mintm_minte_mintes'.split('_'),\n\t        'h': 'stundas_stundm_stunda_stundas'.split('_'),\n\t        'hh': 'stundas_stundm_stunda_stundas'.split('_'),\n\t        'd': 'dienas_dienm_diena_dienas'.split('_'),\n\t        'dd': 'dienas_dienm_diena_dienas'.split('_'),\n\t        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),\n\t        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),\n\t        'y': 'gada_gadiem_gads_gadi'.split('_'),\n\t        'yy': 'gada_gadiem_gads_gadi'.split('_')\n\t    };\n\t    /**\n\t     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.\n\t     */\n\t    function format(forms, number, withoutSuffix) {\n\t        if (withoutSuffix) {\n\t            // E.g. \"21 minte\", \"3 mintes\".\n\t            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];\n\t        } else {\n\t            // E.g. \"21 mintes\" as in \"pc 21 mintes\".\n\t            // E.g. \"3 mintm\" as in \"pc 3 mintm\".\n\t            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];\n\t        }\n\t    }\n\t    function relativeTimeWithPlural(number, withoutSuffix, key) {\n\t        return number + ' ' + format(units[key], number, withoutSuffix);\n\t    }\n\t    function relativeTimeWithSingular(number, withoutSuffix, key) {\n\t        return format(units[key], number, withoutSuffix);\n\t    }\n\t    function relativeSeconds(number, withoutSuffix) {\n\t        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';\n\t    }\n\t\n\t    var lv = moment.defineLocale('lv', {\n\t        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),\n\t        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),\n\t        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),\n\t        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),\n\t        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY.',\n\t            LL : 'YYYY. [gada] D. MMMM',\n\t            LLL : 'YYYY. [gada] D. MMMM, HH:mm',\n\t            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[odien pulksten] LT',\n\t            nextDay : '[Rt pulksten] LT',\n\t            nextWeek : 'dddd [pulksten] LT',\n\t            lastDay : '[Vakar pulksten] LT',\n\t            lastWeek : '[Pagju] dddd [pulksten] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'pc %s',\n\t            past : 'pirms %s',\n\t            s : relativeSeconds,\n\t            m : relativeTimeWithSingular,\n\t            mm : relativeTimeWithPlural,\n\t            h : relativeTimeWithSingular,\n\t            hh : relativeTimeWithPlural,\n\t            d : relativeTimeWithSingular,\n\t            dd : relativeTimeWithPlural,\n\t            M : relativeTimeWithSingular,\n\t            MM : relativeTimeWithPlural,\n\t            y : relativeTimeWithSingular,\n\t            yy : relativeTimeWithPlural\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return lv;\n\t\n\t}));\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Montenegrin [me]\n\t//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var translator = {\n\t        words: { //Different grammatical cases\n\t            m: ['jedan minut', 'jednog minuta'],\n\t            mm: ['minut', 'minuta', 'minuta'],\n\t            h: ['jedan sat', 'jednog sata'],\n\t            hh: ['sat', 'sata', 'sati'],\n\t            dd: ['dan', 'dana', 'dana'],\n\t            MM: ['mjesec', 'mjeseca', 'mjeseci'],\n\t            yy: ['godina', 'godine', 'godina']\n\t        },\n\t        correctGrammaticalCase: function (number, wordKey) {\n\t            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n\t        },\n\t        translate: function (number, withoutSuffix, key) {\n\t            var wordKey = translator.words[key];\n\t            if (key.length === 1) {\n\t                return withoutSuffix ? wordKey[0] : wordKey[1];\n\t            } else {\n\t                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);\n\t            }\n\t        }\n\t    };\n\t\n\t    var me = moment.defineLocale('me', {\n\t        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),\n\t        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n\t        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n\t        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat: {\n\t            LT: 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L: 'DD. MM. YYYY',\n\t            LL: 'D. MMMM YYYY',\n\t            LLL: 'D. MMMM YYYY H:mm',\n\t            LLLL: 'dddd, D. MMMM YYYY H:mm'\n\t        },\n\t        calendar: {\n\t            sameDay: '[danas u] LT',\n\t            nextDay: '[sjutra u] LT',\n\t\n\t            nextWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[u] [nedjelju] [u] LT';\n\t                    case 3:\n\t                        return '[u] [srijedu] [u] LT';\n\t                    case 6:\n\t                        return '[u] [subotu] [u] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[u] dddd [u] LT';\n\t                }\n\t            },\n\t            lastDay  : '[jue u] LT',\n\t            lastWeek : function () {\n\t                var lastWeekDays = [\n\t                    '[prole] [nedjelje] [u] LT',\n\t                    '[prolog] [ponedjeljka] [u] LT',\n\t                    '[prolog] [utorka] [u] LT',\n\t                    '[prole] [srijede] [u] LT',\n\t                    '[prolog] [etvrtka] [u] LT',\n\t                    '[prolog] [petka] [u] LT',\n\t                    '[prole] [subote] [u] LT'\n\t                ];\n\t                return lastWeekDays[this.day()];\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'za %s',\n\t            past   : 'prije %s',\n\t            s      : 'nekoliko sekundi',\n\t            m      : translator.translate,\n\t            mm     : translator.translate,\n\t            h      : translator.translate,\n\t            hh     : translator.translate,\n\t            d      : 'dan',\n\t            dd     : translator.translate,\n\t            M      : 'mjesec',\n\t            MM     : translator.translate,\n\t            y      : 'godinu',\n\t            yy     : translator.translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return me;\n\t\n\t}));\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Macedonian [mk]\n\t//! author : Borislav Mickov : https://github.com/B0k0\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var mk = moment.defineLocale('mk', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : 'e_o_____a'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'D.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY H:mm',\n\t            LLLL : 'dddd, D MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ] LT',\n\t            nextDay : '[ ] LT',\n\t            nextWeek : '[] dddd [] LT',\n\t            lastDay : '[ ] LT',\n\t            lastWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                    case 3:\n\t                    case 6:\n\t                        return '[] dddd [] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[] dddd [] LT';\n\t                }\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : ' %s',\n\t            s : ' ',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d ',\n\t            M : '',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /\\d{1,2}-(|||||)/,\n\t        ordinal : function (number) {\n\t            var lastDigit = number % 10,\n\t                last2Digits = number % 100;\n\t            if (number === 0) {\n\t                return number + '-';\n\t            } else if (last2Digits === 0) {\n\t                return number + '-';\n\t            } else if (last2Digits > 10 && last2Digits < 20) {\n\t                return number + '-';\n\t            } else if (lastDigit === 1) {\n\t                return number + '-';\n\t            } else if (lastDigit === 2) {\n\t                return number + '-';\n\t            } else if (lastDigit === 7 || lastDigit === 8) {\n\t                return number + '-';\n\t            } else {\n\t                return number + '-';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return mk;\n\t\n\t}));\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Malayalam [ml]\n\t//! author : Floyd Pink : https://github.com/floydpink\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ml = moment.defineLocale('ml', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '._._._.___._._._._._.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h:mm -',\n\t            LTS : 'A h:mm:ss -',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm -',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm -'\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd, LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        meridiemParse: /|| ||/i,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if ((meridiem === '' && hour >= 4) ||\n\t                    meridiem === ' ' ||\n\t                    meridiem === '') {\n\t                return hour + 12;\n\t            } else {\n\t                return hour;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 12) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return ' ';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        }\n\t    });\n\t\n\t    return ml;\n\t\n\t}));\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Marathi [mr]\n\t//! author : Harshad Kale : https://github.com/kalehv\n\t//! author : Vivek Athalye : https://github.com/vnathalye\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    },\n\t    numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    function relativeTimeMr(number, withoutSuffix, string, isFuture)\n\t    {\n\t        var output = '';\n\t        if (withoutSuffix) {\n\t            switch (string) {\n\t                case 's': output = ' '; break;\n\t                case 'm': output = ' '; break;\n\t                case 'mm': output = '%d '; break;\n\t                case 'h': output = ' '; break;\n\t                case 'hh': output = '%d '; break;\n\t                case 'd': output = ' '; break;\n\t                case 'dd': output = '%d '; break;\n\t                case 'M': output = ' '; break;\n\t                case 'MM': output = '%d '; break;\n\t                case 'y': output = ' '; break;\n\t                case 'yy': output = '%d '; break;\n\t            }\n\t        }\n\t        else {\n\t            switch (string) {\n\t                case 's': output = ' '; break;\n\t                case 'm': output = ' '; break;\n\t                case 'mm': output = '%d '; break;\n\t                case 'h': output = ' '; break;\n\t                case 'hh': output = '%d '; break;\n\t                case 'd': output = ' '; break;\n\t                case 'dd': output = '%d '; break;\n\t                case 'M': output = ' '; break;\n\t                case 'MM': output = '%d '; break;\n\t                case 'y': output = ' '; break;\n\t                case 'yy': output = '%d '; break;\n\t            }\n\t        }\n\t        return output.replace(/%d/i, number);\n\t    }\n\t\n\t    var mr = moment.defineLocale('mr', {\n\t        months : '___________'.split('_'),\n\t        monthsShort: '._._._._._._._._._._._.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h:mm ',\n\t            LTS : 'A h:mm:ss ',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm ',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd, LT',\n\t            lastDay : '[] LT',\n\t            lastWeek: '[] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future: '%s',\n\t            past: '%s',\n\t            s: relativeTimeMr,\n\t            m: relativeTimeMr,\n\t            mm: relativeTimeMr,\n\t            h: relativeTimeMr,\n\t            hh: relativeTimeMr,\n\t            d: relativeTimeMr,\n\t            dd: relativeTimeMr,\n\t            M: relativeTimeMr,\n\t            MM: relativeTimeMr,\n\t            y: relativeTimeMr,\n\t            yy: relativeTimeMr\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        meridiemParse: /|||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '') {\n\t                return hour < 4 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '') {\n\t                return hour >= 10 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem: function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 10) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return mr;\n\t\n\t}));\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Malay [ms]\n\t//! author : Weldan Jamili : https://github.com/weldan\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ms = moment.defineLocale('ms', {\n\t        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),\n\t        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),\n\t        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),\n\t        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH.mm',\n\t            LTS : 'HH.mm.ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY [pukul] HH.mm',\n\t            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n\t        },\n\t        meridiemParse: /pagi|tengahari|petang|malam/,\n\t        meridiemHour: function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === 'pagi') {\n\t                return hour;\n\t            } else if (meridiem === 'tengahari') {\n\t                return hour >= 11 ? hour : hour + 12;\n\t            } else if (meridiem === 'petang' || meridiem === 'malam') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 11) {\n\t                return 'pagi';\n\t            } else if (hours < 15) {\n\t                return 'tengahari';\n\t            } else if (hours < 19) {\n\t                return 'petang';\n\t            } else {\n\t                return 'malam';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[Hari ini pukul] LT',\n\t            nextDay : '[Esok pukul] LT',\n\t            nextWeek : 'dddd [pukul] LT',\n\t            lastDay : '[Kelmarin pukul] LT',\n\t            lastWeek : 'dddd [lepas pukul] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'dalam %s',\n\t            past : '%s yang lepas',\n\t            s : 'beberapa saat',\n\t            m : 'seminit',\n\t            mm : '%d minit',\n\t            h : 'sejam',\n\t            hh : '%d jam',\n\t            d : 'sehari',\n\t            dd : '%d hari',\n\t            M : 'sebulan',\n\t            MM : '%d bulan',\n\t            y : 'setahun',\n\t            yy : '%d tahun'\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ms;\n\t\n\t}));\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Malay [ms-my]\n\t//! note : DEPRECATED, the correct one is [ms]\n\t//! author : Weldan Jamili : https://github.com/weldan\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var ms_my = moment.defineLocale('ms-my', {\n\t        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),\n\t        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),\n\t        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),\n\t        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH.mm',\n\t            LTS : 'HH.mm.ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY [pukul] HH.mm',\n\t            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n\t        },\n\t        meridiemParse: /pagi|tengahari|petang|malam/,\n\t        meridiemHour: function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === 'pagi') {\n\t                return hour;\n\t            } else if (meridiem === 'tengahari') {\n\t                return hour >= 11 ? hour : hour + 12;\n\t            } else if (meridiem === 'petang' || meridiem === 'malam') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 11) {\n\t                return 'pagi';\n\t            } else if (hours < 15) {\n\t                return 'tengahari';\n\t            } else if (hours < 19) {\n\t                return 'petang';\n\t            } else {\n\t                return 'malam';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[Hari ini pukul] LT',\n\t            nextDay : '[Esok pukul] LT',\n\t            nextWeek : 'dddd [pukul] LT',\n\t            lastDay : '[Kelmarin pukul] LT',\n\t            lastWeek : 'dddd [lepas pukul] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'dalam %s',\n\t            past : '%s yang lepas',\n\t            s : 'beberapa saat',\n\t            m : 'seminit',\n\t            mm : '%d minit',\n\t            h : 'sejam',\n\t            hh : '%d jam',\n\t            d : 'sehari',\n\t            dd : '%d hari',\n\t            M : 'sebulan',\n\t            MM : '%d bulan',\n\t            y : 'setahun',\n\t            yy : '%d tahun'\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ms_my;\n\t\n\t}));\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Burmese [my]\n\t//! author : Squar team, mysquar.com\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    }, numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var my = moment.defineLocale('my', {\n\t        months: '___________'.split('_'),\n\t        monthsShort: '___________'.split('_'),\n\t        weekdays: '______'.split('_'),\n\t        weekdaysShort: '______'.split('_'),\n\t        weekdaysMin: '______'.split('_'),\n\t\n\t        longDateFormat: {\n\t            LT: 'HH:mm',\n\t            LTS: 'HH:mm:ss',\n\t            L: 'DD/MM/YYYY',\n\t            LL: 'D MMMM YYYY',\n\t            LLL: 'D MMMM YYYY HH:mm',\n\t            LLLL: 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar: {\n\t            sameDay: '[.] LT []',\n\t            nextDay: '[] LT []',\n\t            nextWeek: 'dddd LT []',\n\t            lastDay: '[.] LT []',\n\t            lastWeek: '[] dddd LT []',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime: {\n\t            future: ' %s ',\n\t            past: ' %s ',\n\t            s: '.',\n\t            m: '',\n\t            mm: '%d ',\n\t            h: '',\n\t            hh: '%d ',\n\t            d: '',\n\t            dd: '%d ',\n\t            M: '',\n\t            MM: '%d ',\n\t            y: '',\n\t            yy: '%d '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        week: {\n\t            dow: 1, // Monday is the first day of the week.\n\t            doy: 4 // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return my;\n\t\n\t}));\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Norwegian Bokml [nb]\n\t//! authors : Espen Hovlandsdal : https://github.com/rexxars\n\t//!           Sigurd Gartmann : https://github.com/sigurdga\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var nb = moment.defineLocale('nb', {\n\t        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n\t        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n\t        weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),\n\t        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY [kl.] HH:mm',\n\t            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[i dag kl.] LT',\n\t            nextDay: '[i morgen kl.] LT',\n\t            nextWeek: 'dddd [kl.] LT',\n\t            lastDay: '[i gr kl.] LT',\n\t            lastWeek: '[forrige] dddd [kl.] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'om %s',\n\t            past : '%s siden',\n\t            s : 'noen sekunder',\n\t            m : 'ett minutt',\n\t            mm : '%d minutter',\n\t            h : 'en time',\n\t            hh : '%d timer',\n\t            d : 'en dag',\n\t            dd : '%d dager',\n\t            M : 'en mned',\n\t            MM : '%d mneder',\n\t            y : 'ett r',\n\t            yy : '%d r'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return nb;\n\t\n\t}));\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Nepalese [ne]\n\t//! author : suvash : https://github.com/suvash\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    },\n\t    numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var ne = moment.defineLocale('ne', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '._.__.___._._._._._.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '._._._._._._.'.split('_'),\n\t        weekdaysMin : '._._._._._._.'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'A h:mm ',\n\t            LTS : 'A h:mm:ss ',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm ',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        meridiemParse: /|||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '') {\n\t                return hour < 4 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '') {\n\t                return hour >= 10 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 3) {\n\t                return '';\n\t            } else if (hour < 12) {\n\t                return '';\n\t            } else if (hour < 16) {\n\t                return '';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : '[] dddd[,] LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd[,] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ne;\n\t\n\t}));\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Dutch [nl]\n\t//! author : Joris Rling : https://github.com/jjupiter\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),\n\t        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');\n\t\n\t    var nl = moment.defineLocale('nl', {\n\t        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),\n\t        monthsShort : function (m, format) {\n\t            if (/-MMM-/.test(format)) {\n\t                return monthsShortWithoutDots[m.month()];\n\t            } else {\n\t                return monthsShortWithDots[m.month()];\n\t            }\n\t        },\n\t        monthsParseExact : true,\n\t        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),\n\t        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),\n\t        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD-MM-YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[vandaag om] LT',\n\t            nextDay: '[morgen om] LT',\n\t            nextWeek: 'dddd [om] LT',\n\t            lastDay: '[gisteren om] LT',\n\t            lastWeek: '[afgelopen] dddd [om] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'over %s',\n\t            past : '%s geleden',\n\t            s : 'een paar seconden',\n\t            m : 'n minuut',\n\t            mm : '%d minuten',\n\t            h : 'n uur',\n\t            hh : '%d uur',\n\t            d : 'n dag',\n\t            dd : '%d dagen',\n\t            M : 'n maand',\n\t            MM : '%d maanden',\n\t            y : 'n jaar',\n\t            yy : '%d jaar'\n\t        },\n\t        ordinalParse: /\\d{1,2}(ste|de)/,\n\t        ordinal : function (number) {\n\t            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return nl;\n\t\n\t}));\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Nynorsk [nn]\n\t//! author : https://github.com/mechuwind\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var nn = moment.defineLocale('nn', {\n\t        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n\t        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),\n\t        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),\n\t        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),\n\t        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY [kl.] H:mm',\n\t            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[I dag klokka] LT',\n\t            nextDay: '[I morgon klokka] LT',\n\t            nextWeek: 'dddd [klokka] LT',\n\t            lastDay: '[I gr klokka] LT',\n\t            lastWeek: '[Fregande] dddd [klokka] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'om %s',\n\t            past : '%s sidan',\n\t            s : 'nokre sekund',\n\t            m : 'eit minutt',\n\t            mm : '%d minutt',\n\t            h : 'ein time',\n\t            hh : '%d timar',\n\t            d : 'ein dag',\n\t            dd : '%d dagar',\n\t            M : 'ein mnad',\n\t            MM : '%d mnader',\n\t            y : 'eit r',\n\t            yy : '%d r'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return nn;\n\t\n\t}));\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Punjabi (India) [pa-in]\n\t//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    },\n\t    numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var pa_in = moment.defineLocale('pa-in', {\n\t        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h:mm ',\n\t            LTS : 'A h:mm:ss ',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm ',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd, LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists\n\t        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.\n\t        meridiemParse: /|||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '') {\n\t                return hour < 4 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '') {\n\t                return hour >= 10 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 10) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return pa_in;\n\t\n\t}));\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Polish [pl]\n\t//! author : Rafal Hirsz : https://github.com/evoL\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),\n\t        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');\n\t    function plural(n) {\n\t        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);\n\t    }\n\t    function translate(number, withoutSuffix, key) {\n\t        var result = number + ' ';\n\t        switch (key) {\n\t            case 'm':\n\t                return withoutSuffix ? 'minuta' : 'minut';\n\t            case 'mm':\n\t                return result + (plural(number) ? 'minuty' : 'minut');\n\t            case 'h':\n\t                return withoutSuffix  ? 'godzina'  : 'godzin';\n\t            case 'hh':\n\t                return result + (plural(number) ? 'godziny' : 'godzin');\n\t            case 'MM':\n\t                return result + (plural(number) ? 'miesice' : 'miesicy');\n\t            case 'yy':\n\t                return result + (plural(number) ? 'lata' : 'lat');\n\t        }\n\t    }\n\t\n\t    var pl = moment.defineLocale('pl', {\n\t        months : function (momentToFormat, format) {\n\t            if (format === '') {\n\t                // Hack: if format empty we know this is used to generate\n\t                // RegExp by moment. Give then back both valid forms of months\n\t                // in RegExp ready format.\n\t                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';\n\t            } else if (/D MMMM/.test(format)) {\n\t                return monthsSubjective[momentToFormat.month()];\n\t            } else {\n\t                return monthsNominative[momentToFormat.month()];\n\t            }\n\t        },\n\t        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),\n\t        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),\n\t        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),\n\t        weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Dzi o] LT',\n\t            nextDay: '[Jutro o] LT',\n\t            nextWeek: '[W] dddd [o] LT',\n\t            lastDay: '[Wczoraj o] LT',\n\t            lastWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[W zesz niedziel o] LT';\n\t                    case 3:\n\t                        return '[W zesz rod o] LT';\n\t                    case 6:\n\t                        return '[W zesz sobot o] LT';\n\t                    default:\n\t                        return '[W zeszy] dddd [o] LT';\n\t                }\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'za %s',\n\t            past : '%s temu',\n\t            s : 'kilka sekund',\n\t            m : translate,\n\t            mm : translate,\n\t            h : translate,\n\t            hh : translate,\n\t            d : '1 dzie',\n\t            dd : '%d dni',\n\t            M : 'miesic',\n\t            MM : translate,\n\t            y : 'rok',\n\t            yy : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return pl;\n\t\n\t}));\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Portuguese [pt]\n\t//! author : Jefferson : https://github.com/jalex79\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var pt = moment.defineLocale('pt', {\n\t        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),\n\t        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),\n\t        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),\n\t        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),\n\t        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D [de] MMMM [de] YYYY',\n\t            LLL : 'D [de] MMMM [de] YYYY HH:mm',\n\t            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Hoje s] LT',\n\t            nextDay: '[Amanh s] LT',\n\t            nextWeek: 'dddd [s] LT',\n\t            lastDay: '[Ontem s] LT',\n\t            lastWeek: function () {\n\t                return (this.day() === 0 || this.day() === 6) ?\n\t                    '[ltimo] dddd [s] LT' : // Saturday + Sunday\n\t                    '[ltima] dddd [s] LT'; // Monday - Friday\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'em %s',\n\t            past : 'h %s',\n\t            s : 'segundos',\n\t            m : 'um minuto',\n\t            mm : '%d minutos',\n\t            h : 'uma hora',\n\t            hh : '%d horas',\n\t            d : 'um dia',\n\t            dd : '%d dias',\n\t            M : 'um ms',\n\t            MM : '%d meses',\n\t            y : 'um ano',\n\t            yy : '%d anos'\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return pt;\n\t\n\t}));\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Portuguese (Brazil) [pt-br]\n\t//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var pt_br = moment.defineLocale('pt-br', {\n\t        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),\n\t        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),\n\t        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),\n\t        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),\n\t        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D [de] MMMM [de] YYYY',\n\t            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',\n\t            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Hoje s] LT',\n\t            nextDay: '[Amanh s] LT',\n\t            nextWeek: 'dddd [s] LT',\n\t            lastDay: '[Ontem s] LT',\n\t            lastWeek: function () {\n\t                return (this.day() === 0 || this.day() === 6) ?\n\t                    '[ltimo] dddd [s] LT' : // Saturday + Sunday\n\t                    '[ltima] dddd [s] LT'; // Monday - Friday\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'em %s',\n\t            past : '%s atrs',\n\t            s : 'poucos segundos',\n\t            m : 'um minuto',\n\t            mm : '%d minutos',\n\t            h : 'uma hora',\n\t            hh : '%d horas',\n\t            d : 'um dia',\n\t            dd : '%d dias',\n\t            M : 'um ms',\n\t            MM : '%d meses',\n\t            y : 'um ano',\n\t            yy : '%d anos'\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal : '%d'\n\t    });\n\t\n\t    return pt_br;\n\t\n\t}));\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Romanian [ro]\n\t//! author : Vlad Gurdiga : https://github.com/gurdiga\n\t//! author : Valentin Agachi : https://github.com/avaly\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function relativeTimeWithPlural(number, withoutSuffix, key) {\n\t        var format = {\n\t                'mm': 'minute',\n\t                'hh': 'ore',\n\t                'dd': 'zile',\n\t                'MM': 'luni',\n\t                'yy': 'ani'\n\t            },\n\t            separator = ' ';\n\t        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {\n\t            separator = ' de ';\n\t        }\n\t        return number + separator + format[key];\n\t    }\n\t\n\t    var ro = moment.defineLocale('ro', {\n\t        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),\n\t        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),\n\t        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),\n\t        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY H:mm',\n\t            LLLL : 'dddd, D MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[azi la] LT',\n\t            nextDay: '[mine la] LT',\n\t            nextWeek: 'dddd [la] LT',\n\t            lastDay: '[ieri la] LT',\n\t            lastWeek: '[fosta] dddd [la] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'peste %s',\n\t            past : '%s n urm',\n\t            s : 'cteva secunde',\n\t            m : 'un minut',\n\t            mm : relativeTimeWithPlural,\n\t            h : 'o or',\n\t            hh : relativeTimeWithPlural,\n\t            d : 'o zi',\n\t            dd : relativeTimeWithPlural,\n\t            M : 'o lun',\n\t            MM : relativeTimeWithPlural,\n\t            y : 'un an',\n\t            yy : relativeTimeWithPlural\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ro;\n\t\n\t}));\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Russian [ru]\n\t//! author : Viktorminator : https://github.com/Viktorminator\n\t//! Author : Menelion Elensle : https://github.com/Oire\n\t//! author :   : https://github.com/socketpair\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function plural(word, num) {\n\t        var forms = word.split('_');\n\t        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n\t    }\n\t    function relativeTimeWithPlural(number, withoutSuffix, key) {\n\t        var format = {\n\t            'mm': withoutSuffix ? '__' : '__',\n\t            'hh': '__',\n\t            'dd': '__',\n\t            'MM': '__',\n\t            'yy': '__'\n\t        };\n\t        if (key === 'm') {\n\t            return withoutSuffix ? '' : '';\n\t        }\n\t        else {\n\t            return number + ' ' + plural(format[key], +number);\n\t        }\n\t    }\n\t    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];\n\t\n\t    // http://new.gramota.ru/spravka/rules/139-prop :  103\n\t    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637\n\t    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753\n\t    var ru = moment.defineLocale('ru', {\n\t        months : {\n\t            format: '___________'.split('_'),\n\t            standalone: '___________'.split('_')\n\t        },\n\t        monthsShort : {\n\t            //  CLDR  \".\"  \".\",        ?\n\t            format: '._._._.____._._._._.'.split('_'),\n\t            standalone: '._.__.____._._._._.'.split('_')\n\t        },\n\t        weekdays : {\n\t            standalone: '______'.split('_'),\n\t            format: '______'.split('_'),\n\t            isFormat: /\\[ ?[] ?(?:||)? ?\\] ?dddd/\n\t        },\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        monthsParse : monthsParse,\n\t        longMonthsParse : monthsParse,\n\t        shortMonthsParse : monthsParse,\n\t\n\t        //    ,   ,  ,  4 ,      \n\t        monthsRegex: /^([]|\\.?|[]|?\\.?|?|\\.?|[]|\\.?|[]|[]|\\.?|[]|\\.?|?|\\.?|[]|?\\.?|[]|\\.?|[]|?\\.?|[]|\\.?)/i,\n\t\n\t        //  \n\t        monthsShortRegex: /^([]|\\.?|[]|?\\.?|?|\\.?|[]|\\.?|[]|[]|\\.?|[]|\\.?|?|\\.?|[]|?\\.?|[]|\\.?|[]|?\\.?|[]|\\.?)/i,\n\t\n\t        //    \n\t        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,\n\t\n\t        // ,     \n\t        monthsShortStrictRegex: /^(\\.|?\\.|[.]|\\.|[]|[.]|[.]|\\.|?\\.|\\.|?\\.|\\.)/i,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY .',\n\t            LLL : 'D MMMM YYYY ., HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[ ] LT',\n\t            nextDay: '[ ] LT',\n\t            lastDay: '[ ] LT',\n\t            nextWeek: function (now) {\n\t                if (now.week() !== this.week()) {\n\t                    switch (this.day()) {\n\t                        case 0:\n\t                            return '[ ] dddd [] LT';\n\t                        case 1:\n\t                        case 2:\n\t                        case 4:\n\t                            return '[ ] dddd [] LT';\n\t                        case 3:\n\t                        case 5:\n\t                        case 6:\n\t                            return '[ ] dddd [] LT';\n\t                    }\n\t                } else {\n\t                    if (this.day() === 2) {\n\t                        return '[] dddd [] LT';\n\t                    } else {\n\t                        return '[] dddd [] LT';\n\t                    }\n\t                }\n\t            },\n\t            lastWeek: function (now) {\n\t                if (now.week() !== this.week()) {\n\t                    switch (this.day()) {\n\t                        case 0:\n\t                            return '[ ] dddd [] LT';\n\t                        case 1:\n\t                        case 2:\n\t                        case 4:\n\t                            return '[ ] dddd [] LT';\n\t                        case 3:\n\t                        case 5:\n\t                        case 6:\n\t                            return '[ ] dddd [] LT';\n\t                    }\n\t                } else {\n\t                    if (this.day() === 2) {\n\t                        return '[] dddd [] LT';\n\t                    } else {\n\t                        return '[] dddd [] LT';\n\t                    }\n\t                }\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : relativeTimeWithPlural,\n\t            mm : relativeTimeWithPlural,\n\t            h : '',\n\t            hh : relativeTimeWithPlural,\n\t            d : '',\n\t            dd : relativeTimeWithPlural,\n\t            M : '',\n\t            MM : relativeTimeWithPlural,\n\t            y : '',\n\t            yy : relativeTimeWithPlural\n\t        },\n\t        meridiemParse: /|||/i,\n\t        isPM : function (input) {\n\t            return /^(|)$/.test(input);\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 12) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        ordinalParse: /\\d{1,2}-(||)/,\n\t        ordinal: function (number, period) {\n\t            switch (period) {\n\t                case 'M':\n\t                case 'd':\n\t                case 'DDD':\n\t                    return number + '-';\n\t                case 'D':\n\t                    return number + '-';\n\t                case 'w':\n\t                case 'W':\n\t                    return number + '-';\n\t                default:\n\t                    return number;\n\t            }\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ru;\n\t\n\t}));\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Northern Sami [se]\n\t//! authors : Brd Rolstad Henriksen : https://github.com/karamell\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t\n\t    var se = moment.defineLocale('se', {\n\t        months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),\n\t        monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),\n\t        weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),\n\t        weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),\n\t        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'MMMM D. [b.] YYYY',\n\t            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',\n\t            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[otne ti] LT',\n\t            nextDay: '[ihttin ti] LT',\n\t            nextWeek: 'dddd [ti] LT',\n\t            lastDay: '[ikte ti] LT',\n\t            lastWeek: '[ovddit] dddd [ti] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s geaes',\n\t            past : 'mait %s',\n\t            s : 'moadde sekunddat',\n\t            m : 'okta minuhta',\n\t            mm : '%d minuhtat',\n\t            h : 'okta diimmu',\n\t            hh : '%d diimmut',\n\t            d : 'okta beaivi',\n\t            dd : '%d beaivvit',\n\t            M : 'okta mnnu',\n\t            MM : '%d mnut',\n\t            y : 'okta jahki',\n\t            yy : '%d jagit'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return se;\n\t\n\t}));\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Sinhalese [si]\n\t//! author : Sampath Sitinamaluwa : https://github.com/sampathsris\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    /*jshint -W100*/\n\t    var si = moment.defineLocale('si', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'a h:mm',\n\t            LTS : 'a h:mm:ss',\n\t            L : 'YYYY/MM/DD',\n\t            LL : 'YYYY MMMM D',\n\t            LLL : 'YYYY MMMM D, a h:mm',\n\t            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT[]',\n\t            nextDay : '[] LT[]',\n\t            nextWeek : 'dddd LT[]',\n\t            lastDay : '[] LT[]',\n\t            lastWeek : '[] dddd LT[]',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : '',\n\t            mm : ' %d',\n\t            h : '',\n\t            hh : ' %d',\n\t            d : '',\n\t            dd : ' %d',\n\t            M : '',\n\t            MM : ' %d',\n\t            y : '',\n\t            yy : ' %d'\n\t        },\n\t        ordinalParse: /\\d{1,2} /,\n\t        ordinal : function (number) {\n\t            return number + ' ';\n\t        },\n\t        meridiemParse : / | |.|../,\n\t        isPM : function (input) {\n\t            return input === '..' || input === ' ';\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours > 11) {\n\t                return isLower ? '..' : ' ';\n\t            } else {\n\t                return isLower ? '..' : ' ';\n\t            }\n\t        }\n\t    });\n\t\n\t    return si;\n\t\n\t}));\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Slovak [sk]\n\t//! author : Martin Minka : https://github.com/k2s\n\t//! based on work of petrbela : https://github.com/petrbela\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),\n\t        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');\n\t    function plural(n) {\n\t        return (n > 1) && (n < 5);\n\t    }\n\t    function translate(number, withoutSuffix, key, isFuture) {\n\t        var result = number + ' ';\n\t        switch (key) {\n\t            case 's':  // a few seconds / in a few seconds / a few seconds ago\n\t                return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';\n\t            case 'm':  // a minute / in a minute / a minute ago\n\t                return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');\n\t            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'minty' : 'mint');\n\t                } else {\n\t                    return result + 'mintami';\n\t                }\n\t                break;\n\t            case 'h':  // an hour / in an hour / an hour ago\n\t                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');\n\t            case 'hh': // 9 hours / in 9 hours / 9 hours ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'hodiny' : 'hodn');\n\t                } else {\n\t                    return result + 'hodinami';\n\t                }\n\t                break;\n\t            case 'd':  // a day / in a day / a day ago\n\t                return (withoutSuffix || isFuture) ? 'de' : 'dom';\n\t            case 'dd': // 9 days / in 9 days / 9 days ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'dni' : 'dn');\n\t                } else {\n\t                    return result + 'dami';\n\t                }\n\t                break;\n\t            case 'M':  // a month / in a month / a month ago\n\t                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';\n\t            case 'MM': // 9 months / in 9 months / 9 months ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'mesiace' : 'mesiacov');\n\t                } else {\n\t                    return result + 'mesiacmi';\n\t                }\n\t                break;\n\t            case 'y':  // a year / in a year / a year ago\n\t                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';\n\t            case 'yy': // 9 years / in 9 years / 9 years ago\n\t                if (withoutSuffix || isFuture) {\n\t                    return result + (plural(number) ? 'roky' : 'rokov');\n\t                } else {\n\t                    return result + 'rokmi';\n\t                }\n\t                break;\n\t        }\n\t    }\n\t\n\t    var sk = moment.defineLocale('sk', {\n\t        months : months,\n\t        monthsShort : monthsShort,\n\t        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),\n\t        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),\n\t        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),\n\t        longDateFormat : {\n\t            LT: 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY H:mm',\n\t            LLLL : 'dddd D. MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[dnes o] LT',\n\t            nextDay: '[zajtra o] LT',\n\t            nextWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[v nedeu o] LT';\n\t                    case 1:\n\t                    case 2:\n\t                        return '[v] dddd [o] LT';\n\t                    case 3:\n\t                        return '[v stredu o] LT';\n\t                    case 4:\n\t                        return '[vo tvrtok o] LT';\n\t                    case 5:\n\t                        return '[v piatok o] LT';\n\t                    case 6:\n\t                        return '[v sobotu o] LT';\n\t                }\n\t            },\n\t            lastDay: '[vera o] LT',\n\t            lastWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[minul nedeu o] LT';\n\t                    case 1:\n\t                    case 2:\n\t                        return '[minul] dddd [o] LT';\n\t                    case 3:\n\t                        return '[minul stredu o] LT';\n\t                    case 4:\n\t                    case 5:\n\t                        return '[minul] dddd [o] LT';\n\t                    case 6:\n\t                        return '[minul sobotu o] LT';\n\t                }\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'za %s',\n\t            past : 'pred %s',\n\t            s : translate,\n\t            m : translate,\n\t            mm : translate,\n\t            h : translate,\n\t            hh : translate,\n\t            d : translate,\n\t            dd : translate,\n\t            M : translate,\n\t            MM : translate,\n\t            y : translate,\n\t            yy : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return sk;\n\t\n\t}));\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Slovenian [sl]\n\t//! author : Robert Sedovek : https://github.com/sedovsek\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n\t        var result = number + ' ';\n\t        switch (key) {\n\t            case 's':\n\t                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';\n\t            case 'm':\n\t                return withoutSuffix ? 'ena minuta' : 'eno minuto';\n\t            case 'mm':\n\t                if (number === 1) {\n\t                    result += withoutSuffix ? 'minuta' : 'minuto';\n\t                } else if (number === 2) {\n\t                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';\n\t                } else if (number < 5) {\n\t                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';\n\t                } else {\n\t                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';\n\t                }\n\t                return result;\n\t            case 'h':\n\t                return withoutSuffix ? 'ena ura' : 'eno uro';\n\t            case 'hh':\n\t                if (number === 1) {\n\t                    result += withoutSuffix ? 'ura' : 'uro';\n\t                } else if (number === 2) {\n\t                    result += withoutSuffix || isFuture ? 'uri' : 'urama';\n\t                } else if (number < 5) {\n\t                    result += withoutSuffix || isFuture ? 'ure' : 'urami';\n\t                } else {\n\t                    result += withoutSuffix || isFuture ? 'ur' : 'urami';\n\t                }\n\t                return result;\n\t            case 'd':\n\t                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';\n\t            case 'dd':\n\t                if (number === 1) {\n\t                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';\n\t                } else if (number === 2) {\n\t                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';\n\t                } else {\n\t                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';\n\t                }\n\t                return result;\n\t            case 'M':\n\t                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';\n\t            case 'MM':\n\t                if (number === 1) {\n\t                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';\n\t                } else if (number === 2) {\n\t                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';\n\t                } else if (number < 5) {\n\t                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';\n\t                } else {\n\t                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';\n\t                }\n\t                return result;\n\t            case 'y':\n\t                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';\n\t            case 'yy':\n\t                if (number === 1) {\n\t                    result += withoutSuffix || isFuture ? 'leto' : 'letom';\n\t                } else if (number === 2) {\n\t                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';\n\t                } else if (number < 5) {\n\t                    result += withoutSuffix || isFuture ? 'leta' : 'leti';\n\t                } else {\n\t                    result += withoutSuffix || isFuture ? 'let' : 'leti';\n\t                }\n\t                return result;\n\t        }\n\t    }\n\t\n\t    var sl = moment.defineLocale('sl', {\n\t        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),\n\t        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),\n\t        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),\n\t        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L : 'DD. MM. YYYY',\n\t            LL : 'D. MMMM YYYY',\n\t            LLL : 'D. MMMM YYYY H:mm',\n\t            LLLL : 'dddd, D. MMMM YYYY H:mm'\n\t        },\n\t        calendar : {\n\t            sameDay  : '[danes ob] LT',\n\t            nextDay  : '[jutri ob] LT',\n\t\n\t            nextWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[v] [nedeljo] [ob] LT';\n\t                    case 3:\n\t                        return '[v] [sredo] [ob] LT';\n\t                    case 6:\n\t                        return '[v] [soboto] [ob] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[v] dddd [ob] LT';\n\t                }\n\t            },\n\t            lastDay  : '[veraj ob] LT',\n\t            lastWeek : function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[prejnjo] [nedeljo] [ob] LT';\n\t                    case 3:\n\t                        return '[prejnjo] [sredo] [ob] LT';\n\t                    case 6:\n\t                        return '[prejnjo] [soboto] [ob] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[prejnji] dddd [ob] LT';\n\t                }\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'ez %s',\n\t            past   : 'pred %s',\n\t            s      : processRelativeTime,\n\t            m      : processRelativeTime,\n\t            mm     : processRelativeTime,\n\t            h      : processRelativeTime,\n\t            hh     : processRelativeTime,\n\t            d      : processRelativeTime,\n\t            dd     : processRelativeTime,\n\t            M      : processRelativeTime,\n\t            MM     : processRelativeTime,\n\t            y      : processRelativeTime,\n\t            yy     : processRelativeTime\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return sl;\n\t\n\t}));\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Albanian [sq]\n\t//! author : Flakrim Ismani : https://github.com/flakerimi\n\t//! author: Menelion Elensle: https://github.com/Oire (tests)\n\t//! author : Oerd Cukalla : https://github.com/oerd (fixes)\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var sq = moment.defineLocale('sq', {\n\t        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),\n\t        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),\n\t        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),\n\t        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),\n\t        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),\n\t        weekdaysParseExact : true,\n\t        meridiemParse: /PD|MD/,\n\t        isPM: function (input) {\n\t            return input.charAt(0) === 'M';\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            return hours < 12 ? 'PD' : 'MD';\n\t        },\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Sot n] LT',\n\t            nextDay : '[Nesr n] LT',\n\t            nextWeek : 'dddd [n] LT',\n\t            lastDay : '[Dje n] LT',\n\t            lastWeek : 'dddd [e kaluar n] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'n %s',\n\t            past : '%s m par',\n\t            s : 'disa sekonda',\n\t            m : 'nj minut',\n\t            mm : '%d minuta',\n\t            h : 'nj or',\n\t            hh : '%d or',\n\t            d : 'nj dit',\n\t            dd : '%d dit',\n\t            M : 'nj muaj',\n\t            MM : '%d muaj',\n\t            y : 'nj vit',\n\t            yy : '%d vite'\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return sq;\n\t\n\t}));\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Serbian [sr]\n\t//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var translator = {\n\t        words: { //Different grammatical cases\n\t            m: ['jedan minut', 'jedne minute'],\n\t            mm: ['minut', 'minute', 'minuta'],\n\t            h: ['jedan sat', 'jednog sata'],\n\t            hh: ['sat', 'sata', 'sati'],\n\t            dd: ['dan', 'dana', 'dana'],\n\t            MM: ['mesec', 'meseca', 'meseci'],\n\t            yy: ['godina', 'godine', 'godina']\n\t        },\n\t        correctGrammaticalCase: function (number, wordKey) {\n\t            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n\t        },\n\t        translate: function (number, withoutSuffix, key) {\n\t            var wordKey = translator.words[key];\n\t            if (key.length === 1) {\n\t                return withoutSuffix ? wordKey[0] : wordKey[1];\n\t            } else {\n\t                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);\n\t            }\n\t        }\n\t    };\n\t\n\t    var sr = moment.defineLocale('sr', {\n\t        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),\n\t        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),\n\t        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),\n\t        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat: {\n\t            LT: 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L: 'DD. MM. YYYY',\n\t            LL: 'D. MMMM YYYY',\n\t            LLL: 'D. MMMM YYYY H:mm',\n\t            LLLL: 'dddd, D. MMMM YYYY H:mm'\n\t        },\n\t        calendar: {\n\t            sameDay: '[danas u] LT',\n\t            nextDay: '[sutra u] LT',\n\t            nextWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[u] [nedelju] [u] LT';\n\t                    case 3:\n\t                        return '[u] [sredu] [u] LT';\n\t                    case 6:\n\t                        return '[u] [subotu] [u] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[u] dddd [u] LT';\n\t                }\n\t            },\n\t            lastDay  : '[jue u] LT',\n\t            lastWeek : function () {\n\t                var lastWeekDays = [\n\t                    '[prole] [nedelje] [u] LT',\n\t                    '[prolog] [ponedeljka] [u] LT',\n\t                    '[prolog] [utorka] [u] LT',\n\t                    '[prole] [srede] [u] LT',\n\t                    '[prolog] [etvrtka] [u] LT',\n\t                    '[prolog] [petka] [u] LT',\n\t                    '[prole] [subote] [u] LT'\n\t                ];\n\t                return lastWeekDays[this.day()];\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'za %s',\n\t            past   : 'pre %s',\n\t            s      : 'nekoliko sekundi',\n\t            m      : translator.translate,\n\t            mm     : translator.translate,\n\t            h      : translator.translate,\n\t            hh     : translator.translate,\n\t            d      : 'dan',\n\t            dd     : translator.translate,\n\t            M      : 'mesec',\n\t            MM     : translator.translate,\n\t            y      : 'godinu',\n\t            yy     : translator.translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return sr;\n\t\n\t}));\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Serbian Cyrillic [sr-cyrl]\n\t//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var translator = {\n\t        words: { //Different grammatical cases\n\t            m: [' ', ' '],\n\t            mm: ['', '', ''],\n\t            h: [' ', ' '],\n\t            hh: ['', '', ''],\n\t            dd: ['', '', ''],\n\t            MM: ['', '', ''],\n\t            yy: ['', '', '']\n\t        },\n\t        correctGrammaticalCase: function (number, wordKey) {\n\t            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n\t        },\n\t        translate: function (number, withoutSuffix, key) {\n\t            var wordKey = translator.words[key];\n\t            if (key.length === 1) {\n\t                return withoutSuffix ? wordKey[0] : wordKey[1];\n\t            } else {\n\t                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);\n\t            }\n\t        }\n\t    };\n\t\n\t    var sr_cyrl = moment.defineLocale('sr-cyrl', {\n\t        months: '___________'.split('_'),\n\t        monthsShort: '._._._.____._._._._.'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays: '______'.split('_'),\n\t        weekdaysShort: '._._._._._._.'.split('_'),\n\t        weekdaysMin: '______'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat: {\n\t            LT: 'H:mm',\n\t            LTS : 'H:mm:ss',\n\t            L: 'DD. MM. YYYY',\n\t            LL: 'D. MMMM YYYY',\n\t            LLL: 'D. MMMM YYYY H:mm',\n\t            LLLL: 'dddd, D. MMMM YYYY H:mm'\n\t        },\n\t        calendar: {\n\t            sameDay: '[ ] LT',\n\t            nextDay: '[ ] LT',\n\t            nextWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                        return '[] [] [] LT';\n\t                    case 3:\n\t                        return '[] [] [] LT';\n\t                    case 6:\n\t                        return '[] [] [] LT';\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                    case 5:\n\t                        return '[] dddd [] LT';\n\t                }\n\t            },\n\t            lastDay  : '[ ] LT',\n\t            lastWeek : function () {\n\t                var lastWeekDays = [\n\t                    '[] [] [] LT',\n\t                    '[] [] [] LT',\n\t                    '[] [] [] LT',\n\t                    '[] [] [] LT',\n\t                    '[] [] [] LT',\n\t                    '[] [] [] LT',\n\t                    '[] [] [] LT'\n\t                ];\n\t                return lastWeekDays[this.day()];\n\t            },\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past   : ' %s',\n\t            s      : ' ',\n\t            m      : translator.translate,\n\t            mm     : translator.translate,\n\t            h      : translator.translate,\n\t            hh     : translator.translate,\n\t            d      : '',\n\t            dd     : translator.translate,\n\t            M      : '',\n\t            MM     : translator.translate,\n\t            y      : '',\n\t            yy     : translator.translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return sr_cyrl;\n\t\n\t}));\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Swazi [ss]\n\t//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t\n\t    var ss = moment.defineLocale('ss', {\n\t        months : \"Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni\".split('_'),\n\t        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),\n\t        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),\n\t        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),\n\t        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'h:mm A',\n\t            LTS : 'h:mm:ss A',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY h:mm A',\n\t            LLLL : 'dddd, D MMMM YYYY h:mm A'\n\t        },\n\t        calendar : {\n\t            sameDay : '[Namuhla nga] LT',\n\t            nextDay : '[Kusasa nga] LT',\n\t            nextWeek : 'dddd [nga] LT',\n\t            lastDay : '[Itolo nga] LT',\n\t            lastWeek : 'dddd [leliphelile] [nga] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'nga %s',\n\t            past : 'wenteka nga %s',\n\t            s : 'emizuzwana lomcane',\n\t            m : 'umzuzu',\n\t            mm : '%d emizuzu',\n\t            h : 'lihora',\n\t            hh : '%d emahora',\n\t            d : 'lilanga',\n\t            dd : '%d emalanga',\n\t            M : 'inyanga',\n\t            MM : '%d tinyanga',\n\t            y : 'umnyaka',\n\t            yy : '%d iminyaka'\n\t        },\n\t        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 11) {\n\t                return 'ekuseni';\n\t            } else if (hours < 15) {\n\t                return 'emini';\n\t            } else if (hours < 19) {\n\t                return 'entsambama';\n\t            } else {\n\t                return 'ebusuku';\n\t            }\n\t        },\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === 'ekuseni') {\n\t                return hour;\n\t            } else if (meridiem === 'emini') {\n\t                return hour >= 11 ? hour : hour + 12;\n\t            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {\n\t                if (hour === 0) {\n\t                    return 0;\n\t                }\n\t                return hour + 12;\n\t            }\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ss;\n\t\n\t}));\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Swedish [sv]\n\t//! author : Jens Alm : https://github.com/ulmus\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var sv = moment.defineLocale('sv', {\n\t        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),\n\t        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),\n\t        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n\t        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),\n\t        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'YYYY-MM-DD',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY [kl.] HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',\n\t            lll : 'D MMM YYYY HH:mm',\n\t            llll : 'ddd D MMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Idag] LT',\n\t            nextDay: '[Imorgon] LT',\n\t            lastDay: '[Igr] LT',\n\t            nextWeek: '[P] dddd LT',\n\t            lastWeek: '[I] dddd[s] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'om %s',\n\t            past : 'fr %s sedan',\n\t            s : 'ngra sekunder',\n\t            m : 'en minut',\n\t            mm : '%d minuter',\n\t            h : 'en timme',\n\t            hh : '%d timmar',\n\t            d : 'en dag',\n\t            dd : '%d dagar',\n\t            M : 'en mnad',\n\t            MM : '%d mnader',\n\t            y : 'ett r',\n\t            yy : '%d r'\n\t        },\n\t        ordinalParse: /\\d{1,2}(e|a)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (~~(number % 100 / 10) === 1) ? 'e' :\n\t                (b === 1) ? 'a' :\n\t                (b === 2) ? 'a' :\n\t                (b === 3) ? 'e' : 'e';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return sv;\n\t\n\t}));\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Swahili [sw]\n\t//! author : Fahad Kassim : https://github.com/fadsel\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var sw = moment.defineLocale('sw', {\n\t        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),\n\t        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),\n\t        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),\n\t        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),\n\t        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[leo saa] LT',\n\t            nextDay : '[kesho saa] LT',\n\t            nextWeek : '[wiki ijayo] dddd [saat] LT',\n\t            lastDay : '[jana] LT',\n\t            lastWeek : '[wiki iliyopita] dddd [saat] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s baadaye',\n\t            past : 'tokea %s',\n\t            s : 'hivi punde',\n\t            m : 'dakika moja',\n\t            mm : 'dakika %d',\n\t            h : 'saa limoja',\n\t            hh : 'masaa %d',\n\t            d : 'siku moja',\n\t            dd : 'masiku %d',\n\t            M : 'mwezi mmoja',\n\t            MM : 'miezi %d',\n\t            y : 'mwaka mmoja',\n\t            yy : 'miaka %d'\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return sw;\n\t\n\t}));\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Tamil [ta]\n\t//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var symbolMap = {\n\t        '1': '',\n\t        '2': '',\n\t        '3': '',\n\t        '4': '',\n\t        '5': '',\n\t        '6': '',\n\t        '7': '',\n\t        '8': '',\n\t        '9': '',\n\t        '0': ''\n\t    }, numberMap = {\n\t        '': '1',\n\t        '': '2',\n\t        '': '3',\n\t        '': '4',\n\t        '': '5',\n\t        '': '6',\n\t        '': '7',\n\t        '': '8',\n\t        '': '9',\n\t        '': '0'\n\t    };\n\t\n\t    var ta = moment.defineLocale('ta', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY, HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd, LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[ ] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : '  ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : '  ',\n\t            hh : '%d  ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal : function (number) {\n\t            return number + '';\n\t        },\n\t        preparse: function (string) {\n\t            return string.replace(/[]/g, function (match) {\n\t                return numberMap[match];\n\t            });\n\t        },\n\t        postformat: function (string) {\n\t            return string.replace(/\\d/g, function (match) {\n\t                return symbolMap[match];\n\t            });\n\t        },\n\t        // refer http://ta.wikipedia.org/s/1er1\n\t        meridiemParse: /|||||/,\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 2) {\n\t                return ' ';\n\t            } else if (hour < 6) {\n\t                return ' ';  // \n\t            } else if (hour < 10) {\n\t                return ' '; // \n\t            } else if (hour < 14) {\n\t                return ' '; // \n\t            } else if (hour < 18) {\n\t                return ' '; // \n\t            } else if (hour < 22) {\n\t                return ' '; // \n\t            } else {\n\t                return ' ';\n\t            }\n\t        },\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '') {\n\t                return hour < 2 ? hour : hour + 12;\n\t            } else if (meridiem === '' || meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '') {\n\t                return hour >= 10 ? hour : hour + 12;\n\t            } else {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return ta;\n\t\n\t}));\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Telugu [te]\n\t//! author : Krishna Chaitanya Thota : https://github.com/kcthota\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var te = moment.defineLocale('te', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '._.__.____._._._._.'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'A h:mm',\n\t            LTS : 'A h:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY, A h:mm',\n\t            LLLL : 'dddd, D MMMM YYYY, A h:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[] LT',\n\t            nextDay : '[] LT',\n\t            nextWeek : 'dddd, LT',\n\t            lastDay : '[] LT',\n\t            lastWeek : '[] dddd, LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        ordinalParse : /\\d{1,2}/,\n\t        ordinal : '%d',\n\t        meridiemParse: /|||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '') {\n\t                return hour < 4 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '') {\n\t                return hour >= 10 ? hour : hour + 12;\n\t            } else if (meridiem === '') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 10) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else if (hour < 20) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        week : {\n\t            dow : 0, // Sunday is the first day of the week.\n\t            doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return te;\n\t\n\t}));\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Thai [th]\n\t//! author : Kridsada Thanabulpong : https://github.com/sirn\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var th = moment.defineLocale('th', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),\n\t        monthsParseExact: true,\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'), // yes, three characters difference\n\t        weekdaysMin : '._._._._._._.'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'H  m ',\n\t            LTS : 'H  m  s ',\n\t            L : 'YYYY/MM/DD',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY  H  m ',\n\t            LLLL : 'dddd D MMMM YYYY  H  m '\n\t        },\n\t        meridiemParse: /|/,\n\t        isPM: function (input) {\n\t            return input === '';\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 12) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ] LT',\n\t            nextDay : '[ ] LT',\n\t            nextWeek : 'dddd[ ] LT',\n\t            lastDay : '[ ] LT',\n\t            lastWeek : '[]dddd[ ] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : '%s',\n\t            s : '',\n\t            m : '1 ',\n\t            mm : '%d ',\n\t            h : '1 ',\n\t            hh : '%d ',\n\t            d : '1 ',\n\t            dd : '%d ',\n\t            M : '1 ',\n\t            MM : '%d ',\n\t            y : '1 ',\n\t            yy : '%d '\n\t        }\n\t    });\n\t\n\t    return th;\n\t\n\t}));\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Tagalog (Philippines) [tl-ph]\n\t//! author : Dan Hagman\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var tl_ph = moment.defineLocale('tl-ph', {\n\t        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),\n\t        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),\n\t        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),\n\t        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),\n\t        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'MM/D/YYYY',\n\t            LL : 'MMMM D, YYYY',\n\t            LLL : 'MMMM D, YYYY HH:mm',\n\t            LLLL : 'dddd, MMMM DD, YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Ngayon sa] LT',\n\t            nextDay: '[Bukas sa] LT',\n\t            nextWeek: 'dddd [sa] LT',\n\t            lastDay: '[Kahapon sa] LT',\n\t            lastWeek: 'dddd [huling linggo] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'sa loob ng %s',\n\t            past : '%s ang nakalipas',\n\t            s : 'ilang segundo',\n\t            m : 'isang minuto',\n\t            mm : '%d minuto',\n\t            h : 'isang oras',\n\t            hh : '%d oras',\n\t            d : 'isang araw',\n\t            dd : '%d araw',\n\t            M : 'isang buwan',\n\t            MM : '%d buwan',\n\t            y : 'isang taon',\n\t            yy : '%d taon'\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal : function (number) {\n\t            return number;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return tl_ph;\n\t\n\t}));\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Klingon [tlh]\n\t//! author : Dominika Kruk : https://github.com/amaranthrose\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');\n\t\n\t    function translateFuture(output) {\n\t        var time = output;\n\t        time = (output.indexOf('jaj') !== -1) ?\n\t        time.slice(0, -3) + 'leS' :\n\t        (output.indexOf('jar') !== -1) ?\n\t        time.slice(0, -3) + 'waQ' :\n\t        (output.indexOf('DIS') !== -1) ?\n\t        time.slice(0, -3) + 'nem' :\n\t        time + ' pIq';\n\t        return time;\n\t    }\n\t\n\t    function translatePast(output) {\n\t        var time = output;\n\t        time = (output.indexOf('jaj') !== -1) ?\n\t        time.slice(0, -3) + 'Hu' :\n\t        (output.indexOf('jar') !== -1) ?\n\t        time.slice(0, -3) + 'wen' :\n\t        (output.indexOf('DIS') !== -1) ?\n\t        time.slice(0, -3) + 'ben' :\n\t        time + ' ret';\n\t        return time;\n\t    }\n\t\n\t    function translate(number, withoutSuffix, string, isFuture) {\n\t        var numberNoun = numberAsNoun(number);\n\t        switch (string) {\n\t            case 'mm':\n\t                return numberNoun + ' tup';\n\t            case 'hh':\n\t                return numberNoun + ' rep';\n\t            case 'dd':\n\t                return numberNoun + ' jaj';\n\t            case 'MM':\n\t                return numberNoun + ' jar';\n\t            case 'yy':\n\t                return numberNoun + ' DIS';\n\t        }\n\t    }\n\t\n\t    function numberAsNoun(number) {\n\t        var hundred = Math.floor((number % 1000) / 100),\n\t        ten = Math.floor((number % 100) / 10),\n\t        one = number % 10,\n\t        word = '';\n\t        if (hundred > 0) {\n\t            word += numbersNouns[hundred] + 'vatlh';\n\t        }\n\t        if (ten > 0) {\n\t            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';\n\t        }\n\t        if (one > 0) {\n\t            word += ((word !== '') ? ' ' : '') + numbersNouns[one];\n\t        }\n\t        return (word === '') ? 'pagh' : word;\n\t    }\n\t\n\t    var tlh = moment.defineLocale('tlh', {\n\t        months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),\n\t        monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),\n\t        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),\n\t        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[DaHjaj] LT',\n\t            nextDay: '[waleS] LT',\n\t            nextWeek: 'LLL',\n\t            lastDay: '[waHu] LT',\n\t            lastWeek: 'LLL',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : translateFuture,\n\t            past : translatePast,\n\t            s : 'puS lup',\n\t            m : 'wa tup',\n\t            mm : translate,\n\t            h : 'wa rep',\n\t            hh : translate,\n\t            d : 'wa jaj',\n\t            dd : translate,\n\t            M : 'wa jar',\n\t            MM : translate,\n\t            y : 'wa DIS',\n\t            yy : translate\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return tlh;\n\t\n\t}));\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Turkish [tr]\n\t//! authors : Erhan Gundogan : https://github.com/erhangundogan,\n\t//!           Burak Yiit Kaya: https://github.com/BYK\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var suffixes = {\n\t        1: '\\'inci',\n\t        5: '\\'inci',\n\t        8: '\\'inci',\n\t        70: '\\'inci',\n\t        80: '\\'inci',\n\t        2: '\\'nci',\n\t        7: '\\'nci',\n\t        20: '\\'nci',\n\t        50: '\\'nci',\n\t        3: '\\'nc',\n\t        4: '\\'nc',\n\t        100: '\\'nc',\n\t        6: '\\'nc',\n\t        9: '\\'uncu',\n\t        10: '\\'uncu',\n\t        30: '\\'uncu',\n\t        60: '\\'nc',\n\t        90: '\\'nc'\n\t    };\n\t\n\t    var tr = moment.defineLocale('tr', {\n\t        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),\n\t        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),\n\t        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),\n\t        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),\n\t        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[bugn saat] LT',\n\t            nextDay : '[yarn saat] LT',\n\t            nextWeek : '[haftaya] dddd [saat] LT',\n\t            lastDay : '[dn] LT',\n\t            lastWeek : '[geen hafta] dddd [saat] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s sonra',\n\t            past : '%s nce',\n\t            s : 'birka saniye',\n\t            m : 'bir dakika',\n\t            mm : '%d dakika',\n\t            h : 'bir saat',\n\t            hh : '%d saat',\n\t            d : 'bir gn',\n\t            dd : '%d gn',\n\t            M : 'bir ay',\n\t            MM : '%d ay',\n\t            y : 'bir yl',\n\t            yy : '%d yl'\n\t        },\n\t        ordinalParse: /\\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,\n\t        ordinal : function (number) {\n\t            if (number === 0) {  // special case for zero\n\t                return number + '\\'nc';\n\t            }\n\t            var a = number % 10,\n\t                b = number % 100 - a,\n\t                c = number >= 100 ? 100 : null;\n\t            return number + (suffixes[a] || suffixes[b] || suffixes[c]);\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return tr;\n\t\n\t}));\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Talossan [tzl]\n\t//! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iust Canun\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t\n\t    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.\n\t    // This is currently too difficult (maybe even impossible) to add.\n\t    var tzl = moment.defineLocale('tzl', {\n\t        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),\n\t        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),\n\t        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),\n\t        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),\n\t        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH.mm',\n\t            LTS : 'HH.mm.ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D. MMMM [dallas] YYYY',\n\t            LLL : 'D. MMMM [dallas] YYYY HH.mm',\n\t            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'\n\t        },\n\t        meridiemParse: /d\\'o|d\\'a/i,\n\t        isPM : function (input) {\n\t            return 'd\\'o' === input.toLowerCase();\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours > 11) {\n\t                return isLower ? 'd\\'o' : 'D\\'O';\n\t            } else {\n\t                return isLower ? 'd\\'a' : 'D\\'A';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[oxhi ] LT',\n\t            nextDay : '[dem ] LT',\n\t            nextWeek : 'dddd [] LT',\n\t            lastDay : '[ieiri ] LT',\n\t            lastWeek : '[sr el] dddd [lasteu ] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'osprei %s',\n\t            past : 'ja%s',\n\t            s : processRelativeTime,\n\t            m : processRelativeTime,\n\t            mm : processRelativeTime,\n\t            h : processRelativeTime,\n\t            hh : processRelativeTime,\n\t            d : processRelativeTime,\n\t            dd : processRelativeTime,\n\t            M : processRelativeTime,\n\t            MM : processRelativeTime,\n\t            y : processRelativeTime,\n\t            yy : processRelativeTime\n\t        },\n\t        ordinalParse: /\\d{1,2}\\./,\n\t        ordinal : '%d.',\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n\t        var format = {\n\t            's': ['viensas secunds', '\\'iensas secunds'],\n\t            'm': ['\\'n mut', '\\'iens mut'],\n\t            'mm': [number + ' muts', '' + number + ' muts'],\n\t            'h': ['\\'n ora', '\\'iensa ora'],\n\t            'hh': [number + ' oras', '' + number + ' oras'],\n\t            'd': ['\\'n ziua', '\\'iensa ziua'],\n\t            'dd': [number + ' ziuas', '' + number + ' ziuas'],\n\t            'M': ['\\'n mes', '\\'iens mes'],\n\t            'MM': [number + ' mesen', '' + number + ' mesen'],\n\t            'y': ['\\'n ar', '\\'iens ar'],\n\t            'yy': [number + ' ars', '' + number + ' ars']\n\t        };\n\t        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);\n\t    }\n\t\n\t    return tzl;\n\t\n\t}));\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Central Atlas Tamazight [tzm]\n\t//! author : Abdel Said : https://github.com/abdelsaid\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var tzm = moment.defineLocale('tzm', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS: 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[ ] LT',\n\t            nextDay: '[ ] LT',\n\t            nextWeek: 'dddd [] LT',\n\t            lastDay: '[ ] LT',\n\t            lastWeek: 'dddd [] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '   %s',\n\t            past : ' %s',\n\t            s : '',\n\t            m : '',\n\t            mm : '%d ',\n\t            h : '',\n\t            hh : '%d ',\n\t            d : '',\n\t            dd : '%d o',\n\t            M : 'o',\n\t            MM : '%d ',\n\t            y : '',\n\t            yy : '%d '\n\t        },\n\t        week : {\n\t            dow : 6, // Saturday is the first day of the week.\n\t            doy : 12  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return tzm;\n\t\n\t}));\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Central Atlas Tamazight Latin [tzm-latn]\n\t//! author : Abdel Said : https://github.com/abdelsaid\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var tzm_latn = moment.defineLocale('tzm-latn', {\n\t        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),\n\t        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),\n\t        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n\t        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n\t        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[asdkh g] LT',\n\t            nextDay: '[aska g] LT',\n\t            nextWeek: 'dddd [g] LT',\n\t            lastDay: '[assant g] LT',\n\t            lastWeek: 'dddd [g] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : 'dadkh s yan %s',\n\t            past : 'yan %s',\n\t            s : 'imik',\n\t            m : 'minu',\n\t            mm : '%d minu',\n\t            h : 'saa',\n\t            hh : '%d tassain',\n\t            d : 'ass',\n\t            dd : '%d ossan',\n\t            M : 'ayowr',\n\t            MM : '%d iyyirn',\n\t            y : 'asgas',\n\t            yy : '%d isgasn'\n\t        },\n\t        week : {\n\t            dow : 6, // Saturday is the first day of the week.\n\t            doy : 12  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return tzm_latn;\n\t\n\t}));\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Ukrainian [uk]\n\t//! author : zemlanin : https://github.com/zemlanin\n\t//! Author : Menelion Elensle : https://github.com/Oire\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    function plural(word, num) {\n\t        var forms = word.split('_');\n\t        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n\t    }\n\t    function relativeTimeWithPlural(number, withoutSuffix, key) {\n\t        var format = {\n\t            'mm': withoutSuffix ? '__' : '__',\n\t            'hh': withoutSuffix ? '__' : '__',\n\t            'dd': '__',\n\t            'MM': '__',\n\t            'yy': '__'\n\t        };\n\t        if (key === 'm') {\n\t            return withoutSuffix ? '' : '';\n\t        }\n\t        else if (key === 'h') {\n\t            return withoutSuffix ? '' : '';\n\t        }\n\t        else {\n\t            return number + ' ' + plural(format[key], +number);\n\t        }\n\t    }\n\t    function weekdaysCaseReplace(m, format) {\n\t        var weekdays = {\n\t            'nominative': '______'.split('_'),\n\t            'accusative': '______'.split('_'),\n\t            'genitive': '______'.split('_')\n\t        },\n\t        nounCase = (/(\\[[]\\]) ?dddd/).test(format) ?\n\t            'accusative' :\n\t            ((/\\[?(?:|)? ?\\] ?dddd/).test(format) ?\n\t                'genitive' :\n\t                'nominative');\n\t        return weekdays[nounCase][m.day()];\n\t    }\n\t    function processHoursFunction(str) {\n\t        return function () {\n\t            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';\n\t        };\n\t    }\n\t\n\t    var uk = moment.defineLocale('uk', {\n\t        months : {\n\t            'format': '___________'.split('_'),\n\t            'standalone': '___________'.split('_')\n\t        },\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : weekdaysCaseReplace,\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD.MM.YYYY',\n\t            LL : 'D MMMM YYYY .',\n\t            LLL : 'D MMMM YYYY ., HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: processHoursFunction('[ '),\n\t            nextDay: processHoursFunction('[ '),\n\t            lastDay: processHoursFunction('[ '),\n\t            nextWeek: processHoursFunction('[] dddd ['),\n\t            lastWeek: function () {\n\t                switch (this.day()) {\n\t                    case 0:\n\t                    case 3:\n\t                    case 5:\n\t                    case 6:\n\t                        return processHoursFunction('[] dddd [').call(this);\n\t                    case 1:\n\t                    case 2:\n\t                    case 4:\n\t                        return processHoursFunction('[] dddd [').call(this);\n\t                }\n\t            },\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s',\n\t            past : '%s ',\n\t            s : ' ',\n\t            m : relativeTimeWithPlural,\n\t            mm : relativeTimeWithPlural,\n\t            h : '',\n\t            hh : relativeTimeWithPlural,\n\t            d : '',\n\t            dd : relativeTimeWithPlural,\n\t            M : '',\n\t            MM : relativeTimeWithPlural,\n\t            y : '',\n\t            yy : relativeTimeWithPlural\n\t        },\n\t        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason\n\t        meridiemParse: /|||/,\n\t        isPM: function (input) {\n\t            return /^(|)$/.test(input);\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            if (hour < 4) {\n\t                return '';\n\t            } else if (hour < 12) {\n\t                return '';\n\t            } else if (hour < 17) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        ordinalParse: /\\d{1,2}-(|)/,\n\t        ordinal: function (number, period) {\n\t            switch (period) {\n\t                case 'M':\n\t                case 'd':\n\t                case 'DDD':\n\t                case 'w':\n\t                case 'W':\n\t                    return number + '-';\n\t                case 'D':\n\t                    return number + '-';\n\t                default:\n\t                    return number;\n\t            }\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 1st is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return uk;\n\t\n\t}));\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Uzbek [uz]\n\t//! author : Sardor Muminov : https://github.com/muminoff\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var uz = moment.defineLocale('uz', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '___________'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'D MMMM YYYY, dddd HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[ ] LT []',\n\t            nextDay : '[] LT []',\n\t            nextWeek : 'dddd [ ] LT []',\n\t            lastDay : '[ ] LT []',\n\t            lastWeek : '[] dddd [ ] LT []',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : ' %s ',\n\t            past : '  %s ',\n\t            s : '',\n\t            m : ' ',\n\t            mm : '%d ',\n\t            h : ' ',\n\t            hh : '%d ',\n\t            d : ' ',\n\t            dd : '%d ',\n\t            M : ' ',\n\t            MM : '%d ',\n\t            y : ' ',\n\t            yy : '%d '\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 7  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return uz;\n\t\n\t}));\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Vietnamese [vi]\n\t//! author : Bang Nguyen : https://github.com/bangnk\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var vi = moment.defineLocale('vi', {\n\t        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),\n\t        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),\n\t        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),\n\t        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),\n\t        weekdaysParseExact : true,\n\t        meridiemParse: /sa|ch/i,\n\t        isPM : function (input) {\n\t            return /^ch$/i.test(input);\n\t        },\n\t        meridiem : function (hours, minutes, isLower) {\n\t            if (hours < 12) {\n\t                return isLower ? 'sa' : 'SA';\n\t            } else {\n\t                return isLower ? 'ch' : 'CH';\n\t            }\n\t        },\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            LTS : 'HH:mm:ss',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM [nm] YYYY',\n\t            LLL : 'D MMMM [nm] YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',\n\t            l : 'DD/M/YYYY',\n\t            ll : 'D MMM YYYY',\n\t            lll : 'D MMM YYYY HH:mm',\n\t            llll : 'ddd, D MMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay: '[Hm nay lc] LT',\n\t            nextDay: '[Ngy mai lc] LT',\n\t            nextWeek: 'dddd [tun ti lc] LT',\n\t            lastDay: '[Hm qua lc] LT',\n\t            lastWeek: 'dddd [tun ri lc] LT',\n\t            sameElse: 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '%s ti',\n\t            past : '%s trc',\n\t            s : 'vi giy',\n\t            m : 'mt pht',\n\t            mm : '%d pht',\n\t            h : 'mt gi',\n\t            hh : '%d gi',\n\t            d : 'mt ngy',\n\t            dd : '%d ngy',\n\t            M : 'mt thng',\n\t            MM : '%d thng',\n\t            y : 'mt nm',\n\t            yy : '%d nm'\n\t        },\n\t        ordinalParse: /\\d{1,2}/,\n\t        ordinal : function (number) {\n\t            return number;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return vi;\n\t\n\t}));\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Pseudo [x-pseudo]\n\t//! author : Andrew Hood : https://github.com/andrewhood125\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var x_pseudo = moment.defineLocale('x-pseudo', {\n\t        months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),\n\t        monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),\n\t        monthsParseExact : true,\n\t        weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),\n\t        weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),\n\t        weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),\n\t        weekdaysParseExact : true,\n\t        longDateFormat : {\n\t            LT : 'HH:mm',\n\t            L : 'DD/MM/YYYY',\n\t            LL : 'D MMMM YYYY',\n\t            LLL : 'D MMMM YYYY HH:mm',\n\t            LLLL : 'dddd, D MMMM YYYY HH:mm'\n\t        },\n\t        calendar : {\n\t            sameDay : '[T~d~ t] LT',\n\t            nextDay : '[T~m~rr~w t] LT',\n\t            nextWeek : 'dddd [t] LT',\n\t            lastDay : '[~st~rd~ t] LT',\n\t            lastWeek : '[L~st] dddd [t] LT',\n\t            sameElse : 'L'\n\t        },\n\t        relativeTime : {\n\t            future : '~ %s',\n\t            past : '%s ~g',\n\t            s : ' ~fw ~sc~ds',\n\t            m : ' ~m~t',\n\t            mm : '%d m~~ts',\n\t            h : '~ h~r',\n\t            hh : '%d h~rs',\n\t            d : ' ~d',\n\t            dd : '%d d~s',\n\t            M : ' ~m~th',\n\t            MM : '%d m~t~hs',\n\t            y : ' ~r',\n\t            yy : '%d ~rs'\n\t        },\n\t        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (~~(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        },\n\t        week : {\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return x_pseudo;\n\t\n\t}));\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Chinese (China) [zh-cn]\n\t//! author : suupic : https://github.com/suupic\n\t//! author : Zeno Zeng : https://github.com/zenozeng\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var zh_cn = moment.defineLocale('zh-cn', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'Ahmm',\n\t            LTS : 'Ahms',\n\t            L : 'YYYY-MM-DD',\n\t            LL : 'YYYYMMMD',\n\t            LLL : 'YYYYMMMDAhmm',\n\t            LLLL : 'YYYYMMMDddddAhmm',\n\t            l : 'YYYY-MM-DD',\n\t            ll : 'YYYYMMMD',\n\t            lll : 'YYYYMMMDAhmm',\n\t            llll : 'YYYYMMMDddddAhmm'\n\t        },\n\t        meridiemParse: /|||||/,\n\t        meridiemHour: function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '' || meridiem === '' ||\n\t                    meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '' || meridiem === '') {\n\t                return hour + 12;\n\t            } else {\n\t                // ''\n\t                return hour >= 11 ? hour : hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            var hm = hour * 100 + minute;\n\t            if (hm < 600) {\n\t                return '';\n\t            } else if (hm < 900) {\n\t                return '';\n\t            } else if (hm < 1130) {\n\t                return '';\n\t            } else if (hm < 1230) {\n\t                return '';\n\t            } else if (hm < 1800) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : function () {\n\t                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';\n\t            },\n\t            nextDay : function () {\n\t                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';\n\t            },\n\t            lastDay : function () {\n\t                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';\n\t            },\n\t            nextWeek : function () {\n\t                var startOfWeek, prefix;\n\t                startOfWeek = moment().startOf('week');\n\t                prefix = this.diff(startOfWeek, 'days') >= 7 ? '[]' : '[]';\n\t                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';\n\t            },\n\t            lastWeek : function () {\n\t                var startOfWeek, prefix;\n\t                startOfWeek = moment().startOf('week');\n\t                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';\n\t                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';\n\t            },\n\t            sameElse : 'LL'\n\t        },\n\t        ordinalParse: /\\d{1,2}(||)/,\n\t        ordinal : function (number, period) {\n\t            switch (period) {\n\t                case 'd':\n\t                case 'D':\n\t                case 'DDD':\n\t                    return number + '';\n\t                case 'M':\n\t                    return number + '';\n\t                case 'w':\n\t                case 'W':\n\t                    return number + '';\n\t                default:\n\t                    return number;\n\t            }\n\t        },\n\t        relativeTime : {\n\t            future : '%s',\n\t            past : '%s',\n\t            s : '',\n\t            m : '1 ',\n\t            mm : '%d ',\n\t            h : '1 ',\n\t            hh : '%d ',\n\t            d : '1 ',\n\t            dd : '%d ',\n\t            M : '1 ',\n\t            MM : '%d ',\n\t            y : '1 ',\n\t            yy : '%d '\n\t        },\n\t        week : {\n\t            // GB/T 7408-1994ISO 8601:1988\n\t            dow : 1, // Monday is the first day of the week.\n\t            doy : 4  // The week that contains Jan 4th is the first week of the year.\n\t        }\n\t    });\n\t\n\t    return zh_cn;\n\t\n\t}));\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! moment.js locale configuration\n\t//! locale : Chinese (Taiwan) [zh-tw]\n\t//! author : Ben : https://github.com/ben-lin\n\t//! author : Chris Lam : https://github.com/hehachris\n\t\n\t;(function (global, factory) {\n\t    true ? factory(__webpack_require__(2)) :\n\t   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n\t   factory(global.moment)\n\t}(this, function (moment) { 'use strict';\n\t\n\t\n\t    var zh_tw = moment.defineLocale('zh-tw', {\n\t        months : '___________'.split('_'),\n\t        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n\t        weekdays : '______'.split('_'),\n\t        weekdaysShort : '______'.split('_'),\n\t        weekdaysMin : '______'.split('_'),\n\t        longDateFormat : {\n\t            LT : 'Ahmm',\n\t            LTS : 'Ahms',\n\t            L : 'YYYYMMMD',\n\t            LL : 'YYYYMMMD',\n\t            LLL : 'YYYYMMMDAhmm',\n\t            LLLL : 'YYYYMMMDddddAhmm',\n\t            l : 'YYYYMMMD',\n\t            ll : 'YYYYMMMD',\n\t            lll : 'YYYYMMMDAhmm',\n\t            llll : 'YYYYMMMDddddAhmm'\n\t        },\n\t        meridiemParse: /|||||/,\n\t        meridiemHour : function (hour, meridiem) {\n\t            if (hour === 12) {\n\t                hour = 0;\n\t            }\n\t            if (meridiem === '' || meridiem === '' || meridiem === '') {\n\t                return hour;\n\t            } else if (meridiem === '') {\n\t                return hour >= 11 ? hour : hour + 12;\n\t            } else if (meridiem === '' || meridiem === '') {\n\t                return hour + 12;\n\t            }\n\t        },\n\t        meridiem : function (hour, minute, isLower) {\n\t            var hm = hour * 100 + minute;\n\t            if (hm < 600) {\n\t                return '';\n\t            } else if (hm < 900) {\n\t                return '';\n\t            } else if (hm < 1130) {\n\t                return '';\n\t            } else if (hm < 1230) {\n\t                return '';\n\t            } else if (hm < 1800) {\n\t                return '';\n\t            } else {\n\t                return '';\n\t            }\n\t        },\n\t        calendar : {\n\t            sameDay : '[]LT',\n\t            nextDay : '[]LT',\n\t            nextWeek : '[]ddddLT',\n\t            lastDay : '[]LT',\n\t            lastWeek : '[]ddddLT',\n\t            sameElse : 'L'\n\t        },\n\t        ordinalParse: /\\d{1,2}(||)/,\n\t        ordinal : function (number, period) {\n\t            switch (period) {\n\t                case 'd' :\n\t                case 'D' :\n\t                case 'DDD' :\n\t                    return number + '';\n\t                case 'M' :\n\t                    return number + '';\n\t                case 'w' :\n\t                case 'W' :\n\t                    return number + '';\n\t                default :\n\t                    return number;\n\t            }\n\t        },\n\t        relativeTime : {\n\t            future : '%s',\n\t            past : '%s',\n\t            s : '',\n\t            m : '1 ',\n\t            mm : '%d ',\n\t            h : '1 ',\n\t            hh : '%d ',\n\t            d : '1 ',\n\t            dd : '%d ',\n\t            M : '1 ',\n\t            MM : '%d ',\n\t            y : '1 ',\n\t            yy : '%d '\n\t        }\n\t    });\n\t\n\t    return zh_tw;\n\t\n\t}));\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=\"rc-panel rc-timeline-item transition-in\">\n        <div class=rc-timeline-item__content>\n            <div class=rc-timeline-item__info>\n                <div class=left>\n                    <span class=rc-timeline-item__icon data-info=icon></span>\n                </div>\n                <div class=right>\n                    <div class=\"rc-timeline-item__count display-none\" data-info=count-wrapper>\n                        <span class=__number data-info=count></span>\n                        <span class=icon-uni2466></span>\n                    </div>\n                    <div class=rc-timeline-item__line>\n                        <span class=rc-timeline-item__contact data-info=contact></span>\n                    </div>\n                    <div class=rc-timeline-item__time data-info=time></div>\n                </div>\n            </div>\n            <div class=rc-timeline-item__subject data-info=subject></div>\n        </div>\n        \n        <div data-info=collapse class=rc-timeline-item__collapse>\n        </div>\n    </div>\n","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-timeline-item {\n    overflow: hidden;\n    cursor: pointer;\n    background: #fff;\n    border-bottom: 1px solid #eee;\n    -webkit-transition: opacity, -webkit-transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n    transition: opacity, -webkit-transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n    transition: opacity, transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n    transition: opacity, transform .350s cubic-bezier(0.0, 0.0, 0.2, 1), -webkit-transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n}\n.rc-timeline-item .timeline-extra {}\n.rc-timeline-item .timeline-extra__content {}\n.rc-timeline-item .timeline-extra:hover {\n    background-color: #eee;\n}\n.rc-timeline-item__info {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.rc-timeline-item__info .left {}\n.rc-timeline-item__info .right {\n    margin-left: 10px;\n}\n.rc-timeline-item__line {}\n.rc-timeline-item__icon {\n    line-height: 2;\n}\n.rc-timeline-item__contact {\n    color: #286090;\n    font-size: .9em;\n}\n.rc-timeline-item__time {\n    font-size: .7em;\n    color: #999;\n}\n.rc-timeline-item__subject {\n    font-size: .8em;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    margin-top: 10px;\n}\n.rc-timeline-item__count {\n    padding: .5em .7em;\n    position: absolute;\n    top: 0;\n    right: 0;\n    font-size: .8em;\n}\n.rc-timeline-item__count > .__number {\n    color: $timeline-gray;\n}\n.rc-timeline-item__count:hover > .__number {\n    color: #000;\n}\n.rc-timeline-item__content {\n    padding: .5em .7em;\n    position: relative;\n}\n.rc-timeline-item__collapse {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    height: 0;\n    overflow: hidden;\n    -webkit-transition: height .350s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: height .350s cubic-bezier(0.4, 0.0, 0.2, 1);\n}\n.rc-timeline-item__collapse > .timeline-extra {\n    padding: .5em .7em;\n    font-size: .8em;\n}\n.rc-timeline-item:hover {\n    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n    background-color: #fafafa;\n}\n    \n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['time-line'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction transition(t) {\n\t  var e = t.trans,\n\t      r = t.layerHozTrans,\n\t      n = t.layerVerticalTrans,\n\t      o = (t.initPosition, t.transitionStart),\n\t      i = t.transitionTo,\n\t      s = t.createLayer;return function (t) {\n\t    var a = (t.srcScene, t.targetScene),\n\t        l = t.srcDOM,\n\t        c = t.targetDOM,\n\t        d = t.transitionEnd;a && (a.style.display = \"block\");var h = l.getBoundingClientRect(),\n\t        p = c.getBoundingClientRect(),\n\t        f = { width: l.offsetWidth, height: l.offsetHeight, left: h.left, top: h.top },\n\t        u = { width: c.offsetWidth, height: c.offsetHeight, left: p.left, top: p.top },\n\t        y = s({ src: f, target: u }),\n\t        g = _slicedToArray(y, 2),\n\t        m = g[0],\n\t        v = g[1],\n\t        w = div(m, { overflow: \"hidden\" }),\n\t        x = div(v, { position: \"fixed\" }),\n\t        M = div(f, { position: \"static\" });console.log(window.getComputedStyle(l).marginTop), M.style.marginBottom = window.getComputedStyle(l).marginBottom, M.style.marginTop = window.getComputedStyle(l).marginTop;var C = { src: l, target: c, layerHoz: w, layerVertical: x };a && (a.style.display = \"none\"), document.body.appendChild(x), l.parentNode.insertBefore(M, l), x.appendChild(w), w.appendChild(l), l.style.transition = e, w.style.transition = r, x.style.transition = n, o({ src: f, target: u, layerHoz: m, layerVertical: v, dom: C });var T = function T() {\n\t      a && (a.style.display = \"block\"), x.parentNode.removeChild(x), M.parentNode.removeChild(M), d();\n\t    };setTimeout(function () {\n\t      return i(T, { src: f, target: u, layerHoz: m, layerVertical: v, dom: C });\n\t    }, 17);\n\t  };\n\t}function div(t, e) {\n\t  var r = e.overflow,\n\t      n = void 0 === r ? \"inherite\" : r,\n\t      o = e.position,\n\t      i = void 0 === o ? \"absolute\" : o,\n\t      s = document.createElement(\"div\");return s.style.width = t.width + \"px\", s.style.height = t.height + \"px\", s.style.left = t.left + \"px\", s.style.top = t.top + \"px\", s.style.position = i, s.style.overflow = n, s;\n\t}var _slicedToArray = function () {\n\t  function t(t, e) {\n\t    var r = [],\n\t        n = !0,\n\t        o = !1,\n\t        i = void 0;try {\n\t      for (var s, a = t[Symbol.iterator](); !(n = (s = a.next()).done) && (r.push(s.value), !e || r.length !== e); n = !0) {}\n\t    } catch (t) {\n\t      o = !0, i = t;\n\t    } finally {\n\t      try {\n\t        !n && a.return && a.return();\n\t      } finally {\n\t        if (o) throw i;\n\t      }\n\t    }return r;\n\t  }return function (e, r) {\n\t    if (Array.isArray(e)) return e;if (Symbol.iterator in Object(e)) return t(e, r);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t  };\n\t}(),\n\t    _extends = Object.assign || function (t) {\n\t  for (var e = 1; e < arguments.length; e++) {\n\t    var r = arguments[e];for (var n in r) {\n\t      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n\t    }\n\t  }return t;\n\t};w.register(function () {\n\t  var t = [];this.data = {}, this.actions = { init: { after: function after() {\n\t        this.props.mounted = !1, this.props.latestMessage = null;\n\t      } }, mount: { after: function after() {\n\t        this.props.mounted || (this.fetchData(), this.props.mounted = !0);\n\t      } }, fetchData: { method: function method(t) {\n\t        return t();\n\t      }, after: function after(t) {\n\t        var e = this;this.dom.loading.classList.add(\"display-none\"), t && t[0] && (this.props.latestMessage = t[0], t.filter(function (t) {\n\t          return \"Outgoing Fax\" !== t.subject;\n\t        }).forEach(function (t, r) {\n\t          return e.addLine(t, !1, 30 * r);\n\t        }));\n\t      } }, updateTimeline: { after: function after(e) {\n\t        var r = this;console.log(e), e.filter(function (e) {\n\t          return t.indexOf(e.id) === -1;\n\t        }).forEach(function (e) {\n\t          r.props.latestMessage && r.props.latestMessage.type === e.type && r.props.latestMessage.contact.id === e.contact.id && (r.props.latestMessage.others = r.props.latestMessage.others || [], e.others = e.others || [], e.others.push(r.props.latestMessage), e.others = e.others.concat(r.props.latestMessage.others), r.props.latestMessage.widget.unmount()), r.addLine(e, !0), r.props.latestMessage = e, t.push(e.id);\n\t        });\n\t      } }, addLine: { after: function after(t, e, r) {\n\t        var n = this,\n\t            o = w(\"time-line-item\", { data: _extends({}, t, { showingDelay: r }), actions: { enter: { after: function after() {\n\t                var t = this;n.props.selectedContent = this.props.selectedMessage || this.props.content, console.log(this.root.firstChild);var e = this.root.firstChild;enlarge({ srcDOM: e, targetDOM: n.dom.content, transitionEnd: function transitionEnd() {\n\t                    n.enterItem(), t.root.appendChild(e), e.style.width = \"auto\", e.style.height = \"auto\";\n\t                  } });\n\t              } } } });t.widget = o, o.mount(this.dom.timeline, e);\n\t      } }, search: { method: function method(t) {\n\t        return t();\n\t      } }, focusSearchBox: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {} }, blurSearchBox: { method: function method(t) {\n\t        return t();\n\t      }, after: function after() {} }, switchContent: { method: function method() {}, after: function after() {} }, enterItem: { method: function method() {}, after: function after() {} } };\n\t});var enlarge = transition({ trans: \"all .3s cubic-bezier(0.4, 0.0, 0.2, 1)\", layerHozTrans: \"all .375s ease-in\", layerVerticalTrans: \"all .375s ease-out\", transitionStart: function transitionStart(t) {\n\t    var e = t.src,\n\t        r = (t.target, t.layerHoz),\n\t        n = t.layerVertical,\n\t        o = t.dom,\n\t        i = o.src;i.style.width = e.width + \"px\", i.style.height = e.height + \"px\", i.style.left = e.left - r.left + \"px\", i.style.top = e.top - n.top + \"px\";\n\t  }, transitionTo: function transitionTo(t, e) {\n\t    var r = (e.src, e.target),\n\t        n = e.layerHoz,\n\t        o = (e.layerVertical, e.dom),\n\t        i = o.src;setTimeout(function () {\n\t      var e = 0;i.style.height = n.height + \"px\", i.style.top = \"0px\", i.addEventListener(\"transitionend\", function r(n) {\n\t        ++e >= 3 && (t(), i.removeEventListener(\"transitionend\", r));\n\t      });\n\t    }, 30), i.style.width = n.width + \"px\", i.style.left = \"0px\", o.layerHoz.style.left = r.left + \"px\", o.layerVertical.style.top = r.top + \"px\";\n\t  }, createLayer: function createLayer(t) {\n\t    var e = t.src,\n\t        r = t.target;return [{ width: r.width, height: r.height, left: r.left, top: 0 }, { width: r.width, height: r.height, left: 0, top: e.top }];\n\t  } });\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"\n    <div class=\"rc-panel rc-timeline\">\n        <div class=\"rc-panel__content rc-panel__content--full\" data-info=content>\n            <div class=rc-timeline__loading data-info=loading>Loading ...</div>\n            <div class=rc-timeline__list data-info=timeline>\n                \n            </div>\n            <div class=\"rc-timeline__mask display-none\" data-info=mask></div>\n        </div>\n    </div>\n","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-timeline > .rc-panel__content {\n    overflow: auto;\n}\n.rc-timeline__list {}\n.rc-timeline__mask {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n}\n.rc-timeline__loading {\n    padding: .9em 1.1em;\n    color: #878787;\n    text-align: center;\n}\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
__w_widgets['tool-bar'] = {"script":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tw.register(function () {\n\t  var t = w.transition(\"slide-down\");this.props = { itemCount: 0 }, this.actions = { init: { method: function method() {\n\t        this.state = [], this.itemCount = 0;\n\t      } }, mount: { after: function after() {\n\t        var n = this;t.init(this.dom.menu), window.addEventListener(\"click\", function (t) {\n\t          n.hideMenu();\n\t        }, !1), this.root.addEventListener(\"click\", function (t) {\n\t          t.stopPropagation();\n\t        });\n\t      } }, adjustMenuButton: { after: function after() {\n\t        Array.from(this.dom.toolbar.childNodes).forEach(function (t) {\n\t          3 === t.nodeType && t.parentNode.removeChild(t);\n\t        });var t = Math.floor((Array.from(this.dom.toolbar.childNodes).length - 1) / 2) + 1,\n\t            n = this.dom.toolbar.childNodes[t];n.parentNode.insertBefore(this.dom[\"menu-button\"], n);\n\t      } }, addItem: { method: function method() {}, after: function after(t, n, o) {\n\t        var e,\n\t            i = document.createElement(\"div\");if (this.itemCount >= 4) {\n\t          var s = \"<div class='rc-toolbar__more-item text-center'>\\n                                        <button class='rc-button rc-button--circle'>\\n                                            \" + t + \"\\n                                        </button>\\n                                        <div>\" + n + \"</div>\\n                                    </div>\";i.innerHTML = s, e = i.childNodes[0], this.dom.menu.appendChild(e);\n\t        } else {\n\t          var s = \"<button class='rc-toolbar__item rc-button rc-button--ghost rc-icon-switch'>\\n                                        \" + t + \"\\n                                    </button>\";i.innerHTML = s, e = i.childNodes[0], this.dom.toolbar.appendChild(e);\n\t        }return this.adjustMenuButton(), ++this.itemCount, this.props.itemCount = this.itemCount, e;\n\t      } }, clickItem: { method: function method(t, n, o) {\n\t        var e = this;\"number\" == typeof n || n.addEventListener(\"click\", function () {\n\t          o.call(e), e.hideMenu(), e.state.push(o);\n\t        });\n\t      } }, pop: { method: function method() {\n\t        console.log(this.state), this.state.length > 1 && (this.state.pop(), this.state[this.state.length - 1].call(this));\n\t      } }, toggleMenu: { after: function after() {\n\t        t.toggle(this.dom.menu);\n\t      } }, hideMenu: { after: function after() {\n\t        t.out(this.dom.menu);\n\t      } }, disableMenu: { after: function after() {\n\t        this.dom[\"menu-button\"].classList.add(\"display-none\");\n\t      } } }, this.on(\"click\", \"menu-button\", function (t) {\n\t    this.props.itemCount > 4 && this.toggleMenu();\n\t  });\n\t});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map","template":"<div class=rc-toolbar>\n    <div class=\"rc-toolbar__bar text-center\" data-info=toolbar>\n        <button class=\"rc-button rc-toolbar__menu-button\" data-info=menu-button data-event=click:toggleMenu>\n            <span class=icon-ActionButtons_down></span>\n        </button>\n    </div>\n    <div class=rc-toolbar__panel data-info=menu>\n    </div>\n</div>","style":"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-toolbar {\n    /* used as a positioned reference */\n    position: relative;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    z-index: 1;\n    height: 100%\n}\n.rc-toolbar__bar {\n    /* used as a positioned reference */\n    position: relative;\n    height: 100%;\n    z-index: 1;\n    background-color: #fafafa\n}\n.rc-toolbar__menu-button {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    position: relative;\n    z-index: 1;\n    background-color: #fafafa;\n    border: 0;\n    border-left: 1px solid #bdc3c7;\n    border-right: 1px solid #bdc3c7;\n    border-bottom: 1px solid #bdc3c7;\n    height: calc(25px + 20px);\n    margin-bottom: -20px\n}\n.rc-toolbar__panel {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-wrap: wrap;\n    flex-wrap: wrap;\n    -ms-flex-pack: distribute;\n    justify-content: space-around;\n    position: absolute;\n    width: 100%;\n    min-height: 100px;\n    background-color: #fff\n}\n.rc-toolbar__item {\n    background-color: transparent\n}\n.rc-toolbar__item:hover {\n    background-color: transparent;\n    color: #333\n}\n.rc-toolbar__more-item {\n    font-size: .6em;\n    margin: 5px;\n}\n.rc-toolbar__more-item > .rc-button {\n    font-size: 1.8em;\n    width: 45px;\n    height: 45px\n}\n.rc-toolbar__more-item:hover {\n    color: #333\n}\n\n","imports":{"scripts":[],"styles":[]},"options":{"scopedStyle":false}};
