__w_widgets = {};__w_widgets["auth-panel"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  function t() {\n	    this.dom["country-list"].classList.toggle("display-none");\n	  }function o(t) {\n	    this.dom["country-dropdown"].textContent = t, this.dom["country-list"].classList.add("display-none"), this.props.country = t;\n	  }var s = w.transition("fade");this.props = { country: "United States", username: null, extension: null, password: null, oauth: !1 }, this.actions = { init: { before: function before() {\n	        this.data.oauth && (this.props.oauth = this.data.oauth);\n	      }, method: function method(t) {\n	        t();\n	      }, after: function after() {\n	        var t = (w.t(this.data.lang), this.data),\n	            o = (t.color, t.lang, t.logo);this.dom.logo.src = o || "./ringcentral_logo.png", this.props.oauth && (this.dom["user-info"].classList.add("display-none"), this.dom["remember-wrapper"].classList.add("display-none"));\n	      } }, mount: { before: function before() {}, after: function after() {\n	        this.dom.username.value = localStorage.getItem("username"), this.dom.extension.value = localStorage.getItem("extension"), this.dom.password.value = localStorage.getItem("password"), this.data.external ? (this.dom["login-button"].classList.add("display-none"), this.dom["user-info"].classList.add("display-none")) : this.dom["external-login-button"].classList.add("display-none"), s["in"](this.root);\n	      } }, login: { before: function before() {\n	        this.dom["login-button"].disabled = !0, this.dom.error.textContent = "", this.dom["disabled-mask"].classList.remove("display-none"), this.dom.container.classList.add("blur");\n	      }, method: function method(t) {\n	        return this.props.username = this.dom.username.value, this.props.extension = this.dom.extension.value, this.props.password = this.dom.password.value, t();\n	      }, after: function after() {\n	        this.dom["login-button"].disabled = !1, this.dom["disabled-mask"].classList.add("display-none"), this.dom.container.classList.remove("blur"), this.dom.remember.checked && (localStorage.setItem("username", this.dom.username.value || ""), localStorage.setItem("extension", this.dom.extension.value || ""), localStorage.setItem("password", this.dom.password.value || ""));\n	      }, error: function error(t) {\n	        this.dom.error.textContent = t.message || t, this.dom["disabled-mask"].classList.add("display-none"), this.dom.container.classList.remove("blur"), this.dom["login-button"].disabled = !1;\n	      } }, externalLogin: { before: function before() {\n	        this.dom["login-button"].disabled = !0, this.dom.error.textContent = "", this.dom["login-button"].classList.add("rc-button-loading");\n	      }, method: function method(t) {\n	        return t();\n	      }, after: function after() {}, error: function error(t) {\n	        console.error(t), this.dom.error.textContent = t.message, this.dom["login-button"].disabled = !1;\n	      } }, disable: { method: function method(t) {} }, warn: { method: function method(t, o) {} }, country: { method: function method(t, s) {\n	        return s ? (o.call(this, s), s) : void 0;\n	      } } }, this.on("click", function (o) {\n	    o.target === this.dom["login-button"] && this.login(), o.target === this.dom["external-login-button"] && this.externalLogin(), o.target === this.dom[""] && t.call(this, o.target.textContent);\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class="rc-panel rc-auth-panel">\n        <div class=rc-auth-panel__container data-info=container>\n            <div class="rc-panel__header rc-auth-panel__header rc-auth-panel__header--color">\n                <img class="rc-img rc-auth-panel__img" src=./ringcentral_logo.png data-info=logo>\n            </div>\n            <div class="rc-panel__content rc-auth-panel__content rc-auth-panel__content--color">\n                <div data-info=user-info>\n                    <input class="rc-input rc-input--round" data-info=username placeholder=username>\n                    \n                    <input class="rc-input rc-input--round" data-info=extension placeholder=extension>\n                    <input class="rc-input rc-input--round" data-info=password placeholder=password type=password>\n                    \n                </div>\n                <div class="rc-label rc-auth-panel__error" data-info=error></div>\n                <div class=button-panel>\n                    <button class="rc-button rc-button--round rc-auth-panel__button rc-auth-panel__button--color" data-info=external-login-button>Third party\n                    </button>\n                    <button class="rc-button rc-button--round rc-button--material rc-auth-panel__button rc-auth-panel__button--color" data-info=login-button>LOG IN\n                    </button>\n                </div>\n                <div class=rc-label data-info=remember-wrapper>\n                    <label for=remember>Remember me:</label>\n                    <input id=remember type=checkbox data-info=remember checked=checked>\n                </div>\n            </div>\n        </div>\n        <div class="rc-auth-panel__mask display-none" data-info=disabled-mask>\n            <p data-info=disabled-mask-text>Log in...</p>\n        </div>\n    </div>\n',style:"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-auth-panel .input-panel {\n    border-radius: 2px;\n    border: 1px solid #bdc3c7;\n}\n.rc-auth-panel .input-panel > .rc-input {}\n.rc-auth-panel .input-panel__flag {\n    float: left;\n    width: 40px;\n    /* For test, the position is for country flag */\n    height: 30px;\n    background: #000;\n}\n.rc-auth-panel .input-panel__phone {\n    float: left;\n    width: calc(100% - 40px);\n}\n.rc-auth-panel .button-panel {\n    /* Move to the bottom of flex container */\n    margin-top: auto\n}\n.rc-auth-panel .button-panel > .rc-button {\n    margin-top: 10px;\n    width: 100%;\n}\n.rc-auth-panel .blur {\n    filter: blur(2px);\n    -webkit-filter: blur(2px);\n}\n.rc-auth-panel__content {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    padding: 10px;\n}\n.rc-auth-panel__content .rc-input {\n    margin: 5px 0;\n}\n.rc-auth-panel__container {\n    /* used as a positioned reference */\n    position: relative;\n    height: 100%;\n}\n.rc-auth-panel__header {\n    text-align: center;\n}\n.rc-auth-panel__img {\n    width: 60%;\n}\n.rc-auth-panel__button {}\n.rc-auth-panel__button--color {}\n.rc-auth-panel__mask {\n    position: absolute;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.rc-auth-panel__mask > p {\n    font-weight: bold;\n    text-align: center;\n}\n.rc-auth-panel__mask::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.rc-auth-panel__error {\n    color: #e74c3c;\n    font-size: .9em;\n}\n\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["auto-complete"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = { init: { before: function before() {}, after: function after() {} }, mount: { before: function before() {}, method: function method(t) {\n	        t();\n	      }, after: function after() {\n	        var t = this;window.addEventListener("click", function (i) {\n	          i.target === t.dom.input || i.target.classList.contains("candidate") || t.hide();\n	        });\n	      } }, hide: { after: function after() {\n	        this.dom.candidates.classList.add("display-none"), this.showingTimeout && (window.clearTimeout(this.showingTimeout), this.showingTimeout = null);\n	      } }, show: { after: function after() {\n	        var t = this;this.showingTimeout || (this.showingTimeout = window.setTimeout(function () {\n	          t.dom.input === document.activeElement && t.dom.candidates.classList.remove("display-none");\n	        }, 300));\n	      } }, appendInput: { before: function before(t) {\n	        this.dom.input.value += t, this.dom.input.focus();\n	      } }, autoComplete: { before: function before() {}, method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        var i = this;if (t) {\n	          for (; this.dom.candidates.firstChild;) {\n	            this.dom.candidates.removeChild(this.dom.candidates.firstChild);\n	          }t.length > 0 ? this.show() : this.hide(), t.forEach(function (t) {\n	            var n = i.dom["candidate-template"].cloneNode(!0);n.addEventListener("click", function (t) {\n	              i.dom.input.value = n.textContent, i.hide();\n	            }), n.textContent = t.from.phoneNumber, i.dom.candidates.appendChild(n);\n	          });\n	        }\n	      } } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class=auto-complete>\n    <input class=rc-input placeholder="To: Enter name or number" data-info=input data-event=input:autoComplete>\n    <div data-info=candidates class="candidates display-none">\n        <div data-info=candidate-template class=candidate></div>\n    </div>\n</div>',style:"\n.auto-complete .candidates {\n    position: absolute;\n    background-color: #fff;\n    width: 228px;\n    padding: 2px 0;\n    margin-top: 1px;\n    border: 1px solid #878787;\n    color: #878787;\n}\n\n.auto-complete .candidate {\n    font-size: 14px;\n    padding: 5px 10px;\n}\n\n.auto-complete .candidate:hover {\n    background-color: #3498db;\n    color: #fff;\n}\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["call-log-item"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = { init: { method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        this.props.item = t, "Missed" === t.result && this.dom.callResult.classList.add("--missed"), "Outbound" === t.direction ? (this.dom.time.innerHTML = t.startTime, t.to.name ? this.dom.contact.innerHTML = t.to.name : this.dom.contact.innerHTML = t.to.phoneNumber, t.to.location && (this.dom.location.innerHTML = t.to.location), "Missed" !== t.result && this.dom.callResult.classList.add("--outbound")) : (this.dom.time.innerHTML = t.startTime, t.from.name ? this.dom.contact.innerHTML = t.from.name : this.dom.contact.innerHTML = t.from.phoneNumber, "Missed" !== t.result && this.dom.callResult.classList.add("--inbound"));\n	      } } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:"<div class=rc-call-log-item data-info=entry>\n    <i data-info=callResult class=rc-call-log-item__icon></i>\n    <span class=rc-call-log-item__time data-info=time></span>\n    <div class=rc-call-log-item__body>\n        <a class=__contact data-info=contact>\n            \n        </a>\n        <p class=__location data-info=location></p>\n    </div>\n</div>",style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["call-log"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  function t(t, s) {\n	    t && t.forEach(function (t) {\n	      var i = w("call-log-item", { actions: { init: { method: function method() {\n	              return t;\n	            } } } });i.mount(s.dom.logs), s.props.widgetItems.push(i);\n	    });\n	  }function s(t, s) {\n	    t.forEach(function (t) {\n	      s(t) ? t.show() : t.hide();\n	    });\n	  }function i(t, s) {\n	    t.classList.contains("--active") === !1 && (t.classList.add("--active"), s.classList.remove("--active"));\n	  }this.actions = { init: { before: function before() {\n	        this.props.widgetItems = [];\n	      }, method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        this.props.logItems = t, this.refreshCallLogs();\n	      } }, mount: { after: function after() {\n	        this.refreshCallLogs();\n	      } }, refreshCallLogs: { method: function method(t) {\n	        return t();\n	      }, after: function after() {\n	        this.props.widgetItems.length > 0 || t(this.props.logItems, this);\n	      } }, enableAllCallTab: { after: function after() {\n	        i(this.dom.allCallTab, this.dom.missedCallTab), s(this.props.widgetItems, function () {\n	          return !0;\n	        });\n	      } }, enableMissedCallTab: { after: function after() {\n	        i(this.dom.missedCallTab, this.dom.allCallTab), s(this.props.widgetItems, function (t) {\n	          return "Missed" === t.props.item.result;\n	        });\n	      } } }, this.on("click", function (t) {\n	    t.target === this.dom.allCallTab ? this.enableAllCallTab() : t.target === this.dom.missedCallTab && this.enableMissedCallTab();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class=rc-panel>\n    <div class=rc-panel__header>\n        <div class=rc-tabs>\n            <a class="rc-tabs__tab --active --color --width2" data-info=allCallTab>\n                All\n            </a>\n            <a class="rc-tabs__tab --color --width2" data-info=missedCallTab>\n                Missed\n            </a>\n        </div>\n    </div>\n    <div class="rc-panel__content rc-call-log__content" data-info=logs>\n        <call-log-item dynamic></call-log-item>\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["call-panel-incoming"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  var t = (w.transition("circle"), w.transition("fade")),\n	      e = function e(t) {\n	    var e = this;document.querySelector("#rc-advance-button") && this.dom["advance-panel"].removeChild(document.querySelector("#rc-advance-button"));var n = document.createElement("div");n.innerHTML = "<button \\n            id=\'rc-advance-button\'\\n            class=\'rc-button rc-button--circle rc-button--positive advance-panel__button\'>\\n        </button>", n.firstChild.addEventListener("click", function (n) {\n	      var i = e.refs["contact-picker"].getInput();e[t](i);\n	    }), this.dom["advance-panel"].appendChild(n.firstChild);\n	  };this.props = { name: null, target: null, remoteVideo: null, localVideo: null, session: null, width: 250, height: 400, simple: !1, actionNumber: "" }, this.actions = { init: { method: function method(t) {\n	        return t();\n	      }, after: function after() {\n	        this.props.target = this.data.target, this.props.remoteVideo = this.data.remoteVideo, this.props.localVideo = this.data.localVideo, this.props.width = this.data.width, this.props.height = this.data.height, this.data.simple && (this.props.simple = this.data.simple), this.root.firstChild.style.width = this.props.width + "px", this.root.firstChild.style.height = this.props.height + "px", this.props.simple && this.dom["control-panel"].classList.add("display-none");var t = this;w.customize(this, "contact-picker", { actions: { autoComplete: { method: function method() {\n	                return t.props.inputValue = this.props.inputValue, t.queryContacts();\n	              } } } });\n	      } }, mount: { after: function after() {\n	        t.init(this.root), t["in"](this.root);\n	      } }, unmount: { after: function after() {\n	        this.dom["advance-panel"].classList.add("display-none");\n	      } }, setName: { method: function method(t, e) {\n	        this.props.name = e, this.dom.name.textContent = e;\n	      } }, ignore: { after: function after() {\n	        console.log("unmount"), this.unmount();\n	      } }, reject: { method: function method(t) {\n	        return t();\n	      }, after: function after() {\n	        this.unmount();\n	      } }, accept: { method: function method(t) {\n	        return t();\n	      }, error: function error(t) {\n	        console.log(t);\n	      } }, readyForward: { after: function after() {\n	        this.dom["advance-panel"].classList.remove("display-none"), e.call(this, "forward");\n	      } }, forward: { method: function method(t, e) {\n	        return this.props.actionNumber = e, t();\n	      } }, simplify: { before: function before(t) {\n	        t ? this.dom.panel.classList.add("rc-panel__content--min") : this.dom.panel.classList.remove("rc-panel__content--min");\n	      } }, queryContacts: { method: function method(t) {\n	        return t();\n	      } } }, this.on("click", function (t) {\n	    var e = this;["accept", "ignore", "reject", "message", "readyForward"].forEach(function (n) {\n	      t.target !== e.dom[n] && t.target.parentNode !== e.dom[n] || e[n]();\n	    });\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class="rc-panel rc-call-panel">\n    <div class="rc-panel__header rc-panel__header--colored rc-panel__header--center">\n        <h1 data-info=name>Incoming call</h1>\n    </div>\n    <div class=rc-panel__content data-info=panel>\n        <div class=control-panel data-info=control-panel>\n            <div class=control-panel__line>\n                <div class=control-panel__item>\n                    <button data-info=readyForward class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                        <span class=icon-uni27></span>\n                        <span class=icon-uni34></span>\n                    </button>\n                    <div class=text-center>Forward</div>\n                </div>\n                \n                <div class=control-panel__item>\n                    <button data-info=ignore class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                        <span class=icon-uni43></span>\n                        <span class=icon-uni43></span>\n                    </button>\n                    <div class=text-center>Ignore</div>\n                </div>\n            </div>\n        </div>\n        <div class="advance-panel display-none" data-info=advance-panel>\n            <contact-picker data-info=contact-picker></contact-picker>\n        </div>\n        <div class=rc-call-panel__footer>\n            \n\n            <div class="action-panel text-center">\n                <button data-info=accept class="rc-button rc-button--positive rc-button--round action-panel__action">\n                        <span class=icon-uniAE></span>\n                    </button>\n                <button data-info=reject class="rc-button rc-button--negative rc-button--round action-panel__action">\n                        <span class=icon-uni44></span>\n                    </button>\n            </div>\n        </div>\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["call-panel"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  function t(t) {\n	    return 10 > t ? "0" + t : t;\n	  }var i,\n	      e = w.transition("fade"),\n	      d = function d(t) {\n	    var i = this;document.querySelector("#rc-advance-button") && this.dom["advance-panel"].removeChild(document.querySelector("#rc-advance-button"));var e = document.createElement("div");e.innerHTML = "<button \\n            id=\'rc-advance-button\'\\n            class=\'rc-button rc-button--circle rc-button--positive advance-panel__button\'>\\n        </button>", e.firstChild.addEventListener("click", function (e) {\n	      var d = "flip" === t ? i.refs.dropdown.getSelected() : i.refs["contact-picker"].getInput();console.log(i.refs.dropdown.getSelected()), i[t](d);\n	    }), this.dom["advance-panel"].appendChild(e.firstChild);\n	  };this.props = { name: null, advance: !0, time: 0, minimized: !1, width: 250, height: 400, target: null, remoteVideo: null, localVideo: null, isMute: !1, isHold: !1, isRecord: !1, isPark: !1, actionNumber: "", dtmfNumber: "" }, this.actions = { init: { after: function after() {\n	        this.props.name = this.data.name, this.props.width = this.data.width, this.props.height = this.data.height, this.props.target = this.data.target, "undefined" != typeof this.data.advance && (this.props.advance = this.data.advance), this.props.remoteVideo = this.dom.remote, this.props.localVideo = this.dom.local, this.root.firstChild.style.width = this.props.width + "px", this.root.firstChild.style.height = this.props.height + "px", this.props.advance || this.dom["contral-panel"].classList.add("display-none");var t = this;w.customize(this, "contact-picker", { actions: { autoComplete: { method: function method() {\n	                return t.props.inputValue = this.props.inputValue, t.queryContacts();\n	              } } } }), w.customize(this, "dropdown", { data: { height: 35 }, actions: { getData: { method: function method() {\n	                return t.getOutboundCallerID();\n	              } }, switchTitle: { method: function method(i) {\n	                t.props.actionNumber = i;\n	              } } } });\n	      } }, mount: { after: function after() {\n	        var t = this;this.props.advance || this.dom["contral-panel"].classList.add("display-none"), e.init(this.root), e["in"](this.root), this.props.name && this.setName(this.props.name), this.refs.dropdown.getData(), this.getContact().then(function (i) {\n	          i && i[0] && i[0].name && (console.log(i[0].name), t.setName(i[0].name));\n	        });\n	      } }, unmount: { after: function after() {\n	        this.dom.time.textContent = "00:00", this.props.duration = 0, i && (i(), i = null), this.props.isMute = !1;var t = document.createElement("span");for (t.classList.add("icon-uniCE"); this.dom.mute.firstChild;) {\n	          this.dom.mute.removeChild(this.dom.mute.firstChild);\n	        }this.dom.mute.appendChild(t), this.enableFlip(), this.enableRecord(), this.enablePark(), this.props.isHold = !1;var t = document.createElement("span"),\n	            e = document.createElement("span");for (t.classList.add("icon-uni28"), e.classList.add("icon-uni35"); this.dom.hold.firstChild;) {\n	          this.dom.hold.removeChild(this.dom.hold.firstChild);\n	        }this.dom.hold.appendChild(t), this.dom.hold.appendChild(e), this.props.isRecord = !1;var t = document.createElement("span"),\n	            e = document.createElement("span");for (t.classList.add("icon-uni24"), e.classList.add("icon-Active_Call-33"); this.dom.record.firstChild;) {\n	          this.dom.record.removeChild(this.dom.record.firstChild);\n	        }this.dom.record.appendChild(t), this.dom.record.appendChild(e), this.dom["contral-panel"].classList.remove("display-none"), this.dom["dialing-panel"].classList.add("display-none"), this.props.isPark = !1;var t = document.createElement("span"),\n	            e = document.createElement("span");for (t.classList.add("icon-uni22"), e.classList.add("icon-uni2E"); this.dom.park.firstChild;) {\n	          this.dom.park.removeChild(this.dom.park.firstChild);\n	        }this.dom.park.appendChild(t), this.dom.park.appendChild(e), this.dom["advance-panel"].classList.add("display-none");\n	      } }, getContact: { method: function method(t) {\n	        return t();\n	      } }, setName: { method: function method(t, i) {\n	        this.props.name = i, this.dom.name.textContent = i, this.dom["bar-name"].textContent = i;\n	      } }, start: { after: function after(e) {\n	        this.props.startTime = Date.now(), this.props.duration = 0;var d = Math.floor(this.props.duration / 60),\n	            s = this.props.duration % 60;this.dom.time.textContent = t(d) + ":" + t(s), i && (i(), i = null), i = function (t) {\n	          console.log("set interval");var i = setInterval(function () {\n	            t.count();\n	          }, 1e3);return function () {\n	            clearInterval(i);\n	          };\n	        }(this);\n	      } }, count: { after: function after() {\n	        this.props.duration += 1;var i = Math.floor(this.props.duration / 60),\n	            e = this.props.duration % 60;this.dom.time.textContent = t(i) + ":" + t(e), this.dom["bar-time"].textContent = t(i) + ":" + t(e);\n	      } }, ended: { after: function after() {\n	        this.unmount();\n	      } }, hangup: { method: function method(t) {\n	        return t();\n	      }, after: function after() {\n	        this.ended();\n	      } }, hold: { method: function method(t) {\n	        return console.log("ui hold"), t();\n	      }, after: function after(t) {\n	        if (t && (this.props.isHold = t.isOnHold().local), this.props.isHold) {\n	          var i = document.createElement("span"),\n	              e = document.createElement("span");for (i.classList.add("icon-uni37"), e.classList.add("icon-uni3C"); this.dom.hold.firstChild;) {\n	            this.dom.hold.removeChild(this.dom.hold.firstChild);\n	          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.disablePark(), this.disableFlip(), this.disableRecord();\n	        } else {\n	          var i = document.createElement("span"),\n	              e = document.createElement("span");for (i.classList.add("icon-uni28"), e.classList.add("icon-uni35"); this.dom.hold.firstChild;) {\n	            this.dom.hold.removeChild(this.dom.hold.firstChild);\n	          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.enablePark(), this.enableFlip(), this.enableRecord();\n	        }\n	      }, error: function error(t) {\n	        if (console.error(t), t && (this.props.isHold = t.isOnHold().local), this.props.isHold) {\n	          var i = document.createElement("span"),\n	              e = document.createElement("span");for (i.classList.add("icon-uni37"), e.classList.add("icon-uni3C"); this.dom.hold.firstChild;) {\n	            this.dom.hold.removeChild(this.dom.hold.firstChild);\n	          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.disablePark(), this.disableFlip(), this.disableRecord();\n	        } else {\n	          var i = document.createElement("span"),\n	              e = document.createElement("span");for (i.classList.add("icon-uni28"), e.classList.add("icon-uni35"); this.dom.hold.firstChild;) {\n	            this.dom.hold.removeChild(this.dom.hold.firstChild);\n	          }this.dom.hold.appendChild(i), this.dom.hold.appendChild(e), this.enablePark(), this.enableFlip(), this.enableRecord();\n	        }\n	      } }, mute: { method: function method(t) {\n	        return console.log("ui mute"), t();\n	      }, after: function after() {\n	        if (this.props.isMute = !this.props.isMute, this.props.isMute) {\n	          var t = document.createElement("span");for (t.classList.add("icon-uni7B"); this.dom.mute.firstChild;) {\n	            this.dom.mute.removeChild(this.dom.mute.firstChild);\n	          }this.dom.mute.appendChild(t);\n	        } else {\n	          var t = document.createElement("span");for (t.classList.add("icon-uniCE"); this.dom.mute.firstChild;) {\n	            this.dom.mute.removeChild(this.dom.mute.firstChild);\n	          }this.dom.mute.appendChild(t);\n	        }\n	      } }, readyFlip: { method: function method(t, i) {\n	        return this.dom["advance-panel"].classList.remove("display-none"), this.dom["contact-picker"].classList.add("display-none"), this.dom.dropdown.classList.remove("display-none"), d.call(this, "flip"), t();\n	      } }, flip: { method: function method(t, i) {\n	        return console.log("flip: " + i), this.props.actionNumber = i, t();\n	      }, after: function after() {\n	        this.dom["advance-panel"].classList.add("display-none");\n	      }, error: function error(t) {\n	        console.error(t), this.dom["advance-panel"].classList.add("display-none");\n	      } }, readyTransfer: { method: function method(t, i) {\n	        return this.dom["advance-panel"].classList.remove("display-none"), this.dom["contact-picker"].classList.remove("display-none"), this.dom.dropdown.classList.add("display-none"), d.call(this, "transfer"), t();\n	      } }, disableFlip: { after: function after() {\n	        var t = document.createElement("span"),\n	            i = document.createElement("span");for (t.classList.add("control-panel__icon--disabled"), i.classList.add("control-panel__icon--disabled"), t.classList.add("icon-uni34"), i.classList.add("icon-uni34"); this.dom.readyFlip.firstChild;) {\n	          this.dom.readyFlip.removeChild(this.dom.readyFlip.firstChild);\n	        }this.dom.readyFlip.appendChild(t), this.dom.readyFlip.appendChild(i), this.dom.readyFlip.disabled = !0;\n	      } }, enableFlip: { after: function after() {\n	        var t = document.createElement("span"),\n	            i = document.createElement("span");for (t.classList.add("icon-uni27"), i.classList.add("icon-uni34"); this.dom.readyFlip.firstChild;) {\n	          this.dom.readyFlip.removeChild(this.dom.readyFlip.firstChild);\n	        }this.dom.readyFlip.appendChild(t), this.dom.readyFlip.appendChild(i), this.dom.readyFlip.disabled = !1;\n	      } }, transfer: { method: function method(t, i) {\n	        return console.log("transfer:" + i), this.props.actionNumber = i, t();\n	      }, after: function after() {\n	        console.log("after transfer"), this.dom["advance-panel"].classList.add("display-none");\n	      }, error: function error(t) {\n	        console.error(t), this.dom["advance-panel"].classList.add("display-none");\n	      } }, record: { method: function method(t) {\n	        return console.log("ui record"), t();\n	      }, after: function after() {\n	        if (console.log("after record"), this.props.isRecord = !this.props.isRecord, this.props.isRecord) {\n	          var t = document.createElement("span"),\n	              i = document.createElement("span");for (t.classList.add("icon-uni30"), i.classList.add("icon-uni30"); this.dom.record.firstChild;) {\n	            this.dom.record.removeChild(this.dom.record.firstChild);\n	          }this.dom.record.appendChild(t), this.dom.record.appendChild(i);\n	        } else {\n	          var t = document.createElement("span"),\n	              i = document.createElement("span");for (t.classList.add("icon-uni24"), i.classList.add("icon-Active_Call-33"); this.dom.record.firstChild;) {\n	            this.dom.record.removeChild(this.dom.record.firstChild);\n	          }this.dom.record.appendChild(t), this.dom.record.appendChild(i);\n	        }\n	      }, error: function error(t) {\n	        if (console.error(t), -200 === t.code) {\n	          this.props.isRecord = !0;var i = document.createElement("span"),\n	              e = document.createElement("span");for (i.classList.add("icon-uni30"), e.classList.add("icon-uni30"); this.dom.record.firstChild;) {\n	            this.dom.record.removeChild(this.dom.record.firstChild);\n	          }this.dom.record.appendChild(i), this.dom.record.appendChild(e);\n	        }\n	      } }, disableRecord: { after: function after() {\n	        var t = document.createElement("span"),\n	            i = document.createElement("span");for (t.classList.add("control-panel__icon--disabled"), i.classList.add("control-panel__icon--disabled"), t.classList.add("icon-uni30"), i.classList.add("icon-uni30"); this.dom.record.firstChild;) {\n	          this.dom.record.removeChild(this.dom.record.firstChild);\n	        }this.dom.record.appendChild(t), this.dom.record.appendChild(i), this.dom.record.disabled = !0;\n	      } }, enableRecord: { after: function after() {\n	        var t = document.createElement("span"),\n	            i = document.createElement("span");for (t.classList.add("icon-uni24"), i.classList.add("icon-Active_Call-33"); this.dom.record.firstChild;) {\n	          this.dom.record.removeChild(this.dom.record.firstChild);\n	        }this.dom.record.appendChild(t), this.dom.record.appendChild(i), this.dom.record.disabled = !1;\n	      } }, park: { method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        var i = document.createElement("span"),\n	            e = document.createElement("span");for (i.classList.add("icon-uni2E"), e.classList.add("icon-uni2E"); this.dom.park.firstChild;) {\n	          this.dom.park.removeChild(this.dom.park.firstChild);\n	        }this.dom.park.appendChild(i), this.dom.park.appendChild(e), this.props.isPark = !0;\n	      }, error: function error(t) {\n	        console.error(t), this.props.isPark = !1;\n	      } }, disablePark: { after: function after() {\n	        var t = document.createElement("span"),\n	            i = document.createElement("span");for (t.classList.add("control-panel__icon--disabled"), i.classList.add("control-panel__icon--disabled"), t.classList.add("icon-uni2E"), i.classList.add("icon-uni2E"); this.dom.park.firstChild;) {\n	          this.dom.park.removeChild(this.dom.park.firstChild);\n	        }this.dom.park.appendChild(t), this.dom.park.appendChild(i), this.dom.park.disabled = !0;\n	      } }, enablePark: { after: function after() {\n	        var t = document.createElement("span"),\n	            i = document.createElement("span");for (t.classList.add("icon-uni22"), i.classList.add("icon-uni2E"); this.dom.park.firstChild;) {\n	          this.dom.park.removeChild(this.dom.park.firstChild);\n	        }this.dom.park.appendChild(t), this.dom.park.appendChild(i), this.dom.park.disabled = !1;\n	      } }, dtmf: { method: function method(t, i) {\n	        return this.props.dtmfNumber = i, t();\n	      } }, minimize: { after: function after() {\n	        this.dom.bar.classList.remove("display-none"), this.dom.header.classList.add("display-none"), this.dom.content.classList.add("display-none"), this.root.firstChild.style.height = "auto", this.props.minimized = !0;\n	      } }, resume: { after: function after() {\n	        this.dom.bar.classList.add("display-none"), this.dom.header.classList.remove("display-none"), this.dom.content.classList.remove("display-none"), this.root.firstChild.style.height = this.props.height + "px", this.props.minimized = !1;\n	      } }, keypad: { method: function method(t) {\n	        this.dom["contral-panel"].classList.add("display-none"), this.dom["dialing-panel"].classList.remove("display-none"), this.dom.mask.classList.remove("display-none");\n	      } }, hideKeypad: { method: function method(t) {\n	        this.dom["contral-panel"].classList.remove("display-none"), this.dom["dialing-panel"].classList.add("display-none"), this.dom.mask.classList.add("display-none");\n	      } }, queryContacts: { method: function method(t) {\n	        return t();\n	      } }, getOutboundCallerID: { method: function method(t) {\n	        return t();\n	      } } }, this.on("click", function (t) {\n	    var i = this;["hangup", "hold", "mute", "readyFlip", "readyTransfer", "record", "keypad", "park"].forEach(function (e) {\n	      if (t.target === i.dom[e] || t.target.parentNode === i.dom[e]) {\n	        if (i.props.isHold && ("record" === e || "park" === e || "readyFlip" === e)) return;console.log(i.props.isHold), console.log(e), i[e]();\n	      }\n	    }), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].forEach(function (e) {\n	      t.target !== i.dom["dial-button-" + e] && t.target.parentNode !== i.dom["dial-button-" + e] || i.dtmf(e);\n	    }), t.target !== this.dom.bar && t.target.parentNode !== this.dom.bar || this.resume(), t.target === this.dom.mask && this.hideKeypad();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',
template:'\n    <div class="rc-panel rc-call-panel">\n        <section data-info=header class="rc-panel__header rc-panel__header--colored rc-panel__header--center">\n            <div data-info=time-wrapper class="text-right time-wrapper">\n                <span data-info=time>00:00</span>\n            </div>\n            <div>\n                <h1 data-info=name>Number</h1>\n            </div>\n        </section>\n        <section data-info=content class=rc-panel__content>\n            <div class="rc-call-panel__center control-panel" data-info=contral-panel>\n                <div class=control-panel__line>\n                    <div class=control-panel__item>\n                        <button data-info=hold class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                            <span class=icon-uni28></span>\n                            <span class=icon-uni35></span>\n                        </button>\n                        <div class=text-center>Hold</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=keypad class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                            <span class=icon-uni21></span>\n                            <span class=icon-uni2D></span>\n                        </button>\n                        <div class=text-center>Keypad</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=record class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                            <span class=icon-uni24></span>\n                            <span class=icon-Active_Call-33></span>\n                        </button>\n                        <div class=text-center>Record</div>\n                    </div>\n                    \n                </div>\n                <div class=control-panel__line>\n                    <div class=control-panel__item>\n                        <button data-info=readyFlip class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                            <span class=icon-uni27></span>\n                            <span class=icon-uni34></span>\n                        </button>\n                        <div class=text-center>Flip</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=readyTransfer class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                            <span class=icon-uni23></span>\n                            <span class=icon-uni2F></span>\n                        </button>\n                        <div class=text-center>Transfer</div>\n                    </div>\n                    <div class=control-panel__item>\n                        <button data-info=park class="rc-button rc-button--circle rc-button--ghost rc-button--dense rc-icon-switch control-panel__button">\n                            <span class=icon-uni22></span>\n                            <span class=icon-uni2E></span>\n                        </button>\n                        <div class=text-center>Park</div>\n                    </div>\n                </div>\n            </div>\n            <div class="rc-call-panel__center dialing-panel display-none" data-info=dialing-panel>\n                <div class=rc-dial-pad__line>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-1>\n                        <div class=dial-button__number>1</div>\n                    </button>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-2>\n                        <div class=dial-button__number>2</div>\n                        <div class=dial-button__symbol>ABC</div>\n                    </button>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-3>\n                        <div class=dial-button__number>3</div>\n                        <div class=dial-button__symbol>DEF</div>\n                    </button>\n                </div>\n                <div class=rc-dial-pad__line>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-4>\n                        <div class=dial-button__number>4</div>\n                        <div class=dial-button__symbol>GHI</div>\n                    </button>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-5>\n                        <div class=dial-button__number>5</div>\n                        <div class=dial-button__symbol>JKL</div>\n                    </button>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-6>\n                        <div class=dial-button__number>6</div>\n                        <div class=dial-button__symbol>MNO</div>\n                    </button>\n                </div>\n                <div class=rc-dial-pad__line>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-7>\n                        <div class=dial-button__number>7</div>\n                        <div class=dial-button__symbol>PQRS</div>\n                    </button>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-8>\n                        <div class=dial-button__number>8</div>\n                        <div class=dial-button__symbol>TUV</div>\n                    </button>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-9>\n                        <div class=dial-button__number>9</div>\n                        <div class=dial-button__symbol>WXYZ</div>\n                    </button>\n                </div>\n                <div class=rc-dial-pad__line>\n                    <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-0>\n                        <div class=dial-button__number>0</div>\n                        <div class=dial-button__symbol>+</div>\n                    </button>\n                </div>\n            </div>\n            <div class="rc-call-panel__mask display-none" data-info=mask></div>\n            <div class="advance-panel display-none" data-info=advance-panel>\n                <contact-picker data-info=contact-picker></contact-picker>\n                <dropdown class=display-none data-info=dropdown></dropdown>\n            </div>\n            <div class=rc-call-panel__footer>\n                <div class=action-panel>\n                    <button data-info=mute class="rc-button rc-button--round action-panel__action">\n                        <span class=icon-uniCE></span>\n                    </button>\n                    <button data-info=hangup class="rc-button rc-button--negative rc-button--round action-panel__action">\n                        <span class=icon-uni44></span>\n                    </button>\n                </div>\n            </div>\n        </section>\n        <div data-info=bar class="bar display-none">\n            <span data-info=bar-name class=bar__name>bar</span>\n            <span data-info=bar-time class=bar__time>00:00</span>\n        </div>\n        <video data-info=local class=display-none hidden=hidden muted></video>\n        <video data-info=remote class=display-none hidden=hidden></video>\n    </div>\n',style:'/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-call-panel {\n    font-size: .8em;\n}\n.rc-call-panel .rc-panel__content {\n    padding: .5em .7em;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: end;\n    -webkit-justify-content: flex-end;\n    -ms-flex-pack: end;\n    justify-content: flex-end\n}\n.rc-call-panel .rc-panel__content--min {\n    -webkit-box-pack: start;\n    -webkit-justify-content: flex-start;\n    -ms-flex-pack: start;\n    justify-content: flex-start;\n}\n.rc-call-panel .time-wrapper {\n    min-height: 15px;\n}\n.rc-call-panel .action-panel {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: justify;\n    -webkit-justify-content: space-between;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    margin-top: 10px\n}\n.rc-call-panel .action-panel__action {\n    width: 130px;\n}\n.rc-call-panel .action-panel__action > [class*="icon-"] {\n    font-size: 1.6em;\n}\n.rc-call-panel .action-panel__action:first-child {\n    margin-right: 10px;\n}\n.rc-call-panel .control-panel {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n    -ms-flex-pack: center;\n    justify-content: center\n}\n.rc-call-panel .control-panel__title {\n    padding: .1em .3em;\n}\n.rc-call-panel .control-panel__line {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: justify;\n    -webkit-justify-content: space-between;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    margin-bottom: 10px;\n}\n.rc-call-panel .control-panel__item {\n    color: #2196F3;\n}\n.rc-call-panel .control-panel__button {\n    margin-bottom: 3px;\n}\n.rc-call-panel .control-panel__button > [class*="icon-"] {\n    font-size: 4em;\n}\n.rc-call-panel .control-panel__icon {}\n.rc-call-panel .control-panel__icon--disabled {\n    color: #ddd;\n}\n.rc-call-panel .bar {\n    width: 100%;\n    height: 30px;\n    background-color: #e74c3c;\n    text-align: center;\n    line-height: 2;\n    color: #fff;\n    cursor: pointer\n}\n.rc-call-panel .bar__name {\n    margin-right: 10px;\n}\n.rc-call-panel .dialing-panel, .rc-call-panel .advance-panel {\n    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n    position: relative;\n    z-index: 2;\n    background: #fff;\n}\n.rc-call-panel .dialing-panel {\n    padding: .5em .7em;\n    border-radius: 3px;\n    font-size: 1.2em;\n}\n.rc-call-panel .advance-panel {}\n.rc-call-panel .advance-panel__button {\n    position: absolute;\n    top: 12px;\n    right: 10px;\n    padding: 0;\n    width: 10px;\n    height: 10px;\n}\n/* We need to use some element from dial pad */\n.rc-call-panel .rc-dial-pad {}\n.rc-call-panel .rc-dial-pad__line {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n}\n.rc-call-panel .rc-dial-pad__line > .dial-button {\n    margin: 4px 8px;\n    width: 3.2em;\n    height: 3.2em;\n    color: #2196F3;\n    border-color: #2196F3;\n}\n.rc-call-panel .rc-dial-pad__line > .dial-button > .dial-button__number {}\n.rc-call-panel .rc-dial-pad__line > .dial-button > .dial-button__symbol {\n    font-size: .5em;\n}\n.rc-call-panel .rc-dial-pad__line > .dial-button:hover {\n    background-color: #2196F3;\n    color: #fff;\n}\n.rc-call-panel__reply {\n    width: 100%;\n}\n.rc-call-panel__center {\n    /* fill out all flex panel */\n    height: 100%;\n}\n.rc-call-panel__footer {}\n.rc-call-panel__mask {\n    position: absolute;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    z-index: 1;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: #000;\n    opacity: .3;\n}\n.rc-call-panel__mask::before {\n    content: \'\';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n',imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["compose-text"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = w.action("interaction"), this.actions.init = { after: function after() {\n	      var t = this;w.customize(this, "contact-picker", { actions: { autoComplete: { method: function method() {\n	              return t.queryContacts(this.props.inputValue);\n	            } } } }), w.customize(this, "dropdown", { actions: { getData: { method: function method() {\n	              return t.getOutboundCallerID();\n	            }, after: function after(t) {\n	              var n = this;t.forEach(function (t) {\n	                return n.addItem(t);\n	              });\n	            } }, switchTitle: { method: function method(n) {\n	              t.props.fromNumber = n;\n	            } } } });\n	    } }, this.actions.mount = { after: function after() {\n	      this.props.dropdown.getData();\n	    } }, this.actions.send = { method: function method(t) {\n	      return this.props.text = this.dom.text.value, this.props.fromNumber = this.props.dropdown.getSelected(), this.props.toNumber = this.props["contact-picker"].getInput(), t();\n	    }, after: function after(t) {\n	      "Sent" === t.json().messageStatus && this.sent();\n	    } }, this.actions.sent = { after: function after() {\n	      this.dom.send.textContent = "Success!", this.dom.text.value = "";\n	    } }, this.actions.readyToSend = { after: function after() {\n	      this.dom.send.textContent = "Send";\n	    } }, this.actions.getOutboundCallerID = { method: function method(t) {\n	      return t();\n	    } }, this.actions.queryContacts = { method: function method(t, n) {\n	      return this.props.to = n, t();\n	    } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class="rc-panel rc-compose-text">\n    <div class="rc-panel__header --colored">\n        <h5 class=text-center>\n            Compose text\n        </h5>\n        <contact-picker data-info=contact-picker></contact-picker>\n        <dropdown data-info=dropdown></dropdown>\n    </div>\n    <div class=rc-panel__content>\n        <textarea class="rc-textarea rc-compose-text__textarea" placeholder="Type any text..." data-info=text data-event=focus:readyToSend></textarea>\n        <button class="rc-button --circle --positive rc-compose-text__send" data-info=send data-event=click:send>\n            <span class=icon-uniB1></span>\n        </button>\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets.conference={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = { init: { method: function method() {\n	        this.getConferenceInfo();\n	      }, after: function after() {\n	        var t = w.t(this.data.lang);this.dom.dialInNumberLabel.textContent = t("conference-dialinnumber-text"), this.dom.hostCodeLabel.textContent = t("conference-hostcode-text"), this.dom.participantCodeLabel.textContent = t("conference-participantcode-text"), this.dom.inviteWithTextButton.textContent = t("conference-invitewithtext-text"), this.dom.joinAsHostButton.textContent = t("conference-joinashost-text");\n	      } }, getConferenceInfo: { method: function method(t) {\n	        var e = this;return Promise.resolve(t()).then(function (t) {\n	          return t && (e.props.dialInNumber = t.phoneNumber), e.props.inviteMessage = "Test", t;\n	        });\n	      }, after: function after(t) {\n	        t && (this.dom.dialInNumber.textContent = t.phoneNumber, this.dom.hostCode.textContent = t.hostCode, this.dom.participantCode.textContent = t.participantCode, this.enable());\n	      } }, inviteWithText: { method: function method(t) {\n	        return t();\n	      } }, joinAsHost: { method: function method(t) {\n	        return t();\n	      } }, enable: { method: function method() {\n	        this.dom.inviteWithTextButton.disabled = !1, this.dom.joinAsHostButton.disabled = !1;\n	      } } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class="rc-panel rc-conference --color">\n    <div class=rc-panel__header></div>\n    <div class="rc-panel__content rc-conference__content">\n        <div class=rc-conference__line>\n            <label class="__label --color" data-info=dialInNumberLabel></label>\n            <div class="__value --right" data-info=dialInNumber>\n            </div>\n        </div>\n        <div class=rc-conference__line>\n            <label class="__label --color" data-info=hostCodeLabel></label>\n            <div class="__value --right" data-info=hostCode>\n            </div>\n        </div>\n        <div class=rc-conference__line>\n            <label class="__label --color" data-info=participantCodeLabel></label>\n            <div class="__value --right" data-info=participantCode>\n            </div>\n        </div>\n        <div class=rc-conference__buttons>\n            <button class="rc-button --clean --round __button" data-info=inviteWithTextButton data-event=click:inviteWithText disabled=disabled>\n            </button>\n            <button class="rc-button --positive --round __button" data-info=joinAsHostButton data-event=click:joinAsHost disabled=disabled>\n            </button>\n        </div>\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["contact-detail"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  function e(e, n) {\n	    n.emails.forEach(function (n) {\n	      var i = \'<div class=\\\'rc-contact-detail__section-line\\\'>\\n                                <label class="__label">Email</label>\\n                                <div class="__value">\\n                                    \' + n + "\\n                                </div>\\n                            </div>",\n	          t = document.createElement("div");t.innerHTML = i, e.appendChild(t);\n	    });\n	  }function n(e, n) {\n	    var i = \'<div class="rc-contact-detail__section-line">\\n                            <label class="__label">Extension</label>\\n                            <div class="__value">\' + n.extension + "</div>\\n                        </div>",\n	        t = document.createElement("div");t.innerHTML = i, e.appendChild(t), n.phoneNumbers.forEach(function (n) {\n	      i = \'<div class="rc-contact-detail__section-line">\\n                            <label class="__label">Direct Number</label>\\n                            <div class="__value">\' + n + "</div>\\n                        </div>", t = document.createElement("div"), t.innerHTML = i, e.appendChild(t);\n	    });\n	  }var i = w.transition("fade");this.actions = { init: { method: function method(e) {\n	        return e();\n	      }, after: function after(t) {\n	        t && (this.dom.displayName.textContent = t.displayName, e(this.dom.emails, t), n(this.dom.phoneNumbers, t)), i.init(this.root), i["in"](this.root);\n	      } } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class=rc-contact-detail>\n    <div class="rc-panel__header rc-contact-detail__info">\n        <div class="rc-avatar --small __avatar"></div>\n        <div class=__name data-info=displayName>\n        </div>\n    </div>\n    <div class=rc-panel__content>\n        <section class=rc-contact-detail__section data-info=emails>\n            \n        </section>\n        <section class=rc-contact-detail__section data-info=phoneNumbers>\n        </section>\n    </div>    \n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["contact-item"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = { init: { before: function before() {\n	        this.props.contact = null;\n	      }, method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        this.props.contact = t, this.dom.name.textContent = t.name;\n	      } }, select: { method: function method(t) {\n	        return t();\n	      } } }, this.on("click", function () {\n	    this.select();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:"\n    <div class=rc-contact-item data-event=click:select>\n        <a class=rc-contact-item__body>\n            <span class=__contact data-info=name></span>\n        </a>\n    </div>\n",style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["contact-picker-item"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.props = { contact: null, hovered: !1, focused: !1 }, this.actions = { init: { method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        this.props.contact = t, this.dom.name.textContent = t.name, this.dom.value.textContent = t.value;\n	      } }, select: { method: function method(t) {\n	        return t();\n	      } }, hover: { after: function after(t) {\n	        t ? this.root.firstChild.classList.add("hover") : this.root.firstChild.classList.remove("hover"), this.props.hovered = t;\n	      } }, focus: { after: function after(t) {\n	        t ? this.root.firstChild.classList.add("rc-contact--focus") : this.root.firstChild.classList.remove("rc-contact--focus"), this.props.focused = t;\n	      } } }, this.on("click", function (t) {\n	    this.select();\n	  }), this.on("mouseover", function (t) {\n	    this.hover(!0);\n	  }), this.on("mouseout", function (t) {\n	    this.hover(!1);\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class="rc-contact rc-list__item" data-event=click:select>\n    <div class=rc-contact__name data-info=name></div>\n    <div class=rc-contact__value data-info=value></div>\n</div>',style:"\n    .rc-contact {\n    }\n.rc-contact--focus {\n    background: #64B5F6\n}\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["contact-picker"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n	"use strict";\n	function _interopRequireDefault(t) {\n	  return t && t.__esModule ? t : { "default": t };\n	}function _readyAC() {\n	  var t = this;return this.props.show ? void this.autoComplete() : (timeout && (clearTimeout(timeout), timeout = !1), void (timeout = setTimeout(function () {\n	    t.autoComplete();\n	  }, 500)));\n	}var _leopard = __webpack_require__(2),\n	    _leopard2 = _interopRequireDefault(_leopard),\n	    timeout;w.register(function () {\n	  var t = w.transition("enter"),\n	      o = w.transition("fade");this.props = { limit: 10, show: !1, whiteList: null, contacts: [] }, this.actions = { init: { method: function method(t) {\n	        var o = this;return this.data.whiteList && (this.props.whiteList = this.data.whiteList.slice()), document.addEventListener("click", function (t) {\n	          for (var i = t.target; i.parentNode;) {\n	            if (i === o.root || o.props.whiteList && o.props.whiteList.indexOf(i) > -1) return;i = i.parentNode;\n	          }o.hide();\n	        }), t();\n	      } }, mount: { method: function method(t) {\n	        t();\n	      }, after: function after() {\n	        t.init(this.dom.contacts), o.init(this.dom.contacts), this.dom.contacts.transition = "\\n                transform .25s cubic-bezier(0.4, 0.0, 0.2, 1),\\n                opacity .08s cubic-bezier(0.4, 0.0, 0.2, 1)\\n                ", this.data.contact && (this.dom.input.value = this.data.contact);\n	      } }, hide: { after: function after() {\n	        var i = this;this.props.show && setTimeout(function () {\n	          i.props.show = !1, console.log("out"), t.out(i.dom.contacts), o.out(i.dom.contacts);\n	        }, 50);\n	      } }, show: { after: function after() {\n	        this.props.show || (this.props.show = !0, t["in"](this.dom.contacts), o["in"](this.dom.contacts));\n	      } }, getInput: { method: function method() {\n	        return this.dom.input.value;\n	      } }, appendInput: { before: function before(t) {\n	        this.dom.input.value += t, this.dom.input.focus();\n	      } }, setInput: { before: function before(t) {\n	        this.dom.input.value = t, this.dom.input.focus(), this.props.input = t;\n	      } }, disable: { method: function method() {\n	        this.dom.input.readOnly = !0;\n	      } }, focus: { method: function method() {\n	        this.dom.input.focus();\n	      } }, autoComplete: { before: function before() {\n	        _leopard2["default"].stop();\n	      }, method: function method(t) {\n	        return this.props.inputValue = this.dom.input.value, t();\n	      }, after: function after(t) {\n	        var o = this;if (_leopard2["default"].stop(), t) {\n	          for (; this.dom.contacts.firstChild;) {\n	            this.dom.contacts.removeChild(this.dom.contacts.firstChild);\n	          }t.length > 0 ? this.show() : this.hide(), this.props.contacts.length = 0;var i = this;this.props.limit;_leopard2["default"].start({ autoStop: !0, strategy: "batch", limit: 1e3 }), t.forEach(function (t) {\n	            _leopard2["default"].put(1, function () {\n	              var n = w("contact-picker-item", { actions: { init: { method: function method() {\n	                      return t;\n	                    } }, select: { method: function method() {\n	                      i.setInput(this.props.contact.value), i.hide();\n	                    } }, hover: { before: function before(t) {\n	                      t && i.props.contacts.forEach(function (t) {\n	                        t.props.focused && t.focus(!1), t.props.hovered && t.hover(!1);\n	                      });\n	                    } }, focus: { before: function before(t) {\n	                      t && i.props.contacts.forEach(function (t) {\n	                        t.props.focused && t.focus(!1), t.props.hovered && t.hover(!1);\n	                      });\n	                    } } } });n.mount(o.dom.contacts), o.props.contacts.push(n);\n	            });\n	          });\n	        }\n	      } } }, this.on("input", "input", function (t) {\n	    console.log("input"), this.setInput(this.dom.input.value), "" === this.dom.input.value ? this.hide() : _readyAC.call(this);\n	  }), this.on("keydown", "input", function (t) {\n	    if (38 === t.keyCode) {\n	      t.preventDefault();var o = this.props.contacts.findIndex(function (t) {\n	        return t.props.hovered;\n	      });-1 === o && (o = this.props.contacts.findIndex(function (t) {\n	        return t.props.focused;\n	      })), -1 === o && (o = 0);var i = this.props.contacts[o];0 === o && (o = this.props.contacts.length), this.props.contacts[o - 1].focus(!0);\n	    } else if (40 === t.keyCode) {\n	      t.preventDefault();var o = this.props.contacts.findIndex(function (t) {\n	        return t.props.hovered;\n	      });-1 === o && (o = this.props.contacts.findIndex(function (t) {\n	        return t.props.focused;\n	      })), -1 === o && (o = 0);var i = this.props.contacts[o];o === this.props.contacts.length - 1 && (o = -1), this.props.contacts[o + 1].focus(!0);\n	    } else if (13 === t.keyCode) {\n	      t.preventDefault();var o = this.props.contacts.findIndex(function (t) {\n	        return t.props.hovered;\n	      });-1 === o && (o = this.props.contacts.findIndex(function (t) {\n	        return t.props.focused;\n	      })), -1 === o && (o = 0);var i = this.props.contacts[o];i && this.setInput(i.props.contact.value), this.hide();\n	    }\n	  });\n	});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var __WEBPACK_AMD_DEFINE_RESULT__;\'use strict\';\n	\n	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };\n	\n	var Emitter = function Emitter() {\n	  this.uid = 0;\n	  this.handlers = [];\n	  for (var i = 0; i < 1000; i++) {\n	    this.handlers.push([]);\n	  }\n	};\n	Emitter.prototype.on = function (level, callback) {\n	  this.handlers[level].push({\n	    id: this.uid++,\n	    action: callback\n	  });\n	};\n	Emitter.prototype.emit = function (level) {\n	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n	    args[_key - 1] = arguments[_key];\n	  }\n	\n	  this.handlers[level].forEach(function (handler) {\n	    if (typeof handler.action === \'function\') handler.action.apply(handler, args);\n	  });\n	};\n	Emitter.prototype.once = function (level, callback) {\n	  var _this = this;\n	\n	  var id = this.uid;\n	  this.on(level, function () {\n	    callback.apply(undefined, arguments);\n	    var handler = _this.handlers[level].find(function (handler) {\n	      return handler.id === id;\n	    });\n	    _this.handlers[level].splice(_this.handlers[level].indexOf(handler), 1);\n	    // delete handler\n	  });\n	};\n	var singletonEmitter = new Emitter()\n	\n	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n	// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n	\n	// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n	\n	// MIT license\n	\n	;(function () {\n	  var lastTime = 0;\n	  var vendors = [\'ms\', \'moz\', \'webkit\', \'o\'];\n	  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n	    window.requestAnimationFrame = window[vendors[x] + \'RequestAnimationFrame\'];\n	    window.cancelAnimationFrame = window[vendors[x] + \'CancelAnimationFrame\'] || window[vendors[x] + \'CancelRequestAnimationFrame\'];\n	  }\n	\n	  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n	    var currTime = new Date().getTime();\n	    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n	    var id = window.setTimeout(function () {\n	      callback(currTime + timeToCall);\n	    }, timeToCall);\n	    lastTime = currTime + timeToCall;\n	    return id;\n	  };\n	  /* istanbul ignore if */\n	  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n	    clearTimeout(id);\n	  };\n	})();\n	\n	// @license http://opensource.org/licenses/MIT\n	// copyright Paul Irish 2015\n	\n	// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n	//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n	// as Safari 6 doesn\'t have support for NavigationTiming, we use a Date.now() timestamp for relative values\n	\n	// if you want values similar to what you\'d get with real perf.now, place this towards the head of the page\n	// but in reality, you\'re just getting the delta between now() calls, so it\'s not terribly important where it\'s placed\n	\n	(function () {\n	\n	  if (\'performance\' in window == false) {\n	    window.performance = {};\n	  }\n	  /* istanbul ignore next */\n	  Date.now = Date.now || function () {\n	    // thanks IE8\n	    return new Date().getTime();\n	  };\n	\n	  if (\'now\' in window.performance == false) {\n	\n	    var nowOffset = Date.now();\n	    /* istanbul ignore next */\n	    if (window.performance.timing && window.performance.timing.navigationStart) {\n	      nowOffset = window.performance.timing.navigationStart;\n	    }\n	\n	    window.performance.now = function now() {\n	      return Date.now() - nowOffset;\n	    };\n	  }\n	})();\n	\n	var queue = [];\n	var counter = 0;\n	var levels = 1000;\n	\n	for (var i = 0; i < levels; i++) {\n	  queue.push([]);\n	}function run(count) {\n	  for (var i = 0; i < queue.length; i++) {\n	    if (count < 1) break;\n	    var level = queue[i];\n	    while (level.length) {\n	      if (count < 1) break;\n	      counter--;\n	      // the bigger of level, the less emergent to complete\n	      // So we deduce more for higher level (lower priority) actions\n	      count--;\n	      var callback = level.shift();\n	      if (callback && typeof callback === \'function\') callback();\n	      if (!level.length) {\n	        singletonEmitter.emit(i);\n	      }\n	    }\n	    /* istanbul ignore if */\n	    if (i === queue.length - 1 && counter === 0) {\n	      return false;\n	    }\n	  }\n	  return true;\n	}\n	function enqueue(priority, callback, times) {\n	  if (!times) {\n	    queue[priority].push(callback);\n	    counter++;\n	  } else {\n	    while (times--) {\n	      queue[priority].push(callback);\n	      counter++;\n	    }\n	  }\n	}\n	function flush() {\n	  for (var _i = 0; _i < levels; _i++) {\n	    queue[_i].length = 0;\n	  }counter = 0;\n	}\n	\n	var perFrame = 16;\n	\n	// options\n	var expectedFrame = perFrame;\n	var limit = 1000;\n	var count = limit;\n	var strategy = \'normal\';\n	var perf = 2;\n	var autoStop = false;\n	\n	var isRunning = false;\n	var accelerate = 1; // for slow start\n	\n	var scriptStart;\n	var scriptEnd;\n	var styleStart;\n	var styleEnd;\n	\n	var styleDuration;\n	var scriptDuration;\n	\n	function frame(frameStart) {\n	  if (!isRunning) return;\n	  // calculate metrix\n	  styleEnd = frameStart;\n	  styleDuration = styleStart ? styleEnd - styleStart : expectedFrame;\n	  scriptDuration = scriptEnd - scriptStart;\n	\n	  var inc = true;\n	  var dec = true;\n	  // calculate limit\n	  if (strategy === \'batch\') {\n	    // will try to batch up all update\n	    inc = scriptDuration < expectedFrame + 1;\n	    dec = scriptDuration >= expectedFrame + 1;\n	  } else {\n	    inc = styleDuration >= expectedFrame && styleDuration < expectedFrame + 1 && styleDuration !== 0;\n	    dec = styleDuration >= expectedFrame + 1;\n	  }\n	  if (inc) {\n	    accelerate = accelerate * perf;\n	    count += accelerate;\n	  } else if (dec) {\n	    accelerate = 1;\n	    count = Math.floor(count / 2);\n	    /* istanbul ignore next */\n	  } else if (styleDuration === 0) {\n	      // This is a skipped frame\n	    }\n	  if (count < 1) count = 1;\n	  scriptStart = window.performance.now();\n	  var continueRun = run(count);\n	  if (!continueRun && autoStop) return;\n	  scriptEnd = window.performance.now();\n	  styleStart = frameStart;\n	\n	  window.requestAnimationFrame(frame);\n	  if (window && window.requestIdleCallback) {\n	    // For browsers which support requestIdleCallback\n	    /* istanbul ignore next */\n	    window.requestIdleCallback(function (deadline) {\n	      if (deadline.timeRemaining() > 0) {\n	        var ratio = deadline.timeRemaining() / perFrame;\n	        run(Math.floor(count * ratio));\n	      }\n	    });\n	  }\n	}\n	\n	function stop() {\n	  accelerate = 1; // for slow start\n	  count = limit;\n	  isRunning = false;\n	  flush();\n	}\n	function start() {\n	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n	\n	  if (!isRunning) window.requestAnimationFrame(frame);\n	  options.limit && (limit = count = options.limit);\n	  options.expectedFrame && (expectedFrame = options.expectedFrame);\n	  options.strategy && (strategy = options.strategy);\n	  options.perf && (perf = options.perf);\n	  options.autoStop && (autoStop = options.autoStop);\n	  scriptStart = null;\n	  scriptEnd = null;\n	  styleStart = null;\n	  styleEnd = null;\n	  isRunning = true;\n	}\n	function put(priority, callback, times) {\n	  enqueue(priority, callback, times);\n	}\n	function getCount() {\n	  return count;\n	}\n	\n	var Leopard = {\n	  on: singletonEmitter.on.bind(singletonEmitter),\n	  once: singletonEmitter.once.bind(singletonEmitter),\n	  start: start,\n	  stop: stop,\n	  put: put,\n	  get limit() {\n	    return getCount();\n	  }\n	};\n	\n	if (( false ? \'undefined\' : _typeof(exports)) === \'object\') module.exports = Leopard;else if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n	  return Leopard;\n	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else window.Leopard = Leopard;\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',
template:'<div class=rc-contact-picker>\n    <input class="rc-input rc-input--clean" data-info=input placeholder="">\n    \n    <div class="rc-contact-picker__contacts rc-list" data-info=contacts>\n        <contact-picker-item dynamic></contact-picker-item>\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets.contacts={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  function t(t, n) {\n	    return w("contact-item", { actions: { init: { method: function method() {\n	            return n;\n	          } }, select: { method: function method() {\n	            t.selectContact(this.props.contact);\n	          } } } });\n	  }this.data = { loadingContacts: 30, searchBox: !0 }, this.actions = { init: { before: function before() {\n	        this.props.selectedContact = null, this.props.contactItemWidgets = [], this.props.currentIndex = 0;\n	      }, after: function after() {\n	        "undefined" == typeof this.data.searchBox || this.data.searchBox || this.dom.header.classList.add("display-none");\n	      } }, fetchContacts: { method: function method(t) {\n	        return t();\n	      }, after: function after(n) {\n	        var o = this;this.props.contactItemWidgets.length > 0 || (n.forEach(function (n) {\n	          var e = t(o, n);o.props.contactItemWidgets.push(e);\n	        }), this.displayContacts(this.props.currentIndex));\n	      } }, displayContacts: { method: function method(t, n) {\n	        var o = this;return this.props.contactItemWidgets.slice(n, n + this.data.loadingContacts).forEach(function (t) {\n	          return t.mount(o.dom.contacts);\n	        }), this.props.currentIndex = n + this.data.loadingContacts, t();\n	      }, after: function after() {}, error: function error(t) {\n	        console.error(t);\n	      } }, fetchRelatedContact: { method: function method(t) {\n	        return t();\n	      }, after: function after() {\n	        this.pinContacts();\n	      } }, pinContacts: { method: function method() {\n	        var n = this;Object.keys(this.props.relateContacts).filter(function (t) {\n	          var o = n.props.contactItemWidgets.filter(function (o) {\n	            var e = o.props.contact.id == t;return e && o.mount(n.dom["pin-contacts"]), e;\n	          });return 0 === o.length;\n	        }).forEach(function (o) {\n	          var e = n.props.relateContacts[o];e.name = e.displayName, t(n, e).mount(n.dom["pin-contacts"]);\n	        });\n	      } }, search: { method: function method() {\n	        var t = this,\n	            n = this.dom.searchText.value;this.props.contactItemWidgets.forEach(function (o) {\n	          o.props.contact.name.toLowerCase().indexOf(n.toLowerCase()) > -1 ? o.mount(t.dom.contacts) : o.unmount();\n	        });\n	      } }, selectContact: { method: function method(t, n) {\n	        return this.props.selectedContact = n, t();\n	      } }, input: { method: function method(t, n) {\n	        "searchText" === n.target && this.search();\n	      } }, reachBottom: { before: function before() {}, method: function method(t) {\n	        return t();\n	      }, after: function after() {\n	        var t = this.dom.contacts.offsetHeight;this.displayContacts(this.props.currentIndex), this.dom.container.scrollTop = this.dom.contacts.offsetHeight - t;\n	      } }, focus: { method: function method(t) {\n	        return t();\n	      }, after: function after() {} } }, this.on("click", "searchText", function (t) {\n	    this.focus();\n	  }), this.on("scroll", "container", function (t) {\n	    t.target.scrollHeight - t.target.scrollTop < t.target.offsetHeight + 10 && this.reachBottom();\n	  }), this.on("input", "searchText", function (t) {\n	    this.search();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class=rc-panel>\n        <div class="rc-panel__header --flat" data-info=header>\n            <div data-info=search-box class=rc-contacts__searchBox>\n                <input class=__input type=text data-info=searchText>\n            </div>\n        </div>\n        <div class=rc-panel__content data-info=container>\n            <div class=rc-contacts__list>\n                <div data-info=pin-contacts class=rc-contacts__pins>\n                </div>\n                <div data-info=contacts>\n                    <contact-item dynamic></contact-item>\n                </div>\n            </div>\n        </div>\n    </div>\n',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["conversation-advanced"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  function t(t) {\n	    return 10 > t ? "0" + t : t;\n	  }var e = (w.transition("fade"), 0);this.props = { syncedMessages: [], toNumbers: [], toNumber: null, fromNumbers: [], fromNumber: null, width: 250, height: 400, profileImage: null, remoteVideo: null, localVideo: null, originalLoadingPeriod: 72, loadingPeriod: 72, limitOfRetry: 3 }, this.actions = { init: { method: function method() {}, after: function after() {\n	        this.props.syncedMessages = [], this.props.toNumbers = [], this.data.toNumber && (this.props.toNumber = this.data.toNumber), this.data.fromNumber && (this.props.fromNumber = this.data.fromNumber), this.data.fromNumbers && (this.props.fromNumbers = this.data.fromNumbers), this.data.width && (this.props.width = this.data.width), this.data.height && (this.props.height = this.data.height), this.data.remoteVideo && (this.props.remoteVideo = this.data.remoteVideo), this.data.localVideo && (this.props.localVideo = this.data.localVideo), this.root.firstChild.style.width = this.props.width + "px", this.root.firstChild.style.height = this.props.height + "px", this.dom.panel.style.opacity = 0, this.dom.panel.style.transition = "opacity .1s cubic-bezier(0.4, 0.0, 0.2, 1)";var t = this;w.customize(this, "dropdown", { data: {}, actions: { mount: { after: function after() {} }, getData: { method: function method() {\n	                return t.getOutboundCallerID();\n	              }, after: function after(t) {\n	                var e = this;t.forEach(function (t) {\n	                  return e.addItem(t);\n	                });\n	              } } } });\n	      } }, mount: { method: function method(t) {\n	        var e = this,\n	            n = this.props.contact = this.data.contact;this.props.toExtension = n.extension, n.msg && this.appendMessages(n.msg), this.scrollToAnchor(), this.setTitle(n.displayName), this.props.profileImage = n.profileImage, this.getAvatar().then(function (t) {\n	          return e.dom["profile-img"].src = t;\n	        });\n	      }, after: function after() {\n	        var t = this;this.dom.input.value = this.data.message || "", requestAnimationFrame(function () {\n	          return t.dom.input.focus();\n	        }), setTimeout(function () {\n	          return t.dom.panel.style.opacity = 1;\n	        }, 125);\n	      } }, unmount: { after: function after() {\n	        e = 0;\n	      } }, setTitle: { after: function after(t) {\n	        this.dom.header.textContent = t;\n	      } }, send: { before: function before() {\n	        this.props.message = this.dom.input.value, this.dom.input.value = "";var t = new Date(),\n	            e = this.addBubble(null, "SMS", this.props.message, "Outgoing", t.getHours() + ":" + t.getMinutes() + ":" + t.getSeconds());return this.scrollToBottom(), e;\n	      }, method: function method(t, e) {\n	        var n = this;return this.props.fromNumber = this.data.fromNumber || this.props.fromNumber, this.props.toNumber = this.data.toNumber || this.props.toNumber, t().then(function (t) {\n	          return e.setAttribute("data-id", t.id), n.unconfirm = n.unconfirm || [], n.unconfirm.push(e), t;\n	        })["catch"](function (t) {\n	          return e.parentNode.removeChild(e);\n	        });\n	      }, after: function after(t) {} }, addBubble: { after: function after(t, e, n, o, i, s) {\n	        var r,\n	            a = "Inbound" === o,\n	            c = this.props.contact.msg && this.props.contact.msg.find(function (e) {\n	          return e.id === t;\n	        });return "SMS" === e || "Pager" === e ? r = this.createSMSTemplate(t, n, a, i) : "VoiceMail" === e ? r = this.createVoiceMailTemplate(t, n, a, i) : "Voice" === e ? r = this.createCallLogTemplate(t, n, a, i) : "Fax" === e && (r = this.createFaxTemplate(t, n, a, i)), c && (c.dom = r, this.markBubble(c)), s ? this.dom.conversations.insertBefore(r, this.dom.conversations.firstChild) : this.dom.conversations.appendChild(r), this.dom.conversations.lastChild;\n	      } }, markBubble: { method: function method(t, e) {\n	        var n = this;e.dom.addEventListener("mouseover", function (t) {\n	          if (n.props.fromNumbers) {\n	            var o = e.from,\n	                i = e.to;n.props.contact.extension == o || n.props.fromNumbers.indexOf(o) > -1 ? (n.dom["from-number"].textContent = o, n.dom["to-number"].textContent = i) : (n.dom["from-number"].textContent = i, n.dom["to-number"].textContent = o), n.props.contact.msg.filter(function (t) {\n	              return t.from == o || t.from == i || t.to == i || t.to == o;\n	            }).filter(function (t) {\n	              return t.dom;\n	            }).map(function (t) {\n	              return t.dom;\n	            }).map(function (t) {\n	              t.classList.add("conversations__conv--marked"), t.previousSibling && t.previousSibling.classList && t.previousSibling.classList.contains("conversations__conv--ts") && t.previousSibling.classList.add("conversations__conv--marked");\n	            });\n	          }\n	        }), e.dom.addEventListener("mouseout", function (t) {\n	          if (n.props.fromNumbers) {\n	            var o = e.from,\n	                i = e.to;n.props.contact.extension == o || n.props.fromNumbers.indexOf(o) > -1 ? (n.dom["from-number"].textContent = o, n.dom["to-number"].textContent = i) : (n.dom["from-number"].textContent = i, n.dom["to-number"].textContent = o), n.props.contact.msg.filter(function (t) {\n	              return t.dom;\n	            }).map(function (t) {\n	              return t.dom;\n	            }).map(function (t) {\n	              t.classList.remove("conversations__conv--marked"), t.previousSibling && t.previousSibling.classList && t.previousSibling.classList.contains("conversations__conv--marked") && t.previousSibling.classList.remove("conversations__conv--marked");\n	            });\n	          }\n	        });\n	      } }, createSMSTemplate: { method: function method(t, e, n, o, i) {\n	        var s = document.createElement("div");return s.innerHTML = "<div class=\'clearfix conversations__conv\'>\\n                                <div\\n                                    data-tooltip=\'" + i + "\' \\n                                    class=\'conversations__bubble " + (o ? "conversations__bubble--opponent" : "conversations__bubble--self") + " \'>\\n                                    " + n + "\\n                                </div>\\n                            </div>", s.firstChild;\n	      } }, createFaxTemplate: { method: function method(t, e, n, o, i) {\n	        if ("Outgoing Fax" === n) return this.createSMSTemplate(e, n, o, i);this.props.transformee = n.uri;var s = document.createElement("div");return s.innerHTML = "<div class=\'clearfix conversations__conv\'>\\n                                <div\\n                                    data-tooltip=\'" + i + "\'\\n                                    class=\'conversations__bubble " + (o ? "conversations__bubble--opponent" : "conversations__bubble--self") + " --voice voice-bubble\'>\\n\\n                                    <a target=\\"_blank\\" href=\'" + this.transformURL() + "\'>\\n                                        <span class=\'icon-uniCB\'></span>\\n                                    </a>\\n                                </div>\\n                            </div>", s.firstChild;\n	      } }, createVoiceMailTemplate: { method: function method(t, e, n, o, i) {\n	        var s = this,\n	            r = null,\n	            a = (this.transformURL(), document.createElement("div"));a.innerHTML = "<div class=\'clearfix conversations__conv\'>\\n                                <div\\n                                    data-tooltip=\'" + i + "\'\\n                                    class=\' conversations__bubble \\n                                            " + (o ? "conversations__bubble--opponent" : "conversations__bubble--self") + " \\n                                            conversations__bubble--voice \\n                                            voice-bubble\'>\\n                                    <span class=\'voice-bubble__play icon-uniA5\'></span>\\n                                    <span class=\'voice-bubble__duration\'>" + n.vmDuration + " s</span>\\n                                </div>\\n                            </div>";var c = a.firstChild.querySelector(".voice-bubble"),\n	            d = 1;2 * n.vmDuration > 167 ? d = 2 * n.vmDuration / 167 : 2 * n.vmDuration < 65 && (d = 2 * n.vmDuration / 65);var u = 2 * n.vmDuration / d,\n	            m = !1;return c.style.width = u + "px", c.addEventListener("click", function (t) {\n	          r || (s.props.transformee = n.uri, r = new Audio(s.transformURL()));var e;m ? r.pause() : r.play(), r.addEventListener("pause", function (t) {\n	            m = !1;\n	          }), r.addEventListener("playing", function (t) {\n	            m = !0, e = requestAnimationFrame(function n() {\n	              if (m) {\n	                var t = 2 * r.currentTime / d;c.style.background = "linear-gradient( 90deg, #eee " + t + "px, white " + t + "px, white )", requestAnimationFrame(n);\n	              }\n	            });\n	          });\n	        }), a.firstChild;\n	      } }, createCallLogTemplate: { method: function method(t, e, n, o, i) {\n	        var s = this,\n	            r = document.createElement("div");if ("string" == typeof n) r.innerHTML = "<div class=\'clearfix conversations__conv\'>\\n                                    <div\\n                                        data-tooltip=\'" + i + "\'\\n                                        class=\'conversations__bubble " + (o ? "conversations__bubble--opponent" : "conversations__bubble--self") + " \\n                                            conversations__bubble--log\'>\\n                                        <span class=\'bubble--log icon-uniAE\'>\\n                                        <span>" + n + "</span>\\n                                    </div>\\n                                </div>", r = r.firstChild;else {\n	          r.innerHTML = "<div class=\'clearfix conversations__conv\'>\\n                                    <div\\n                                        data-tooltip=\'" + i + "\'\\n                                        class=\'conversations__bubble " + (o ? "conversations__bubble--opponent" : "conversations__bubble--self") + " \\n                                            conversations__bubble--log\'>\\n                                        <span class=\'bubble--log icon-uniAE\'>\\n                                        <span>Phone Call</span>\\n                                    </div>\\n                                </div>", this.props.fileURL = n.uri;this.getFileInfo().then(function (t) {\n	            if (t.duration && 0 != t.duration) {\n	              t.vmDuration = t.duration, t.uri = t.contentUri;var n = s.createVoiceMailTemplate(e, t, o, i);r.innerHTML = "", r.appendChild(n);\n	            }\n	          })["catch"](function (t) {\n	            return console.error(t);\n	          });r.addEventListener("click", function (t) {\n	            s.props.transformee = n.contentUri;var e = new Audio(s.transformURL());e.play();\n	          });\n	        }return r;\n	      } }, reachTop: { before: function before() {}, method: function method(t) {\n	        return this.isLoading ? !1 : (this.isLoading = !0, this.dom.loading.classList.remove("display-none"), t());\n	      }, after: function after(t) {\n	        if (t && (this.isLoading = !1, this.dom.loading.classList.add("display-none")), t && t.length) {\n	          var n = this.dom.conversations.offsetHeight - this.dom.container.scrollTop;this.prependMessages(t.slice().reverse(), !1), this.dom.container.scrollTop = this.dom.conversations.offsetHeight - n, e = 0, this.props.loadingPeriod = this.props.originalLoadingPeriod;\n	        } else if (t && !t.length) {\n	          if (e++ > this.props.limitOfRetry) return;this.props.loadingPeriod *= 10, console.log(this.props.loadingPeriod), this.reachTop();\n	        }\n	      } }, addTimestamp: { method: function method(t, e, n) {\n	        var o = document.createElement("div");o.innerHTML = "<div class=\'clearfix conversations__conv conversations__conv--ts\'>\\n                                <div class=\'timestamp\'>\\n                                    " + e + "\\n                                </div>\\n                            </div>", n ? this.dom.conversations.insertBefore(o.firstChild, this.dom.conversations.firstChild) : this.dom.conversations.appendChild(o.firstChild);\n	      } }, parseMessages: { method: function method(e, n, o) {\n	        var i = this;n.map(function (e) {\n	          var n = new Date(e.time);return e.displayTime = ("\\n                    " + t(n.getHours()) + ":\\n                    " + t(n.getMinutes()) + ":\\n                    " + t(n.getSeconds()) + "\\n                    ").trim(), e.status.sendConfirmed = !0, e.status.receiveConfirmed = !0, e;\n	        }).forEach(function (t) {\n	          i.addBubble(t.id, t.type, t.subject, t.direction, t.displayTime, o);var e = new Date(t.time),\n	              n = e.getDate(),\n	              s = e.getMonth() + 1;(!o && n > i.props.convDate && s >= i.props.convMonth || o && n < i.props.convDate && s <= i.props.convMonth) && i.addTimestamp(s + "/" + n, o), i.props.convDate = n, i.props.convMonth = s;\n	        });\n	      } }, appendMessages: { method: function method(t, e, n) {\n	        e && this.parseMessages(e, !1);\n	      }, after: function after(t) {\n	        var e = arguments.length <= 1 || void 0 === arguments[1] ? !0 : arguments[1];e && this.scrollToBottom();\n	      } }, prependMessages: { before: function before() {}, method: function method(t, e, n) {\n	        this.props.contact.msg = this.props.contact.msg || [], e && this.parseMessages(e, !0);\n	      }, after: function after(t) {\n	        var e = arguments.length <= 1 || void 0 === arguments[1] ? !0 : arguments[1];e && this.scrollToBottom();\n	      } }, addIncomingMessages: { method: function method(t) {\n	        var e = this;this.props.contact.msg = this.props.contact.msg || [], console.log("incoming"), this.parseMessages(this.props.contact.msg.filter(function (t) {\n	          return !t.status.receiveConfirmed;\n	        }).filter(function (t) {\n	          return -1 === e.props.syncedMessages.indexOf(t.id);\n	        }).map(function (t) {\n	          return e.props.syncedMessages.push(t.id), t;\n	        }).filter(function (t) {\n	          return "Inbound" === t.direction;\n	        }), !1);\n	      }, after: function after() {\n	        this.scrollToBottom();\n	      } }, confirmMessages: { method: function method(t) {\n	        var e = this;return this.unconfirm ? (this.props.contact.msg = this.props.contact.msg || [], this.props.contact.msg.filter(function (t) {\n	          return !t.status.sendConfirmed;\n	        }).map(function (t) {\n	          var n = e.unconfirm.findIndex(function (e) {\n	            return e.getAttribute("data-id") == t.id;\n	          }),\n	              o = e.unconfirm[n] || null;return o && (o.removeAttribute("data-id"), t.dom = o, t.status.sendConfirmed = !0, e.unconfirm.splice(n, 1), e.markBubble(t)), o;\n	        })) : [];\n	      } }, getAvatar: { method: function method(t) {\n	        return t();\n	      } }, transformURL: { method: function method(t) {\n	        return t();\n	      } }, getFileInfo: { method: function method(t) {\n	        return t();\n	      } }, scrollToAnchor: { after: function after() {\n	        var t,\n	            e = this;this.data.anchorContent && (t = this.props.contact.msg.find(function (t) {\n	          return t.id == e.data.anchorContent.id;\n	        })) && (this.dom.container.scrollTop = t.dom.offsetTop - t.dom.offsetHeight);\n	      } }, warnBubble: { after: function after(t) {} }, scrollToBottom: { after: function after() {\n	        this.dom.container.scrollTop = this.dom.container.scrollHeight;\n	      } }, setOutboundCallerID: { method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        this.props.fromNumber || this.setSender(t[0]), this.setSenderCandidates(t);\n	      } }, queryContacts: { method: function method(t, e) {\n	        return this.props.to = e, t();\n	      } }, setSender: { method: function method(t, e) {\n	        this.props.fromNumber = e;\n	      } }, setSenderCandidates: { method: function method(t, e) {\n	        this.props.fromNumbers = e;\n	      } }, setReceiver: { method: function method(t, e) {\n	        this.props.toNumber = e;\n	      } }, setReceiverCandidates: { method: function method(t, e) {\n	        this.props.toNumbers = e;\n	      } }, togglePhoneModal: { before: function before() {\n	        this.dom["phone-mask"].classList.toggle("display-none");\n	      } }, callout: { method: function method(t) {\n	        return t();\n	      } }, back: { after: function after() {} } }, this.on("click", function (t) {\n	    t.target === this.dom.back && this.back(), t.target !== this.dom.callout && t.target.parentNode !== this.dom.callout || this.callout();\n	  }), this.on("keydown", function (t) {\n	    t.target === this.dom.input && 13 === t.keyCode && (this.send(), t.preventDefault());\n	  }), this.on("scroll", function (t) {\n	    t.target === this.dom.container && 0 === t.target.scrollTop && this.reachTop();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class="rc-panel rc-conversation">\n        <div data-info=header-wrapper class="rc-panel__header rc-panel__header--colored">\n            <span class="close icon-uni3E" data-info=back></span>\n            <div class=header>\n                <div class=avatar-wrapper>\n                    <img class=avatar data-info=profile-img src="">\n                </div>\n                <div class=header-title data-info=header></div>\n            </div>\n        </div>\n        <div class="rc-panel__content container" data-info=panel>\n            <div class="bar clearfix">\n                <div class=hint data-info=to-number>to</div>\n                <div class="hint hint--right" data-info=from-number>from</div>\n            </div>\n            <div class=content data-info=container>\n                <div class="conversations__loading display-none" data-info=loading>\n                    loading...\n                </div>\n                <div class=conversations data-info=conversations>\n                </div>\n            </div>\n            <div class=textarea-wrapper>\n                <textarea data-info=input placeholder=messages...></textarea>\n                <button class="rc-button rc-button--circle rc-button--positive callout" data-info=callout>\n                    <span class=icon-ActionButtons_Filters></span>\n                </button>\n            </div>\n        </div>\n        <div class="mask display-none" data-info=phone-mask>\n            <div class=modal data-info=phone-modal>\n                <h2>\n                    <span class="voice-bubble__play icon-uniAE"></span>\n                    <span>Phone call</span>\n                </h2>\n                <div>\n                    <dropdown data-info=from-number-dropdown></dropdown>\n                    <dropdown data-info=to-number-dropdown></dropdown>\n                </div>\n                <button class="rc-button rc-button--round rc-button--positive">Call out</button>\n            </div>\n        </div>\n    </div>\n',style:"/* rc-input.--round, rc-button.--round */\n\n/* rc-panel */\n\n/* TODO */\n.rc-conversation {\n    background-color: #fff;\n}\n.rc-conversation .close {\n    position: absolute;\n    cursor: pointer;\n}\n.rc-conversation .container {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n\n    /* Adjust all conversation related font size */\n    font-size: .8em;\n    -webkit-transition: -webkit-transform .2s ease-in;\n    transition: -webkit-transform .2s ease-in;\n    transition: transform .2s ease-in;\n    transition: transform .2s ease-in, -webkit-transform .2s ease-in;\n}\n.rc-conversation .content {\n    overflow: auto;\n    height: 100%;\n}\n.rc-conversation .textarea-wrapper {\n    position: relative;\n    width: 100%;\n}\n.rc-conversation .textarea-wrapper > textarea {\n    padding: .5em .7em;\n    width: 100%;\n    border: 0;\n    border-top: 1px solid #bdc3c7;\n    resize: none;\n}\n.rc-conversation .bar {\n    margin-bottom: 5px;\n}\n.rc-conversation .hint {\n    padding: .5em .7em;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n\n    /* overlay bubbles */\n    float: left;\n    position: relative;\n    width: 48%;\n    text-align: center;\n    font-size: .9em\n}\n.rc-conversation .hint--right {\n    float: right;\n}\n.rc-conversation .callout {\n    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n    position: absolute;\n    bottom: 10px;\n    right: 10px;\n    width: 40px;\n    height: 40px;\n    -webkit-transition: all 0.3s cubic-bezier(.25,.8,.25,1);\n    transition: all 0.3s cubic-bezier(.25,.8,.25,1)\n}\n.rc-conversation .callout:hover {\n    box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);\n}\n.rc-conversation .mask {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(10,10,10,.6);\n}\n.rc-conversation .modal {\n    box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);\n    padding: .9em 1.1em;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    position: absolute;\n    z-index: 2;\n    top: 5%;\n    left: 5%;\n    width: 90%;\n    height: 50%;\n    border: 1px solid #bdc3c7;\n    border-radius: 4px;\n    background-color: #fff;\n    text-align: center\n}\n.rc-conversation .modal > .rc-button {\n    width: 100%;\n    margin-top: auto;\n    -webkit-align-self: center;\n    -ms-flex-item-align: center;\n    align-self: center;\n}\n.rc-conversation .timestamp {\n    padding: .5em .7em;\n    text-align: center;\n    color: #bdc3c7;\n}\n.rc-conversation .header {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n}\n.rc-conversation .header-title {\n    -webkit-align-self: center;\n    -ms-flex-item-align: center;\n    align-self: center;\n    font-size: 1.2em;\n}\n.rc-conversation .avatar-wrapper {\n    width: 40px;\n    height: 40px;\n    margin-right: .8em;\n    border-radius: 50%;\n    overflow: hidden;\n    line-height: 2;\n}\n.rc-conversation .avatar {\n    max-width: 100%;\n}\n.rc-conversation .conversations {}\n.rc-conversation .conversations__conv {\n    padding-left: 1em;\n    padding-right: 1em;\n}\n.rc-conversation .conversations__conv--marked {\n    background-color: #eee;\n}\n.rc-conversation .conversations__bubble {\n    padding: .5em .7em;\n    position: relative;\n    max-width: 77%;\n    word-break: break-all;\n    border: 1px solid #bdc3c7;\n    border-radius: 10px;\n    margin-bottom: 5px;\n}\n.rc-conversation .conversations__bubble--opponent {\n    float: left;\n}\n.rc-conversation .conversations__bubble--opponent:after {\n    left: 100%;\n}\n.rc-conversation .conversations__bubble--self {\n    float: right;\n    background-color: #ecf0f1;\n}\n.rc-conversation .conversations__bubble--self:after {\n    right: 100%;\n}\n.rc-conversation .conversations__bubble--log {\n\n    /*background-color: $conversation-bubble-log-color;*/\n\n    /*border-color: $conversation-bubble-log-color;*/\n}\n.rc-conversation .conversations__bubble--voice {\n\n    /*background-color: $conversation-bubble-voice-color;*/\n\n    /*border-color: $conversation-bubble-voice-color;*/\n}\n.rc-conversation .conversations__bubble:hover {}\n.rc-conversation .conversations__bubble:hover:after {\n    box-sizing: border-box;\n    width: 60px;\n    position: absolute;\n    z-index: 2;\n    content: attr(data-tooltip);\n\n    /* centering */\n    top: 3px;\n    background-color: #000;\n    color: #fff;\n    font-size: .8em;\n    border-radius: 2px;\n    padding: .5em .7em;\n    text-align: center;\n\n    /*min-width: 100%;*/\n    word-break: normal;\n}\n.rc-conversation .conversations__timestamp {\n    text-align: center;\n    color: #bdc3c7;\n}\n.rc-conversation .conversations__loading {\n    padding: .5em .7em;\n    text-align: center;\n}\n.rc-conversation .voice-bubble {\n    min-width: 65px;\n    cursor: pointer;\n    -webkit-transition: background .1s ease-in-out;\n    transition: background .1s ease-in-out\n}\n.rc-conversation .voice-bubble__play {}\n.rc-conversation .voice-bubble__duration {}\n\n",
imports:{scripts:["https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.3.0/js/md5.min.js"],styles:[]},options:{scopedStyle:!1}},__w_widgets["conversation-item-voice"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class=clearfix>\n    <div data-tooltip=$ class="conversations__bubble --self">\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets.conversation={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  var t = w.transition("fade");this.actions = { init: { method: function method() {}, after: function after() {\n	        var t = this;w.customize(this, "contact-picker", { data: { contact: t.data.toNumber }, actions: { autoComplete: { method: function method() {\n	                return t.queryContacts(this.props.inputValue);\n	              } } } }), w.customize(this, "dropdown", { data: { defaultValue: t.data.fromNumber }, actions: { getData: { method: function method() {\n	                return t.getOutboundCallerID();\n	              }, after: function after(t) {\n	                var e = this;t.forEach(function (t) {\n	                  return e.addItem(t);\n	                });\n	              } }, switchTitle: { method: function method(e) {\n	                t.props.fromNumber = e;\n	              } } } });\n	      } }, mount: { method: function method() {\n	        this.data["new"] || (this.refs["contact-picker"].disable(), this.refs.dropdown.disable());\n	      }, after: function after() {\n	        var e = this;this.refs.dropdown.getData(), this.dom.input.value = this.data.message || "", t.init(this.root), t["in"](this.root, { after: function after() {\n	            return e.refs["contact-picker"].focus();\n	          } });\n	      } }, enter: { method: function method(t, e) {\n	        13 === e.keyCode && (this.send(), e.preventDefault());\n	      } }, send: { before: function before() {\n	        this.props.message = this.dom.input.value, this.dom.input.value = "";var t = new Date(),\n	            e = this.addBubble(this.props.message, "Outgoing", t.getHours() + ":" + t.getMinutes() + ":" + t.getSeconds());return this.scrollToBottom(), e;\n	      }, method: function method(t, e) {\n	        var n = this;return this.props.fromNumber = this.data.fromNumber || this.props.fromNumber, this.props.toNumber = this.data.toNumber || this.refs["contact-picker"].dom.input.value, t().then(function (t) {\n	          return e.setAttribute("data-id", t.id), n.unconfirm = n.unconfirm || [], n.unconfirm.push(e), t;\n	        })["catch"](function (t) {\n	          return e.parentNode.removeChild(e);\n	        });\n	      }, after: function after(t) {} }, addBubble: { after: function after(t, e, n, o) {\n	        var i = "Inbound" === e,\n	            r = "<div class=\'clearfix\'>\\n                                    <div\\n                                        data-tooltip=\'" + n + "\' \\n                                        class=\'conversations__bubble " + (i ? "--opponent" : "--self") + " \'>\\n                                        " + t + "\\n                                    </div>\\n                                </div>",\n	            s = document.createElement("div");return s.innerHTML = r, o ? this.dom.conversations.insertBefore(s.childNodes[0], this.dom.conversations.firstChild) : this.dom.conversations.appendChild(s.childNodes[0]), this.dom.conversations.lastChild;\n	      } }, disable: { after: function after() {\n	        this.refs["contact-picker"].disable(), this.refs.dropdown.disable();\n	      } }, scroll: { method: function method(t, e) {\n	        0 === e.target.scrollTop && this.reachTop();\n	      } }, reachTop: { before: function before() {}, method: function method(t) {\n	        var e = this;if (!this.isLoading) return this.isLoading = !0, this.dom.loading.classList.remove("display-none"), t().then(function (t) {\n	          return e.isLoading = !1, e.dom.loading.classList.add("display-none"), t;\n	        });\n	      }, after: function after(t) {\n	        if (t) {\n	          var e = this.dom.conversations.offsetHeight;this.prependMessages(t, !1), this.dom.container.scrollTop = this.dom.conversations.offsetHeight - e;\n	        }\n	      } }, appendMessages: { method: function method(t, e, n) {\n	        var o = this;e && e.map(function (t) {\n	          var e = new Date(t.lastModifiedTime);return t.time = e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds(), t;\n	        }).forEach(function (t) {\n	          return o.addBubble(t.subject, t.direction, t.time);\n	        });\n	      }, after: function after(t) {\n	        var e = arguments.length <= 1 || void 0 === arguments[1] ? !0 : arguments[1];e && this.scrollToBottom();\n	      } }, prependMessages: { before: function before() {}, method: function method(t, e, n) {\n	        var o = this;e && e.map(function (t) {\n	          var e = new Date(t.lastModifiedTime);return t.time = e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds(), t;\n	        }).forEach(function (t) {\n	          return o.addBubble(t.subject, t.direction, t.time, !0);\n	        });\n	      }, after: function after(t) {\n	        var e = arguments.length <= 1 || void 0 === arguments[1] ? !0 : arguments[1];e && this.scrollToBottom();\n	      } }, warnBubble: { after: function after(t) {} }, scrollToBottom: { after: function after() {\n	        this.dom.container.scrollTop = this.dom.container.scrollHeight;\n	      } }, getOutboundCallerID: { method: function method(t) {\n	        return t();\n	      } }, queryContacts: { method: function method(t, e) {\n	        return this.props.to = e, t();\n	      } }, addIncomingMessages: { method: function method(t, e) {\n	        var n = this;e.filter(function (t) {\n	          return "Alive" === t.availability;\n	        }).filter(function (t) {\n	          return "Received" === t.messageStatus;\n	        }).filter(function (t) {\n	          return "Inbound" === t.direction;\n	        }).filter(function (t) {\n	          return "Unread" === t.readStatus;\n	        }).map(function (t) {\n	          console.log(t);var e = new Date(t.lastModifiedTime);return t.time = e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds(), t;\n	        }).forEach(function (t) {\n	          return n.addBubble(t.subject, t.direction, t.time);\n	        });\n	      }, after: this.scrollToBottom }, confirmMessages: { method: function method(t, e) {\n	        return this.unconfirm && e ? this.unconfirm.filter(function (t) {\n	          return e.map(function (t) {\n	            return t.id;\n	          }).indexOf(parseInt(t.getAttribute("data-id"))) > -1;\n	        }).forEach(function (t) {\n	          return t.removeAttribute("data-id");\n	        }) : [];\n	      } } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class="rc-panel rc-conversation">\n        <div class="rc-panel__header --colored" data-info=header>\n            <contact-picker data-info=contact-picker></contact-picker>\n        </div>\n        <div class="rc-panel__content rc-conversation__container" data-info=panel>\n            <dropdown class="" data-info=dropdown></dropdown>\n            <div class=rc-conversation__content data-info=container data-event=scroll:scroll>\n                <div class="conversations__loading display-none" data-info=loading>\n                    loading...\n                </div>\n                <div class=conversations data-info=conversations>\n                </div>\n            </div>\n            <div class=rc-conversation__textarea-wrapper>\n                <textarea data-info=input data-event=keydown:enter placeholder=messages...></textarea>\n            </div>\n        </div>\n    </div>\n',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["dial-pad"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.data = { autoComplete: !0, outboundID: !0 }, this.props = { fromNumber: null, toNumber: null, isListenToKeyboard: !1, remoteVideo: null, localVideo: null, pad: !0 }, this.actions = { init: { before: function before() {}, method: function method() {}, after: function after() {\n	        var t = this,\n	            o = this.data;o.color, o.lang, o.logo;this.props.remoteVideo = this.data.remoteVideo, this.props.localVideo = this.data.localVideo, this.data.pad && (this.props.pad = this.data.pad), this.props.pad || this.dom.container.classList.add("display-none"), w.customize(this, "contact-picker", { data: { whiteList: [this.dom["dial-button-0"], this.dom["dial-button-1"], this.dom["dial-button-2"], this.dom["dial-button-3"], this.dom["dial-button-4"], this.dom["dial-button-5"], this.dom["dial-button-6"], this.dom["dial-button-7"], this.dom["dial-button-8"], this.dom["dial-button-9"]] }, actions: { autoComplete: { method: function method() {\n	                return t.data.autoComplete ? (t.props.toNumber !== this.dom.input.value && t.numberChange(), t.queryContacts(this.props.inputValue)) : [];\n	              } }, setInput: { after: function after() {\n	                t.props.toNumber !== this.dom.input.value && t.numberChange();\n	              } } } }), w.customize(this, "dropdown", { actions: { getData: { method: function method() {\n	                return t.getOutboundCallerID();\n	              } }, switchTitle: { method: function method(o) {\n	                t.props.fromNumber = o;\n	              } } } });\n	      } }, mount: { before: function before() {}, method: function method() {}, after: function after() {\n	        var t = this;this.refs.dropdown.getData(), requestAnimationFrame(function () {\n	          return t.refs["contact-picker"].focus();\n	        }), this.data.outboundID || this.dom.dropdown.classList.add("display-none"), this.listenToKeyboard(!0);\n	      } }, unmount: { method: function method(t) {\n	        this.listenToKeyboard(!1);\n	      } }, dialing: { method: function method(t, o) {\n	        var i = this.refs["contact-picker"];return i.appendInput(o), i.autoComplete(), this.props.toNumber = i.dom.input.value, t();\n	      }, after: function after() {\n	        this.refs["contact-picker"].dom.input.focus();\n	      } }, callout: { before: function before() {\n	        this.dom.callout.classList.add("rc-button--active");\n	      }, method: function method(t, o) {\n	        if (console.log("callout dialpad"), !this.props.toNumber || !this.props.fromNumber) throw console.error("from- or to-Number is missing."), Error("from- or to-Number is missing.");var i = this.refs["contact-picker"];return this.props.toNumber = i.dom.input.value, t();\n	      }, after: function after() {\n	        var t = this;console.log("callout dialpad after"), setTimeout(function () {\n	          return t.dom.callout.classList.remove("rc-button--active");\n	        }, 1e3);\n	      } }, disable: { method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        this.dom["disabled-mask"].classList.remove("display-none"), this.dom.container.classList.add("blur"), t && (this.dom["disabled-mask-text"].textContent = t);\n	      } }, getOutboundCallerID: { method: function method(t) {\n	        return t();\n	      } }, queryContacts: { method: function method(t, o) {\n	        return this.props.toNumber = o, t();\n	      } }, number: { method: function method(t, o) {\n	        this.refs["contact-picker"].setInput(o), this.props.toNumber !== this.refs["contact-picker"].dom.input.value && this.numberChange();\n	      } }, numberChange: { method: function method(t) {\n	        this.props.toNumber = this.refs["contact-picker"].dom.input.value;\n	      } }, listenToKeyboard: { method: function method(t, o) {\n	        return this.props.isListenToKeyboard = !!o, t();\n	      } } }, this.on("click", function (t) {\n	    var o = this;[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, "#", "*"].forEach(function (i) {\n	      t.target !== o.dom["dial-button-" + i] && t.target.parentNode !== o.dom["dial-button-" + i] || o.dialing(i);\n	    }), t.target !== this.dom.callout && t.target.parentNode !== this.dom.callout || this.callout();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class="rc-panel rc-dial-pad">\n        <div class="rc-panel__header rc-panel__header--colored" data-info=header>\n            <contact-picker data-info=contact-picker></contact-picker>\n        </div>\n        <button class="rc-button rc-button--circle call-button call-button--color" data-info=callout>\n            <span class=icon-ActionButtons_Filters></span>\n        </button>\n        <div class=pad-container data-info=container>\n            <div class=rc-panel__content>\n                <dropdown data-info=dropdown></dropdown>\n                <div data-info=dialing-panel class=margin-top-1>\n                    <div class=rc-dial-pad__line>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-1>\n                            <div class=dial-button__number>1</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-2>\n                            <div class=dial-button__number>2</div>\n                            <div class=dial-button__symbol>ABC</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-3>\n                            <div class=dial-button__number>3</div>\n                            <div class=dial-button__symbol>DEF</div>\n                        </button>\n                    </div>\n                    <div class=rc-dial-pad__line>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-4>\n                            <div class=dial-button__number>4</div>\n                            <div class=dial-button__symbol>GHI</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-5>\n                            <div class=dial-button__number>5</div>\n                            <div class=dial-button__symbol>JKL</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-6>\n                            <div class=dial-button__number>6</div>\n                            <div class=dial-button__symbol>MNO</div>\n                        </button>\n                    </div>\n                    <div class=rc-dial-pad__line>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-7>\n                            <div class=dial-button__number>7</div>\n                            <div class=dial-button__symbol>PQRS</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-8>\n                            <div class=dial-button__number>8</div>\n                            <div class=dial-button__symbol>TUV</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-9>\n                            <div class=dial-button__number>9</div>\n                            <div class=dial-button__symbol>WXYZ</div>\n                        </button>\n                    </div>\n                    <div class=rc-dial-pad__line>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-*>\n                            <div class=dial-button__number>*</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-0>\n                            <div class=dial-button__number>0</div>\n                            <div class=dial-button__symbol>+</div>\n                        </button>\n                        <button class="rc-button rc-button--circle dial-button dial-button--color" data-info=dial-button-#>\n                            <div class=dial-button__number>#</div>\n                        </button>\n                    </div>\n                </div>\n            </div>\n            \n        </div>\n        <div class="rc-dial-pad__mask display-none" data-info=disabled-mask>\n            <p data-info=disabled-mask-text>Your account doesn\'t not have Web Phone permission.</p>\n        </div>\n    </div>\n',style:"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-dial-pad .blur {\n    filter: blur(2px);\n    -webkit-filter: blur(2px);\n}\n.rc-dial-pad .call-button {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    width:  3em;\n    height: 3em;\n    /* 1: 0.6, same as the panel width: panel height*/\n    background-color:   #2ecc71;\n    border-color:       #2ecc71;\n}\n.rc-dial-pad .call-button > span {\n    color: #fff;\n    font-size: 1.3em;\n}\n.rc-dial-pad .call-button:hover {\n    box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);\n}\n.rc-dial-pad .pad-container {\n    height: 100%;\n}\n.rc-dial-pad__line {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n}\n.rc-dial-pad__line > .dial-button {\n    margin: 4px 8px;\n    width: 3.2em;\n    height: 3.2em;\n    color: #2196F3;\n    border-color: #2196F3;\n}\n.rc-dial-pad__line > .dial-button > .dial-button__number {\n    font-size: 1.3em;\n}\n.rc-dial-pad__line > .dial-button > .dial-button__symbol {\n    font-size: .5em;\n}\n.rc-dial-pad__line > .dial-button:hover {\n    background-color: #2196F3;\n    color: #fff;\n}\n.rc-dial-pad__mask {\n    position: absolute;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.rc-dial-pad__mask > p {\n    font-weight: bold;\n    text-align: center;\n}\n.rc-dial-pad__mask::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets.dropdown={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  var t = w.transition("enlarge");this.props = { items: [] }, this.actions = { init: { after: function after() {\n	        this.data.defaultValue && this.switchTitle(this.data.defaultValue), t.init(this.dom.list), this.data.height && (this.dom.dropdown.style.height = this.data.height + "px");\n	      } }, mount: { after: function after() {\n	        var t = this;document.addEventListener("click", function (i) {\n	          for (var n = i.target; n.parentNode;) {\n	            if (n = n.parentNode, n === t.root) return;\n	          }\n	        });\n	      } }, collapse: { after: function after() {\n	        t.toggle(this.dom.list), this.dom["dropdown-icon"].classList.toggle("icon-uni2462"), this.dom["dropdown-icon"].classList.toggle("icon-uni2463");\n	      } }, hide: { after: function after() {\n	        t.out(this.dom.list), this.dom["dropdown-icon"].classList.remove("icon-uni2462"), this.dom["dropdown-icon"].classList.add("icon-uni2463");\n	      } }, getData: { method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        var i = this;this.props.items && this.props.items.length || (this.props.items = t, t = t.map(function (t) {\n	          return 0 === t.indexOf("+") ? t.substring(1) : t;\n	        }), t.forEach(function (t) {\n	          return i.addItem(t);\n	        }), this.switchTitle(t[0]));\n	      } }, addItem: { after: function after(t) {\n	        var i = this,\n	            n = document.createElement("div");n.classList.add("rc-list__item", "rc-dropdown__item"), n.textContent = t, n.addEventListener("click", function (n) {\n	          i.switchTitle(t);\n	        }), this.dom.list.appendChild(n);\n	      } }, getSelected: { method: function method() {\n	        return this.dom["dropdown-text"].textContent;\n	      } }, disable: { method: function method() {\n	        this.dom.dropdown.disabled = !0;\n	      } }, switchTitle: { method: function method(t, i) {\n	        t(i);\n	      }, after: function after(t) {\n	        this.dom["dropdown-text"].textContent = t, this.hide();\n	      } } }, this.on("click", "dropdown", function () {\n	    this.collapse();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class=rc-dropdown>\n        <button class="rc-dropdown__trigger rc-button" data-info=dropdown>\n            <span>From: </span>\n            <span data-info=dropdown-text></span>\n            <span data-info=dropdown-icon class="icon-uni2463 rc-dropdown__icon"></span>\n        </button>\n        <div class="rc-dropdown__list rc-list" data-info=list>\n        </div>\n    </div>\n',style:"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-dropdown {\n    /* used as a positioned reference */\n    position: relative\n}\n.rc-dropdown__trigger {\n    padding: .5em .7em;\n    width: 100%;\n    background: inherit;\n    border: 0;\n    border-bottom: 1px solid #bdc3c7;\n    font-size: .8em\n}\n.rc-dropdown__list {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    position: absolute;\n    width: 100%;\n    max-height: 200px;\n    overflow: auto;\n    background: #fff\n}\n.rc-dropdown__item {\n    padding: .9em 1.1em;\n    font-size: .8em;\n    text-align: center;\n    cursor: pointer\n}\n.rc-dropdown__item:hover {\n    background: #ecf0f1\n}\n.rc-dropdown__icon {\n    margin-left: 5px\n}\n\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["message-detail"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = { init: {}, mount: {} };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class=rc-panel>\n    <div class=rc-panel__content>\n        <div class=rc-message-detail>\n            <div>Conversation with</div>\n            <div class=rc-message-detail__contact>\n                <div class=__name>Colin Liu</div>\n                <div><span>6508370092</span></div>\n            </div>\n            <img class="rc-avatar --big rc-message-detail__avatar">\n            \n            <div>&nbsp</div>\n            <div class="rc-button --positive rc-message-detail__button">\n                Call\n            </div>\n            <div class="rc-button --positive rc-message-detail__button">\n                Send\n            </div>\n        \n        </div>\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["message-item-fax"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = {}, this.actions.init = { method: function method(t) {\n	      return t();\n	    }, after: function after(t) {\n	      var e = this,\n	          n = w.t(this.data.lang);w.customize(this, "message-item", { data: e.data, actions: { init: { method: function method() {\n	              return t;\n	            }, after: function after() {\n	              this.setShortText();\n	            } }, setShortText: { method: function method() {\n	              return n("message-item-fax-text");\n	            } }, viewInfo: { method: function method() {\n	              e.viewInfo();\n	            } }, enter: { method: function method() {\n	              e.enter();\n	            } } } }), this.props.message = t;\n	    } }, this.actions.viewInfo = { method: function method(t) {\n	      return t();\n	    } }, this.actions.enter = { method: function method(t) {\n	      return t();\n	    }, after: function after() {} };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',
template:"<div>\n    <message-item></message-item>\n</div>",style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["message-item-text"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = {}, this.actions.init = { method: function method(t) {\n	      return t();\n	    }, after: function after(t) {\n	      var n = this;w.customize(this, "message-item", { data: n.data, actions: { init: { method: function method() {\n	              return t;\n	            }, after: function after() {\n	              this.setShortText();\n	            } }, setShortText: { method: function method() {\n	              return t.subject;\n	            } }, viewInfo: { method: function method() {\n	              n.viewInfo();\n	            } }, enter: { method: function method() {\n	              n.enter();\n	            } } } }), this.props.message = t;\n	    } }, this.actions.viewInfo = { method: function method(t) {\n	      return t();\n	    } }, this.actions.enter = { method: function method(t) {\n	      return t();\n	    }, after: function after() {} };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:"<div>\n    <message-item></message-item>\n</div>",style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["message-item-voicemail"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = {}, this.actions.init = { method: function method(t) {\n	      return t();\n	    }, after: function after(t) {\n	      var e = this,\n	          n = w.t(this.data.lang);w.customize(this, "message-item", { data: e.data, actions: { init: { method: function method() {\n	              return t;\n	            }, after: function after() {\n	              this.setShortText();\n	            } }, setShortText: { method: function method() {\n	              return n("message-item-voicemail-text");\n	            } }, viewInfo: { method: function method() {\n	              e.viewInfo();\n	            } }, enter: { method: function method() {\n	              e.enter();\n	            } } } }), this.props.message = t;\n	    } }, this.actions.viewInfo = { method: function method(t) {\n	      return t();\n	    } }, this.actions.enter = { method: function method(t) {\n	      return t();\n	    }, after: function after() {} };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:"<div>\n    <message-item></message-item>\n</div>",style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["message-item"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  this.actions = {}, this.actions.init = { method: function method(t) {\n	      var n = t();return this.props.message = n, n;\n	    }, after: function after(t) {\n	      "Unread" === t.readStatus && (this.dom.icon.classList.add("--not-read"), this.dom.contact.classList.add("--not-read")), this.dom.icon.classList.add("--" + t.type.toLowerCase()), this.dom.time.textContent = t.time, this.dom.contact.textContent = t.contact;\n	    } }, this.actions.setShortText = { method: function method(t) {\n	      return t();\n	    }, after: function after(t) {\n	      this.dom.text.textContent = t;\n	    } }, this.actions.open = { method: function method(t) {\n	      return t();\n	    } }, this.actions.viewInfo = { method: function method(t, n) {\n	      return n.stopPropagation(), t();\n	    } }, this.actions.enter = { method: function method(t) {\n	      return t();\n	    }, after: function after() {} };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:"<div data-info=message class=rc-message-item data-event=click:open>\n    <i data-info=icon class=rc-message-item__icon></i>\n    <a class=rc-message-item__info data-event=click:viewInfo></a>\n    <span class=rc-message-item__time data-info=time></span>\n    <div class=rc-message-item__body>\n        <span class=__contact data-info=contact data-event=click:enter>\n        </span>\n        <div class=__text data-info=text data-event=click:enter>\n        </div>\n    </div>\n</div>",style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets.messages={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  function e(e, t) {\n	    e.classList.contains("--active") === !1 && (e.classList.add("--active"), t.classList.remove("--active"));\n	  }function t(e, t, s) {\n	    return w(e, { data: s.data, actions: { init: { method: function method() {\n	            return t;\n	          } }, viewInfo: { method: function method() {\n	            s.viewMessageInfo(this.props.message);\n	          } }, enter: { method: function method() {\n	            return s.enterMessage(this.props.message);\n	          } } } });\n	  }function s(e, s) {\n	    e.forEach(function (e) {\n	      var i = null;i = "Fax" === e.type ? t("message-item-fax", e, s) : "VoiceMail" === e.type ? t("message-item-voicemail", e, s) : t("message-item-text", e, s), i.mount(s.dom.messages), s.props.widgetItems.push(i);\n	    });\n	  }function i(e, t) {\n	    e.forEach(function (e) {\n	      "all" === t ? e.show() : t.indexOf(e.props.message.type.toLowerCase()) >= 0 ? e.show() : e.hide();\n	    });\n	  }var n = null;this.actions = { init: { before: function before() {\n	        this.props.widgetItems = [];\n	      }, after: function after() {\n	        w.t(this.data.lang);\n	      } }, mount: { after: function after() {\n	        this.refreshMessages();\n	      } }, enableTab: { after: function after(t, s) {\n	        e(t.target, n), n = t.target, i(this.props.widgetItems, t.target.getAttribute("data-value"));\n	      } }, refreshMessages: { method: function method(e) {\n	        return e();\n	      }, after: function after(e) {\n	        console.log(e);for (var t = this.dom.messages; t.firstChild;) {\n	          t.removeChild(t.firstChild);\n	        }s(e, this);\n	      } }, viewMessageInfo: { method: function method(e, t) {\n	        return this.props.selectedMessage = t, e();\n	      } }, enterMessage: { method: function method(e, t) {\n	        return this.props.selectedMessage = t, e();\n	      } }, compose: { before: function before() {\n	        this.dom.compose.classList.add("--active");\n	      }, method: function method(e) {\n	        return new Promise(function (t) {\n	          return setTimeout(function () {\n	            return t(e());\n	          }, 500);\n	        });\n	      }, after: function after() {\n	        var e = this;setTimeout(function () {\n	          return e.dom.compose.classList.remove("--active");\n	        }, 1e3);\n	      } } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class="rc-panel rc-messages">\n    <div class="rc-panel__header --flat">\n        <div class=rc-contacts__searchBox>\n            <input class=__input type=text data-info=searchText data-event=input:search>\n        </div>\n    </div>\n    <div class=rc-panel__content>\n        <button class="rc-button --circle compose-button" data-info=compose data-event=click:compose>\n        </button>\n        <div data-info=messages>\n            <message-item-text dynamic></message-item-text>\n            <message-item-fax dynamic></message-item-fax>\n            <message-item-voicemail dynamic></message-item-voicemail>\n        </div>\n    </div>\n</div>',style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets.notification={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	var slideDown = w.transition("slide-down");w.register(function () {\n	  this.actions = { mount: { method: function method() {}, after: function after() {\n	        slideDown["in"](this.root);\n	      } }, msg: { method: function method(t, n) {\n	        return this.dom.msg.textContent = n, t();\n	      } }, show: { method: function method(t, n, o) {\n	        var i = this;return this.mount(n), t(), new Promise(function (t) {\n	          setTimeout(function () {\n	            slideDown.out(i.root, { after: function after() {\n	                return t(i.unmount());\n	              } });\n	          }, o);\n	        });\n	      } } };\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:"<div>\n    <div class=rc-notification data-event=click:unmount>\n        <span class=rc-notification__icon></span>\n        <span class=rc-notification__text data-info=msg>Error occur</span>\n    </div>\n</div>",style:null,imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["rc-phone-incontact"]={script:"/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = \"\";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	function _interopRequireDefault(t) {\n	  return t && t.__esModule ? t : { \"default\": t };\n	}var _factory = __webpack_require__(2),\n	    _factory2 = _interopRequireDefault(_factory),\n	    _eventemitter = __webpack_require__(64),\n	    _eventemitter2 = _interopRequireDefault(_eventemitter),\n	    factory = new _factory2[\"default\"]();w.register(function () {\n	  this.actions = factory.create(\"incontact\", { init: { before: function before() {\n	        this.props.key = this.data.key, this.props.secret = this.data.secret, this.props.sandbox = \"true\" === this.data.sandbox;\n	      } }, mount: { after: function after() {\n	        var t = this;this.checkLogin().then(function (e) {\n	          if (e) t.dom[\"main-panel\"].hidden = !1, webPhone(null, { width: t.data.width, height: t.data.height });else {\n	            var a = t,\n	                n = w(\"auth-panel\", { data: { oauth: !0 }, actions: factory.create(\"auth-panel\", { login: { after: function after() {\n	                    this.unmount(), a.dom[\"main-panel\"].hidden = !1, webPhone(null, { width: this.data.width, height: this.data.height });\n	                  } } }) });n.mount(t.dom[\"auth-panel\"]);\n	          }\n	        })[\"catch\"](function (t) {\n	          return console.error(t);\n	        });\n	      } }, setSize: { method: function method() {} }, on: { method: function method() {} } });\n	});var webPhone = function webPhone(t, e) {\n	  var a = e.width,\n	      n = e.height,\n	      i = w(\"call-panel\", { data: { target: \"#call-panel\", width: a, height: n, advance: !1 }, actions: factory.create(\"call-panel\") });w(\"call-panel-incoming\", { data: { target: \"#call-panel-incoming\", width: a, height: n, remoteVideo: i.props.remoteVideo, localVideo: i.props.localVideo, simple: !0 }, actions: factory.create(\"call-panel-incoming\", { accept: { after: function after() {\n	          this.unmount(), i.setName(this.props.name), i.mount(\"#call-panel\"), i.start();\n	        } } }) });\n	};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcServices = __webpack_require__(3);\n	\n	var _rcServices2 = _interopRequireDefault(_rcServices);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function extend(base, mixin) {\n	    // FIXME: avoid create function in for loop\n	    Object.keys(mixin).forEach(function (action) {\n	        if (base[action]) {\n	            Object.keys(mixin[action]).forEach(function (hook) {\n	                var origin = base[action][hook];\n	                var mix = mixin[action][hook];\n	                base[action][hook] = function () {\n	                    var result;\n	                    if (origin) {\n	                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n	                            args[_key] = arguments[_key];\n	                        }\n	\n	                        result = origin.call.apply(origin, [this].concat(args));\n	                    }\n	                    mix.call(this);\n	                    return result;\n	                };\n	            });\n	        } else {\n	            base[action] = mixin[action];\n	        }\n	    });\n	    return base;\n	} // TODO: use dependency injection\n	\n	\n	var Factory = function Factory() {};\n	\n	Factory.prototype.create = function (type) {\n	    var mixin = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n	\n	    return extend(_rcServices2.default[type], mixin);\n	};\n	\n	exports.default = Factory;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _phoneService = __webpack_require__(12);\n	\n	var _phoneService2 = _interopRequireDefault(_phoneService);\n	\n	var _loginService = __webpack_require__(51);\n	\n	var _loginService2 = _interopRequireDefault(_loginService);\n	\n	var _callLogService = __webpack_require__(52);\n	\n	var _callLogService2 = _interopRequireDefault(_callLogService);\n	\n	var _accountService = __webpack_require__(54);\n	\n	var _accountService2 = _interopRequireDefault(_accountService);\n	\n	var _rcContactService = __webpack_require__(55);\n	\n	var _rcContactService2 = _interopRequireDefault(_rcContactService);\n	\n	var _contactSearchService = __webpack_require__(57);\n	\n	var _contactSearchService2 = _interopRequireDefault(_contactSearchService);\n	\n	var _rcContactSearchProvider = __webpack_require__(58);\n	\n	var _rcContactSearchProvider2 = _interopRequireDefault(_rcContactSearchProvider);\n	\n	var _rcMessageService = __webpack_require__(59);\n	\n	var _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n	\n	var _rcMessageProvider = __webpack_require__(60);\n	\n	var _rcMessageProvider2 = _interopRequireDefault(_rcMessageProvider);\n	\n	var _rcConferenceService = __webpack_require__(61);\n	\n	var _rcConferenceService2 = _interopRequireDefault(_rcConferenceService);\n	\n	var _rcConversationService = __webpack_require__(62);\n	\n	var _rcConversationService2 = _interopRequireDefault(_rcConversationService);\n	\n	var _blueimpMd = __webpack_require__(63);\n	\n	var _blueimpMd2 = _interopRequireDefault(_blueimpMd);\n	\n	var _rcConfig = __webpack_require__(11);\n	\n	var _rcConfig2 = _interopRequireDefault(_rcConfig);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n	\n	var dialPadSearchProviders = [_rcContactSearchProvider2.default];\n	\n	var services = {};\n	services['incontact'] = {\n	    init: {\n	        after: function after() {\n	            /// critical, inject app key & secret into service\n	            (0, _rcSdk.injectSDK)({\n	                key: this.props.key,\n	                secret: this.props.secret,\n	                sandbox: this.props.sandbox\n	            });\n	            _phoneService2.default.init({\n	                incomingAudio: _rcConfig2.default.incomingAudio,\n	                outgoingAudio: _rcConfig2.default.outgoingAudio\n	            });\n	        }\n	    },\n	    checkLogin: {\n	        method: function method() {\n	            return _loginService2.default.checkLoginStatus();\n	        }\n	    }\n	};\n	services['rcPhone'] = {\n	    init: {\n	        after: function after() {\n	            /// critical, inject app key & secret into service\n	            (0, _rcSdk.injectSDK)({\n	                key: this.props.key,\n	                secret: this.props.secret,\n	                sandbox: this.props.sandbox\n	            });\n	        }\n	    },\n	    loadData: {\n	        method: function method() {\n	            _rcMessageService2.default.subscribeToMessageUpdate();\n	            // rcMessageService.syncMessages(this.props.cachedMessageHours);\n	            _accountService2.default.getAccountInfo();\n	            _accountService2.default.getPhoneNumber();\n	            _rcContactService2.default.cacheContacts();\n	            _phoneService2.default.init({\n	                incomingAudio: _rcConfig2.default.incomingAudio,\n	                outgoingAudio: _rcConfig2.default.outgoingAudio\n	            });\n	            _callLogService2.default.getCallLogs();\n	        }\n	    },\n	    checkLogin: {\n	        method: function method() {\n	            return _loginService2.default.checkLoginStatus();\n	        }\n	    },\n	    logout: {\n	        method: function method() {\n	            return _loginService2.default.logout();\n	        }\n	    }\n	};\n	services['auth-panel'] = {\n	    login: {\n	        method: function method() {\n	            // return loginService.login(\n	            //     this.props.username,\n	            //     this.props.extension,\n	            //     this.props.password\n	            // )\n	            return _loginService2.default.oauth();\n	        }\n	    }\n	};\n	services['dial-pad'] = {\n	    mount: {\n	        after: function after() {\n	            if (!_accountService2.default.hasServiceFeature('VoipCalling')) this.disable();\n	        }\n	    },\n	    callout: {\n	        method: function method() {\n	            console.log('real call');\n	            return _phoneService2.default.call(this.props.fromNumber, this.props.toNumber, {\n	                remoteVideo: this.props.remoteVideo,\n	                localVideo: this.props.localVideo\n	            });\n	        }\n	    },\n	    queryContacts: {\n	        method: function method() {\n	            var _this = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this.props.toNumber);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    },\n	    getOutboundCallerID: {\n	        method: function method() {\n	            return _accountService2.default.getPhoneNumber().then(function () {\n	                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n	            });\n	        }\n	    }\n	};\n	\n	services['conference'] = {\n	    getConferenceInfo: {\n	        method: function method() {\n	            return _rcConferenceService2.default.getConferenceInfo();\n	        }\n	    }\n	};\n	services['call-log'] = {\n	    init: {\n	        method: function method() {\n	            return _callLogService2.default.getCallLogs();\n	        }\n	    }\n	};\n	\n	services['time-line'] = {\n	    mount: {\n	        after: function after() {\n	            var _this2 = this;\n	\n	            _rcMessageService2.default.subscribeToMessageUpdate();\n	            _rcMessageProvider2.default.onMessageUpdated(function (msg) {\n	                _this2.updateTimeline(_rcConversationService2.default.syncContent(_this2.props.contacts, msg));\n	                if (_this2.props.currentConv) {\n	                    _this2.props.currentConv.confirmMessages();\n	                    _this2.props.currentConv.addIncomingMessages();\n	                }\n	            });\n	            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n	                return _this2.props.contacts = contacts;\n	            });\n	        }\n	    },\n	    fetchData: {\n	        method: function method() {\n	            return Promise.all([_rcContactService2.default.cacheContacts(), // first one must be the contacts\n	            _rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs()]).then(function (result) {\n	                return _rcConversationService2.default.organizeContent.apply(_rcConversationService2.default, _toConsumableArray(result));\n	            });\n	        }\n	    }\n	};\n	\n	services['contacts'] = {\n	    mount: {\n	        after: function after() {\n	            this.fetchContacts();\n	        }\n	    },\n	    fetchRelatedContact: {\n	        method: function method() {\n	            var _this3 = this;\n	\n	            return Promise.all([_rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs(), _rcContactService2.default.cacheContacts()]).then(function (result) {\n	                var _result = _slicedToArray(result, 3);\n	\n	                var msgs = _result[0];\n	                var logs = _result[1];\n	                var contacts = _result[2];\n	\n	                _this3.props.contacts = contacts.reduce(function (result, contact) {\n	                    result[contact.id] = contact;\n	                    return result;\n	                }, {});\n	                return _rcConversationService2.default.getConversations(contacts, msgs, logs);\n	            }).then(function (relateContacts) {\n	                _this3.props.relateContacts = relateContacts;\n	                return relateContacts;\n	            }).then(function (relateContacts) {\n	                return Object.keys(relateContacts).map(function (index) {\n	                    // adapt to messages template format\n	                    relateContacts[index].msg[0].contact = relateContacts[index].displayName;\n	                    // for conversation-advance temaplate\n	                    relateContacts[index].msg[0].contactId = index;\n	                    return relateContacts[index].msg[0];\n	                });\n	            });\n	        }\n	    },\n	    fetchContacts: {\n	        method: function method() {\n	            var _this4 = this;\n	\n	            // var dialPadSearchFunctions = dialPadSearchProviders.map(provider => {\n	            //     return provider.searchAll();\n	            // });\n	            // return contactSearchService.query(dialPadSearchFunctions);\n	            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n	                _this4.props.contacts = contacts.reduce(function (result, contact) {\n	                    result[contact.id] = contact;\n	                    return result;\n	                }, {});\n	                return contacts.map(function (contact) {\n	                    return {\n	                        name: contact.displayName,\n	                        type: 'rc',\n	                        id: contact.id\n	                    };\n	                });\n	            }).catch(function (e) {\n	                return console.error(e);\n	            });\n	        }\n	    }\n	};\n	\n	services['conversation-advanced'] = {\n	    init: {\n	        after: function after() {}\n	    },\n	    mount: {\n	        after: function after() {\n	            var _this5 = this;\n	\n	            console.log('get account info');\n	            return _accountService2.default.getAccountInfo().then(function (info) {\n	                return _this5.props.fromExtension = info.extensionNumber;\n	            }).then(function () {\n	                _this5.setOutboundCallerID();\n	            });\n	        }\n	    },\n	    send: {\n	        method: function method() {\n	            if (this.props.toNumber === this.props.toExtension) {\n	                return _rcMessageService2.default.sendPagerMessage(this.props.message, this.props.fromExtension, this.props.toExtension);\n	            } else {\n	                return _rcMessageService2.default.sendSMSMessage(this.props.message, this.props.fromNumber, this.props.toNumber);\n	            }\n	        }\n	    },\n	    callout: {\n	        method: function method() {\n	            return _phoneService2.default.call(this.props.fromNumber, this.props.toNumber, {\n	                remoteVideo: this.props.remoteVideo,\n	                localVideo: this.props.localVideo\n	            });\n	        }\n	    },\n	    reachTop: {\n	        method: function method() {\n	            console.log('load content');\n	            return _rcConversationService2.default.loadContent(this.props.contact, this.props.loadingPeriod);\n	        }\n	    },\n	    getAvatar: {\n	        method: function method() {\n	            var _this6 = this;\n	\n	            if (!this.props.profileImage) return Promise.resolve('https://www.gravatar.com/avatar/' + (0, _blueimpMd2.default)(this.props.contact.id) + '?d=retro');\n	            return _rcSdk.RC.sdk.platform().get(this.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken())).then(function (r) {\n	                return r.response();\n	            }).then(function (r) {\n	                // Real contact, no avatar\n	                if (r.status === 204 || r.status === 404) {\n	                    var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n	                    return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n	                } else {\n	                    // Real contact, has avatar\n	                    return;\n	                    _this6.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken());\n	                }\n	            }).catch(function (e) {\n	                // Real contact, no avatar\n	                var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n	                return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n	            });\n	        }\n	    },\n	    transformURL: {\n	        method: function method() {\n	            return this.props.transformee + ('?access_token=' + _rcContactService2.default.accessToken());\n	        }\n	    },\n	    getFileInfo: {\n	        method: function method() {\n	            console.log(this.props.fileURL);\n	            return _rcSdk.RC.sdk.platform().get(this.props.fileURL).then(function (r) {\n	                return r.json();\n	            });\n	        }\n	    },\n	    setOutboundCallerID: {\n	        method: function method() {\n	            return _accountService2.default.getPhoneNumber().then(function () {\n	                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n	            });\n	        }\n	    }\n	};\n	services['call-panel'] = {\n	    init: {\n	        after: function after() {\n	            var _this7 = this;\n	\n	            _phoneService2.default.on('progress', function () {\n	                if (!_this7._mounted) {\n	                    _this7.mount(_this7.props.target);\n	                }\n	            });\n	            _phoneService2.default.on('bye', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('terminated', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('rejected', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('failed', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('accepted', function () {\n	                console.log('accept');\n	                _this7.start();\n	            });\n	        }\n	    },\n	    mount: {\n	        after: function after() {}\n	    },\n	    getContact: {\n	        method: function method() {\n	            var _this8 = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this8.props.name);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    },\n	    hangup: {\n	        method: function method() {\n	            return _phoneService2.default.hangup();\n	        }\n	    },\n	    hold: {\n	        method: function method() {\n	            return _phoneService2.default.hold(!this.props.isHold);\n	        }\n	    },\n	    mute: {\n	        method: function method() {\n	            return _phoneService2.default.mute(!this.props.isMute);\n	        }\n	    },\n	    flip: {\n	        method: function method() {\n	            return _phoneService2.default.flip(this.props.actionNumber);\n	        }\n	    },\n	    transfer: {\n	        method: function method() {\n	            return _phoneService2.default.transfer(this.props.actionNumber);\n	        }\n	    },\n	    record: {\n	        method: function method() {\n	            console.log(this.props.isRecord);\n	            return _phoneService2.default.record(!this.props.isRecord);\n	        }\n	    },\n	    park: {\n	        method: function method() {\n	            return _phoneService2.default.park();\n	        }\n	    },\n	    dtmf: {\n	        method: function method(number) {\n	            return _phoneService2.default.dtmf(this.props.dtmfNumber);\n	        }\n	    },\n	    queryContacts: {\n	        method: function method() {\n	            var _this9 = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this9.props.inputValue);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    },\n	    getOutboundCallerID: {\n	        method: function method() {\n	            return _accountService2.default.getPhoneNumber().then(function () {\n	                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n	            });\n	        }\n	    }\n	};\n	services['call-panel-incoming'] = {\n	    init: {\n	        method: function method() {\n	            var _this10 = this;\n	\n	            _phoneService2.default.on('invite', function (session) {\n	                _this10.props.session = session;\n	                var name = session.request.from.displayName || session.request.from.friendlyName.split(\"@\")[0];\n	                _this10.setName(name);\n	                _this10.mount(_this10.props.target);\n	                _phoneService2.default.on('terminated', function () {\n	                    _this10.unmount();\n	                });\n	                _phoneService2.default.on('failed', function () {\n	                    _this10.unmount();\n	                });\n	            });\n	        }\n	    },\n	    accept: {\n	        method: function method() {\n	            return _phoneService2.default.accept({\n	                remoteVideo: this.props.remoteVideo,\n	                localVideo: this.props.localVideo\n	            });\n	        }\n	    },\n	    reject: {\n	        method: function method() {\n	            return _phoneService2.default.reject();\n	        }\n	    },\n	    forward: {\n	        method: function method() {\n	            return _phoneService2.default.forward(this.props.actionNumber);\n	        }\n	    },\n	    queryContacts: {\n	        method: function method() {\n	            var _this11 = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this11.props.inputValue);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    }\n	};\n	exports.default = services;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	exports.RC = exports.injectSDK = undefined;\n	\n	var _ringcentralBundle = __webpack_require__(5);\n	\n	var _ringcentralBundle2 = _interopRequireDefault(_ringcentralBundle);\n	\n	var _rcConfig = __webpack_require__(11);\n	\n	var _rcConfig2 = _interopRequireDefault(_rcConfig);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var holder = {};\n	\n	// for dependency injection\n	var sdk = function () {\n	    return holder.sdk;\n	}();\n	\n	var injectSDK = function injectSDK(_ref) {\n	    var key = _ref.key;\n	    var secret = _ref.secret;\n	    var sandbox = _ref.sandbox;\n	\n	    holder.sdk = new _ringcentralBundle2.default({\n	        appKey: key,\n	        appSecret: secret,\n	        server: sandbox ? _ringcentralBundle2.default.server.sandbox : _ringcentralBundle2.default.server.production\n	    });\n	};\n	exports.injectSDK = injectSDK;\n	exports.RC = holder;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {\n		if(true)\n			module.exports = factory();\n		else if(typeof define === 'function' && define.amd)\n			define([], factory);\n		else if(typeof exports === 'object')\n			exports[\"SDK\"] = factory();\n		else\n			root[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"SDK\"] = factory();\n	})(this, function() {\n	return /******/ (function(modules) { // webpackBootstrap\n	/******/ 	// The module cache\n	/******/ 	var installedModules = {};\n	/******/\n	/******/ 	// The require function\n	/******/ 	function __webpack_require__(moduleId) {\n	/******/\n	/******/ 		// Check if module is in cache\n	/******/ 		if(installedModules[moduleId])\n	/******/ 			return installedModules[moduleId].exports;\n	/******/\n	/******/ 		// Create a new module (and put it into the cache)\n	/******/ 		var module = installedModules[moduleId] = {\n	/******/ 			exports: {},\n	/******/ 			id: moduleId,\n	/******/ 			loaded: false\n	/******/ 		};\n	/******/\n	/******/ 		// Execute the module function\n	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n	/******/\n	/******/ 		// Flag the module as loaded\n	/******/ 		module.loaded = true;\n	/******/\n	/******/ 		// Return the exports of the module\n	/******/ 		return module.exports;\n	/******/ 	}\n	/******/\n	/******/\n	/******/ 	// expose the modules object (__webpack_modules__)\n	/******/ 	__webpack_require__.m = modules;\n	/******/\n	/******/ 	// expose the module cache\n	/******/ 	__webpack_require__.c = installedModules;\n	/******/\n	/******/ 	// __webpack_public_path__\n	/******/ 	__webpack_require__.p = \"/build/\";\n	/******/\n	/******/ 	// Load entry module and return exports\n	/******/ 	return __webpack_require__(0);\n	/******/ })\n	/************************************************************************/\n	/******/ ([\n	/* 0 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	__webpack_require__(1);\n	module.exports = __webpack_require__(2);\n	\n	\n	/***/ },\n	/* 1 */\n	/***/ function(module, exports) {\n	\n	/* WEBPACK VAR INJECTION */(function(global) {/**\n	 * Copyright (c) 2014, Facebook, Inc.\n	 * All rights reserved.\n	 *\n	 * This source code is licensed under the BSD-style license found in the\n	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n	 * additional grant of patent rights can be found in the PATENTS file in\n	 * the same directory.\n	 */\n	\n	!(function(global) {\n	  \"use strict\";\n	\n	  var hasOwn = Object.prototype.hasOwnProperty;\n	  var undefined; // More compressible than void 0.\n	  var iteratorSymbol =\n	    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n	\n	  var inModule = typeof module === \"object\";\n	  var runtime = global.regeneratorRuntime;\n	  if (runtime) {\n	    if (inModule) {\n	      // If regeneratorRuntime is defined globally and we're in a module,\n	      // make the exports object identical to regeneratorRuntime.\n	      module.exports = runtime;\n	    }\n	    // Don't bother evaluating the rest of this file if the runtime was\n	    // already defined globally.\n	    return;\n	  }\n	\n	  // Define the runtime globally (as expected by generated code) as either\n	  // module.exports (if we're in a module) or a new, empty object.\n	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n	\n	  function wrap(innerFn, outerFn, self, tryLocsList) {\n	    // If outerFn provided, then outerFn.prototype instanceof Generator.\n	    var generator = Object.create((outerFn || Generator).prototype);\n	    var context = new Context(tryLocsList || []);\n	\n	    // The ._invoke method unifies the implementations of the .next,\n	    // .throw, and .return methods.\n	    generator._invoke = makeInvokeMethod(innerFn, self, context);\n	\n	    return generator;\n	  }\n	  runtime.wrap = wrap;\n	\n	  // Try/catch helper to minimize deoptimizations. Returns a completion\n	  // record like context.tryEntries[i].completion. This interface could\n	  // have been (and was previously) designed to take a closure to be\n	  // invoked without arguments, but in all the cases we care about we\n	  // already have an existing method we want to call, so there's no need\n	  // to create a new function object. We can even get away with assuming\n	  // the method takes exactly one argument, since that happens to be true\n	  // in every case, so we don't have to touch the arguments object. The\n	  // only additional allocation required is the completion record, which\n	  // has a stable shape and so hopefully should be cheap to allocate.\n	  function tryCatch(fn, obj, arg) {\n	    try {\n	      return { type: \"normal\", arg: fn.call(obj, arg) };\n	    } catch (err) {\n	      return { type: \"throw\", arg: err };\n	    }\n	  }\n	\n	  var GenStateSuspendedStart = \"suspendedStart\";\n	  var GenStateSuspendedYield = \"suspendedYield\";\n	  var GenStateExecuting = \"executing\";\n	  var GenStateCompleted = \"completed\";\n	\n	  // Returning this object from the innerFn has the same effect as\n	  // breaking out of the dispatch switch statement.\n	  var ContinueSentinel = {};\n	\n	  // Dummy constructor functions that we use as the .constructor and\n	  // .constructor.prototype properties for functions that return Generator\n	  // objects. For full spec compliance, you may wish to configure your\n	  // minifier not to mangle the names of these two functions.\n	  function Generator() {}\n	  function GeneratorFunction() {}\n	  function GeneratorFunctionPrototype() {}\n	\n	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n	  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n	  GeneratorFunction.displayName = \"GeneratorFunction\";\n	\n	  // Helper for defining the .next, .throw, and .return methods of the\n	  // Iterator interface in terms of a single ._invoke method.\n	  function defineIteratorMethods(prototype) {\n	    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n	      prototype[method] = function(arg) {\n	        return this._invoke(method, arg);\n	      };\n	    });\n	  }\n	\n	  runtime.isGeneratorFunction = function(genFun) {\n	    var ctor = typeof genFun === \"function\" && genFun.constructor;\n	    return ctor\n	      ? ctor === GeneratorFunction ||\n	        // For the native GeneratorFunction constructor, the best we can\n	        // do is to check its .name property.\n	        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n	      : false;\n	  };\n	\n	  runtime.mark = function(genFun) {\n	    if (Object.setPrototypeOf) {\n	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n	    } else {\n	      genFun.__proto__ = GeneratorFunctionPrototype;\n	    }\n	    genFun.prototype = Object.create(Gp);\n	    return genFun;\n	  };\n	\n	  // Within the body of any async function, `await x` is transformed to\n	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n	  // `value instanceof AwaitArgument` to determine if the yielded value is\n	  // meant to be awaited. Some may consider the name of this method too\n	  // cutesy, but they are curmudgeons.\n	  runtime.awrap = function(arg) {\n	    return new AwaitArgument(arg);\n	  };\n	\n	  function AwaitArgument(arg) {\n	    this.arg = arg;\n	  }\n	\n	  function AsyncIterator(generator) {\n	    // This invoke function is written in a style that assumes some\n	    // calling function (or Promise) will handle exceptions.\n	    function invoke(method, arg) {\n	      var result = generator[method](arg);\n	      var value = result.value;\n	      return value instanceof AwaitArgument\n	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)\n	        : Promise.resolve(value).then(function(unwrapped) {\n	            // When a yielded Promise is resolved, its final value becomes\n	            // the .value of the Promise<{value,done}> result for the\n	            // current iteration. If the Promise is rejected, however, the\n	            // result for this iteration will be rejected with the same\n	            // reason. Note that rejections of yielded Promises are not\n	            // thrown back into the generator function, as is the case\n	            // when an awaited Promise is rejected. This difference in\n	            // behavior between yield and await is important, because it\n	            // allows the consumer to decide what to do with the yielded\n	            // rejection (swallow it and continue, manually .throw it back\n	            // into the generator, abandon iteration, whatever). With\n	            // await, by contrast, there is no opportunity to examine the\n	            // rejection reason outside the generator function, so the\n	            // only option is to throw it from the await expression, and\n	            // let the generator function handle the exception.\n	            result.value = unwrapped;\n	            return result;\n	          });\n	    }\n	\n	    if (typeof process === \"object\" && process.domain) {\n	      invoke = process.domain.bind(invoke);\n	    }\n	\n	    var invokeNext = invoke.bind(generator, \"next\");\n	    var invokeThrow = invoke.bind(generator, \"throw\");\n	    var invokeReturn = invoke.bind(generator, \"return\");\n	    var previousPromise;\n	\n	    function enqueue(method, arg) {\n	      function callInvokeWithMethodAndArg() {\n	        return invoke(method, arg);\n	      }\n	\n	      return previousPromise =\n	        // If enqueue has been called before, then we want to wait until\n	        // all previous Promises have been resolved before calling invoke,\n	        // so that results are always delivered in the correct order. If\n	        // enqueue has not been called before, then it is important to\n	        // call invoke immediately, without waiting on a callback to fire,\n	        // so that the async generator function has the opportunity to do\n	        // any necessary setup in a predictable way. This predictability\n	        // is why the Promise constructor synchronously invokes its\n	        // executor callback, and why async functions synchronously\n	        // execute code before the first await. Since we implement simple\n	        // async functions in terms of async generators, it is especially\n	        // important to get this right, even though it requires care.\n	        previousPromise ? previousPromise.then(\n	          callInvokeWithMethodAndArg,\n	          // Avoid propagating failures to Promises returned by later\n	          // invocations of the iterator.\n	          callInvokeWithMethodAndArg\n	        ) : new Promise(function (resolve) {\n	          resolve(callInvokeWithMethodAndArg());\n	        });\n	    }\n	\n	    // Define the unified helper method that is used to implement .next,\n	    // .throw, and .return (see defineIteratorMethods).\n	    this._invoke = enqueue;\n	  }\n	\n	  defineIteratorMethods(AsyncIterator.prototype);\n	\n	  // Note that simple async functions are implemented on top of\n	  // AsyncIterator objects; they just return a Promise for the value of\n	  // the final result produced by the iterator.\n	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n	    var iter = new AsyncIterator(\n	      wrap(innerFn, outerFn, self, tryLocsList)\n	    );\n	\n	    return runtime.isGeneratorFunction(outerFn)\n	      ? iter // If outerFn is a generator, return the full iterator.\n	      : iter.next().then(function(result) {\n	          return result.done ? result.value : iter.next();\n	        });\n	  };\n	\n	  function makeInvokeMethod(innerFn, self, context) {\n	    var state = GenStateSuspendedStart;\n	\n	    return function invoke(method, arg) {\n	      if (state === GenStateExecuting) {\n	        throw new Error(\"Generator is already running\");\n	      }\n	\n	      if (state === GenStateCompleted) {\n	        if (method === \"throw\") {\n	          throw arg;\n	        }\n	\n	        // Be forgiving, per 25.3.3.3.3 of the spec:\n	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n	        return doneResult();\n	      }\n	\n	      while (true) {\n	        var delegate = context.delegate;\n	        if (delegate) {\n	          if (method === \"return\" ||\n	              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n	            // A return or throw (when the delegate iterator has no throw\n	            // method) always terminates the yield* loop.\n	            context.delegate = null;\n	\n	            // If the delegate iterator has a return method, give it a\n	            // chance to clean up.\n	            var returnMethod = delegate.iterator[\"return\"];\n	            if (returnMethod) {\n	              var record = tryCatch(returnMethod, delegate.iterator, arg);\n	              if (record.type === \"throw\") {\n	                // If the return method threw an exception, let that\n	                // exception prevail over the original return or throw.\n	                method = \"throw\";\n	                arg = record.arg;\n	                continue;\n	              }\n	            }\n	\n	            if (method === \"return\") {\n	              // Continue with the outer return, now that the delegate\n	              // iterator has been terminated.\n	              continue;\n	            }\n	          }\n	\n	          var record = tryCatch(\n	            delegate.iterator[method],\n	            delegate.iterator,\n	            arg\n	          );\n	\n	          if (record.type === \"throw\") {\n	            context.delegate = null;\n	\n	            // Like returning generator.throw(uncaught), but without the\n	            // overhead of an extra function call.\n	            method = \"throw\";\n	            arg = record.arg;\n	            continue;\n	          }\n	\n	          // Delegate generator ran and handled its own exceptions so\n	          // regardless of what the method was, we continue as if it is\n	          // \"next\" with an undefined arg.\n	          method = \"next\";\n	          arg = undefined;\n	\n	          var info = record.arg;\n	          if (info.done) {\n	            context[delegate.resultName] = info.value;\n	            context.next = delegate.nextLoc;\n	          } else {\n	            state = GenStateSuspendedYield;\n	            return info;\n	          }\n	\n	          context.delegate = null;\n	        }\n	\n	        if (method === \"next\") {\n	          context._sent = arg;\n	\n	          if (state === GenStateSuspendedYield) {\n	            context.sent = arg;\n	          } else {\n	            context.sent = undefined;\n	          }\n	        } else if (method === \"throw\") {\n	          if (state === GenStateSuspendedStart) {\n	            state = GenStateCompleted;\n	            throw arg;\n	          }\n	\n	          if (context.dispatchException(arg)) {\n	            // If the dispatched exception was caught by a catch block,\n	            // then let that catch block handle the exception normally.\n	            method = \"next\";\n	            arg = undefined;\n	          }\n	\n	        } else if (method === \"return\") {\n	          context.abrupt(\"return\", arg);\n	        }\n	\n	        state = GenStateExecuting;\n	\n	        var record = tryCatch(innerFn, self, context);\n	        if (record.type === \"normal\") {\n	          // If an exception is thrown from innerFn, we leave state ===\n	          // GenStateExecuting and loop back for another invocation.\n	          state = context.done\n	            ? GenStateCompleted\n	            : GenStateSuspendedYield;\n	\n	          var info = {\n	            value: record.arg,\n	            done: context.done\n	          };\n	\n	          if (record.arg === ContinueSentinel) {\n	            if (context.delegate && method === \"next\") {\n	              // Deliberately forget the last sent value so that we don't\n	              // accidentally pass it on to the delegate.\n	              arg = undefined;\n	            }\n	          } else {\n	            return info;\n	          }\n	\n	        } else if (record.type === \"throw\") {\n	          state = GenStateCompleted;\n	          // Dispatch the exception by looping back around to the\n	          // context.dispatchException(arg) call above.\n	          method = \"throw\";\n	          arg = record.arg;\n	        }\n	      }\n	    };\n	  }\n	\n	  // Define Generator.prototype.{next,throw,return} in terms of the\n	  // unified ._invoke helper method.\n	  defineIteratorMethods(Gp);\n	\n	  Gp[iteratorSymbol] = function() {\n	    return this;\n	  };\n	\n	  Gp.toString = function() {\n	    return \"[object Generator]\";\n	  };\n	\n	  function pushTryEntry(locs) {\n	    var entry = { tryLoc: locs[0] };\n	\n	    if (1 in locs) {\n	      entry.catchLoc = locs[1];\n	    }\n	\n	    if (2 in locs) {\n	      entry.finallyLoc = locs[2];\n	      entry.afterLoc = locs[3];\n	    }\n	\n	    this.tryEntries.push(entry);\n	  }\n	\n	  function resetTryEntry(entry) {\n	    var record = entry.completion || {};\n	    record.type = \"normal\";\n	    delete record.arg;\n	    entry.completion = record;\n	  }\n	\n	  function Context(tryLocsList) {\n	    // The root entry object (effectively a try statement without a catch\n	    // or a finally block) gives us a place to store values thrown from\n	    // locations where there is no enclosing try statement.\n	    this.tryEntries = [{ tryLoc: \"root\" }];\n	    tryLocsList.forEach(pushTryEntry, this);\n	    this.reset(true);\n	  }\n	\n	  runtime.keys = function(object) {\n	    var keys = [];\n	    for (var key in object) {\n	      keys.push(key);\n	    }\n	    keys.reverse();\n	\n	    // Rather than returning an object with a next method, we keep\n	    // things simple and return the next function itself.\n	    return function next() {\n	      while (keys.length) {\n	        var key = keys.pop();\n	        if (key in object) {\n	          next.value = key;\n	          next.done = false;\n	          return next;\n	        }\n	      }\n	\n	      // To avoid creating an additional object, we just hang the .value\n	      // and .done properties off the next function object itself. This\n	      // also ensures that the minifier will not anonymize the function.\n	      next.done = true;\n	      return next;\n	    };\n	  };\n	\n	  function values(iterable) {\n	    if (iterable) {\n	      var iteratorMethod = iterable[iteratorSymbol];\n	      if (iteratorMethod) {\n	        return iteratorMethod.call(iterable);\n	      }\n	\n	      if (typeof iterable.next === \"function\") {\n	        return iterable;\n	      }\n	\n	      if (!isNaN(iterable.length)) {\n	        var i = -1, next = function next() {\n	          while (++i < iterable.length) {\n	            if (hasOwn.call(iterable, i)) {\n	              next.value = iterable[i];\n	              next.done = false;\n	              return next;\n	            }\n	          }\n	\n	          next.value = undefined;\n	          next.done = true;\n	\n	          return next;\n	        };\n	\n	        return next.next = next;\n	      }\n	    }\n	\n	    // Return an iterator with no values.\n	    return { next: doneResult };\n	  }\n	  runtime.values = values;\n	\n	  function doneResult() {\n	    return { value: undefined, done: true };\n	  }\n	\n	  Context.prototype = {\n	    constructor: Context,\n	\n	    reset: function(skipTempReset) {\n	      this.prev = 0;\n	      this.next = 0;\n	      this.sent = undefined;\n	      this.done = false;\n	      this.delegate = null;\n	\n	      this.tryEntries.forEach(resetTryEntry);\n	\n	      if (!skipTempReset) {\n	        for (var name in this) {\n	          // Not sure about the optimal order of these conditions:\n	          if (name.charAt(0) === \"t\" &&\n	              hasOwn.call(this, name) &&\n	              !isNaN(+name.slice(1))) {\n	            this[name] = undefined;\n	          }\n	        }\n	      }\n	    },\n	\n	    stop: function() {\n	      this.done = true;\n	\n	      var rootEntry = this.tryEntries[0];\n	      var rootRecord = rootEntry.completion;\n	      if (rootRecord.type === \"throw\") {\n	        throw rootRecord.arg;\n	      }\n	\n	      return this.rval;\n	    },\n	\n	    dispatchException: function(exception) {\n	      if (this.done) {\n	        throw exception;\n	      }\n	\n	      var context = this;\n	      function handle(loc, caught) {\n	        record.type = \"throw\";\n	        record.arg = exception;\n	        context.next = loc;\n	        return !!caught;\n	      }\n	\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        var record = entry.completion;\n	\n	        if (entry.tryLoc === \"root\") {\n	          // Exception thrown outside of any try block that could handle\n	          // it, so set the completion value of the entire function to\n	          // throw the exception.\n	          return handle(\"end\");\n	        }\n	\n	        if (entry.tryLoc <= this.prev) {\n	          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n	          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n	\n	          if (hasCatch && hasFinally) {\n	            if (this.prev < entry.catchLoc) {\n	              return handle(entry.catchLoc, true);\n	            } else if (this.prev < entry.finallyLoc) {\n	              return handle(entry.finallyLoc);\n	            }\n	\n	          } else if (hasCatch) {\n	            if (this.prev < entry.catchLoc) {\n	              return handle(entry.catchLoc, true);\n	            }\n	\n	          } else if (hasFinally) {\n	            if (this.prev < entry.finallyLoc) {\n	              return handle(entry.finallyLoc);\n	            }\n	\n	          } else {\n	            throw new Error(\"try statement without catch or finally\");\n	          }\n	        }\n	      }\n	    },\n	\n	    abrupt: function(type, arg) {\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        if (entry.tryLoc <= this.prev &&\n	            hasOwn.call(entry, \"finallyLoc\") &&\n	            this.prev < entry.finallyLoc) {\n	          var finallyEntry = entry;\n	          break;\n	        }\n	      }\n	\n	      if (finallyEntry &&\n	          (type === \"break\" ||\n	           type === \"continue\") &&\n	          finallyEntry.tryLoc <= arg &&\n	          arg <= finallyEntry.finallyLoc) {\n	        // Ignore the finally entry if control is not jumping to a\n	        // location outside the try/catch block.\n	        finallyEntry = null;\n	      }\n	\n	      var record = finallyEntry ? finallyEntry.completion : {};\n	      record.type = type;\n	      record.arg = arg;\n	\n	      if (finallyEntry) {\n	        this.next = finallyEntry.finallyLoc;\n	      } else {\n	        this.complete(record);\n	      }\n	\n	      return ContinueSentinel;\n	    },\n	\n	    complete: function(record, afterLoc) {\n	      if (record.type === \"throw\") {\n	        throw record.arg;\n	      }\n	\n	      if (record.type === \"break\" ||\n	          record.type === \"continue\") {\n	        this.next = record.arg;\n	      } else if (record.type === \"return\") {\n	        this.rval = record.arg;\n	        this.next = \"end\";\n	      } else if (record.type === \"normal\" && afterLoc) {\n	        this.next = afterLoc;\n	      }\n	    },\n	\n	    finish: function(finallyLoc) {\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        if (entry.finallyLoc === finallyLoc) {\n	          this.complete(entry.completion, entry.afterLoc);\n	          resetTryEntry(entry);\n	          return ContinueSentinel;\n	        }\n	      }\n	    },\n	\n	    \"catch\": function(tryLoc) {\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        if (entry.tryLoc === tryLoc) {\n	          var record = entry.completion;\n	          if (record.type === \"throw\") {\n	            var thrown = record.arg;\n	            resetTryEntry(entry);\n	          }\n	          return thrown;\n	        }\n	      }\n	\n	      // The context.catch method must only be called with a location\n	      // argument that corresponds to a known catch block.\n	      throw new Error(\"illegal catch attempt\");\n	    },\n	\n	    delegateYield: function(iterable, resultName, nextLoc) {\n	      this.delegate = {\n	        iterator: values(iterable),\n	        resultName: resultName,\n	        nextLoc: nextLoc\n	      };\n	\n	      return ContinueSentinel;\n	    }\n	  };\n	})(\n	  // Among the various tricks for obtaining a reference to the global\n	  // object, this seems to be the most reliable technique that does not\n	  // use indirect eval (which violates Content Security Policy).\n	  typeof global === \"object\" ? global :\n	  typeof window === \"object\" ? window :\n	  typeof self === \"object\" ? self : this\n	);\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n	\n	/***/ },\n	/* 2 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	var _Utils = __webpack_require__(3);\n	\n	var Utils = _interopRequireWildcard(_Utils);\n	\n	var _Cache = __webpack_require__(12);\n	\n	var _Cache2 = _interopRequireDefault(_Cache);\n	\n	var _Externals = __webpack_require__(4);\n	\n	var Externals = _interopRequireWildcard(_Externals);\n	\n	var _Observable = __webpack_require__(13);\n	\n	var _Observable2 = _interopRequireDefault(_Observable);\n	\n	var _Queue = __webpack_require__(14);\n	\n	var _Queue2 = _interopRequireDefault(_Queue);\n	\n	var _Client = __webpack_require__(15);\n	\n	var _Client2 = _interopRequireDefault(_Client);\n	\n	var _ApiResponse = __webpack_require__(16);\n	\n	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n	\n	var _ClientMock = __webpack_require__(17);\n	\n	var _ClientMock2 = _interopRequireDefault(_ClientMock);\n	\n	var _Mock = __webpack_require__(19);\n	\n	var _Mock2 = _interopRequireDefault(_Mock);\n	\n	var _Registry = __webpack_require__(18);\n	\n	var _Registry2 = _interopRequireDefault(_Registry);\n	\n	var _Platform = __webpack_require__(20);\n	\n	var _Platform2 = _interopRequireDefault(_Platform);\n	\n	var _Auth = __webpack_require__(21);\n	\n	var _Auth2 = _interopRequireDefault(_Auth);\n	\n	var _PubnubFactory = __webpack_require__(22);\n	\n	var _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);\n	\n	var _Subscription = __webpack_require__(24);\n	\n	var _Subscription2 = _interopRequireDefault(_Subscription);\n	\n	var _CachedSubscription = __webpack_require__(25);\n	\n	var _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var SDK = function () {\n	\n	    /**\n	     * @namespace RingCentral\n	     * @constructor\n	     * @param {object} [options]\n	     * @param {string} [options.server]\n	     * @param {string} [options.cachePrefix]\n	     * @param {string} [options.appSecret]\n	     * @param {string} [options.appKey]\n	     * @param {string} [options.appName]\n	     * @param {string} [options.appVersion]\n	     * @param {string} [options.pubnubFactory]\n	     * @param {string} [options.client]\n	     */\n	\n	    function SDK(options) {\n	        _classCallCheck(this, SDK);\n	\n	        options = options || {};\n	\n	        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);\n	\n	        this._client = options.client || new _Client2.default();\n	\n	        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);\n	\n	        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;\n	    }\n	\n	    /**\n	     * @return {Platform}\n	     */\n	\n	\n	    SDK.prototype.platform = function platform() {\n	        return this._platform;\n	    };\n	\n	    /**\n	     * @return {Subscription}\n	     */\n	\n	\n	    SDK.prototype.createSubscription = function createSubscription() {\n	        return new _Subscription2.default(this._pubnubFactory, this._platform);\n	    };\n	\n	    /**\n	     * @return {CachedSubscription}\n	     */\n	\n	\n	    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {\n	        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);\n	    };\n	\n	    /**\n	     * @return {Cache}\n	     */\n	\n	\n	    SDK.prototype.cache = function cache() {\n	        return this._cache;\n	    };\n	\n	    SDK.handleAuthRedirect = function handleAuthRedirect(origin) {\n	        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);\n	    };\n	\n	    return SDK;\n	}();\n	\n	SDK.version = '2.0.6';\n	SDK.server = {\n	    sandbox: 'https://platform.devtest.ringcentral.com',\n	    production: 'https://platform.ringcentral.com'\n	};\n	SDK.core = {\n	    Cache: _Cache2.default,\n	    Observable: _Observable2.default,\n	    Utils: Utils,\n	    Externals: Externals,\n	    Queue: _Queue2.default\n	};\n	SDK.http = {\n	    Client: _Client2.default,\n	    ApiResponse: _ApiResponse2.default\n	};\n	SDK.platform = {\n	    Auth: _Auth2.default,\n	    Platform: _Platform2.default\n	};\n	SDK.subscription = {\n	    Subscription: _Subscription2.default\n	};\n	SDK.mocks = {\n	    Client: _ClientMock2.default,\n	    Registry: _Registry2.default,\n	    Mock: _Mock2.default\n	};\n	SDK.pubnub = {\n	    PubnubMockFactory: _PubnubFactory2.default\n	};\n	\n	\n	module.exports = SDK;\n	\n	/***/ },\n	/* 3 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n	\n	exports.queryStringify = queryStringify;\n	exports.parseQueryString = parseQueryString;\n	exports.isFunction = isFunction;\n	exports.isArray = isArray;\n	exports.isObject = isObject;\n	exports.isObjectObject = isObjectObject;\n	exports.isPlainObject = isPlainObject;\n	exports.poll = poll;\n	exports.stopPolling = stopPolling;\n	exports.isNodeJS = isNodeJS;\n	exports.isBrowser = isBrowser;\n	exports.delay = delay;\n	\n	var _Externals = __webpack_require__(4);\n	\n	/**\n	 * TODO Replace with something better\n	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n	 * @param {object} parameters\n	 * @returns {string}\n	 */\n	function queryStringify(parameters) {\n	\n	    var array = [];\n	\n	    parameters = parameters || {};\n	\n	    Object.keys(parameters).forEach(function (k) {\n	\n	        var v = parameters[k];\n	\n	        if (isArray(v)) {\n	            v.forEach(function (vv) {\n	                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));\n	            });\n	        } else {\n	            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));\n	        }\n	    });\n	\n	    return array.join('&');\n	}\n	\n	/**\n	 * TODO Replace with something better\n	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n	 * @param {string} queryString\n	 * @returns {object}\n	 */\n	function parseQueryString(queryString) {\n	\n	    var argsParsed = {};\n	\n	    queryString.split('&').forEach(function (arg) {\n	\n	        arg = decodeURIComponent(arg);\n	\n	        if (arg.indexOf('=') == -1) {\n	\n	            argsParsed[arg.trim()] = true;\n	        } else {\n	\n	            var pair = arg.split('='),\n	                key = pair[0].trim(),\n	                value = pair[1].trim();\n	\n	            if (key in argsParsed) {\n	                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];\n	                argsParsed[key].push(value);\n	            } else {\n	                argsParsed[key] = value;\n	            }\n	        }\n	    });\n	\n	    return argsParsed;\n	}\n	\n	/**\n	 * @param obj\n	 * @return {boolean}\n	 */\n	function isFunction(obj) {\n	    return typeof obj === \"function\";\n	}\n	\n	/**\n	 * @param obj\n	 * @return {boolean}\n	 */\n	function isArray(obj) {\n	    return Array.isArray ? Array.isArray(obj) : typeof obj === \"array\";\n	}\n	\n	function isObject(o) {\n	    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);\n	}\n	\n	function isObjectObject(o) {\n	    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n	}\n	\n	function isPlainObject(o) {\n	    var ctor, prot;\n	\n	    if (isObjectObject(o) === false) return false;\n	\n	    // If has modified constructor\n	    ctor = o.constructor;\n	    if (typeof ctor !== 'function') return false;\n	\n	    // If has modified prototype\n	    prot = ctor.prototype;\n	    if (isObjectObject(prot) === false) return false;\n	\n	    // If constructor does not have an Object-specific method\n	    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n	        return false;\n	    }\n	\n	    // Most likely a plain Object\n	    return true;\n	}\n	\n	/**\n	 * @param fn\n	 * @param interval\n	 * @param timeout\n	 */\n	function poll(fn, interval, timeout) {\n	    //NodeJS.Timer|number\n	\n	    module.exports.stopPolling(timeout);\n	\n	    interval = interval || 1000;\n	\n	    var next = function next(delay) {\n	\n	        delay = delay || interval;\n	\n	        interval = delay;\n	\n	        return setTimeout(function () {\n	\n	            fn(next, delay);\n	        }, delay);\n	    };\n	\n	    return next();\n	}\n	\n	function stopPolling(timeout) {\n	    if (timeout) clearTimeout(timeout);\n	}\n	\n	function isNodeJS() {\n	    return typeof process !== 'undefined';\n	}\n	\n	function isBrowser() {\n	    return typeof window !== 'undefined';\n	}\n	\n	function delay(timeout) {\n	    return new _Externals.Promise(function (resolve, reject) {\n	        setTimeout(function () {\n	            resolve(null);\n	        }, timeout);\n	    });\n	}\n	\n	/***/ },\n	/* 4 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n	\n	exports.__esModule = true;\n	exports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;\n	\n	var _es6Promise = __webpack_require__(5);\n	\n	var _es6Promise2 = _interopRequireDefault(_es6Promise);\n	\n	var _nodeFetch = __webpack_require__(10);\n	\n	var _nodeFetch2 = _interopRequireDefault(_nodeFetch);\n	\n	var _pubnub = __webpack_require__(11);\n	\n	var _pubnub2 = _interopRequireDefault(_pubnub);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var root = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function(\"return this;\")();\n	\n	var Promise = exports.Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;\n	\n	var fetch = exports.fetch = root.fetch || _nodeFetch2.default;\n	var Request = exports.Request = root.Request || fetch.Request;\n	var Response = exports.Response = root.Response || fetch.Response;\n	var Headers = exports.Headers = root.Headers || fetch.Headers;\n	\n	var PUBNUB = exports.PUBNUB = root.PUBNUB || _pubnub2.default;\n	\n	var localStorage = exports.localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n	\n	/***/ },\n	/* 5 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate, global, module) {/*!\n	 * @overview es6-promise - a tiny implementation of Promises/A+.\n	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n	 * @license   Licensed under MIT license\n	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n	 * @version   2.2.0\n	 */\n	\n	(function() {\n	    \"use strict\";\n	    function lib$es6$promise$utils$$objectOrFunction(x) {\n	      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n	    }\n	\n	    function lib$es6$promise$utils$$isFunction(x) {\n	      return typeof x === 'function';\n	    }\n	\n	    function lib$es6$promise$utils$$isMaybeThenable(x) {\n	      return typeof x === 'object' && x !== null;\n	    }\n	\n	    var lib$es6$promise$utils$$_isArray;\n	    if (!Array.isArray) {\n	      lib$es6$promise$utils$$_isArray = function (x) {\n	        return Object.prototype.toString.call(x) === '[object Array]';\n	      };\n	    } else {\n	      lib$es6$promise$utils$$_isArray = Array.isArray;\n	    }\n	\n	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n	    var lib$es6$promise$asap$$len = 0;\n	    var lib$es6$promise$asap$$toString = {}.toString;\n	    var lib$es6$promise$asap$$vertxNext;\n	    var lib$es6$promise$asap$$customSchedulerFn;\n	\n	    function lib$es6$promise$asap$$asap(callback, arg) {\n	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n	      lib$es6$promise$asap$$len += 2;\n	      if (lib$es6$promise$asap$$len === 2) {\n	        // If len is 2, that means that we need to schedule an async flush.\n	        // If additional callbacks are queued before the queue is flushed, they\n	        // will be processed by this flush that we are scheduling.\n	        if (lib$es6$promise$asap$$customSchedulerFn) {\n	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n	        } else {\n	          lib$es6$promise$asap$$scheduleFlush();\n	        }\n	      }\n	    }\n	\n	    var lib$es6$promise$asap$$default = lib$es6$promise$asap$$asap;\n	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n	    }\n	\n	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n	\n	    // test for web worker but not in IE10\n	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n	      typeof importScripts !== 'undefined' &&\n	      typeof MessageChannel !== 'undefined';\n	\n	    // node\n	    function lib$es6$promise$asap$$useNextTick() {\n	      var nextTick = process.nextTick;\n	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n	      // setImmediate should be used instead instead\n	      var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n	      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n	        nextTick = setImmediate;\n	      }\n	      return function() {\n	        nextTick(lib$es6$promise$asap$$flush);\n	      };\n	    }\n	\n	    // vertx\n	    function lib$es6$promise$asap$$useVertxTimer() {\n	      return function() {\n	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n	      };\n	    }\n	\n	    function lib$es6$promise$asap$$useMutationObserver() {\n	      var iterations = 0;\n	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n	      var node = document.createTextNode('');\n	      observer.observe(node, { characterData: true });\n	\n	      return function() {\n	        node.data = (iterations = ++iterations % 2);\n	      };\n	    }\n	\n	    // web worker\n	    function lib$es6$promise$asap$$useMessageChannel() {\n	      var channel = new MessageChannel();\n	      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n	      return function () {\n	        channel.port2.postMessage(0);\n	      };\n	    }\n	\n	    function lib$es6$promise$asap$$useSetTimeout() {\n	      return function() {\n	        setTimeout(lib$es6$promise$asap$$flush, 1);\n	      };\n	    }\n	\n	    var lib$es6$promise$asap$$queue = new Array(1000);\n	    function lib$es6$promise$asap$$flush() {\n	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n	        var callback = lib$es6$promise$asap$$queue[i];\n	        var arg = lib$es6$promise$asap$$queue[i+1];\n	\n	        callback(arg);\n	\n	        lib$es6$promise$asap$$queue[i] = undefined;\n	        lib$es6$promise$asap$$queue[i+1] = undefined;\n	      }\n	\n	      lib$es6$promise$asap$$len = 0;\n	    }\n	\n	    function lib$es6$promise$asap$$attemptVertex() {\n	      try {\n	        var r = require;\n	        var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"vertx\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n	        return lib$es6$promise$asap$$useVertxTimer();\n	      } catch(e) {\n	        return lib$es6$promise$asap$$useSetTimeout();\n	      }\n	    }\n	\n	    var lib$es6$promise$asap$$scheduleFlush;\n	    // Decide what async method to use to triggering processing of queued callbacks:\n	    if (lib$es6$promise$asap$$isNode) {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n	    } else if (lib$es6$promise$asap$$isWorker) {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n	    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();\n	    } else {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n	    }\n	\n	    function lib$es6$promise$$internal$$noop() {}\n	\n	    var lib$es6$promise$$internal$$PENDING   = void 0;\n	    var lib$es6$promise$$internal$$FULFILLED = 1;\n	    var lib$es6$promise$$internal$$REJECTED  = 2;\n	\n	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n	\n	    function lib$es6$promise$$internal$$selfFullfillment() {\n	      return new TypeError(\"You cannot resolve a promise with itself\");\n	    }\n	\n	    function lib$es6$promise$$internal$$cannotReturnOwn() {\n	      return new TypeError('A promises callback cannot return that same promise.');\n	    }\n	\n	    function lib$es6$promise$$internal$$getThen(promise) {\n	      try {\n	        return promise.then;\n	      } catch(error) {\n	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n	        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n	      try {\n	        then.call(value, fulfillmentHandler, rejectionHandler);\n	      } catch(e) {\n	        return e;\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n	       lib$es6$promise$asap$$default(function(promise) {\n	        var sealed = false;\n	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n	          if (sealed) { return; }\n	          sealed = true;\n	          if (thenable !== value) {\n	            lib$es6$promise$$internal$$resolve(promise, value);\n	          } else {\n	            lib$es6$promise$$internal$$fulfill(promise, value);\n	          }\n	        }, function(reason) {\n	          if (sealed) { return; }\n	          sealed = true;\n	\n	          lib$es6$promise$$internal$$reject(promise, reason);\n	        }, 'Settle: ' + (promise._label || ' unknown promise'));\n	\n	        if (!sealed && error) {\n	          sealed = true;\n	          lib$es6$promise$$internal$$reject(promise, error);\n	        }\n	      }, promise);\n	    }\n	\n	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n	        lib$es6$promise$$internal$$reject(promise, thenable._result);\n	      } else {\n	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n	          lib$es6$promise$$internal$$resolve(promise, value);\n	        }, function(reason) {\n	          lib$es6$promise$$internal$$reject(promise, reason);\n	        });\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n	      if (maybeThenable.constructor === promise.constructor) {\n	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n	      } else {\n	        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n	\n	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n	        } else if (then === undefined) {\n	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n	        } else if (lib$es6$promise$utils$$isFunction(then)) {\n	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n	        } else {\n	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n	        }\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$resolve(promise, value) {\n	      if (promise === value) {\n	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());\n	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n	      } else {\n	        lib$es6$promise$$internal$$fulfill(promise, value);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$publishRejection(promise) {\n	      if (promise._onerror) {\n	        promise._onerror(promise._result);\n	      }\n	\n	      lib$es6$promise$$internal$$publish(promise);\n	    }\n	\n	    function lib$es6$promise$$internal$$fulfill(promise, value) {\n	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n	\n	      promise._result = value;\n	      promise._state = lib$es6$promise$$internal$$FULFILLED;\n	\n	      if (promise._subscribers.length !== 0) {\n	        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, promise);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$reject(promise, reason) {\n	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n	      promise._state = lib$es6$promise$$internal$$REJECTED;\n	      promise._result = reason;\n	\n	      lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publishRejection, promise);\n	    }\n	\n	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n	      var subscribers = parent._subscribers;\n	      var length = subscribers.length;\n	\n	      parent._onerror = null;\n	\n	      subscribers[length] = child;\n	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n	\n	      if (length === 0 && parent._state) {\n	        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, parent);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$publish(promise) {\n	      var subscribers = promise._subscribers;\n	      var settled = promise._state;\n	\n	      if (subscribers.length === 0) { return; }\n	\n	      var child, callback, detail = promise._result;\n	\n	      for (var i = 0; i < subscribers.length; i += 3) {\n	        child = subscribers[i];\n	        callback = subscribers[i + settled];\n	\n	        if (child) {\n	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n	        } else {\n	          callback(detail);\n	        }\n	      }\n	\n	      promise._subscribers.length = 0;\n	    }\n	\n	    function lib$es6$promise$$internal$$ErrorObject() {\n	      this.error = null;\n	    }\n	\n	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n	\n	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n	      try {\n	        return callback(detail);\n	      } catch(e) {\n	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n	          value, error, succeeded, failed;\n	\n	      if (hasCallback) {\n	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n	\n	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n	          failed = true;\n	          error = value.error;\n	          value = null;\n	        } else {\n	          succeeded = true;\n	        }\n	\n	        if (promise === value) {\n	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n	          return;\n	        }\n	\n	      } else {\n	        value = detail;\n	        succeeded = true;\n	      }\n	\n	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n	        // noop\n	      } else if (hasCallback && succeeded) {\n	        lib$es6$promise$$internal$$resolve(promise, value);\n	      } else if (failed) {\n	        lib$es6$promise$$internal$$reject(promise, error);\n	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n	        lib$es6$promise$$internal$$fulfill(promise, value);\n	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n	        lib$es6$promise$$internal$$reject(promise, value);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n	      try {\n	        resolver(function resolvePromise(value){\n	          lib$es6$promise$$internal$$resolve(promise, value);\n	        }, function rejectPromise(reason) {\n	          lib$es6$promise$$internal$$reject(promise, reason);\n	        });\n	      } catch(e) {\n	        lib$es6$promise$$internal$$reject(promise, e);\n	      }\n	    }\n	\n	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n	      var enumerator = this;\n	\n	      enumerator._instanceConstructor = Constructor;\n	      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n	\n	      if (enumerator._validateInput(input)) {\n	        enumerator._input     = input;\n	        enumerator.length     = input.length;\n	        enumerator._remaining = input.length;\n	\n	        enumerator._init();\n	\n	        if (enumerator.length === 0) {\n	          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n	        } else {\n	          enumerator.length = enumerator.length || 0;\n	          enumerator._enumerate();\n	          if (enumerator._remaining === 0) {\n	            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n	          }\n	        }\n	      } else {\n	        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n	      }\n	    }\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n	      return lib$es6$promise$utils$$isArray(input);\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n	      return new Error('Array Methods must be provided an Array');\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n	      this._result = new Array(this.length);\n	    };\n	\n	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n	      var enumerator = this;\n	\n	      var length  = enumerator.length;\n	      var promise = enumerator.promise;\n	      var input   = enumerator._input;\n	\n	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n	        enumerator._eachEntry(input[i], i);\n	      }\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n	      var enumerator = this;\n	      var c = enumerator._instanceConstructor;\n	\n	      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n	        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n	          entry._onerror = null;\n	          enumerator._settledAt(entry._state, i, entry._result);\n	        } else {\n	          enumerator._willSettleAt(c.resolve(entry), i);\n	        }\n	      } else {\n	        enumerator._remaining--;\n	        enumerator._result[i] = entry;\n	      }\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n	      var enumerator = this;\n	      var promise = enumerator.promise;\n	\n	      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n	        enumerator._remaining--;\n	\n	        if (state === lib$es6$promise$$internal$$REJECTED) {\n	          lib$es6$promise$$internal$$reject(promise, value);\n	        } else {\n	          enumerator._result[i] = value;\n	        }\n	      }\n	\n	      if (enumerator._remaining === 0) {\n	        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n	      }\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n	      var enumerator = this;\n	\n	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n	      }, function(reason) {\n	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n	      });\n	    };\n	    function lib$es6$promise$promise$all$$all(entries) {\n	      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n	    }\n	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n	    function lib$es6$promise$promise$race$$race(entries) {\n	      /*jshint validthis:true */\n	      var Constructor = this;\n	\n	      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n	\n	      if (!lib$es6$promise$utils$$isArray(entries)) {\n	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n	        return promise;\n	      }\n	\n	      var length = entries.length;\n	\n	      function onFulfillment(value) {\n	        lib$es6$promise$$internal$$resolve(promise, value);\n	      }\n	\n	      function onRejection(reason) {\n	        lib$es6$promise$$internal$$reject(promise, reason);\n	      }\n	\n	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n	      }\n	\n	      return promise;\n	    }\n	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n	    function lib$es6$promise$promise$resolve$$resolve(object) {\n	      /*jshint validthis:true */\n	      var Constructor = this;\n	\n	      if (object && typeof object === 'object' && object.constructor === Constructor) {\n	        return object;\n	      }\n	\n	      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n	      lib$es6$promise$$internal$$resolve(promise, object);\n	      return promise;\n	    }\n	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n	    function lib$es6$promise$promise$reject$$reject(reason) {\n	      /*jshint validthis:true */\n	      var Constructor = this;\n	      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n	      lib$es6$promise$$internal$$reject(promise, reason);\n	      return promise;\n	    }\n	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n	\n	    var lib$es6$promise$promise$$counter = 0;\n	\n	    function lib$es6$promise$promise$$needsResolver() {\n	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n	    }\n	\n	    function lib$es6$promise$promise$$needsNew() {\n	      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n	    }\n	\n	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n	    /**\n	      Promise objects represent the eventual result of an asynchronous operation. The\n	      primary way of interacting with a promise is through its `then` method, which\n	      registers callbacks to receive either a promises eventual value or the reason\n	      why the promise cannot be fulfilled.\n	\n	      Terminology\n	      -----------\n	\n	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n	      - `thenable` is an object or function that defines a `then` method.\n	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n	      - `exception` is a value that is thrown using the throw statement.\n	      - `reason` is a value that indicates why a promise was rejected.\n	      - `settled` the final resting state of a promise, fulfilled or rejected.\n	\n	      A promise can be in one of three states: pending, fulfilled, or rejected.\n	\n	      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n	      state.  Promises that are rejected have a rejection reason and are in the\n	      rejected state.  A fulfillment value is never a thenable.\n	\n	      Promises can also be said to *resolve* a value.  If this value is also a\n	      promise, then the original promise's settled state will match the value's\n	      settled state.  So a promise that *resolves* a promise that rejects will\n	      itself reject, and a promise that *resolves* a promise that fulfills will\n	      itself fulfill.\n	\n	\n	      Basic Usage:\n	      ------------\n	\n	      ```js\n	      var promise = new Promise(function(resolve, reject) {\n	        // on success\n	        resolve(value);\n	\n	        // on failure\n	        reject(reason);\n	      });\n	\n	      promise.then(function(value) {\n	        // on fulfillment\n	      }, function(reason) {\n	        // on rejection\n	      });\n	      ```\n	\n	      Advanced Usage:\n	      ---------------\n	\n	      Promises shine when abstracting away asynchronous interactions such as\n	      `XMLHttpRequest`s.\n	\n	      ```js\n	      function getJSON(url) {\n	        return new Promise(function(resolve, reject){\n	          var xhr = new XMLHttpRequest();\n	\n	          xhr.open('GET', url);\n	          xhr.onreadystatechange = handler;\n	          xhr.responseType = 'json';\n	          xhr.setRequestHeader('Accept', 'application/json');\n	          xhr.send();\n	\n	          function handler() {\n	            if (this.readyState === this.DONE) {\n	              if (this.status === 200) {\n	                resolve(this.response);\n	              } else {\n	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n	              }\n	            }\n	          };\n	        });\n	      }\n	\n	      getJSON('/posts.json').then(function(json) {\n	        // on fulfillment\n	      }, function(reason) {\n	        // on rejection\n	      });\n	      ```\n	\n	      Unlike callbacks, promises are great composable primitives.\n	\n	      ```js\n	      Promise.all([\n	        getJSON('/posts'),\n	        getJSON('/comments')\n	      ]).then(function(values){\n	        values[0] // => postsJSON\n	        values[1] // => commentsJSON\n	\n	        return values;\n	      });\n	      ```\n	\n	      @class Promise\n	      @param {function} resolver\n	      Useful for tooling.\n	      @constructor\n	    */\n	    function lib$es6$promise$promise$$Promise(resolver) {\n	      this._id = lib$es6$promise$promise$$counter++;\n	      this._state = undefined;\n	      this._result = undefined;\n	      this._subscribers = [];\n	\n	      if (lib$es6$promise$$internal$$noop !== resolver) {\n	        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n	          lib$es6$promise$promise$$needsResolver();\n	        }\n	\n	        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n	          lib$es6$promise$promise$$needsNew();\n	        }\n	\n	        lib$es6$promise$$internal$$initializePromise(this, resolver);\n	      }\n	    }\n	\n	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$default;\n	\n	    lib$es6$promise$promise$$Promise.prototype = {\n	      constructor: lib$es6$promise$promise$$Promise,\n	\n	    /**\n	      The primary way of interacting with a promise is through its `then` method,\n	      which registers callbacks to receive either a promise's eventual value or the\n	      reason why the promise cannot be fulfilled.\n	\n	      ```js\n	      findUser().then(function(user){\n	        // user is available\n	      }, function(reason){\n	        // user is unavailable, and you are given the reason why\n	      });\n	      ```\n	\n	      Chaining\n	      --------\n	\n	      The return value of `then` is itself a promise.  This second, 'downstream'\n	      promise is resolved with the return value of the first promise's fulfillment\n	      or rejection handler, or rejected if the handler throws an exception.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        return user.name;\n	      }, function (reason) {\n	        return 'default name';\n	      }).then(function (userName) {\n	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n	        // will be `'default name'`\n	      });\n	\n	      findUser().then(function (user) {\n	        throw new Error('Found user, but still unhappy');\n	      }, function (reason) {\n	        throw new Error('`findUser` rejected and we're unhappy');\n	      }).then(function (value) {\n	        // never reached\n	      }, function (reason) {\n	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n	      });\n	      ```\n	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        throw new PedagogicalException('Upstream error');\n	      }).then(function (value) {\n	        // never reached\n	      }).then(function (value) {\n	        // never reached\n	      }, function (reason) {\n	        // The `PedgagocialException` is propagated all the way down to here\n	      });\n	      ```\n	\n	      Assimilation\n	      ------------\n	\n	      Sometimes the value you want to propagate to a downstream promise can only be\n	      retrieved asynchronously. This can be achieved by returning a promise in the\n	      fulfillment or rejection handler. The downstream promise will then be pending\n	      until the returned promise is settled. This is called *assimilation*.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        return findCommentsByAuthor(user);\n	      }).then(function (comments) {\n	        // The user's comments are now available\n	      });\n	      ```\n	\n	      If the assimliated promise rejects, then the downstream promise will also reject.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        return findCommentsByAuthor(user);\n	      }).then(function (comments) {\n	        // If `findCommentsByAuthor` fulfills, we'll have the value here\n	      }, function (reason) {\n	        // If `findCommentsByAuthor` rejects, we'll have the reason here\n	      });\n	      ```\n	\n	      Simple Example\n	      --------------\n	\n	      Synchronous Example\n	\n	      ```javascript\n	      var result;\n	\n	      try {\n	        result = findResult();\n	        // success\n	      } catch(reason) {\n	        // failure\n	      }\n	      ```\n	\n	      Errback Example\n	\n	      ```js\n	      findResult(function(result, err){\n	        if (err) {\n	          // failure\n	        } else {\n	          // success\n	        }\n	      });\n	      ```\n	\n	      Promise Example;\n	\n	      ```javascript\n	      findResult().then(function(result){\n	        // success\n	      }, function(reason){\n	        // failure\n	      });\n	      ```\n	\n	      Advanced Example\n	      --------------\n	\n	      Synchronous Example\n	\n	      ```javascript\n	      var author, books;\n	\n	      try {\n	        author = findAuthor();\n	        books  = findBooksByAuthor(author);\n	        // success\n	      } catch(reason) {\n	        // failure\n	      }\n	      ```\n	\n	      Errback Example\n	\n	      ```js\n	\n	      function foundBooks(books) {\n	\n	      }\n	\n	      function failure(reason) {\n	\n	      }\n	\n	      findAuthor(function(author, err){\n	        if (err) {\n	          failure(err);\n	          // failure\n	        } else {\n	          try {\n	            findBoooksByAuthor(author, function(books, err) {\n	              if (err) {\n	                failure(err);\n	              } else {\n	                try {\n	                  foundBooks(books);\n	                } catch(reason) {\n	                  failure(reason);\n	                }\n	              }\n	            });\n	          } catch(error) {\n	            failure(err);\n	          }\n	          // success\n	        }\n	      });\n	      ```\n	\n	      Promise Example;\n	\n	      ```javascript\n	      findAuthor().\n	        then(findBooksByAuthor).\n	        then(function(books){\n	          // found books\n	      }).catch(function(reason){\n	        // something went wrong\n	      });\n	      ```\n	\n	      @method then\n	      @param {Function} onFulfilled\n	      @param {Function} onRejected\n	      Useful for tooling.\n	      @return {Promise}\n	    */\n	      then: function(onFulfillment, onRejection) {\n	        var parent = this;\n	        var state = parent._state;\n	\n	        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n	          return this;\n	        }\n	\n	        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n	        var result = parent._result;\n	\n	        if (state) {\n	          var callback = arguments[state - 1];\n	          lib$es6$promise$asap$$default(function(){\n	            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n	          });\n	        } else {\n	          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n	        }\n	\n	        return child;\n	      },\n	\n	    /**\n	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n	      as the catch block of a try/catch statement.\n	\n	      ```js\n	      function findAuthor(){\n	        throw new Error('couldn't find that author');\n	      }\n	\n	      // synchronous\n	      try {\n	        findAuthor();\n	      } catch(reason) {\n	        // something went wrong\n	      }\n	\n	      // async with promises\n	      findAuthor().catch(function(reason){\n	        // something went wrong\n	      });\n	      ```\n	\n	      @method catch\n	      @param {Function} onRejection\n	      Useful for tooling.\n	      @return {Promise}\n	    */\n	      'catch': function(onRejection) {\n	        return this.then(null, onRejection);\n	      }\n	    };\n	    function lib$es6$promise$polyfill$$polyfill() {\n	      var local;\n	\n	      if (typeof global !== 'undefined') {\n	          local = global;\n	      } else if (typeof self !== 'undefined') {\n	          local = self;\n	      } else {\n	          try {\n	              local = Function('return this')();\n	          } catch (e) {\n	              throw new Error('polyfill failed because global object is unavailable in this environment');\n	          }\n	      }\n	\n	      var P = local.Promise;\n	\n	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n	        return;\n	      }\n	\n	      local.Promise = lib$es6$promise$promise$$default;\n	    }\n	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n	\n	    var lib$es6$promise$umd$$ES6Promise = {\n	      'Promise': lib$es6$promise$promise$$default,\n	      'polyfill': lib$es6$promise$polyfill$$default\n	    };\n	\n	    /* global define:true module:true window: true */\n	    if (\"function\" === 'function' && __webpack_require__(9)['amd']) {\n	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	    } else if (typeof module !== 'undefined' && module['exports']) {\n	      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n	    } else if (typeof this !== 'undefined') {\n	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n	    }\n	\n	    lib$es6$promise$polyfill$$default();\n	}).call(this);\n	\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, (function() { return this; }()), __webpack_require__(8)(module)))\n	\n	/***/ },\n	/* 6 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(7).nextTick;\n	var apply = Function.prototype.apply;\n	var slice = Array.prototype.slice;\n	var immediateIds = {};\n	var nextImmediateId = 0;\n	\n	// DOM APIs, for completeness\n	\n	exports.setTimeout = function() {\n	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n	};\n	exports.setInterval = function() {\n	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n	};\n	exports.clearTimeout =\n	exports.clearInterval = function(timeout) { timeout.close(); };\n	\n	function Timeout(id, clearFn) {\n	  this._id = id;\n	  this._clearFn = clearFn;\n	}\n	Timeout.prototype.unref = Timeout.prototype.ref = function() {};\n	Timeout.prototype.close = function() {\n	  this._clearFn.call(window, this._id);\n	};\n	\n	// Does not start the time, just sets up the members needed.\n	exports.enroll = function(item, msecs) {\n	  clearTimeout(item._idleTimeoutId);\n	  item._idleTimeout = msecs;\n	};\n	\n	exports.unenroll = function(item) {\n	  clearTimeout(item._idleTimeoutId);\n	  item._idleTimeout = -1;\n	};\n	\n	exports._unrefActive = exports.active = function(item) {\n	  clearTimeout(item._idleTimeoutId);\n	\n	  var msecs = item._idleTimeout;\n	  if (msecs >= 0) {\n	    item._idleTimeoutId = setTimeout(function onTimeout() {\n	      if (item._onTimeout)\n	        item._onTimeout();\n	    }, msecs);\n	  }\n	};\n	\n	// That's not how node.js implements it but the exposed api is the same.\n	exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n	  var id = nextImmediateId++;\n	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n	\n	  immediateIds[id] = true;\n	\n	  nextTick(function onNextTick() {\n	    if (immediateIds[id]) {\n	      // fn.call() is faster so we optimize for the common use-case\n	      // @see http://jsperf.com/call-apply-segu\n	      if (args) {\n	        fn.apply(null, args);\n	      } else {\n	        fn.call(null);\n	      }\n	      // Prevent ids from leaking\n	      exports.clearImmediate(id);\n	    }\n	  });\n	\n	  return id;\n	};\n	\n	exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n	  delete immediateIds[id];\n	};\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, __webpack_require__(6).clearImmediate))\n	\n	/***/ },\n	/* 7 */\n	/***/ function(module, exports) {\n	\n	// shim for using process in browser\n	\n	var process = module.exports = {};\n	var queue = [];\n	var draining = false;\n	var currentQueue;\n	var queueIndex = -1;\n	\n	function cleanUpNextTick() {\n	    draining = false;\n	    if (currentQueue.length) {\n	        queue = currentQueue.concat(queue);\n	    } else {\n	        queueIndex = -1;\n	    }\n	    if (queue.length) {\n	        drainQueue();\n	    }\n	}\n	\n	function drainQueue() {\n	    if (draining) {\n	        return;\n	    }\n	    var timeout = setTimeout(cleanUpNextTick);\n	    draining = true;\n	\n	    var len = queue.length;\n	    while(len) {\n	        currentQueue = queue;\n	        queue = [];\n	        while (++queueIndex < len) {\n	            if (currentQueue) {\n	                currentQueue[queueIndex].run();\n	            }\n	        }\n	        queueIndex = -1;\n	        len = queue.length;\n	    }\n	    currentQueue = null;\n	    draining = false;\n	    clearTimeout(timeout);\n	}\n	\n	process.nextTick = function (fun) {\n	    var args = new Array(arguments.length - 1);\n	    if (arguments.length > 1) {\n	        for (var i = 1; i < arguments.length; i++) {\n	            args[i - 1] = arguments[i];\n	        }\n	    }\n	    queue.push(new Item(fun, args));\n	    if (queue.length === 1 && !draining) {\n	        setTimeout(drainQueue, 0);\n	    }\n	};\n	\n	// v8 likes predictible objects\n	function Item(fun, array) {\n	    this.fun = fun;\n	    this.array = array;\n	}\n	Item.prototype.run = function () {\n	    this.fun.apply(null, this.array);\n	};\n	process.title = 'browser';\n	process.browser = true;\n	process.env = {};\n	process.argv = [];\n	process.version = ''; // empty string to avoid regexp issues\n	process.versions = {};\n	\n	function noop() {}\n	\n	process.on = noop;\n	process.addListener = noop;\n	process.once = noop;\n	process.off = noop;\n	process.removeListener = noop;\n	process.removeAllListeners = noop;\n	process.emit = noop;\n	\n	process.binding = function (name) {\n	    throw new Error('process.binding is not supported');\n	};\n	\n	process.cwd = function () { return '/' };\n	process.chdir = function (dir) {\n	    throw new Error('process.chdir is not supported');\n	};\n	process.umask = function() { return 0; };\n	\n	\n	/***/ },\n	/* 8 */\n	/***/ function(module, exports) {\n	\n	module.exports = function(module) {\n		if(!module.webpackPolyfill) {\n			module.deprecate = function() {};\n			module.paths = [];\n			// module.parent = undefined by default\n			module.children = [];\n			module.webpackPolyfill = 1;\n		}\n		return module;\n	}\n	\n	\n	/***/ },\n	/* 9 */\n	/***/ function(module, exports) {\n	\n	module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\n	\n	\n	/***/ },\n	/* 10 */\n	/***/ function(module, exports) {\n	\n	(function() {\n	  'use strict';\n	\n	  if (self.fetch) {\n	    return\n	  }\n	\n	  function normalizeName(name) {\n	    if (typeof name !== 'string') {\n	      name = String(name)\n	    }\n	    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n	      throw new TypeError('Invalid character in header field name')\n	    }\n	    return name.toLowerCase()\n	  }\n	\n	  function normalizeValue(value) {\n	    if (typeof value !== 'string') {\n	      value = String(value)\n	    }\n	    return value\n	  }\n	\n	  function Headers(headers) {\n	    this.map = {}\n	\n	    if (headers instanceof Headers) {\n	      headers.forEach(function(value, name) {\n	        this.append(name, value)\n	      }, this)\n	\n	    } else if (headers) {\n	      Object.getOwnPropertyNames(headers).forEach(function(name) {\n	        this.append(name, headers[name])\n	      }, this)\n	    }\n	  }\n	\n	  Headers.prototype.append = function(name, value) {\n	    name = normalizeName(name)\n	    value = normalizeValue(value)\n	    var list = this.map[name]\n	    if (!list) {\n	      list = []\n	      this.map[name] = list\n	    }\n	    list.push(value)\n	  }\n	\n	  Headers.prototype['delete'] = function(name) {\n	    delete this.map[normalizeName(name)]\n	  }\n	\n	  Headers.prototype.get = function(name) {\n	    var values = this.map[normalizeName(name)]\n	    return values ? values[0] : null\n	  }\n	\n	  Headers.prototype.getAll = function(name) {\n	    return this.map[normalizeName(name)] || []\n	  }\n	\n	  Headers.prototype.has = function(name) {\n	    return this.map.hasOwnProperty(normalizeName(name))\n	  }\n	\n	  Headers.prototype.set = function(name, value) {\n	    this.map[normalizeName(name)] = [normalizeValue(value)]\n	  }\n	\n	  Headers.prototype.forEach = function(callback, thisArg) {\n	    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n	      this.map[name].forEach(function(value) {\n	        callback.call(thisArg, value, name, this)\n	      }, this)\n	    }, this)\n	  }\n	\n	  function consumed(body) {\n	    if (body.bodyUsed) {\n	      return Promise.reject(new TypeError('Already read'))\n	    }\n	    body.bodyUsed = true\n	  }\n	\n	  function fileReaderReady(reader) {\n	    return new Promise(function(resolve, reject) {\n	      reader.onload = function() {\n	        resolve(reader.result)\n	      }\n	      reader.onerror = function() {\n	        reject(reader.error)\n	      }\n	    })\n	  }\n	\n	  function readBlobAsArrayBuffer(blob) {\n	    var reader = new FileReader()\n	    reader.readAsArrayBuffer(blob)\n	    return fileReaderReady(reader)\n	  }\n	\n	  function readBlobAsText(blob) {\n	    var reader = new FileReader()\n	    reader.readAsText(blob)\n	    return fileReaderReady(reader)\n	  }\n	\n	  var support = {\n	    blob: 'FileReader' in self && 'Blob' in self && (function() {\n	      try {\n	        new Blob();\n	        return true\n	      } catch(e) {\n	        return false\n	      }\n	    })(),\n	    formData: 'FormData' in self\n	  }\n	\n	  function Body() {\n	    this.bodyUsed = false\n	\n	\n	    this._initBody = function(body) {\n	      this._bodyInit = body\n	      if (typeof body === 'string') {\n	        this._bodyText = body\n	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n	        this._bodyBlob = body\n	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n	        this._bodyFormData = body\n	      } else if (!body) {\n	        this._bodyText = ''\n	      } else {\n	        throw new Error('unsupported BodyInit type')\n	      }\n	    }\n	\n	    if (support.blob) {\n	      this.blob = function() {\n	        var rejected = consumed(this)\n	        if (rejected) {\n	          return rejected\n	        }\n	\n	        if (this._bodyBlob) {\n	          return Promise.resolve(this._bodyBlob)\n	        } else if (this._bodyFormData) {\n	          throw new Error('could not read FormData body as blob')\n	        } else {\n	          return Promise.resolve(new Blob([this._bodyText]))\n	        }\n	      }\n	\n	      this.arrayBuffer = function() {\n	        return this.blob().then(readBlobAsArrayBuffer)\n	      }\n	\n	      this.text = function() {\n	        var rejected = consumed(this)\n	        if (rejected) {\n	          return rejected\n	        }\n	\n	        if (this._bodyBlob) {\n	          return readBlobAsText(this._bodyBlob)\n	        } else if (this._bodyFormData) {\n	          throw new Error('could not read FormData body as text')\n	        } else {\n	          return Promise.resolve(this._bodyText)\n	        }\n	      }\n	    } else {\n	      this.text = function() {\n	        var rejected = consumed(this)\n	        return rejected ? rejected : Promise.resolve(this._bodyText)\n	      }\n	    }\n	\n	    if (support.formData) {\n	      this.formData = function() {\n	        return this.text().then(decode)\n	      }\n	    }\n	\n	    this.json = function() {\n	      return this.text().then(JSON.parse)\n	    }\n	\n	    return this\n	  }\n	\n	  // HTTP methods whose capitalization should be normalized\n	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n	\n	  function normalizeMethod(method) {\n	    var upcased = method.toUpperCase()\n	    return (methods.indexOf(upcased) > -1) ? upcased : method\n	  }\n	\n	  function Request(input, options) {\n	    options = options || {}\n	    var body = options.body\n	    if (Request.prototype.isPrototypeOf(input)) {\n	      if (input.bodyUsed) {\n	        throw new TypeError('Already read')\n	      }\n	      this.url = input.url\n	      this.credentials = input.credentials\n	      if (!options.headers) {\n	        this.headers = new Headers(input.headers)\n	      }\n	      this.method = input.method\n	      this.mode = input.mode\n	      if (!body) {\n	        body = input._bodyInit\n	        input.bodyUsed = true\n	      }\n	    } else {\n	      this.url = input\n	    }\n	\n	    this.credentials = options.credentials || this.credentials || 'omit'\n	    if (options.headers || !this.headers) {\n	      this.headers = new Headers(options.headers)\n	    }\n	    this.method = normalizeMethod(options.method || this.method || 'GET')\n	    this.mode = options.mode || this.mode || null\n	    this.referrer = null\n	\n	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n	      throw new TypeError('Body not allowed for GET or HEAD requests')\n	    }\n	    this._initBody(body)\n	  }\n	\n	  function decode(body) {\n	    var form = new FormData()\n	    body.trim().split('&').forEach(function(bytes) {\n	      if (bytes) {\n	        var split = bytes.split('=')\n	        var name = split.shift().replace(/\\+/g, ' ')\n	        var value = split.join('=').replace(/\\+/g, ' ')\n	        form.append(decodeURIComponent(name), decodeURIComponent(value))\n	      }\n	    })\n	    return form\n	  }\n	\n	  function headers(xhr) {\n	    var head = new Headers()\n	    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n	    pairs.forEach(function(header) {\n	      var split = header.trim().split(':')\n	      var key = split.shift().trim()\n	      var value = split.join(':').trim()\n	      head.append(key, value)\n	    })\n	    return head\n	  }\n	\n	  Body.call(Request.prototype)\n	\n	  function Response(bodyInit, options) {\n	    if (!options) {\n	      options = {}\n	    }\n	\n	    this._initBody(bodyInit)\n	    this.type = 'default'\n	    this.url = null\n	    this.status = options.status\n	    this.ok = this.status >= 200 && this.status < 300\n	    this.statusText = options.statusText\n	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n	    this.url = options.url || ''\n	  }\n	\n	  Body.call(Response.prototype)\n	\n	  self.Headers = Headers;\n	  self.Request = Request;\n	  self.Response = Response;\n	\n	  self.fetch = function(input, init) {\n	    var request\n	    if (Request.prototype.isPrototypeOf(input) && !init) {\n	      request = input\n	    } else {\n	      request = new Request(input, init)\n	    }\n	\n	    return new Promise(function(resolve, reject) {\n	      var xhr = new XMLHttpRequest()\n	\n	      function responseURL() {\n	        if ('responseURL' in xhr) {\n	          return xhr.responseURL\n	        }\n	\n	        // Avoid security warnings on getResponseHeader when not allowed by CORS\n	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n	          return xhr.getResponseHeader('X-Request-URL')\n	        }\n	\n	        return;\n	      }\n	\n	      xhr.onload = function() {\n	        var status = (xhr.status === 1223) ? 204 : xhr.status\n	        if (status < 100 || status > 599) {\n	          reject(new TypeError('Network request failed'))\n	          return\n	        }\n	        var options = {\n	          status: status,\n	          statusText: xhr.statusText,\n	          headers: headers(xhr),\n	          url: responseURL()\n	        }\n	        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n	        resolve(new Response(body, options))\n	      }\n	\n	      xhr.onerror = function() {\n	        reject(new TypeError('Network request failed'))\n	      }\n	\n	      xhr.open(request.method, request.url, true)\n	\n	      if (request.credentials === 'include') {\n	        xhr.withCredentials = true\n	      }\n	\n	      if ('responseType' in xhr && support.blob) {\n	        xhr.responseType = 'blob'\n	      }\n	\n	      request.headers.forEach(function(value, name) {\n	        xhr.setRequestHeader(name, value)\n	      })\n	\n	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n	    })\n	  }\n	  self.fetch.polyfill = true\n	})();\n	\n	\n	/***/ },\n	/* 11 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	/* WEBPACK VAR INJECTION */(function(module) {// Version: 3.7.16\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	/* =-=========================     JSON     =============================-= */\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	\n	(window['JSON'] && window['JSON']['stringify']) || (function () {\n	    window['JSON'] || (window['JSON'] = {});\n	\n	    function toJSON(key) {\n	        try      { return this.valueOf() }\n	        catch(e) { return null }\n	    }\n	\n	    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n	        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n	        gap,\n	        indent,\n	        meta = {    // table of character substitutions\n	            '\\b': '\\\\b',\n	            '\\t': '\\\\t',\n	            '\\n': '\\\\n',\n	            '\\f': '\\\\f',\n	            '\\r': '\\\\r',\n	            '\"' : '\\\\\"',\n	            '\\\\': '\\\\\\\\'\n	        },\n	        rep;\n	\n	    function quote(string) {\n	        escapable.lastIndex = 0;\n	        return escapable.test(string) ?\n	            '\"' + string.replace(escapable, function (a) {\n	                var c = meta[a];\n	                return typeof c === 'string' ? c :\n	                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n	            }) + '\"' :\n	            '\"' + string + '\"';\n	    }\n	\n	    function str(key, holder) {\n	        var i,          // The loop counter.\n	            k,          // The member key.\n	            v,          // The member value.\n	            length,\n	            partial,\n	            mind  = gap,\n	            value = holder[key];\n	\n	        if (value && typeof value === 'object') {\n	            value = toJSON.call( value, key );\n	        }\n	\n	        if (typeof rep === 'function') {\n	            value = rep.call(holder, key, value);\n	        }\n	\n	        switch (typeof value) {\n	        case 'string':\n	            return quote(value);\n	\n	        case 'number':\n	            return isFinite(value) ? String(value) : 'null';\n	\n	        case 'boolean':\n	        case 'null':\n	            return String(value);\n	\n	        case 'object':\n	\n	            if (!value) {\n	                return 'null';\n	            }\n	\n	            gap += indent;\n	            partial = [];\n	\n	            if (Object.prototype.toString.apply(value) === '[object Array]') {\n	\n	                length = value.length;\n	                for (i = 0; i < length; i += 1) {\n	                    partial[i] = str(i, value) || 'null';\n	                }\n	\n	                v = partial.length === 0 ? '[]' :\n	                    gap ? '[\\n' + gap +\n	                            partial.join(',\\n' + gap) + '\\n' +\n	                                mind + ']' :\n	                          '[' + partial.join(',') + ']';\n	                gap = mind;\n	                return v;\n	            }\n	            if (rep && typeof rep === 'object') {\n	                length = rep.length;\n	                for (i = 0; i < length; i += 1) {\n	                    k = rep[i];\n	                    if (typeof k === 'string') {\n	                        v = str(k, value);\n	                        if (v) {\n	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n	                        }\n	                    }\n	                }\n	            } else {\n	                for (k in value) {\n	                    if (Object.hasOwnProperty.call(value, k)) {\n	                        v = str(k, value);\n	                        if (v) {\n	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n	                        }\n	                    }\n	                }\n	            }\n	\n	            v = partial.length === 0 ? '{}' :\n	                gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n	                        mind + '}' : '{' + partial.join(',') + '}';\n	            gap = mind;\n	            return v;\n	        }\n	    }\n	\n	    if (typeof JSON['stringify'] !== 'function') {\n	        JSON['stringify'] = function (value, replacer, space) {\n	            var i;\n	            gap = '';\n	            indent = '';\n	\n	            if (typeof space === 'number') {\n	                for (i = 0; i < space; i += 1) {\n	                    indent += ' ';\n	                }\n	            } else if (typeof space === 'string') {\n	                indent = space;\n	            }\n	            rep = replacer;\n	            if (replacer && typeof replacer !== 'function' &&\n	                    (typeof replacer !== 'object' ||\n	                     typeof replacer.length !== 'number')) {\n	                throw new Error('JSON.stringify');\n	            }\n	            return str('', {'': value});\n	        };\n	    }\n	\n	    if (typeof JSON['parse'] !== 'function') {\n	        // JSON is parsed on the server for security.\n	        JSON['parse'] = function (text) {return eval('('+text+')')};\n	    }\n	}());\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	/* =-=========================     UTIL     =============================-= */\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	\n	window['PUBNUB'] || (function() {\n	var NOW             = 1\n	,   READY           = false\n	,   READY_BUFFER    = []\n	,   PRESENCE_SUFFIX = '-pnpres'\n	,   DEF_WINDOWING   = 10     // MILLISECONDS.\n	,   DEF_TIMEOUT     = 10000  // MILLISECONDS.\n	,   DEF_SUB_TIMEOUT = 310    // SECONDS.\n	,   DEF_KEEPALIVE   = 60     // SECONDS (FOR TIMESYNC).\n	,   SECOND          = 1000   // A THOUSAND MILLISECONDS.\n	,   URLBIT          = '/'\n	,   PARAMSBIT       = '&'\n	,   PRESENCE_HB_THRESHOLD = 5\n	,   PRESENCE_HB_DEFAULT  = 30\n	,   SDK_VER         = '3.7.16'\n	,   REPL            = /{([\\w\\-]+)}/g;\n	\n	/**\n	 * UTILITIES\n	 */\n	function unique() { return'x'+ ++NOW+''+(+new Date) }\n	function rnow()   { return+new Date }\n	\n	/**\n	 * NEXTORIGIN\n	 * ==========\n	 * var next_origin = nextorigin();\n	 */\n	var nextorigin = (function() {\n	    var max = 20\n	    ,   ori = Math.floor(Math.random() * max);\n	    return function( origin, failover ) {\n	        return origin.indexOf('pubsub.') > 0\n	            && origin.replace(\n	             'pubsub', 'ps' + (\n	                failover ? generate_uuid().split('-')[0] :\n	                (++ori < max? ori : ori=1)\n	            ) ) || origin;\n	    }\n	})();\n	\n	\n	/**\n	 * Build Url\n	 * =======\n	 *\n	 */\n	function build_url( url_components, url_params ) {\n	    var url    = url_components.join(URLBIT)\n	    ,   params = [];\n	\n	    if (!url_params) return url;\n	\n	    each( url_params, function( key, value ) {\n	        var value_str = (typeof value == 'object')?JSON['stringify'](value):value;\n	        (typeof value != 'undefined' &&\n	            value != null && encode(value_str).length > 0\n	        ) && params.push(key + \"=\" + encode(value_str));\n	    } );\n	\n	    url += \"?\" + params.join(PARAMSBIT);\n	    return url;\n	}\n	\n	/**\n	 * UPDATER\n	 * =======\n	 * var timestamp = unique();\n	 */\n	function updater( fun, rate ) {\n	    var timeout\n	    ,   last   = 0\n	    ,   runnit = function() {\n	        if (last + rate > rnow()) {\n	            clearTimeout(timeout);\n	            timeout = setTimeout( runnit, rate );\n	        }\n	        else {\n	            last = rnow();\n	            fun();\n	        }\n	    };\n	\n	    return runnit;\n	}\n	\n	/**\n	 * GREP\n	 * ====\n	 * var list = grep( [1,2,3], function(item) { return item % 2 } )\n	 */\n	function grep( list, fun ) {\n	    var fin = [];\n	    each( list || [], function(l) { fun(l) && fin.push(l) } );\n	    return fin\n	}\n	\n	/**\n	 * SUPPLANT\n	 * ========\n	 * var text = supplant( 'Hello {name}!', { name : 'John' } )\n	 */\n	function supplant( str, values ) {\n	    return str.replace( REPL, function( _, match ) {\n	        return values[match] || _\n	    } );\n	}\n	\n	/**\n	 * timeout\n	 * =======\n	 * timeout( function(){}, 100 );\n	 */\n	function timeout( fun, wait ) {\n	    return setTimeout( fun, wait );\n	}\n	\n	/**\n	 * uuid\n	 * ====\n	 * var my_uuid = generate_uuid();\n	 */\n	function generate_uuid(callback) {\n	    var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,\n	    function(c) {\n	        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n	        return v.toString(16);\n	    });\n	    if (callback) callback(u);\n	    return u;\n	}\n	\n	function isArray(arg) {\n	  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n	  //return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n	}\n	\n	/**\n	 * EACH\n	 * ====\n	 * each( [1,2,3], function(item) { } )\n	 */\n	function each( o, f) {\n	    if ( !o || !f ) return;\n	\n	    if ( isArray(o) )\n	        for ( var i = 0, l = o.length; i < l; )\n	            f.call( o[i], o[i], i++ );\n	    else\n	        for ( var i in o )\n	            o.hasOwnProperty    &&\n	            o.hasOwnProperty(i) &&\n	            f.call( o[i], i, o[i] );\n	}\n	\n	/**\n	 * MAP\n	 * ===\n	 * var list = map( [1,2,3], function(item) { return item + 1 } )\n	 */\n	function map( list, fun ) {\n	    var fin = [];\n	    each( list || [], function( k, v ) { fin.push(fun( k, v )) } );\n	    return fin;\n	}\n	\n	\n	function pam_encode(str) {\n	  return encodeURIComponent(str).replace(/[!'()*~]/g, function(c) {\n	    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n	  });\n	}\n	\n	/**\n	 * ENCODE\n	 * ======\n	 * var encoded_data = encode('path');\n	 */\n	function encode(path) { return encodeURIComponent(path) }\n	\n	/**\n	 * Generate Subscription Channel List\n	 * ==================================\n	 * generate_channel_list(channels_object);\n	 */\n	function generate_channel_list(channels, nopresence) {\n	    var list = [];\n	    each( channels, function( channel, status ) {\n	        if (nopresence) {\n	            if(channel.search('-pnpres') < 0) {\n	                if (status.subscribed) list.push(channel);\n	            }\n	        } else {\n	            if (status.subscribed) list.push(channel);\n	        }\n	    });\n	    return list.sort();\n	}\n	\n	/**\n	 * Generate Subscription Channel Groups List\n	 * ==================================\n	 * generate_channel_group_list(channels_groups object);\n	 */\n	function generate_channel_group_list(channel_groups, nopresence) {\n	    var list = [];\n	    each(channel_groups, function( channel_group, status ) {\n	        if (nopresence) {\n	            if(channel_group.search('-pnpres') < 0) {\n	                if (status.subscribed) list.push(channel_group);\n	            }\n	        } else {\n	            if (status.subscribed) list.push(channel_group);\n	        }\n	    });\n	    return list.sort();\n	}\n	\n	// PUBNUB READY TO CONNECT\n	function ready() { timeout( function() {\n	    if (READY) return;\n	    READY = 1;\n	    each( READY_BUFFER, function(connect) { connect() } );\n	}, SECOND ); }\n	\n	function PNmessage(args) {\n	    msg = args || {'apns' : {}},\n	    msg['getPubnubMessage'] = function() {\n	        var m = {};\n	\n	        if (Object.keys(msg['apns']).length) {\n	            m['pn_apns'] = {\n	                    'aps' : {\n	                        'alert' : msg['apns']['alert'] ,\n	                        'badge' : msg['apns']['badge']\n	                    }\n	            }\n	            for (var k in msg['apns']) {\n	                m['pn_apns'][k] = msg['apns'][k];\n	            }\n	            var exclude1 = ['badge','alert'];\n	            for (var k in exclude1) {\n	                delete m['pn_apns'][exclude1[k]];\n	            }\n	        }\n	\n	\n	\n	        if (msg['gcm']) {\n	            m['pn_gcm'] = {\n	                'data' : msg['gcm']\n	            }\n	        }\n	\n	        for (var k in msg) {\n	            m[k] = msg[k];\n	        }\n	        var exclude = ['apns','gcm','publish', 'channel','callback','error'];\n	        for (var k in exclude) {\n	            delete m[exclude[k]];\n	        }\n	\n	        return m;\n	    };\n	    msg['publish'] = function() {\n	\n	        var m = msg.getPubnubMessage();\n	\n	        if (msg['pubnub'] && msg['channel']) {\n	            msg['pubnub'].publish({\n	                'message' : m,\n	                'channel' : msg['channel'],\n	                'callback' : msg['callback'],\n	                'error' : msg['error']\n	            })\n	        }\n	    };\n	    return msg;\n	}\n	\n	function PN_API(setup) {\n	    var SUB_WINDOWING =  +setup['windowing']   || DEF_WINDOWING\n	    ,   SUB_TIMEOUT   = (+setup['timeout']     || DEF_SUB_TIMEOUT) * SECOND\n	    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n	    ,   TIME_CHECK    = setup['timecheck']     || 0\n	    ,   NOLEAVE       = setup['noleave']       || 0\n	    ,   PUBLISH_KEY   = setup['publish_key']\n	    ,   SUBSCRIBE_KEY = setup['subscribe_key']\n	    ,   AUTH_KEY      = setup['auth_key']      || ''\n	    ,   SECRET_KEY    = setup['secret_key']    || ''\n	    ,   hmac_SHA256   = setup['hmac_SHA256']\n	    ,   SSL           = setup['ssl']            ? 's' : ''\n	    ,   ORIGIN        = 'http'+SSL+'://'+(setup['origin']||'pubsub.pubnub.com')\n	    ,   STD_ORIGIN    = nextorigin(ORIGIN)\n	    ,   SUB_ORIGIN    = nextorigin(ORIGIN)\n	    ,   CONNECT       = function(){}\n	    ,   PUB_QUEUE     = []\n	    ,   CLOAK         = true\n	    ,   TIME_DRIFT    = 0\n	    ,   SUB_CALLBACK  = 0\n	    ,   SUB_CHANNEL   = 0\n	    ,   SUB_RECEIVER  = 0\n	    ,   SUB_RESTORE   = setup['restore'] || 0\n	    ,   SUB_BUFF_WAIT = 0\n	    ,   TIMETOKEN     = 0\n	    ,   RESUMED       = false\n	    ,   CHANNELS      = {}\n	    ,   CHANNEL_GROUPS       = {}\n	    ,   SUB_ERROR     = function(){}\n	    ,   STATE         = {}\n	    ,   PRESENCE_HB_TIMEOUT  = null\n	    ,   PRESENCE_HB          = validate_presence_heartbeat(\n	        setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']\n	    )\n	    ,   PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) -1\n	    ,   PRESENCE_HB_RUNNING  = false\n	    ,   NO_WAIT_FOR_PENDING  = setup['no_wait_for_pending']\n	    ,   COMPATIBLE_35 = setup['compatible_3.5']  || false\n	    ,   xdr           = setup['xdr']\n	    ,   params        = setup['params'] || {}\n	    ,   error         = setup['error']      || function() {}\n	    ,   _is_online    = setup['_is_online'] || function() { return 1 }\n	    ,   jsonp_cb      = setup['jsonp_cb']   || function() { return 0 }\n	    ,   db            = setup['db']         || {'get': function(){}, 'set': function(){}}\n	    ,   CIPHER_KEY    = setup['cipher_key']\n	    ,   UUID          = setup['uuid'] || ( !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY+'uuid') || '')\n	    ,   USE_INSTANCEID = setup['instance_id'] || false\n	    ,   INSTANCEID    = ''\n	    ,   shutdown      = setup['shutdown']\n	    ,   use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined')?setup['use_send_beacon']:true\n	    ,   sendBeacon    = (use_send_beacon)?setup['sendBeacon']:null\n	    ,   _poll_timer\n	    ,   _poll_timer2;\n	\n	    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n	\n	    var crypto_obj    = setup['crypto_obj'] ||\n	        {\n	            'encrypt' : function(a,key){ return a},\n	            'decrypt' : function(b,key){return b}\n	        };\n	\n	    function _get_url_params(data) {\n	        if (!data) data = {};\n	        each( params , function( key, value ) {\n	            if (!(key in data)) data[key] = value;\n	        });\n	        return data;\n	    }\n	\n	    function _object_to_key_list(o) {\n	        var l = []\n	        each( o , function( key, value ) {\n	            l.push(key);\n	        });\n	        return l;\n	    }\n	    function _object_to_key_list_sorted(o) {\n	        return _object_to_key_list(o).sort();\n	    }\n	\n	    function _get_pam_sign_input_from_params(params) {\n	        var si = \"\";\n	        var l = _object_to_key_list_sorted(params);\n	\n	        for (var i in l) {\n	            var k = l[i]\n	            si += k + \"=\" + pam_encode(params[k]) ;\n	            if (i != l.length - 1) si += \"&\"\n	        }\n	        return si;\n	    }\n	\n	    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n	        var err = false;\n	\n	        if (typeof heartbeat === 'undefined') {\n	            return cur_heartbeat;\n	        }\n	\n	        if (typeof heartbeat === 'number') {\n	            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0)\n	                err = false;\n	            else\n	                err = true;\n	        } else if(typeof heartbeat === 'boolean'){\n	            if (!heartbeat) {\n	                return 0;\n	            } else {\n	                return PRESENCE_HB_DEFAULT;\n	            }\n	        } else {\n	            err = true;\n	        }\n	\n	        if (err) {\n	            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n	            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n	        } else return heartbeat;\n	    }\n	\n	    function encrypt(input, key) {\n	        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n	    }\n	    function decrypt(input, key) {\n	        return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||\n	               crypto_obj['decrypt'](input, CIPHER_KEY) ||\n	               input;\n	    }\n	\n	    function error_common(message, callback) {\n	        callback && callback({ 'error' : message || \"error occurred\"});\n	        error && error(message);\n	    }\n	    function _presence_heartbeat() {\n	\n	        clearTimeout(PRESENCE_HB_TIMEOUT);\n	\n	        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||\n	            PRESENCE_HB_INTERVAL < 1 ||\n	            (!generate_channel_list(CHANNELS,true).length  && !generate_channel_group_list(CHANNEL_GROUPS, true).length ) )\n	        {\n	            PRESENCE_HB_RUNNING = false;\n	            return;\n	        }\n	\n	        PRESENCE_HB_RUNNING = true;\n	        SELF['presence_heartbeat']({\n	            'callback' : function(r) {\n	                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n	            },\n	            'error' : function(e) {\n	                error && error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n	                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n	            }\n	        });\n	    }\n	\n	    function start_presence_heartbeat() {\n	        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n	    }\n	\n	    function publish(next) {\n	\n	        if (NO_WAIT_FOR_PENDING) {\n	            if (!PUB_QUEUE.length) return;\n	        } else {\n	            if (next) PUB_QUEUE.sending = 0;\n	            if ( PUB_QUEUE.sending || !PUB_QUEUE.length ) return;\n	            PUB_QUEUE.sending = 1;\n	        }\n	\n	        xdr(PUB_QUEUE.shift());\n	    }\n	    function each_channel_group(callback) {\n	        var count = 0;\n	\n	        each( generate_channel_group_list(CHANNEL_GROUPS), function(channel_group) {\n	            var chang = CHANNEL_GROUPS[channel_group];\n	\n	            if (!chang) return;\n	\n	            count++;\n	            (callback||function(){})(chang);\n	        } );\n	\n	        return count;\n	    }\n	\n	    function each_channel(callback) {\n	        var count = 0;\n	\n	        each( generate_channel_list(CHANNELS), function(channel) {\n	            var chan = CHANNELS[channel];\n	\n	            if (!chan) return;\n	\n	            count++;\n	            (callback||function(){})(chan);\n	        } );\n	\n	        return count;\n	    }\n	    function _invoke_callback(response, callback, err) {\n	        if (typeof response == 'object') {\n	            if (response['error']) {\n	                var callback_data = {};\n	\n	                if (response['message']) {\n	                    callback_data['message'] = response['message'];\n	                }\n	\n	                if (response['payload']) {\n	                    callback_data['payload'] = response['payload'];\n	                }\n	\n	                err && err(callback_data);\n	                return;\n	\n	            }\n	            if (response['payload']) {\n	                if (response['next_page'])\n	                    callback && callback(response['payload'], response['next_page']);\n	                else\n	                    callback && callback(response['payload']);\n	                return;\n	            }\n	        }\n	        callback && callback(response);\n	    }\n	\n	    function _invoke_error(response,err) {\n	\n	        if (typeof response == 'object' && response['error']) {\n	                var callback_data = {};\n	\n	                if (response['message']) {\n	                    callback_data['message'] = response['message'];\n	                }\n	\n	                if (response['payload']) {\n	                    callback_data['payload'] = response['payload'];\n	                }\n	                \n	                err && err(callback_data);\n	                return;\n	        } else {\n	            err && err(response);\n	        }\n	    }\n	    function CR(args, callback, url1, data) {\n	            var callback        = args['callback']      || callback\n	            ,   err             = args['error']         || error\n	            ,   jsonp           = jsonp_cb();\n	\n	            data = data || {};\n	            \n	            if (!data['auth']) {\n	                data['auth'] = args['auth_key'] || AUTH_KEY;\n	            }\n	            \n	            var url = [\n	                    STD_ORIGIN, 'v1', 'channel-registration',\n	                    'sub-key', SUBSCRIBE_KEY\n	                ];\n	\n	            url.push.apply(url,url1);\n	            \n	            if (jsonp) data['callback']              = jsonp;\n	            \n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	\n	    }\n	\n	    // Announce Leave Event\n	    var SELF = {\n	        'LEAVE' : function( channel, blocking, auth_key, callback, error ) {\n	\n	            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n	            ,   origin = nextorigin(ORIGIN)\n	            ,   callback = callback || function(){}\n	            ,   err      = error    || function(){}\n	            ,   url\n	            ,   params\n	            ,   jsonp  = jsonp_cb();\n	\n	            // Prevent Leaving a Presence Channel\n	            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n	\n	\n	            if (COMPATIBLE_35) {\n	                if (!SSL)         return false;\n	                if (jsonp == '0') return false;\n	            }\n	\n	            if (NOLEAVE)  return false;\n	\n	            if (jsonp != '0') data['callback'] = jsonp;\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            url = [\n	                    origin, 'v2', 'presence', 'sub_key',\n	                    SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'\n	                ];\n	\n	            params = _get_url_params(data);\n	\n	\n	            if (sendBeacon) {\n	                url_string = build_url(url, params);\n	                if (sendBeacon(url_string)) {\n	                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n	                    return true;\n	                }\n	            }\n	\n	\n	            xdr({\n	                blocking : blocking || SSL,\n	                timeout  : 2000,\n	                callback : jsonp,\n	                data     : params,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	            return true;\n	        },\n	        'LEAVE_GROUP' : function( channel_group, blocking, auth_key, callback, error ) {\n	\n	            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n	            ,   origin = nextorigin(ORIGIN)\n	            ,   url\n	            ,   params\n	            ,   callback = callback || function(){}\n	            ,   err      = error    || function(){}\n	            ,   jsonp  = jsonp_cb();\n	\n	            // Prevent Leaving a Presence Channel Group\n	            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n	\n	            if (COMPATIBLE_35) {\n	                if (!SSL)         return false;\n	                if (jsonp == '0') return false;\n	            }\n	\n	            if (NOLEAVE)  return false;\n	\n	            if (jsonp != '0') data['callback'] = jsonp;\n	\n	            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            url = [\n	                    origin, 'v2', 'presence', 'sub_key',\n	                    SUBSCRIBE_KEY, 'channel', encode(','), 'leave'\n	            ];\n	\n	            params = _get_url_params(data);\n	\n	            if (sendBeacon) {\n	                url_string = build_url(url, params);\n	                if (sendBeacon(url_string)) {\n	                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n	                    return true;\n	                }\n	            }\n	\n	            xdr({\n	                blocking : blocking || SSL,\n	                timeout  : 5000,\n	                callback : jsonp,\n	                data     : params,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	            return true;\n	        },\n	        'set_resumed' : function(resumed) {\n	                RESUMED = resumed;\n	        },\n	        'get_cipher_key' : function() {\n	            return CIPHER_KEY;\n	        },\n	        'set_cipher_key' : function(key) {\n	            CIPHER_KEY = key;\n	        },\n	        'raw_encrypt' : function(input, key) {\n	            return encrypt(input, key);\n	        },\n	        'raw_decrypt' : function(input, key) {\n	            return decrypt(input, key);\n	        },\n	        'get_heartbeat' : function() {\n	            return PRESENCE_HB;\n	        },\n	        \n	        'set_heartbeat' : function(heartbeat, heartbeat_interval) {\n	            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);\n	            PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;\n	            if (PRESENCE_HB == 2) {\n	                PRESENCE_HB_INTERVAL = 1;\n	            }\n	            CONNECT();\n	            _presence_heartbeat();\n	        },\n	        \n	        'get_heartbeat_interval' : function() {\n	            return PRESENCE_HB_INTERVAL;\n	        },\n	        \n	        'set_heartbeat_interval' : function(heartbeat_interval) {\n	            PRESENCE_HB_INTERVAL = heartbeat_interval;\n	            _presence_heartbeat();\n	        },\n	        \n	        'get_version' : function() {\n	            return SDK_VER;\n	        },\n	        'getGcmMessageObject' : function(obj) {\n	            return {\n	                'data' : obj\n	            }\n	        },\n	        'getApnsMessageObject' : function(obj) {\n	            var x =  {\n	                'aps' : { 'badge' : 1, 'alert' : ''}\n	            }\n	            for (k in obj) {\n	                k[x] = obj[k];\n	            }\n	            return x;\n	        },\n	        'newPnMessage' : function() {\n	            var x = {};\n	            if (gcm) x['pn_gcm'] = gcm;\n	            if (apns) x['pn_apns'] = apns;\n	            for ( k in n ) {\n	                x[k] = n[k];\n	            }\n	            return x;\n	        },\n	\n	        '_add_param' : function(key,val) {\n	            params[key] = val;\n	        },\n	\n	        'channel_group' : function(args, callback) {\n	            var ns_ch       = args['channel_group']\n	            ,   callback    = callback         || args['callback']\n	            ,   channels    = args['channels'] || args['channel']\n	            ,   cloak       = args['cloak']\n	            ,   namespace\n	            ,   channel_group\n	            ,   url = []\n	            ,   data = {}\n	            ,   mode = args['mode'] || 'add';\n	\n	\n	            if (ns_ch) {\n	                var ns_ch_a = ns_ch.split(':');\n	\n	                if (ns_ch_a.length > 1) {\n	                    namespace = (ns_ch_a[0] === '*')?null:ns_ch_a[0];\n	\n	                    channel_group = ns_ch_a[1];\n	                } else {\n	                    channel_group = ns_ch_a[0];\n	                }\n	            }\n	\n	            namespace && url.push('namespace') && url.push(encode(namespace));\n	\n	            url.push('channel-group');\n	\n	            if (channel_group && channel_group !== '*') {\n	                url.push(channel_group);\n	            }\n	\n	            if (channels ) {\n	                if (isArray(channels)) {\n	                    channels = channels.join(',');\n	                }\n	                data[mode] = channels;\n	                data['cloak'] = (CLOAK)?'true':'false';\n	            } else {\n	                if (mode === 'remove') url.push('remove');\n	            }\n	\n	            if (typeof cloak != 'undefined') data['cloak'] = (cloak)?'true':'false';\n	\n	            CR(args, callback, url, data);\n	        },\n	\n	        'channel_group_list_groups' : function(args, callback) {\n	            var namespace;\n	\n	            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n	            if (namespace) {\n	                args[\"channel_group\"] = namespace + \":*\";\n	            }\n	\n	            SELF['channel_group'](args, callback);\n	        },\n	\n	        'channel_group_list_channels' : function(args, callback) {\n	            if (!args['channel_group']) return error('Missing Channel Group');\n	            SELF['channel_group'](args, callback);\n	        },\n	\n	        'channel_group_remove_channel' : function(args, callback) {\n	            if (!args['channel_group']) return error('Missing Channel Group');\n	            if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n	\n	            args['mode'] = 'remove';\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_remove_group' : function(args, callback) {\n	            if (!args['channel_group']) return error('Missing Channel Group');\n	            if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n	\n	            args['mode'] = 'remove';\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_add_channel' : function(args, callback) {\n	           if (!args['channel_group']) return error('Missing Channel Group');\n	           if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_cloak' : function(args, callback) {\n	            if (typeof args['cloak'] == 'undefined') {\n	                callback(CLOAK);\n	                return;\n	            }\n	            CLOAK = args['cloak'];\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_list_namespaces' : function(args, callback) {\n	            var url = ['namespace'];\n	            CR(args, callback, url);\n	        },\n	        'channel_group_remove_namespace' : function(args, callback) {\n	            var url = ['namespace',args['namespace'],'remove'];\n	            CR(args, callback, url);\n	        },\n	\n	        /*\n	            PUBNUB.history({\n	                channel  : 'my_chat_channel',\n	                limit    : 100,\n	                callback : function(history) { }\n	            });\n	        */\n	        'history' : function( args, callback ) {\n	            var callback         = args['callback'] || callback\n	            ,   count            = args['count']    || args['limit'] || 100\n	            ,   reverse          = args['reverse']  || \"false\"\n	            ,   err              = args['error']    || function(){}\n	            ,   auth_key         = args['auth_key'] || AUTH_KEY\n	            ,   cipher_key       = args['cipher_key']\n	            ,   channel          = args['channel']\n	            ,   channel_group    = args['channel_group']\n	            ,   start            = args['start']\n	            ,   end              = args['end']\n	            ,   include_token    = args['include_token']\n	            ,   string_msg_token = args['string_message_token'] || false\n	            ,   params           = {}\n	            ,   jsonp            = jsonp_cb();\n	\n	            // Make sure we have a Channel\n	            if (!channel && !channel_group) return error('Missing Channel');\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            params['stringtoken'] = 'true';\n	            params['count']       = count;\n	            params['reverse']     = reverse;\n	            params['auth']        = auth_key;\n	\n	            if (channel_group) {\n	                params['channel-group'] = channel_group;\n	                if (!channel) {\n	                    channel = ','; \n	                }\n	            }\n	            if (jsonp) params['callback']              = jsonp;\n	            if (start) params['start']                 = start;\n	            if (end)   params['end']                   = end;\n	            if (include_token) params['include_token'] = 'true';\n	            if (string_msg_token) params['string_message_token'] = 'true';\n	\n	            // Send Message\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(params),\n	                success  : function(response) {\n	                    if (typeof response == 'object' && response['error']) {\n	                        err({'message' : response['message'], 'payload' : response['payload']});\n	                        return;\n	                    }\n	                    var messages = response[0];\n	                    var decrypted_messages = [];\n	                    for (var a = 0; a < messages.length; a++) {\n	                        if (include_token) {\n	                            var new_message = decrypt(messages[a]['message'],cipher_key);\n	                            var timetoken = messages[a]['timetoken'];\n	                            try {\n	                                decrypted_messages['push']({\"message\" : JSON['parse'](new_message), \"timetoken\" : timetoken});\n	                            } catch (e) {\n	                                decrypted_messages['push'](({\"message\" : new_message, \"timetoken\" : timetoken}));\n	                            }\n	                        } else {\n	                            var new_message = decrypt(messages[a],cipher_key);\n	                            try {\n	                                decrypted_messages['push'](JSON['parse'](new_message));\n	                            } catch (e) {\n	                                decrypted_messages['push']((new_message));\n	                            }     \n	                        }\n	                    }\n	                    callback([decrypted_messages, response[1], response[2]]);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v2', 'history', 'sub-key',\n	                    SUBSCRIBE_KEY, 'channel', encode(channel)\n	                ]\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.replay({\n	                source      : 'my_channel',\n	                destination : 'new_channel'\n	            });\n	        */\n	        'replay' : function(args, callback) {\n	            var callback    = callback || args['callback'] || function(){}\n	            ,   auth_key    = args['auth_key'] || AUTH_KEY\n	            ,   source      = args['source']\n	            ,   destination = args['destination']\n	            ,   stop        = args['stop']\n	            ,   start       = args['start']\n	            ,   end         = args['end']\n	            ,   reverse     = args['reverse']\n	            ,   limit       = args['limit']\n	            ,   jsonp       = jsonp_cb()\n	            ,   data        = {}\n	            ,   url;\n	\n	            // Check User Input\n	            if (!source)        return error('Missing Source Channel');\n	            if (!destination)   return error('Missing Destination Channel');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            // Setup URL Params\n	            if (jsonp != '0') data['callback'] = jsonp;\n	            if (stop)         data['stop']     = 'all';\n	            if (reverse)      data['reverse']  = 'true';\n	            if (start)        data['start']    = start;\n	            if (end)          data['end']      = end;\n	            if (limit)        data['count']    = limit;\n	\n	            data['auth'] = auth_key;\n	\n	            // Compose URL Parts\n	            url = [\n	                STD_ORIGIN, 'v1', 'replay',\n	                PUBLISH_KEY, SUBSCRIBE_KEY,\n	                source, destination\n	            ];\n	\n	            // Start (or Stop) Replay!\n	            xdr({\n	                callback : jsonp,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function() { callback([ 0, 'Disconnected' ]) },\n	                url      : url,\n	                data     : _get_url_params(data)\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.auth('AJFLKAJSDKLA');\n	        */\n	        'auth' : function(auth) {\n	            AUTH_KEY = auth;\n	            CONNECT();\n	        },\n	\n	        /*\n	            PUBNUB.time(function(time){ });\n	        */\n	        'time' : function(callback) {\n	            var jsonp = jsonp_cb();\n	\n	            var data = { 'uuid' : UUID, 'auth' : AUTH_KEY }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                timeout  : SECOND * 5,\n	                url      : [STD_ORIGIN, 'time', jsonp],\n	                success  : function(response) { callback(response[0]) },\n	                fail     : function() { callback(0) }\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.publish({\n	                channel : 'my_chat_channel',\n	                message : 'hello!'\n	            });\n	        */\n	        'publish' : function( args, callback ) {\n	            var msg      = args['message'];\n	            if (!msg) return error('Missing Message');\n	\n	            var callback = callback || args['callback'] || msg['callback'] || function(){}\n	            ,   channel  = args['channel'] || msg['channel']\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   cipher_key = args['cipher_key']\n	            ,   err      = args['error'] || msg['error'] || function() {}\n	            ,   post     = args['post'] || false\n	            ,   store    = ('store_in_history' in args) ? args['store_in_history']: true\n	            ,   jsonp    = jsonp_cb()\n	            ,   add_msg  = 'push'\n	            ,   params\n	            ,   url;\n	\n	            if (args['prepend']) add_msg = 'unshift'\n	\n	            if (!channel)       return error('Missing Channel');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            if (msg['getPubnubMessage']) {\n	                msg = msg['getPubnubMessage']();\n	            }\n	\n	            // If trying to send Object\n	            msg = JSON['stringify'](encrypt(msg, cipher_key));\n	\n	            // Create URL\n	            url = [\n	                STD_ORIGIN, 'publish',\n	                PUBLISH_KEY, SUBSCRIBE_KEY,\n	                0, encode(channel),\n	                jsonp, encode(msg)\n	            ];\n	\n	            params = { 'uuid' : UUID, 'auth' : auth_key }\n	\n	            if (!store) params['store'] =\"0\"\n	\n	            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n	\n	            // Queue Message Send\n	            PUB_QUEUE[add_msg]({\n	                callback : jsonp,\n	                timeout  : SECOND * 5,\n	                url      : url,\n	                data     : _get_url_params(params),\n	                fail     : function(response){\n	                    _invoke_error(response, err);\n	                    publish(1);\n	                },\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                    publish(1);\n	                },\n	                mode     : (post)?'POST':'GET'\n	            });\n	\n	            // Send Message\n	            publish();\n	        },\n	\n	        /*\n	            PUBNUB.unsubscribe({ channel : 'my_chat' });\n	        */\n	        'unsubscribe' : function(args, callback) {\n	            var channel       = args['channel']\n	            ,   channel_group = args['channel_group']\n	            ,   auth_key      = args['auth_key']    || AUTH_KEY\n	            ,   callback      = callback            || args['callback'] || function(){}\n	            ,   err           = args['error']       || function(){};\n	\n	            TIMETOKEN   = 0;\n	            SUB_RESTORE = 1;   // REVISIT !!!!\n	\n	            if (channel) {\n	\n	                // Prepare LeaveChannel(s)\n	                var leave_c = map( (\n	                    channel.join ? channel.join(',') : ''+channel\n	                ).split(','), function(channel) {\n	                    if (!CHANNELS[channel]) return;\n	                    return channel;\n	                } ).join(',');\n	\n	                // Prepare Channel(s)\n	                channel = map( (\n	                    channel.join ? channel.join(',') : ''+channel\n	                ).split(','), function(channel) {\n	                    if (!CHANNELS[channel]) return;\n	                    return channel + ',' + channel + PRESENCE_SUFFIX;\n	                } ).join(',');\n	\n	                // Iterate over Channels\n	                each(channel.split(','), function(ch) {\n	                    if (!ch) return;\n	                    CHANNELS[ch] = 0;\n	                    if (ch in STATE) delete STATE[ch];\n	                } );\n	\n	                var CB_CALLED = true;\n	                if (READY) {\n	                    CB_CALLED = SELF['LEAVE'](leave_c, 0 , auth_key, callback, err);\n	                }\n	                if (!CB_CALLED) callback({action : \"leave\"});\n	            }\n	\n	            if (channel_group) {\n	\n	                // Prepare channel group(s)\n	                var leave_gc = map( (\n	                    channel_group.join ? channel_group.join(',') : ''+channel_group\n	                ).split(','), function(channel_group) {\n	                    if (!CHANNEL_GROUPS[channel_group]) return;\n	                    return channel_group;\n	                } ).join(',');\n	\n	                // Prepare channel group(s)\n	                channel_group = map( (\n	                    channel_group.join ? channel_group.join(',') : ''+channel_group\n	                ).split(','), function(channel_group) {\n	                    if (!CHANNEL_GROUPS[channel_group]) return;\n	                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n	                } ).join(',');\n	\n	                // Iterate over channel groups\n	                each( channel_group.split(','), function(chg) {\n	                    if (!chg) return;\n	                    CHANNEL_GROUPS[chg] = 0;\n	                    if (chg in STATE) delete STATE[chg];\n	                } );\n	\n	                var CB_CALLED = true;\n	                if (READY) {\n	                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0 , auth_key, callback, err);\n	                }\n	                if (!CB_CALLED) callback({action : \"leave\"});\n	            }\n	\n	            // Reset Connection if Count Less\n	            CONNECT();\n	        },\n	\n	        /*\n	            PUBNUB.subscribe({\n	                channel  : 'my_chat'\n	                callback : function(message) { }\n	            });\n	        */\n	        'subscribe' : function( args, callback ) {\n	            var channel         = args['channel']\n	            ,   channel_group   = args['channel_group']\n	            ,   callback        = callback            || args['callback']\n	            ,   callback        = callback            || args['message']\n	            ,   connect         = args['connect']     || function(){}\n	            ,   reconnect       = args['reconnect']   || function(){}\n	            ,   disconnect      = args['disconnect']  || function(){}\n	            ,   SUB_ERROR       = args['error']       || SUB_ERROR || function(){}\n	            ,   idlecb          = args['idle']        || function(){}\n	            ,   presence        = args['presence']    || 0\n	            ,   noheresync      = args['noheresync']  || 0\n	            ,   backfill        = args['backfill']    || 0\n	            ,   timetoken       = args['timetoken']   || 0\n	            ,   sub_timeout     = args['timeout']     || SUB_TIMEOUT\n	            ,   windowing       = args['windowing']   || SUB_WINDOWING\n	            ,   state           = args['state']\n	            ,   heartbeat       = args['heartbeat'] || args['pnexpires']\n	            ,   heartbeat_interval = args['heartbeat_interval']\n	            ,   restore         = args['restore'] || SUB_RESTORE;\n	\n	            AUTH_KEY            = args['auth_key']    || AUTH_KEY;\n	\n	            // Restore Enabled?\n	            SUB_RESTORE = restore;\n	\n	            // Always Reset the TT\n	            TIMETOKEN = timetoken;\n	\n	            // Make sure we have a Channel\n	            if (!channel && !channel_group) {\n	                return error('Missing Channel');\n	            }\n	\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n	                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n	            }\n	\n	            // Setup Channel(s)\n	            if (channel) {\n	                each( (channel.join ? channel.join(',') : ''+channel).split(','),\n	                function(channel) {\n	                    var settings = CHANNELS[channel] || {};\n	\n	                    // Store Channel State\n	                    CHANNELS[SUB_CHANNEL = channel] = {\n	                        name         : channel,\n	                        connected    : settings.connected,\n	                        disconnected : settings.disconnected,\n	                        subscribed   : 1,\n	                        callback     : SUB_CALLBACK = callback,\n	                        'cipher_key' : args['cipher_key'],\n	                        connect      : connect,\n	                        disconnect   : disconnect,\n	                        reconnect    : reconnect\n	                    };\n	\n	                    if (state) {\n	                        if (channel in state) {\n	                            STATE[channel] = state[channel];\n	                        } else {\n	                            STATE[channel] = state;\n	                        }\n	                    }\n	\n	                    // Presence Enabled?\n	                    if (!presence) return;\n	\n	                    // Subscribe Presence Channel\n	                    SELF['subscribe']({\n	                        'channel'  : channel + PRESENCE_SUFFIX,\n	                        'callback' : presence,\n	                        'restore'  : restore\n	                    });\n	\n	                    // Presence Subscribed?\n	                    if (settings.subscribed) return;\n	\n	                    // See Who's Here Now?\n	                    if (noheresync) return;\n	                    SELF['here_now']({\n	                        'channel'  : channel,\n	                        'data'     : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n	                        'callback' : function(here) {\n	                            each( 'uuids' in here ? here['uuids'] : [],\n	                            function(uid) { presence( {\n	                                'action'    : 'join',\n	                                'uuid'      : uid,\n	                                'timestamp' : Math.floor(rnow() / 1000),\n	                                'occupancy' : here['occupancy'] || 1\n	                            }, here, channel ); } );\n	                        }\n	                    });\n	                } );\n	            }\n	\n	            // Setup Channel Groups\n	            if (channel_group) {\n	                each( (channel_group.join ? channel_group.join(',') : ''+channel_group).split(','),\n	                function(channel_group) {\n	                    var settings = CHANNEL_GROUPS[channel_group] || {};\n	\n	                    CHANNEL_GROUPS[channel_group] = {\n	                        name         : channel_group,\n	                        connected    : settings.connected,\n	                        disconnected : settings.disconnected,\n	                        subscribed   : 1,\n	                        callback     : SUB_CALLBACK = callback,\n	                        'cipher_key' : args['cipher_key'],\n	                        connect      : connect,\n	                        disconnect   : disconnect,\n	                        reconnect    : reconnect\n	                    };\n	\n	                    // Presence Enabled?\n	                    if (!presence) return;\n	\n	                    // Subscribe Presence Channel\n	                    SELF['subscribe']({\n	                        'channel_group'  : channel_group + PRESENCE_SUFFIX,\n	                        'callback' : presence,\n	                        'restore'  : restore,\n	                        'auth_key' : AUTH_KEY\n	                    });\n	\n	                    // Presence Subscribed?\n	                    if (settings.subscribed) return;\n	\n	                    // See Who's Here Now?\n	                    if (noheresync) return;\n	                    SELF['here_now']({\n	                        'channel_group'  : channel_group,\n	                        'data'           : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n	                        'callback' : function(here) {\n	                            each( 'uuids' in here ? here['uuids'] : [],\n	                            function(uid) { presence( {\n	                                'action'    : 'join',\n	                                'uuid'      : uid,\n	                                'timestamp' : Math.floor(rnow() / 1000),\n	                                'occupancy' : here['occupancy'] || 1\n	                            }, here, channel_group ); } );\n	                        }\n	                    });\n	                } );\n	            }\n	\n	\n	            // Test Network Connection\n	            function _test_connection(success) {\n	                if (success) {\n	                    // Begin Next Socket Connection\n	                    timeout( CONNECT, windowing);\n	                }\n	                else {\n	                    // New Origin on Failed Connection\n	                    STD_ORIGIN = nextorigin( ORIGIN, 1 );\n	                    SUB_ORIGIN = nextorigin( ORIGIN, 1 );\n	\n	                    // Re-test Connection\n	                    timeout( function() {\n	                        SELF['time'](_test_connection);\n	                    }, SECOND );\n	                }\n	\n	                // Disconnect & Reconnect\n	                each_channel(function(channel){\n	                    // Reconnect\n	                    if (success && channel.disconnected) {\n	                        channel.disconnected = 0;\n	                        return channel.reconnect(channel.name);\n	                    }\n	\n	                    // Disconnect\n	                    if (!success && !channel.disconnected) {\n	                        channel.disconnected = 1;\n	                        channel.disconnect(channel.name);\n	                    }\n	                });\n	                \n	                // Disconnect & Reconnect for channel groups\n	                each_channel_group(function(channel_group){\n	                    // Reconnect\n	                    if (success && channel_group.disconnected) {\n	                        channel_group.disconnected = 0;\n	                        return channel_group.reconnect(channel_group.name);\n	                    }\n	\n	                    // Disconnect\n	                    if (!success && !channel_group.disconnected) {\n	                        channel_group.disconnected = 1;\n	                        channel_group.disconnect(channel_group.name);\n	                    }\n	                });\n	            }\n	\n	            // Evented Subscribe\n	            function _connect() {\n	                var jsonp           = jsonp_cb()\n	                ,   channels        = generate_channel_list(CHANNELS).join(',')\n	                ,   channel_groups  = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n	\n	                // Stop Connection\n	                if (!channels && !channel_groups) return;\n	\n	                if (!channels) channels = ',';\n	\n	                // Connect to PubNub Subscribe Servers\n	                _reset_offline();\n	\n	                var data = _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY });\n	\n	                if (channel_groups) {\n	                    data['channel-group'] = channel_groups;\n	                }\n	\n	\n	                var st = JSON.stringify(STATE);\n	                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n	\n	                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n	\n	                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	                start_presence_heartbeat();\n	                SUB_RECEIVER = xdr({\n	                    timeout  : sub_timeout,\n	                    callback : jsonp,\n	                    fail     : function(response) {\n	                        if (response && response['error'] && response['service']) {\n	                            _invoke_error(response, SUB_ERROR);\n	                            _test_connection(1);\n	                        } else {\n	                            SELF['time'](function(success){\n	                                !success && ( _invoke_error(response, SUB_ERROR));\n	                                _test_connection(success);\n	                            });\n	                        }\n	                    },\n	                    data     : _get_url_params(data),\n	                    url      : [\n	                        SUB_ORIGIN, 'subscribe',\n	                        SUBSCRIBE_KEY, encode(channels),\n	                        jsonp, TIMETOKEN\n	                    ],\n	                    success : function(messages) {\n	\n	                        // Check for Errors\n	                        if (!messages || (\n	                            typeof messages == 'object' &&\n	                            'error' in messages         &&\n	                            messages['error']\n	                        )) {\n	                            SUB_ERROR(messages['error']);\n	                            return timeout( CONNECT, SECOND );\n	                        }\n	\n	                        // User Idle Callback\n	                        idlecb(messages[1]);\n	\n	                        // Restore Previous Connection Point if Needed\n	                        TIMETOKEN = !TIMETOKEN               &&\n	                                    SUB_RESTORE              &&\n	                                    db['get'](SUBSCRIBE_KEY) || messages[1];\n	\n	                        /*\n	                        // Connect\n	                        each_channel_registry(function(registry){\n	                            if (registry.connected) return;\n	                            registry.connected = 1;\n	                            registry.connect(channel.name);\n	                        });\n	                        */\n	\n	                        // Connect\n	                        each_channel(function(channel){\n	                            if (channel.connected) return;\n	                            channel.connected = 1;\n	                            channel.connect(channel.name);\n	                        });\n	\n	                        // Connect for channel groups\n	                        each_channel_group(function(channel_group){\n	                            if (channel_group.connected) return;\n	                            channel_group.connected = 1;\n	                            channel_group.connect(channel_group.name);\n	                        });\n	\n	                        if (RESUMED && !SUB_RESTORE) {\n	                                TIMETOKEN = 0;\n	                                RESUMED = false;\n	                                // Update Saved Timetoken\n	                                db['set']( SUBSCRIBE_KEY, 0 );\n	                                timeout( _connect, windowing );\n	                                return;\n	                        }\n	\n	                        // Invoke Memory Catchup and Receive Up to 100\n	                        // Previous Messages from the Queue.\n	                        if (backfill) {\n	                            TIMETOKEN = 10000;\n	                            backfill  = 0;\n	                        }\n	\n	                        // Update Saved Timetoken\n	                        db['set']( SUBSCRIBE_KEY, messages[1] );\n	\n	                        // Route Channel <---> Callback for Message\n	                        var next_callback = (function() {\n	                            var channels = '';\n	                            var channels2 = '';\n	\n	                            if (messages.length > 3) {\n	                                channels  = messages[3];\n	                                channels2 = messages[2];\n	                            } else if (messages.length > 2) {\n	                                channels = messages[2];\n	                            } else {\n	                                channels =  map(\n	                                    generate_channel_list(CHANNELS), function(chan) { return map(\n	                                        Array(messages[0].length)\n	                                        .join(',').split(','),\n	                                        function() { return chan; }\n	                                    ) }).join(',')\n	                            }\n	\n	                            var list  = channels.split(',');\n	                            var list2 = (channels2)?channels2.split(','):[];\n	\n	                            return function() {\n	                                var channel  = list.shift()||SUB_CHANNEL;\n	                                var channel2 = list2.shift();\n	\n	                                var chobj = {};\n	\n	                                if (channel2) {\n	                                    if (channel && channel.indexOf('-pnpres') >= 0 \n	                                        && channel2.indexOf('-pnpres') < 0) {\n	                                        channel2 += '-pnpres';\n	                                    }\n	                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || {'callback' : function(){}};\n	                                } else {\n	                                    chobj = CHANNELS[channel];\n	                                }\n	\n	                                var r = [\n	                                    chobj\n	                                    .callback||SUB_CALLBACK,\n	                                    channel.split(PRESENCE_SUFFIX)[0]\n	                                ];\n	                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n	                                return r;\n	                            };\n	                        })();\n	\n	                        var latency = detect_latency(+messages[1]);\n	                        each( messages[0], function(msg) {\n	                            var next = next_callback();\n	                            var decrypted_msg = decrypt(msg,\n	                                (CHANNELS[next[1]])?CHANNELS[next[1]]['cipher_key']:null);\n	                            next[0] && next[0]( decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n	                        });\n	\n	                        timeout( _connect, windowing );\n	                    }\n	                });\n	            }\n	\n	            CONNECT = function() {\n	                _reset_offline();\n	                timeout( _connect, windowing );\n	            };\n	\n	            // Reduce Status Flicker\n	            if (!READY) return READY_BUFFER.push(CONNECT);\n	\n	            // Connect Now\n	            CONNECT();\n	        },\n	\n	        /*\n	            PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n	        */\n	        'here_now' : function( args, callback ) {\n	            var callback = args['callback'] || callback\n	            ,   debug    = args['debug']\n	            ,   err      = args['error']    || function(){}\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   channel  = args['channel']\n	            ,   channel_group = args['channel_group']\n	            ,   jsonp    = jsonp_cb()\n	            ,   uuids    = ('uuids' in args) ? args['uuids'] : true\n	            ,   state    = args['state']\n	            ,   data     = { 'uuid' : UUID, 'auth' : auth_key };\n	\n	            if (!uuids) data['disable_uuids'] = 1;\n	            if (state) data['state'] = 1;\n	\n	            // Make sure we have a Channel\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            var url = [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub_key', SUBSCRIBE_KEY\n	                ];\n	\n	            channel && url.push('channel') && url.push(encode(channel));\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            if (channel_group) {\n	                data['channel-group'] = channel_group;\n	                !channel && url.push('channel') && url.push(','); \n	            }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                debug    : debug,\n	                url      : url\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n	        */\n	        'where_now' : function( args, callback ) {\n	            var callback = args['callback'] || callback\n	            ,   err      = args['error']    || function(){}\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   jsonp    = jsonp_cb()\n	            ,   uuid     = args['uuid']     || UUID\n	            ,   data     = { 'auth' : auth_key };\n	\n	            // Make sure we have a Channel\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub_key', SUBSCRIBE_KEY,\n	                    'uuid', encode(uuid)\n	                ]\n	            });\n	        },\n	\n	        'state' : function(args, callback) {\n	            var callback = args['callback'] || callback || function(r) {}\n	            ,   err      = args['error']    || function(){}\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   jsonp    = jsonp_cb()\n	            ,   state    = args['state']\n	            ,   uuid     = args['uuid'] || UUID\n	            ,   channel  = args['channel']\n	            ,   channel_group = args['channel_group']\n	            ,   url\n	            ,   data     = _get_url_params({ 'auth' : auth_key });\n	\n	            // Make sure we have a Channel\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	            if (!uuid) return error('Missing UUID');\n	            if (!channel && !channel_group) return error('Missing Channel');\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            if (typeof channel != 'undefined'\n	                && CHANNELS[channel] && CHANNELS[channel].subscribed ) {\n	                if (state) STATE[channel] = state;\n	            }\n	\n	            if (typeof channel_group != 'undefined'\n	                && CHANNEL_GROUPS[channel_group]\n	                && CHANNEL_GROUPS[channel_group].subscribed\n	                ) {\n	                if (state) STATE[channel_group] = state;\n	                data['channel-group'] = channel_group;\n	\n	                if (!channel) {\n	                    channel = ',';\n	                }\n	            }\n	\n	            data['state'] = JSON.stringify(state);\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            if (state) {\n	                url      = [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub-key', SUBSCRIBE_KEY,\n	                    'channel', channel,\n	                    'uuid', uuid, 'data'\n	                ]\n	            } else {\n	                url      = [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub-key', SUBSCRIBE_KEY,\n	                    'channel', channel,\n	                    'uuid', encode(uuid)\n	                ]\n	            }\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	\n	            });\n	\n	        },\n	\n	        /*\n	            PUBNUB.grant({\n	                channel  : 'my_chat',\n	                callback : fun,\n	                error    : fun,\n	                ttl      : 24 * 60, // Minutes\n	                read     : true,\n	                write    : true,\n	                auth_key : '3y8uiajdklytowsj'\n	            });\n	        */\n	        'grant' : function( args, callback ) {\n	            var callback        = args['callback'] || callback\n	            ,   err             = args['error']    || function(){}\n	            ,   channel         = args['channel']  || args['channels']\n	            ,   channel_group   = args['channel_group']\n	            ,   jsonp           = jsonp_cb()\n	            ,   ttl             = args['ttl']\n	            ,   r               = (args['read'] )?\"1\":\"0\"\n	            ,   w               = (args['write'])?\"1\":\"0\"\n	            ,   m               = (args['manage'])?\"1\":\"0\"\n	            ,   auth_key        = args['auth_key'] || args['auth_keys'];\n	\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SECRET_KEY)    return error('Missing Secret Key');\n	\n	            var timestamp  = Math.floor(new Date().getTime() / 1000)\n	            ,   sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\"\n	                    + \"grant\" + \"\\n\";\n	\n	            var data = {\n	                'w'         : w,\n	                'r'         : r,\n	                'timestamp' : timestamp\n	            };\n	            if (args['manage']) {\n	                data['m'] = m;\n	            }\n	            if (isArray(channel)) {\n	                channel = channel['join'](',');\n	            }\n	            if (isArray(auth_key)) {\n	                auth_key = auth_key['join'](',');\n	            }\n	            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n	            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n	                data['channel-group'] = channel_group;\n	            }\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	            if (ttl || ttl === 0) data['ttl'] = ttl;\n	\n	            if (auth_key) data['auth'] = auth_key;\n	\n	            data = _get_url_params(data)\n	\n	            if (!auth_key) delete data['auth'];\n	\n	            sign_input += _get_pam_sign_input_from_params(data);\n	\n	            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n	\n	            signature = signature.replace( /\\+/g, \"-\" );\n	            signature = signature.replace( /\\//g, \"_\" );\n	\n	            data['signature'] = signature;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : data,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v1', 'auth', 'grant' ,\n	                    'sub-key', SUBSCRIBE_KEY\n	                ]\n	            });\n	        },\n	\n	        /*\n	         PUBNUB.mobile_gw_provision ({\n	         device_id: 'A655FBA9931AB',\n	         op       : 'add' | 'remove',\n	         gw_type  : 'apns' | 'gcm',\n	         channel  : 'my_chat',\n	         callback : fun,\n	         error    : fun,\n	         });\n	         */\n	\n	        'mobile_gw_provision' : function( args ) {\n	\n	            var callback = args['callback'] || function(){}\n	                ,   auth_key       = args['auth_key'] || AUTH_KEY\n	                ,   err            = args['error'] || function() {}\n	                ,   jsonp          = jsonp_cb()\n	                ,   channel        = args['channel']\n	                ,   op             = args['op']\n	                ,   gw_type        = args['gw_type']\n	                ,   device_id      = args['device_id']\n	                ,   params\n	                ,   url;\n	\n	            if (!device_id)     return error('Missing Device ID (device_id)');\n	            if (!gw_type)       return error('Missing GW Type (gw_type: gcm or apns)');\n	            if (!op)            return error('Missing GW Operation (op: add or remove)');\n	            if (!channel)       return error('Missing gw destination Channel (channel)');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            // Create URL\n	            url = [\n	                STD_ORIGIN, 'v1/push/sub-key',\n	                SUBSCRIBE_KEY, 'devices', device_id\n	            ];\n	\n	            params = { 'uuid' : UUID, 'auth' : auth_key, 'type': gw_type};\n	\n	            if (op == \"add\") {\n	                params['add'] = channel;\n	            } else if (op == \"remove\") {\n	                params['remove'] = channel;\n	            }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : params,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	\n	        },\n	\n	        /*\n	            PUBNUB.audit({\n	                channel  : 'my_chat',\n	                callback : fun,\n	                error    : fun,\n	                read     : true,\n	                write    : true,\n	                auth_key : '3y8uiajdklytowsj'\n	            });\n	        */\n	        'audit' : function( args, callback ) {\n	            var callback        = args['callback'] || callback\n	            ,   err             = args['error']    || function(){}\n	            ,   channel         = args['channel']\n	            ,   channel_group   = args['channel_group']\n	            ,   auth_key        = args['auth_key']\n	            ,   jsonp           = jsonp_cb();\n	\n	            // Make sure we have a Channel\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SECRET_KEY)    return error('Missing Secret Key');\n	\n	            var timestamp  = Math.floor(new Date().getTime() / 1000)\n	            ,   sign_input = SUBSCRIBE_KEY + \"\\n\"\n	                + PUBLISH_KEY + \"\\n\"\n	                + \"audit\" + \"\\n\";\n	\n	            var data = {'timestamp' : timestamp };\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n	            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n	                data['channel-group'] = channel_group;\n	            }\n	            if (auth_key) data['auth']    = auth_key;\n	\n	            data = _get_url_params(data);\n	\n	            if (!auth_key) delete data['auth'];\n	\n	            sign_input += _get_pam_sign_input_from_params(data);\n	\n	            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n	\n	            signature = signature.replace( /\\+/g, \"-\" );\n	            signature = signature.replace( /\\//g, \"_\" );\n	\n	            data['signature'] = signature;\n	            xdr({\n	                callback : jsonp,\n	                data     : data,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v1', 'auth', 'audit' ,\n	                    'sub-key', SUBSCRIBE_KEY\n	                ]\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.revoke({\n	                channel  : 'my_chat',\n	                callback : fun,\n	                error    : fun,\n	                auth_key : '3y8uiajdklytowsj'\n	            });\n	        */\n	        'revoke' : function( args, callback ) {\n	            args['read']  = false;\n	            args['write'] = false;\n	            SELF['grant']( args, callback );\n	        },\n	        'set_uuid' : function(uuid) {\n	            UUID = uuid;\n	            CONNECT();\n	        },\n	        'get_uuid' : function() {\n	            return UUID;\n	        },\n	        'isArray'  : function(arg) {\n	            return isArray(arg);\n	        },\n	        'get_subscibed_channels' : function() {\n	            return generate_channel_list(CHANNELS, true);\n	        },\n	        'presence_heartbeat' : function(args) {\n	            var callback = args['callback'] || function() {}\n	            var err      = args['error']    || function() {}\n	            var jsonp    = jsonp_cb();\n	            var data     = { 'uuid' : UUID, 'auth' : AUTH_KEY };\n	\n	            var st = JSON['stringify'](STATE);\n	            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n	\n	            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            var channels        = encode(generate_channel_list(CHANNELS, true)['join'](','));\n	            var channel_groups  = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n	\n	            if (!channels) channels = ',';\n	            if (channel_groups) data['channel-group'] = channel_groups;\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                timeout  : SECOND * 5,\n	                url      : [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub-key', SUBSCRIBE_KEY,\n	                    'channel' , channels,\n	                    'heartbeat'\n	                ],\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) { _invoke_error(response, err); }\n	            });\n	        },\n	        'stop_timers': function () {\n	            clearTimeout(_poll_timer);\n	            clearTimeout(_poll_timer2);\n	            clearTimeout(PRESENCE_HB_TIMEOUT);\n	        },\n	        'shutdown': function () {\n	            SELF['stop_timers']();\n	            shutdown && shutdown();\n	        },\n	\n	        // Expose PUBNUB Functions\n	        'xdr'           : xdr,\n	        'ready'         : ready,\n	        'db'            : db,\n	        'uuid'          : generate_uuid,\n	        'map'           : map,\n	        'each'          : each,\n	        'each-channel'  : each_channel,\n	        'grep'          : grep,\n	        'offline'       : function(){ _reset_offline(\n	            1, { \"message\" : \"Offline. Please check your network settings.\" })\n	        },\n	        'supplant'      : supplant,\n	        'now'           : rnow,\n	        'unique'        : unique,\n	        'updater'       : updater\n	    };\n	\n	    function _poll_online() {\n	        _is_online() || _reset_offline( 1, {\n	            \"error\" : \"Offline. Please check your network settings. \"\n	        });\n	        _poll_timer && clearTimeout(_poll_timer);\n	        _poll_timer = timeout( _poll_online, SECOND );\n	    }\n	\n	    function _poll_online2() {\n	        if (!TIME_CHECK) return;\n	        SELF['time'](function(success){\n	            detect_time_detla( function(){}, success );\n	            success || _reset_offline( 1, {\n	                \"error\" : \"Heartbeat failed to connect to Pubnub Servers.\" +\n	                    \"Please check your network settings.\"\n	                });\n	            _poll_timer2 && clearTimeout(_poll_timer2);\n	            _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n	        });\n	    }\n	\n	    function _reset_offline(err, msg) {\n	        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n	        SUB_RECEIVER = null;\n	\n	        clearTimeout(_poll_timer);\n	        clearTimeout(_poll_timer2);\n	    }\n	    \n	    if (!UUID) UUID = SELF['uuid']();\n	    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n	    db['set']( SUBSCRIBE_KEY + 'uuid', UUID );\n	\n	    _poll_timer  = timeout( _poll_online,  SECOND    );\n	    _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n	    PRESENCE_HB_TIMEOUT = timeout(\n	        start_presence_heartbeat,\n	        ( PRESENCE_HB_INTERVAL - 3 ) * SECOND\n	    );\n	\n	    // Detect Age of Message\n	    function detect_latency(tt) {\n	        var adjusted_time = rnow() - TIME_DRIFT;\n	        return adjusted_time - tt / 10000;\n	    }\n	\n	    detect_time_detla();\n	    function detect_time_detla( cb, time ) {\n	        var stime = rnow();\n	\n	        time && calculate(time) || SELF['time'](calculate);\n	\n	        function calculate(time) {\n	            if (!time) return;\n	            var ptime   = time / 10000\n	            ,   latency = (rnow() - stime) / 2;\n	            TIME_DRIFT = rnow() - (ptime + latency);\n	            cb && cb(TIME_DRIFT);\n	        }\n	    }\n	\n	    return SELF;\n	}\n	function crypto_obj() {\n	\n	    function SHA256(s) {\n	        return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);\n	    }\n	\n	    var iv = \"0123456789012345\";\n	\n	    var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];\n	    var allowedKeyLengths = [128, 256];\n	    var allowedModes = ['ecb', 'cbc'];\n	\n	    var defaultOptions = {\n	        'encryptKey': true,\n	        'keyEncoding': 'utf8',\n	        'keyLength': 256,\n	        'mode': 'cbc'\n	    };\n	\n	    function parse_options(options) {\n	\n	        // Defaults\n	        options = options || {};\n	        if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];\n	        if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];\n	        if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];\n	        if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];\n	\n	        // Validation\n	        if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];\n	        if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];\n	        if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];\n	\n	        return options;\n	\n	    }\n	\n	    function decode_key(key, options) {\n	        if (options['keyEncoding'] == 'base64') {\n	            return CryptoJS['enc']['Base64']['parse'](key);\n	        } else if (options['keyEncoding'] == 'hex') {\n	            return CryptoJS['enc']['Hex']['parse'](key);\n	        } else {\n	            return key;\n	        }\n	    }\n	\n	    function get_padded_key(key, options) {\n	        key = decode_key(key, options);\n	        if (options['encryptKey']) {\n	            return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));\n	        } else {\n	            return key;\n	        }\n	    }\n	\n	    function get_mode(options) {\n	        if (options['mode'] == 'ecb') {\n	            return CryptoJS['mode']['ECB'];\n	        } else {\n	            return CryptoJS['mode']['CBC'];\n	        }\n	    }\n	\n	    function get_iv(options) {\n	        return (options['mode'] == 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;\n	    }\n	\n	    return {\n	\n	        'encrypt': function(data, key, options) {\n	            if (!key) return data;\n	            options = parse_options(options);\n	            var iv = get_iv(options);\n	            var mode = get_mode(options);\n	            var cipher_key = get_padded_key(key, options);\n	            var hex_message = JSON['stringify'](data);\n	            var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, {'iv': iv, 'mode': mode})['ciphertext'];\n	            var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);\n	            return base_64_encrypted || data;\n	        },\n	\n	        'decrypt': function(data, key, options) {\n	            if (!key) return data;\n	            options = parse_options(options);\n	            var iv = get_iv(options);\n	            var mode = get_mode(options);\n	            var cipher_key = get_padded_key(key, options);\n	            try {\n	                var binary_enc = CryptoJS['enc']['Base64']['parse'](data);\n	                var json_plain = CryptoJS['AES']['decrypt']({'ciphertext': binary_enc}, cipher_key, {'iv': iv, 'mode': mode})['toString'](CryptoJS['enc']['Utf8']);\n	                var plaintext = JSON['parse'](json_plain);\n	                return plaintext;\n	            }\n	            catch (e) {\n	                return undefined;\n	            }\n	        }\n	    };\n	}\n	/**\n	 * UTIL LOCALS\n	 */\n	\n	var SWF             = 'https://pubnub.a.ssl.fastly.net/pubnub.swf'\n	,   ASYNC           = 'async'\n	,   UA              = navigator.userAgent\n	,   PNSDK           = 'PubNub-JS-' + 'Web' + '/' + '3.7.16'\n	,   XORIGN          = UA.indexOf('MSIE 6') == -1;\n	\n	/**\n	 * CONSOLE COMPATIBILITY\n	 */\n	window.console || (window.console=window.console||{});\n	console.log    || (\n	    console.log   =\n	    console.error =\n	    ((window.opera||{}).postError||function(){})\n	);\n	\n	/**\n	 * LOCAL STORAGE OR COOKIE\n	 */\n	var db = (function(){\n	    var store = {};\n	    var ls = false;\n	    try {\n	        ls = window['localStorage'];\n	    } catch (e) { }\n	    var cookieGet = function(key) {\n	        if (document.cookie.indexOf(key) == -1) return null;\n	        return ((document.cookie||'').match(\n	            RegExp(key+'=([^;]+)')\n	        )||[])[1] || null;\n	    };\n	    var cookieSet = function( key, value ) {\n	        document.cookie = key + '=' + value +\n	            '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';\n	    };\n	    var cookieTest = (function() {\n	        try {\n	            cookieSet('pnctest', '1');\n	            return cookieGet('pnctest') === '1';\n	        } catch (e) {\n	            return false;\n	        }\n	    }());\n	    return {\n	        'get' : function(key) {\n	            try {\n	                if (ls) return ls.getItem(key);\n	                if (cookieTest) return cookieGet(key);\n	                return store[key];\n	            } catch(e) {\n	                return store[key];\n	            }\n	        },\n	        'set' : function( key, value ) {\n	            try {\n	                if (ls) return ls.setItem( key, value ) && 0;\n	                if (cookieTest) cookieSet( key, value );\n	                store[key] = value;\n	            } catch(e) {\n	                store[key] = value;\n	            }\n	        }\n	    };\n	})();\n	\n	function get_hmac_SHA256(data,key) {\n	    var hash = CryptoJS['HmacSHA256'](data, key);\n	    return hash.toString(CryptoJS['enc']['Base64']);\n	}\n	\n	/**\n	 * $\n	 * =\n	 * var div = $('divid');\n	 */\n	function $(id) { return document.getElementById(id) }\n	\n	/**\n	 * ERROR\n	 * =====\n	 * error('message');\n	 */\n	function error(message) { console['error'](message) }\n	\n	/**\n	 * SEARCH\n	 * ======\n	 * var elements = search('a div span');\n	 */\n	function search( elements, start) {\n	    var list = [];\n	    each( elements.split(/\\s+/), function(el) {\n	        each( (start || document).getElementsByTagName(el), function(node) {\n	            list.push(node);\n	        } );\n	    });\n	    return list;\n	}\n	\n	/**\n	 * BIND\n	 * ====\n	 * bind( 'keydown', search('a')[0], function(element) {\n	 *     ...\n	 * } );\n	 */\n	function bind( type, el, fun ) {\n	    each( type.split(','), function(etype) {\n	        var rapfun = function(e) {\n	            if (!e) e = window.event;\n	            if (!fun(e)) {\n	                e.cancelBubble = true;\n	                e.preventDefault  && e.preventDefault();\n	                e.stopPropagation && e.stopPropagation();\n	            }\n	        };\n	\n	        if ( el.addEventListener ) el.addEventListener( etype, rapfun, false );\n	        else if ( el.attachEvent ) el.attachEvent( 'on' + etype, rapfun );\n	        else  el[ 'on' + etype ] = rapfun;\n	    } );\n	}\n	\n	/**\n	 * UNBIND\n	 * ======\n	 * unbind( 'keydown', search('a')[0] );\n	 */\n	function unbind( type, el, fun ) {\n	    if ( el.removeEventListener ) el.removeEventListener( type, false );\n	    else if ( el.detachEvent ) el.detachEvent( 'on' + type, false );\n	    else  el[ 'on' + type ] = null;\n	}\n	\n	/**\n	 * HEAD\n	 * ====\n	 * head().appendChild(elm);\n	 */\n	function head() { return search('head')[0] }\n	\n	/**\n	 * ATTR\n	 * ====\n	 * var attribute = attr( node, 'attribute' );\n	 */\n	function attr( node, attribute, value ) {\n	    if (value) node.setAttribute( attribute, value );\n	    else return node && node.getAttribute && node.getAttribute(attribute);\n	}\n	\n	/**\n	 * CSS\n	 * ===\n	 * var obj = create('div');\n	 */\n	function css( element, styles ) {\n	    for (var style in styles) if (styles.hasOwnProperty(style))\n	        try {element.style[style] = styles[style] + (\n	            '|width|height|top|left|'.indexOf(style) > 0 &&\n	            typeof styles[style] == 'number'\n	            ? 'px' : ''\n	        )}catch(e){}\n	}\n	\n	/**\n	 * CREATE\n	 * ======\n	 * var obj = create('div');\n	 */\n	function create(element) { return document.createElement(element) }\n	\n	\n	/**\n	 * jsonp_cb\n	 * ========\n	 * var callback = jsonp_cb();\n	 */\n	function jsonp_cb() { return XORIGN || FDomainRequest() ? 0 : unique() }\n	\n	\n	\n	/**\n	 * EVENTS\n	 * ======\n	 * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {\n	 *     // Do Stuff with message\n	 * } );\n	 *\n	 * PUBNUB.events.fire( 'you-stepped-on-flower', \"message-data\" );\n	 * PUBNUB.events.fire( 'you-stepped-on-flower', {message:\"data\"} );\n	 * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );\n	 *\n	 */\n	var events = {\n	    'list'   : {},\n	    'unbind' : function( name ) { events.list[name] = [] },\n	    'bind'   : function( name, fun ) {\n	        (events.list[name] = events.list[name] || []).push(fun);\n	    },\n	    'fire' : function( name, data ) {\n	        each(\n	            events.list[name] || [],\n	            function(fun) { fun(data) }\n	        );\n	    }\n	};\n	\n	/**\n	 * XDR Cross Domain Request\n	 * ========================\n	 *  xdr({\n	 *     url     : ['http://www.blah.com/url'],\n	 *     success : function(response) {},\n	 *     fail    : function() {}\n	 *  });\n	 */\n	function xdr( setup ) {\n	    if (XORIGN || FDomainRequest()) return ajax(setup);\n	\n	    var script    = create('script')\n	    ,   callback  = setup.callback\n	    ,   id        = unique()\n	    ,   finished  = 0\n	    ,   xhrtme    = setup.timeout || DEF_TIMEOUT\n	    ,   timer     = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n	    ,   fail      = setup.fail    || function(){}\n	    ,   data      = setup.data    || {}\n	    ,   success   = setup.success || function(){}\n	    ,   append    = function() { head().appendChild(script) }\n	    ,   done      = function( failed, response ) {\n	            if (finished) return;\n	            finished = 1;\n	\n	            script.onerror = null;\n	            clearTimeout(timer);\n	\n	            (failed || !response) || success(response);\n	\n	            timeout( function() {\n	                failed && fail();\n	                var s = $(id)\n	                ,   p = s && s.parentNode;\n	                p && p.removeChild(s);\n	            }, SECOND );\n	        };\n	\n	    window[callback] = function(response) {\n	        done( 0, response );\n	    };\n	\n	    if (!setup.blocking) script[ASYNC] = ASYNC;\n	\n	    script.onerror = function() { done(1) };\n	    script.src     = build_url( setup.url, data );\n	\n	    attr( script, 'id', id );\n	\n	    append();\n	    return done;\n	}\n	\n	/**\n	 * CORS XHR Request\n	 * ================\n	 *  xdr({\n	 *     url     : ['http://www.blah.com/url'],\n	 *     success : function(response) {},\n	 *     fail    : function() {}\n	 *  });\n	 */\n	function ajax( setup ) {\n	    var xhr, response\n	    ,   finished = function() {\n	            if (loaded) return;\n	            loaded = 1;\n	\n	            clearTimeout(timer);\n	\n	            try       { response = JSON['parse'](xhr.responseText); }\n	            catch (r) { return done(1); }\n	\n	            complete = 1;\n	            success(response);\n	        }\n	    ,   complete = 0\n	    ,   loaded   = 0\n	    ,   xhrtme   = setup.timeout || DEF_TIMEOUT\n	    ,   timer    = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n	    ,   fail     = setup.fail    || function(){}\n	    ,   data     = setup.data    || {}\n	    ,   success  = setup.success || function(){}\n	    ,   async    = !(setup.blocking)\n	    ,   done     = function(failed,response) {\n	            if (complete) return;\n	            complete = 1;\n	\n	            clearTimeout(timer);\n	\n	            if (xhr) {\n	                xhr.onerror = xhr.onload = null;\n	                xhr.abort && xhr.abort();\n	                xhr = null;\n	            }\n	\n	            failed && fail(response);\n	        };\n	\n	    // Send\n	    try {\n	        xhr = FDomainRequest()      ||\n	              window.XDomainRequest &&\n	              new XDomainRequest()  ||\n	              new XMLHttpRequest();\n	\n	        xhr.onerror = xhr.onabort   = function(e){ done(\n	            1, e || (xhr && xhr.responseText) || { \"error\" : \"Network Connection Error\"}\n	        ) };\n	        xhr.onload  = xhr.onloadend = finished;\n	        xhr.onreadystatechange = function() {\n	            if (xhr && xhr.readyState == 4) {\n	                switch(xhr.status) {\n	                    case 200:\n	                        break;\n	                    default:\n	                        try {\n	                            response = JSON['parse'](xhr.responseText);\n	                            done(1,response);\n	                        }\n	                        catch (r) { return done(1, {status : xhr.status, payload : null, message : xhr.responseText}); }\n	                        return;\n	                }\n	            }\n	        }\n	\n	        var url = build_url(setup.url,data);\n	\n	        xhr.open( 'GET', url, async );\n	        if (async) xhr.timeout = xhrtme;\n	        xhr.send();\n	    }\n	    catch(eee) {\n	        done(0);\n	        XORIGN = 0;\n	        return xdr(setup);\n	    }\n	\n	    // Return 'done'\n	    return done;\n	}\n	\n	// Test Connection State\n	function _is_online() {\n	    if (!('onLine' in navigator)) return 1;\n	    try       { return navigator['onLine'] }\n	    catch (e) { return true }\n	}\n	\n	\n	function sendBeacon(url) {\n	    if (!('sendBeacon' in navigator)) return false;\n	\n	    return navigator['sendBeacon'](url);\n	}\n	\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	/* =-=========================     PUBNUB     ===========================-= */\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	\n	var PDIV          = $('pubnub') || 0\n	,   CREATE_PUBNUB = function(setup) {\n	\n	    // Force JSONP if requested from user.\n	    if (setup['jsonp'])  XORIGN = 0;\n	    else                 XORIGN = UA.indexOf('MSIE 6') == -1;\n	\n	    var SUBSCRIBE_KEY = setup['subscribe_key'] || ''\n	    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n	    ,   UUID          = setup['uuid'] || db['get'](SUBSCRIBE_KEY+'uuid')||'';\n	\n	    var leave_on_unload = setup['leave_on_unload'] || 0;\n	\n	    setup['xdr']        = xdr;\n	    setup['db']         = db;\n	    setup['error']      = setup['error'] || error;\n	    setup['_is_online'] = _is_online;\n	    setup['jsonp_cb']   = jsonp_cb;\n	    setup['hmac_SHA256']= get_hmac_SHA256;\n	    setup['crypto_obj'] = crypto_obj();\n	    setup['sendBeacon'] = sendBeacon;\n	    setup['params']     = { 'pnsdk' : PNSDK }\n	\n	    var SELF = function(setup) {\n	        return CREATE_PUBNUB(setup);\n	    };\n	\n	    var PN = PN_API(setup);\n	\n	    for (var prop in PN) {\n	        if (PN.hasOwnProperty(prop)) {\n	            SELF[prop] = PN[prop];\n	        }\n	    }\n	    SELF['css']         = css;\n	    SELF['$']           = $;\n	    SELF['create']      = create;\n	    SELF['bind']        = bind;\n	    SELF['head']        = head;\n	    SELF['search']      = search;\n	    SELF['attr']        = attr;\n	    SELF['events']      = events;\n	    SELF['init']        = SELF;\n	    SELF['secure']      = SELF;\n	    SELF['crypto_obj']  = crypto_obj(); // export to instance\n	\n	\n	    // Add Leave Functions\n	    bind( 'beforeunload', window, function() {\n	        if (leave_on_unload) SELF['each-channel'](function(ch){ SELF['LEAVE']( ch.name, 0 ) });\n	        return true;\n	    } );\n	\n	    // Return without Testing\n	    if (setup['notest']) return SELF;\n	\n	    bind( 'offline', window,   SELF['offline'] );\n	    bind( 'offline', document, SELF['offline'] );\n	\n	    // Return PUBNUB Socket Object\n	    return SELF;\n	};\n	CREATE_PUBNUB['init']   = CREATE_PUBNUB;\n	CREATE_PUBNUB['secure'] = CREATE_PUBNUB;\n	CREATE_PUBNUB['crypto_obj'] = crypto_obj(); // export to constructor\n	\n	// Bind for PUBNUB Readiness to Subscribe\n	if (document.readyState === 'complete') {\n	    timeout( ready, 0 );\n	}\n	else {\n	    bind( 'load', window, function(){ timeout( ready, 0 ) } );\n	}\n	\n	var pdiv = PDIV || {};\n	\n	// CREATE A PUBNUB GLOBAL OBJECT\n	PUBNUB = CREATE_PUBNUB({\n	    'notest'        : 1,\n	    'publish_key'   : attr( pdiv, 'pub-key' ),\n	    'subscribe_key' : attr( pdiv, 'sub-key' ),\n	    'ssl'           : !document.location.href.indexOf('https') ||\n	                      attr( pdiv, 'ssl' ) == 'on',\n	    'origin'        : attr( pdiv, 'origin' ),\n	    'uuid'          : attr( pdiv, 'uuid' )\n	});\n	\n	// jQuery Interface\n	window['jQuery'] && (window['jQuery']['PUBNUB'] = CREATE_PUBNUB);\n	\n	// For Modern JS + Testling.js - http://testling.com/\n	typeof(module) !== 'undefined' && (module['exports'] = PUBNUB) && ready();\n	\n	var pubnubs = $('pubnubs') || 0;\n	\n	// LEAVE NOW IF NO PDIV.\n	if (!PDIV) return;\n	\n	// PUBNUB Flash Socket\n	css( PDIV, { 'position' : 'absolute', 'top' : -SECOND } );\n	\n	if ('opera' in window || attr( PDIV, 'flash' )) PDIV['innerHTML'] =\n	    '<object id=pubnubs data='  + SWF +\n	    '><param name=movie value=' + SWF +\n	    '><param name=allowscriptaccess value=always></object>';\n	\n	// Create Interface for Opera Flash\n	PUBNUB['rdx'] = function( id, data ) {\n	    if (!data) return FDomainRequest[id]['onerror']();\n	    FDomainRequest[id]['responseText'] = unescape(data);\n	    FDomainRequest[id]['onload']();\n	};\n	\n	function FDomainRequest() {\n	    if (!pubnubs || !pubnubs['get']) return 0;\n	\n	    var fdomainrequest = {\n	        'id'    : FDomainRequest['id']++,\n	        'send'  : function() {},\n	        'abort' : function() { fdomainrequest['id'] = {} },\n	        'open'  : function( method, url ) {\n	            FDomainRequest[fdomainrequest['id']] = fdomainrequest;\n	            pubnubs['get']( fdomainrequest['id'], url );\n	        }\n	    };\n	\n	    return fdomainrequest;\n	}\n	FDomainRequest['id'] = SECOND;\n	\n	})();\n	(function(){\n	\n	// ---------------------------------------------------------------------------\n	// WEBSOCKET INTERFACE\n	// ---------------------------------------------------------------------------\n	var WS = PUBNUB['ws'] = function( url, protocols ) {\n	    if (!(this instanceof WS)) return new WS( url, protocols );\n	\n	    var self     = this\n	    ,   url      = self.url      = url || ''\n	    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'\n	    ,   bits     = url.split('/')\n	    ,   setup    = {\n	         'ssl'           : bits[0] === 'wss:'\n	        ,'origin'        : bits[2]\n	        ,'publish_key'   : bits[3]\n	        ,'subscribe_key' : bits[4]\n	        ,'channel'       : bits[5]\n	    };\n	\n	    // READY STATES\n	    self['CONNECTING'] = 0; // The connection is not yet open.\n	    self['OPEN']       = 1; // The connection is open and ready to communicate.\n	    self['CLOSING']    = 2; // The connection is in the process of closing.\n	    self['CLOSED']     = 3; // The connection is closed or couldn't be opened.\n	\n	    // CLOSE STATES\n	    self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.\n	    self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.\n	    self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.\n	    self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.\n	    self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.\n	    self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.\n	    self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.\n	\n	    // Events Default\n	    self['onclose']   = self['onerror'] =\n	    self['onmessage'] = self['onopen']  =\n	    self['onsend']    =  function(){};\n	\n	    // Attributes\n	    self['binaryType']     = '';\n	    self['extensions']     = '';\n	    self['bufferedAmount'] = 0;\n	    self['trasnmitting']   = false;\n	    self['buffer']         = [];\n	    self['readyState']     = self['CONNECTING'];\n	\n	    // Close if no setup.\n	    if (!url) {\n	        self['readyState'] = self['CLOSED'];\n	        self['onclose']({\n	            'code'     : self['CLOSE_ABNORMAL'],\n	            'reason'   : 'Missing URL',\n	            'wasClean' : true\n	        });\n	        return self;\n	    }\n	\n	    // PubNub WebSocket Emulation\n	    self.pubnub       = PUBNUB['init'](setup);\n	    self.pubnub.setup = setup;\n	    self.setup        = setup;\n	\n	    self.pubnub['subscribe']({\n	        'restore'    : false,\n	        'channel'    : setup['channel'],\n	        'disconnect' : self['onerror'],\n	        'reconnect'  : self['onopen'],\n	        'error'      : function() {\n	            self['onclose']({\n	                'code'     : self['CLOSE_ABNORMAL'],\n	                'reason'   : 'Missing URL',\n	                'wasClean' : false\n	            });\n	        },\n	        'callback'   : function(message) {\n	            self['onmessage']({ 'data' : message });\n	        },\n	        'connect'    : function() {\n	            self['readyState'] = self['OPEN'];\n	            self['onopen']();\n	        }\n	    });\n	};\n	\n	// ---------------------------------------------------------------------------\n	// WEBSOCKET SEND\n	// ---------------------------------------------------------------------------\n	WS.prototype.send = function(data) {\n	    var self = this;\n	    self.pubnub['publish']({\n	        'channel'  : self.pubnub.setup['channel'],\n	        'message'  : data,\n	        'callback' : function(response) {\n	            self['onsend']({ 'data' : response });\n	        }\n	    });\n	};\n	\n	// ---------------------------------------------------------------------------\n	// WEBSOCKET CLOSE\n	// ---------------------------------------------------------------------------\n	WS.prototype.close = function() {\n	    var self = this;\n	    self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });\n	    self['readyState'] = self['CLOSED'];\n	    self['onclose']({});\n	};\n	\n	})();\n	/*\n	CryptoJS v3.1.2\n	code.google.com/p/crypto-js\n	(c) 2009-2013 by Jeff Mott. All rights reserved.\n	code.google.com/p/crypto-js/wiki/License\n	*/\n	var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\n	r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n	32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n	2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\n	u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);\n	a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,\n	d)).finalize(c)}}});var t=f.algo={};return f}(Math);\n	\n	// SHA256\n	(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=\n	c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\n	d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);\n	\n	// HMAC SHA256\n	(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;\"string\"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=\n	this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();\n	\n	// Base64\n	(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join(\"\")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<\n	l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"}})();\n	\n	// BlockCipher\n	(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},\n	_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),\n	f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,\n	m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,\n	E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/\n	4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);\n	(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,\n	l)}})();\n	\n	// Cipher\n	CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},\n	finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return(\"string\"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return(\"string\"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=\n	c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,\n	e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,\n	this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,\n	1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},\n	decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return\"string\"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,\n	b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();\n	\n	// AES\n	(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,\n	16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>\n	8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=\n	d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();\n	\n	// Mode ECB\n	CryptoJS.mode.ECB = (function () {\n	    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n	\n	    ECB.Encryptor = ECB.extend({\n	        processBlock: function (words, offset) {\n	            this._cipher.encryptBlock(words, offset);\n	        }\n	    });\n	\n	    ECB.Decryptor = ECB.extend({\n	        processBlock: function (words, offset) {\n	            this._cipher.decryptBlock(words, offset);\n	        }\n	    });\n	\n	    return ECB;\n	}());// Moved to hmac-sha-256.js\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module)))\n	\n	/***/ },\n	/* 12 */\n	/***/ function(module, exports) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Cache = function () {\n	    function Cache(storage, prefix) {\n	        _classCallCheck(this, Cache);\n	\n	        this.setPrefix(prefix);\n	        this._storage = storage;\n	    }\n	\n	    Cache.prototype.setPrefix = function setPrefix(prefix) {\n	        this._prefix = prefix || Cache.defaultPrefix;\n	        return this;\n	    };\n	\n	    Cache.prototype.setItem = function setItem(key, data) {\n	        this._storage[this._prefixKey(key)] = JSON.stringify(data);\n	        return this;\n	    };\n	\n	    Cache.prototype.removeItem = function removeItem(key) {\n	        delete this._storage[this._prefixKey(key)];\n	        return this;\n	    };\n	\n	    Cache.prototype.getItem = function getItem(key) {\n	        var item = this._storage[this._prefixKey(key)];\n	        if (!item) return null;\n	        return JSON.parse(item);\n	    };\n	\n	    Cache.prototype.clean = function clean() {\n	\n	        for (var key in this._storage) {\n	\n	            if (!this._storage.hasOwnProperty(key)) continue;\n	\n	            if (key.indexOf(this._prefix) === 0) {\n	                delete this._storage[key];\n	            }\n	        }\n	\n	        return this;\n	    };\n	\n	    Cache.prototype._prefixKey = function _prefixKey(key) {\n	        return this._prefix + key;\n	    };\n	\n	    return Cache;\n	}();\n	\n	Cache.defaultPrefix = 'rc-';\n	exports.default = Cache;\n	\n	/***/ },\n	/* 13 */\n	/***/ function(module, exports) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Observable = function () {\n	    function Observable() {\n	        _classCallCheck(this, Observable);\n	\n	        this.off();\n	    }\n	\n	    Observable.prototype.hasListeners = function hasListeners(event) {\n	        return event in this._listeners;\n	    };\n	\n	    Observable.prototype.on = function on(events, callback) {\n	        var _this = this;\n	\n	        if (typeof events == 'string') events = [events];\n	        if (!events) throw new Error('No events to subscribe to');\n	        if (typeof callback !== 'function') throw new Error('Callback must be a function');\n	\n	        events.forEach(function (event) {\n	\n	            if (!_this.hasListeners(event)) _this._listeners[event] = [];\n	\n	            _this._listeners[event].push(callback);\n	        });\n	\n	        return this;\n	    };\n	\n	    Observable.prototype.emit = function emit(event) {\n	        var _this2 = this;\n	\n	        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n	            args[_key - 1] = arguments[_key];\n	        }\n	\n	        var result = null;\n	\n	        if (!this.hasListeners(event)) return null;\n	\n	        this._listeners[event].some(function (callback) {\n	\n	            result = callback.apply(_this2, args);\n	            return result === false;\n	        });\n	\n	        return result;\n	    };\n	\n	    Observable.prototype.off = function off(event, callback) {\n	        var _this3 = this;\n	\n	        if (!event) {\n	\n	            this._listeners = {};\n	        } else {\n	\n	            if (!callback) {\n	\n	                delete this._listeners[event];\n	            } else {\n	\n	                if (!this.hasListeners(event)) return this;\n	\n	                this._listeners[event].forEach(function (cb, i) {\n	\n	                    if (cb === callback) delete _this3._listeners[event][i];\n	                });\n	            }\n	        }\n	\n	        return this;\n	    };\n	\n	    return Observable;\n	}();\n	\n	exports.default = Observable;\n	\n	/***/ },\n	/* 14 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Queue = function () {\n	    function Queue(cache, cacheId) {\n	        _classCallCheck(this, Queue);\n	\n	        this._cache = cache;\n	        this._cacheId = cacheId;\n	        this._promise = null;\n	    }\n	\n	    Queue.prototype.isPaused = function isPaused() {\n	\n	        var time = this._cache.getItem(this._cacheId);\n	\n	        return !!time && Date.now() - parseInt(time) < Queue._releaseTimeout;\n	    };\n	\n	    Queue.prototype.pause = function pause() {\n	        this._cache.setItem(this._cacheId, Date.now());\n	        return this;\n	    };\n	\n	    Queue.prototype.resume = function resume() {\n	        this._cache.removeItem(this._cacheId);\n	        return this;\n	    };\n	\n	    Queue.prototype.poll = function poll() {\n	        var _this = this;\n	\n	        if (this._promise) return this._promise;\n	\n	        this._promise = new _Externals.Promise(function (resolve, reject) {\n	\n	            (0, _Utils.poll)(function (next) {\n	\n	                if (_this.isPaused()) return next();\n	\n	                _this._promise = null;\n	\n	                _this.resume(); // this is actually not needed but why not\n	\n	                resolve(null);\n	            }, Queue._pollInterval);\n	        });\n	\n	        return this._promise;\n	    };\n	\n	    return Queue;\n	}();\n	\n	Queue._pollInterval = 250;\n	Queue._releaseTimeout = 5000;\n	exports.default = Queue;\n	\n	/***/ },\n	/* 15 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	\"use strict\";\n	\n	exports.__esModule = true;\n	exports.findHeaderName = findHeaderName;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _Utils = __webpack_require__(3);\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _ApiResponse = __webpack_require__(16);\n	\n	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Client = function (_Observable) {\n	    _inherits(Client, _Observable);\n	\n	    function Client() {\n	        var _temp, _this, _ret;\n	\n	        _classCallCheck(this, Client);\n	\n	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n	            args[_key] = arguments[_key];\n	        }\n	\n	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Observable.call.apply(_Observable, [this].concat(args))), _this), _this.events = {\n	            beforeRequest: 'beforeRequest',\n	            requestSuccess: 'requestSuccess',\n	            requestError: 'requestError'\n	        }, _temp), _possibleConstructorReturn(_this, _ret);\n	    }\n	\n	    /**\n	     * @param {Request} request\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	    Client.prototype.sendRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n	            var apiResponse;\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            apiResponse = new _ApiResponse2.default(request);\n	                            _context.prev = 1;\n	\n	\n	                            //TODO Stop request if listeners return false\n	                            this.emit(this.events.beforeRequest, apiResponse);\n	\n	                            _context.next = 5;\n	                            return this._loadResponse(request);\n	\n	                        case 5:\n	                            apiResponse._response = _context.sent;\n	                            _context.next = 8;\n	                            return apiResponse._init();\n	\n	                        case 8:\n	                            if (apiResponse.ok()) {\n	                                _context.next = 10;\n	                                break;\n	                            }\n	\n	                            throw new Error('Response has unsuccessful status');\n	\n	                        case 10:\n	\n	                            this.emit(this.events.requestSuccess, apiResponse);\n	\n	                            return _context.abrupt(\"return\", apiResponse);\n	\n	                        case 14:\n	                            _context.prev = 14;\n	                            _context.t0 = _context[\"catch\"](1);\n	\n	\n	                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);\n	\n	                            this.emit(this.events.requestError, _context.t0);\n	\n	                            throw _context.t0;\n	\n	                        case 19:\n	                        case \"end\":\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this, [[1, 14]]);\n	        }));\n	\n	        function sendRequest(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return sendRequest;\n	    }();\n	\n	    /**\n	     * @param {Request} request\n	     * @return {Promise<Response>}\n	     * @private\n	     */\n	\n	\n	    Client.prototype._loadResponse = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {\n	            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n	                while (1) {\n	                    switch (_context2.prev = _context2.next) {\n	                        case 0:\n	                            _context2.next = 2;\n	                            return _Externals.fetch.call(null, request);\n	\n	                        case 2:\n	                            return _context2.abrupt(\"return\", _context2.sent);\n	\n	                        case 3:\n	                        case \"end\":\n	                            return _context2.stop();\n	                    }\n	                }\n	            }, _callee2, this);\n	        }));\n	\n	        function _loadResponse(_x2) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _loadResponse;\n	    }();\n	\n	    /**\n	     * Wraps the JS Error object with transaction information\n	     * @param {Error|IApiError} e\n	     * @param {ApiResponse} apiResponse\n	     * @return {IApiError}\n	     */\n	\n	\n	    Client.prototype.makeError = function makeError(e, apiResponse) {\n	\n	        // Wrap only if regular error\n	        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {\n	\n	            e.apiResponse = apiResponse;\n	            e.originalMessage = e.message;\n	            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;\n	        }\n	\n	        return e;\n	    };\n	\n	    /**\n	     *\n	     * @param {object} init\n	     * @param {object} [init.url]\n	     * @param {object} [init.body]\n	     * @param {string} [init.method]\n	     * @param {object} [init.query]\n	     * @param {object} [init.headers]\n	     * @return {Request}\n	     */\n	\n	\n	    Client.prototype.createRequest = function createRequest(init) {\n	\n	        init = init || {};\n	        init.headers = init.headers || {};\n	\n	        // Sanity checks\n	        if (!init.url) throw new Error('Url is not defined');\n	        if (!init.method) init.method = 'GET';\n	        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {\n	            throw new Error('Method has wrong value: ' + init.method);\n	        }\n	\n	        // Defaults\n	        init.credentials = init.credentials || 'include';\n	        init.mode = init.mode || 'cors';\n	\n	        // Append Query String\n	        if (init.query) {\n	            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);\n	        }\n	\n	        if (!findHeaderName('Accept', init.headers)) {\n	            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;\n	        }\n	\n	        // Serialize body\n	        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {\n	\n	            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);\n	\n	            if (!contentTypeHeaderName) {\n	                contentTypeHeaderName = _ApiResponse2.default._contentType;\n	                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;\n	            }\n	\n	            var contentType = init.headers[contentTypeHeaderName];\n	\n	            // Assign a new encoded body\n	            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {\n	                init.body = JSON.stringify(init.body);\n	            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {\n	                init.body = (0, _Utils.queryStringify)(init.body);\n	            }\n	        }\n	\n	        // Create a request with encoded body\n	        var req = new _Externals.Request(init.url, init);\n	\n	        // Keep the original body accessible directly (for mocks)\n	        req.originalBody = init.body;\n	\n	        return req;\n	    };\n	\n	    return Client;\n	}(_Observable3.default);\n	\n	Client._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];\n	exports.default = Client;\n	function findHeaderName(name, headers) {\n	    name = name.toLowerCase();\n	    return Object.keys(headers).reduce(function (res, key) {\n	        if (res) return res;\n	        if (name == key.toLowerCase()) return key;\n	        return res;\n	    }, null);\n	}\n	\n	/**\n	 * @name IApiError\n	 * @property {string} stack\n	 * @property {string} originalMessage\n	 * @property {ApiResponse} apiResponse\n	 */\n	\n	/***/ },\n	/* 16 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var ApiResponse = function () {\n	\n	    /**\n	     * @param {Request} request\n	     * @param {Response} response\n	     * @param {string} responseText\n	     */\n	\n	    function ApiResponse(request, response, responseText) {\n	        _classCallCheck(this, ApiResponse);\n	\n	        /** @type {Request} */\n	        this._request = request;\n	\n	        /** @type {Response} */\n	        this._response = response;\n	\n	        this._text = responseText;\n	        this._json = null;\n	        this._multipart = [];\n	    }\n	\n	    ApiResponse.prototype._init = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            if (!(this._isMultipart() || this._isJson())) {\n	                                _context.next = 4;\n	                                break;\n	                            }\n	\n	                            _context.next = 3;\n	                            return this.response().text();\n	\n	                        case 3:\n	                            this._text = _context.sent;\n	\n	                        case 4:\n	                            return _context.abrupt('return', this);\n	\n	                        case 5:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function _init() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _init;\n	    }();\n	\n	    /**\n	     * @return {Response}\n	     */\n	\n	\n	    ApiResponse.prototype.response = function response() {\n	        return this._response;\n	    };\n	\n	    /**\n	     * @return {Request}\n	     */\n	\n	\n	    ApiResponse.prototype.request = function request() {\n	        return this._request;\n	    };\n	\n	    /**\n	     * @return {boolean}\n	     */\n	\n	\n	    ApiResponse.prototype.ok = function ok() {\n	        return this._response && this._response.ok;\n	    };\n	\n	    /**\n	     * @return {string}\n	     */\n	\n	\n	    ApiResponse.prototype.text = function text() {\n	        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');\n	        return this._text;\n	    };\n	\n	    /**\n	     * @return {object}\n	     */\n	\n	\n	    ApiResponse.prototype.json = function json() {\n	        if (!this._isJson()) throw new Error('Response is not JSON');\n	        if (!this._json) {\n	            this._json = this._text ? JSON.parse(this._text) : null;\n	        }\n	        return this._json;\n	    };\n	\n	    /**\n	     * @param [skipOKCheck]\n	     * @return {string}\n	     */\n	\n	\n	    ApiResponse.prototype.error = function error(skipOKCheck) {\n	\n	        if (this.ok() && !skipOKCheck) return null;\n	\n	        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');\n	\n	        try {\n	\n	            if (this.json().message) message = this.json().message;\n	            if (this.json().error_description) message = this.json().error_description;\n	            if (this.json().description) message = this.json().description;\n	        } catch (e) {}\n	\n	        return message;\n	    };\n	\n	    /**\n	     * @return {ApiResponse[]}\n	     */\n	\n	\n	    ApiResponse.prototype.multipart = function multipart() {\n	\n	        if (!this._isMultipart()) throw new Error('Response is not multipart');\n	\n	        if (!this._multipart.length) {\n	\n	            // Step 1. Split multipart response\n	\n	            var text = this.text();\n	\n	            if (!text) throw new Error('No response body');\n	\n	            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];\n	\n	            if (!boundary) throw new Error('Cannot find boundary');\n	\n	            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);\n	\n	            if (parts[0].trim() === '') parts.shift();\n	            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();\n	\n	            if (parts.length < 1) throw new Error('No parts in body');\n	\n	            // Step 2. Parse status info\n	\n	            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();\n	\n	            // Step 3. Parse all other parts\n	\n	            this._multipart = parts.map(function (part, i) {\n	\n	                var status = statusInfo.response[i].status;\n	\n	                return ApiResponse.create(part, status);\n	            });\n	        }\n	\n	        return this._multipart;\n	    };\n	\n	    ApiResponse.prototype._isContentType = function _isContentType(contentType) {\n	        return this._getContentType().indexOf(contentType) > -1;\n	    };\n	\n	    ApiResponse.prototype._getContentType = function _getContentType() {\n	        return this._response.headers.get(ApiResponse._contentType) || '';\n	    };\n	\n	    ApiResponse.prototype._isMultipart = function _isMultipart() {\n	        return this._isContentType(ApiResponse._multipartContentType);\n	    };\n	\n	    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {\n	        return this._isContentType(ApiResponse._urlencodedContentType);\n	    };\n	\n	    ApiResponse.prototype._isJson = function _isJson() {\n	        return this._isContentType(ApiResponse._jsonContentType);\n	    };\n	\n	    /**\n	     * Method is used to create ApiResponse object from string parts of multipart/mixed response\n	     * @param {string} [text]\n	     * @param {number} [status]\n	     * @param {string} [statusText]\n	     * @return {ApiResponse}\n	     */\n	\n	\n	    ApiResponse.create = function create(text, status, statusText) {\n	\n	        text = text || '';\n	        status = status || 200;\n	        statusText = statusText || 'OK';\n	\n	        text = text.replace(/\\r/g, '');\n	\n	        var headers = new _Externals.Headers(),\n	            headersAndBody = text.split(ApiResponse._bodySeparator),\n	            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';\n	\n	        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;\n	\n	        (headersText || '').split('\\n').forEach(function (header) {\n	\n	            var split = header.trim().split(ApiResponse._headerSeparator),\n	                key = split.shift().trim(),\n	                value = split.join(ApiResponse._headerSeparator).trim();\n	\n	            if (key) headers.append(key, value);\n	        });\n	\n	        return new ApiResponse(null, new _Externals.Response(text ? text : null, {\n	            headers: headers,\n	            status: status,\n	            statusText: statusText\n	        }), text);\n	    };\n	\n	    return ApiResponse;\n	}();\n	\n	ApiResponse._contentType = 'Content-Type';\n	ApiResponse._jsonContentType = 'application/json';\n	ApiResponse._multipartContentType = 'multipart/mixed';\n	ApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';\n	ApiResponse._headerSeparator = ':';\n	ApiResponse._bodySeparator = '\\n\\n';\n	ApiResponse._boundarySeparator = '--';\n	exports.default = ApiResponse;\n	\n	/***/ },\n	/* 17 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Registry = __webpack_require__(18);\n	\n	var _Registry2 = _interopRequireDefault(_Registry);\n	\n	var _Client = __webpack_require__(15);\n	\n	var _Client2 = _interopRequireDefault(_Client);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Client = function (_HttpClient) {\n	    _inherits(Client, _HttpClient);\n	\n	    function Client() {\n	        _classCallCheck(this, Client);\n	\n	        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));\n	\n	        _this._registry = new _Registry2.default();\n	        return _this;\n	    }\n	\n	    Client.prototype.registry = function registry() {\n	        return this._registry;\n	    };\n	\n	    Client.prototype._loadResponse = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n	            var mock;\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            mock = this._registry.find(request);\n	                            _context.next = 3;\n	                            return mock.getResponse(request);\n	\n	                        case 3:\n	                            return _context.abrupt('return', _context.sent);\n	\n	                        case 4:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function _loadResponse(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _loadResponse;\n	    }();\n	\n	    return Client;\n	}(_Client2.default);\n	\n	exports.default = Client;\n	\n	/***/ },\n	/* 18 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Mock = __webpack_require__(19);\n	\n	var _Mock2 = _interopRequireDefault(_Mock);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Registry = function () {\n	    function Registry() {\n	        _classCallCheck(this, Registry);\n	\n	        this._mocks = [];\n	    }\n	\n	    Registry.prototype.add = function add(mock) {\n	        this._mocks.push(mock);\n	        return this;\n	    };\n	\n	    Registry.prototype.clear = function clear() {\n	        this._mocks = [];\n	        return this;\n	    };\n	\n	    Registry.prototype.find = function find(request) {\n	\n	        //console.log('Registry is looking for', request);\n	\n	        var mock = this._mocks.shift();\n	\n	        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);\n	\n	        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());\n	\n	        return mock;\n	    };\n	\n	    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText) {\n	\n	        this.add(new _Mock2.default(method, path, response, status, statusText));\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.authentication = function authentication() {\n	\n	        this.apiCall('POST', '/restapi/oauth/token', {\n	            'access_token': 'ACCESS_TOKEN',\n	            'token_type': 'bearer',\n	            'expires_in': 3600,\n	            'refresh_token': 'REFRESH_TOKEN',\n	            'refresh_token_expires_in': 60480,\n	            'scope': 'SMS RCM Foo Boo',\n	            'expireTime': new Date().getTime() + 3600000\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.logout = function logout() {\n	\n	        this.apiCall('POST', '/restapi/oauth/revoke', {});\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.presenceLoad = function presenceLoad(id) {\n	\n	        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {\n	            \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id + \"/presence\",\n	            \"extension\": {\n	                \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id,\n	                \"id\": id,\n	                \"extensionNumber\": \"101\"\n	            },\n	            \"activeCalls\": [],\n	            \"presenceStatus\": \"Available\",\n	            \"telephonyStatus\": \"Ringing\",\n	            \"userStatus\": \"Available\",\n	            \"dndStatus\": \"TakeAllCalls\",\n	            \"extensionId\": id\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {\n	\n	        expiresIn = expiresIn || 15 * 60 * 60;\n	\n	        var date = new Date();\n	\n	        this.apiCall('POST', '/restapi/v1.0/subscription', {\n	            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],\n	            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),\n	            'expiresIn': expiresIn,\n	            'deliveryMode': {\n	                'transportType': 'PubNub',\n	                'encryption': false,\n	                'address': '123_foo',\n	                'subscriberKey': 'sub-c-foo',\n	                'secretKey': 'sec-c-bar'\n	            },\n	            'id': 'foo-bar-baz',\n	            'creationTime': date.toISOString(),\n	            'status': 'Active',\n	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {\n	\n	        id = id || '1';\n	\n	        var date = new Date();\n	\n	        this.apiCall('POST', '/restapi/v1.0/subscription', {\n	            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],\n	            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),\n	            'deliveryMode': {\n	                'transportType': 'PubNub',\n	                'encryption': true,\n	                'address': '123_foo',\n	                'subscriberKey': 'sub-c-foo',\n	                'secretKey': 'sec-c-bar',\n	                'encryptionAlgorithm': 'AES',\n	                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='\n	            },\n	            'creationTime': date.toISOString(),\n	            'id': 'foo-bar-baz',\n	            'status': 'Active',\n	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {\n	\n	        if (!failure) {\n	\n	            this.apiCall('POST', '/restapi/oauth/token', {\n	                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',\n	                'token_type': 'bearer',\n	                'expires_in': 3600,\n	                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',\n	                'refresh_token_expires_in': 60480,\n	                'scope': 'SMS RCM Foo Boo'\n	            });\n	        } else {\n	\n	            this.apiCall('POST', '/restapi/oauth/token', {\n	                'message': 'Wrong token',\n	                'error_description': 'Wrong token',\n	                'description': 'Wrong token'\n	            }, 400);\n	        }\n	\n	        return this;\n	    };\n	\n	    return Registry;\n	}();\n	\n	exports.default = Registry;\n	\n	/***/ },\n	/* 19 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _ApiResponse = __webpack_require__(16);\n	\n	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Mock = function () {\n	    function Mock(method, path, json, status, statusText, delay) {\n	        _classCallCheck(this, Mock);\n	\n	        this._method = method.toUpperCase();\n	        this._path = path;\n	        this._json = json || {};\n	        this._delay = delay || 10;\n	        this._status = status || 200;\n	        this._statusText = statusText || 'OK';\n	    }\n	\n	    Mock.prototype.path = function path() {\n	        return this._path;\n	    };\n	\n	    Mock.prototype.method = function method() {\n	        return this._method;\n	    };\n	\n	    Mock.prototype.test = function test(request) {\n	\n	        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;\n	    };\n	\n	    Mock.prototype.getResponse = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            _context.next = 2;\n	                            return (0, _Utils.delay)(this._delay);\n	\n	                        case 2:\n	                            return _context.abrupt('return', this.createResponse(this._json));\n	\n	                        case 3:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function getResponse(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return getResponse;\n	    }();\n	\n	    Mock.prototype.createResponse = function createResponse(json, init) {\n	\n	        init = init || {};\n	\n	        init.status = init.status || this._status;\n	        init.statusText = init.statusText || this._statusText;\n	\n	        var str = JSON.stringify(json),\n	            res = new _Externals.Response(str, init);\n	\n	        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);\n	\n	        return res;\n	    };\n	\n	    return Mock;\n	}();\n	\n	exports.default = Mock;\n	\n	/***/ },\n	/* 20 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	\"use strict\";\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _Queue = __webpack_require__(14);\n	\n	var _Queue2 = _interopRequireDefault(_Queue);\n	\n	var _Auth = __webpack_require__(21);\n	\n	var _Auth2 = _interopRequireDefault(_Auth);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Platform = function (_Observable) {\n	    _inherits(Platform, _Observable);\n	\n	    // 10 hours\n	\n	    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {\n	        _classCallCheck(this, Platform);\n	\n	        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n	\n	        _this.events = {\n	            beforeLogin: 'beforeLogin',\n	            loginSuccess: 'loginSuccess',\n	            loginError: 'loginError',\n	            beforeRefresh: 'beforeRefresh',\n	            refreshSuccess: 'refreshSuccess',\n	            refreshError: 'refreshError',\n	            beforeLogout: 'beforeLogout',\n	            logoutSuccess: 'logoutSuccess',\n	            logoutError: 'logoutError'\n	        };\n	\n	\n	        _this._server = server;\n	        _this._appKey = appKey;\n	        _this._appSecret = appSecret;\n	\n	        /** @type {Cache} */\n	        _this._cache = cache;\n	\n	        /** @type {Client} */\n	        _this._client = client;\n	\n	        _this._queue = new _Queue2.default(_this._cache, Platform._cacheId + '-refresh');\n	\n	        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);\n	\n	        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;\n	\n	        return _this;\n	    }\n	\n	    /**\n	     * @return {Auth}\n	     */\n	    // 1 week\n	\n	\n	    Platform.prototype.auth = function auth() {\n	        return this._auth;\n	    };\n	\n	    /**\n	     * @return {Client}\n	     */\n	\n	\n	    Platform.prototype.client = function client() {\n	        return this._client;\n	    };\n	\n	    /**\n	     * @param {string} path\n	     * @param {object} [options]\n	     * @param {boolean} [options.addServer]\n	     * @param {string} [options.addMethod]\n	     * @param {boolean} [options.addToken]\n	     * @return {string}\n	     */\n	\n	\n	    Platform.prototype.createUrl = function createUrl(path, options) {\n	\n	        path = path || '';\n	        options = options || {};\n	\n	        var builtUrl = '',\n	            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;\n	\n	        if (options.addServer && !hasHttp) builtUrl += this._server;\n	\n	        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;\n	\n	        builtUrl += path;\n	\n	        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';\n	\n	        if (options.addMethod) builtUrl += '_method=' + options.addMethod;\n	        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();\n	\n	        return builtUrl;\n	    };\n	\n	    /**\n	     * @param {string} options.redirectUri\n	     * @param {string} options.state\n	     * @param {string} options.brandId\n	     * @param {string} options.display\n	     * @param {string} options.prompt\n	     * @param {object} [options]\n	     * @return {string}\n	     */\n	\n	\n	    Platform.prototype.authUrl = function authUrl(options) {\n	\n	        options = options || {};\n	\n	        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({\n	            'response_type': 'code',\n	            'redirect_uri': options.redirectUri || '',\n	            'client_id': this._appKey,\n	            'state': options.state || '',\n	            'brand_id': options.brandId || '',\n	            'display': options.display || '',\n	            'prompt': options.prompt || ''\n	        }), { addServer: true });\n	    };\n	\n	    /**\n	     * @param {string} url\n	     * @return {Object}\n	     */\n	\n	\n	    Platform.prototype.parseAuthRedirectUrl = function parseAuthRedirectUrl(url) {\n	\n	        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),\n	            error = qs.error_description || qs.error;\n	\n	        if (error) {\n	            var e = new Error(error);\n	            e.error = qs.error;\n	            throw e;\n	        }\n	\n	        return qs;\n	    };\n	\n	    /**\n	     * Convenience method to handle 3-legged OAuth\n	     *\n	     * Attention! This is an experimental method and it's signature and behavior may change without notice.\n	     *\n	     * @experimental\n	     * @param {number} [options.width]\n	     * @param {number} [options.height]\n	     * @param {object} [options.login] additional options for login()\n	     * @param {string} [options.origin]\n	     * @param {string} [options.property] name of window.postMessage's event data property\n	     * @param {string} [options.target] target for window.open()\n	     * @param {string} options.url\n	     * @return {Promise}\n	     */\n	\n	\n	    Platform.prototype.authWindow = function authWindow(options) {\n	        var _this2 = this;\n	\n	        return new _Externals.Promise(function (resolve, reject) {\n	\n	            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');\n	\n	            if (!options.url) throw new Error('Missing mandatory URL parameter');\n	\n	            options = options || {};\n	            options.url = options.url || 400;\n	            options.width = options.width || 400;\n	            options.height = options.height || 600;\n	            options.origin = options.origin || window.location.origin;\n	            options.property = options.property || 'RCAuthorizationCode';\n	            options.target = options.target || '_blank';\n	\n	            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;\n	            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;\n	\n	            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;\n	            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n	\n	            var left = width / 2 - options.width / 2 + dualScreenLeft;\n	            var top = height / 2 - options.height / 2 + dualScreenTop;\n	            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');\n	\n	            if (window.focus) win.focus();\n	\n	            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';\n	            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';\n	            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';\n	\n	            var eventListener = function eventListener(e) {\n	\n	                if (e.origin != options.origin) return;\n	                if (!e.data || !e.data[options.property]) return; // keep waiting\n	\n	                win.close();\n	                window[eventRemoveMethod](messageEvent, eventListener);\n	\n	                try {\n	\n	                    var loginOptions = _this2.parseAuthRedirectUrl(e.data[options.property]);\n	\n	                    if (!loginOptions.code) throw new Error('No authorization code');\n	\n	                    resolve(loginOptions);\n	                } catch (e) {\n	                    reject(e);\n	                }\n	            };\n	\n	            window[eventMethod](messageEvent, eventListener, false);\n	        });\n	    };\n	\n	    /**\n	     * @return {Promise<boolean>}\n	     */\n	\n	\n	    Platform.prototype.loggedIn = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            _context.prev = 0;\n	                            _context.next = 3;\n	                            return this._ensureAuthentication();\n	\n	                        case 3:\n	                            return _context.abrupt(\"return\", true);\n	\n	                        case 6:\n	                            _context.prev = 6;\n	                            _context.t0 = _context[\"catch\"](0);\n	                            return _context.abrupt(\"return\", false);\n	\n	                        case 9:\n	                        case \"end\":\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this, [[0, 6]]);\n	        }));\n	\n	        function loggedIn() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return loggedIn;\n	    }();\n	\n	    /**\n	     * @param {string} options.username\n	     * @param {string} options.password\n	     * @param {string} options.extension\n	     * @param {string} options.code\n	     * @param {string} options.redirectUri\n	     * @param {string} options.endpointId\n	     * @param {string} options.remember\n	     * @param {string} options.accessTokenTtl\n	     * @param {string} options.refreshTokenTtl\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.login = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {\n	            var body, apiResponse, json;\n	            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n	                while (1) {\n	                    switch (_context2.prev = _context2.next) {\n	                        case 0:\n	                            _context2.prev = 0;\n	\n	\n	                            options = options || {};\n	\n	                            this.emit(this.events.beforeLogin);\n	\n	                            body = {};\n	\n	\n	                            if (!options.code) {\n	\n	                                body.grant_type = 'password';\n	                                body.username = options.username;\n	                                body.password = options.password;\n	                                body.extension = options.extension || '';\n	                            } else if (options.code) {\n	\n	                                body.grant_type = 'authorization_code';\n	                                body.code = options.code;\n	                                body.redirect_uri = options.redirectUri;\n	                                //body.client_id = this.getCredentials().key; // not needed\n	                            }\n	\n	                            if (options.endpointId) body.endpoint_id = options.endpointId;\n	                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;\n	                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;\n	                            if (options.remember && !options.refreshTokenTtl) body.refreshTokenTtl = options.remember ? Platform._refreshTokenTtlRemember : Platform._refreshTokenTtl;\n	\n	                            _context2.next = 11;\n	                            return this._tokenRequest(Platform._tokenEndpoint, body);\n	\n	                        case 11:\n	                            apiResponse = _context2.sent;\n	                            json = apiResponse.json();\n	\n	\n	                            this._auth.setData(json);\n	\n	                            this.emit(this.events.loginSuccess, apiResponse);\n	\n	                            return _context2.abrupt(\"return\", apiResponse);\n	\n	                        case 18:\n	                            _context2.prev = 18;\n	                            _context2.t0 = _context2[\"catch\"](0);\n	\n	\n	                            this._cache.clean();\n	\n	                            this.emit(this.events.loginError, _context2.t0);\n	\n	                            throw _context2.t0;\n	\n	                        case 23:\n	                        case \"end\":\n	                            return _context2.stop();\n	                    }\n	                }\n	            }, _callee2, this, [[0, 18]]);\n	        }));\n	\n	        function login(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return login;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.refresh = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n	            var res, json;\n	            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n	                while (1) {\n	                    switch (_context3.prev = _context3.next) {\n	                        case 0:\n	                            _context3.prev = 0;\n	\n	\n	                            this.emit(this.events.beforeRefresh);\n	\n	                            if (!this._queue.isPaused()) {\n	                                _context3.next = 9;\n	                                break;\n	                            }\n	\n	                            _context3.next = 5;\n	                            return this._queue.poll();\n	\n	                        case 5:\n	                            if (this._isAccessTokenValid()) {\n	                                _context3.next = 7;\n	                                break;\n	                            }\n	\n	                            throw new Error('Automatic authentification timeout');\n	\n	                        case 7:\n	\n	                            this.emit(this.events.refreshSuccess, null);\n	\n	                            return _context3.abrupt(\"return\", null);\n	\n	                        case 9:\n	\n	                            this._queue.pause();\n	\n	                            // Make sure all existing AJAX calls had a chance to reach the server\n	                            _context3.next = 12;\n	                            return (0, _Utils.delay)(Platform._refreshDelayMs);\n	\n	                        case 12:\n	                            if (this._auth.refreshToken()) {\n	                                _context3.next = 14;\n	                                break;\n	                            }\n	\n	                            throw new Error('Refresh token is missing');\n	\n	                        case 14:\n	                            if (this._auth.refreshTokenValid()) {\n	                                _context3.next = 16;\n	                                break;\n	                            }\n	\n	                            throw new Error('Refresh token has expired');\n	\n	                        case 16:\n	                            if (this._queue.isPaused()) {\n	                                _context3.next = 18;\n	                                break;\n	                            }\n	\n	                            throw new Error('Queue was resumed before refresh call');\n	\n	                        case 18:\n	                            _context3.next = 20;\n	                            return this._tokenRequest(Platform._tokenEndpoint, {\n	                                \"grant_type\": \"refresh_token\",\n	                                \"refresh_token\": this._auth.refreshToken(),\n	                                \"access_token_ttl\": this._auth.data().expires_in + 1,\n	                                \"refresh_token_ttl\": this._auth.data().refresh_token_expires_in + 1\n	                            });\n	\n	                        case 20:\n	                            res = _context3.sent;\n	                            json = res.json();\n	\n	                            if (json.access_token) {\n	                                _context3.next = 24;\n	                                break;\n	                            }\n	\n	                            throw this._client.makeError(new Error('Malformed OAuth response'), res);\n	\n	                        case 24:\n	\n	                            this._auth.setData(json);\n	                            this._queue.resume();\n	\n	                            this.emit(this.events.refreshSuccess, res);\n	\n	                            return _context3.abrupt(\"return\", res);\n	\n	                        case 30:\n	                            _context3.prev = 30;\n	                            _context3.t0 = _context3[\"catch\"](0);\n	\n	\n	                            _context3.t0 = this._client.makeError(_context3.t0);\n	\n	                            if (Platform._clearCacheOnRefreshError) {\n	                                this._cache.clean();\n	                            }\n	\n	                            this.emit(this.events.refreshError, _context3.t0);\n	\n	                            throw _context3.t0;\n	\n	                        case 36:\n	                        case \"end\":\n	                            return _context3.stop();\n	                    }\n	                }\n	            }, _callee3, this, [[0, 30]]);\n	        }));\n	\n	        function refresh() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return refresh;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.logout = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n	            var res;\n	            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n	                while (1) {\n	                    switch (_context4.prev = _context4.next) {\n	                        case 0:\n	                            _context4.prev = 0;\n	\n	\n	                            this.emit(this.events.beforeLogout);\n	\n	                            this._queue.pause();\n	\n	                            _context4.next = 5;\n	                            return this._tokenRequest(Platform._revokeEndpoint, {\n	                                token: this._auth.accessToken()\n	                            });\n	\n	                        case 5:\n	                            res = _context4.sent;\n	\n	\n	                            this._queue.resume();\n	                            this._cache.clean();\n	\n	                            this.emit(this.events.logoutSuccess, res);\n	\n	                            return _context4.abrupt(\"return\", res);\n	\n	                        case 12:\n	                            _context4.prev = 12;\n	                            _context4.t0 = _context4[\"catch\"](0);\n	\n	\n	                            this._queue.resume();\n	\n	                            this.emit(this.events.logoutError, _context4.t0);\n	\n	                            throw _context4.t0;\n	\n	                        case 17:\n	                        case \"end\":\n	                            return _context4.stop();\n	                    }\n	                }\n	            }, _callee4, this, [[0, 12]]);\n	        }));\n	\n	        function logout() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return logout;\n	    }();\n	\n	    /**\n	     * @param {Request} request\n	     * @param {object} [options]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<Request>}\n	     */\n	\n	\n	    Platform.prototype.inflateRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(request, options) {\n	            return regeneratorRuntime.wrap(function _callee5$(_context5) {\n	                while (1) {\n	                    switch (_context5.prev = _context5.next) {\n	                        case 0:\n	\n	                            options = options || {};\n	\n	                            if (!options.skipAuthCheck) {\n	                                _context5.next = 3;\n	                                break;\n	                            }\n	\n	                            return _context5.abrupt(\"return\", request);\n	\n	                        case 3:\n	                            _context5.next = 5;\n	                            return this._ensureAuthentication();\n	\n	                        case 5:\n	\n	                            request.headers.set('X-User-Agent', this._userAgent);\n	                            request.headers.set('Client-Id', this._appKey);\n	                            request.headers.set('Authorization', this._authHeader());\n	                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...\n	\n	                            return _context5.abrupt(\"return\", request);\n	\n	                        case 9:\n	                        case \"end\":\n	                            return _context5.stop();\n	                    }\n	                }\n	            }, _callee5, this);\n	        }));\n	\n	        function inflateRequest(_x2, _x3) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return inflateRequest;\n	    }();\n	\n	    /**\n	     * @param {Request} request\n	     * @param {object} [options]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.sendRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {\n	            return regeneratorRuntime.wrap(function _callee6$(_context6) {\n	                while (1) {\n	                    switch (_context6.prev = _context6.next) {\n	                        case 0:\n	                            _context6.prev = 0;\n	                            _context6.next = 3;\n	                            return this.inflateRequest(request, options);\n	\n	                        case 3:\n	                            request = _context6.sent;\n	                            _context6.next = 6;\n	                            return this._client.sendRequest(request);\n	\n	                        case 6:\n	                            return _context6.abrupt(\"return\", _context6.sent);\n	\n	                        case 9:\n	                            _context6.prev = 9;\n	                            _context6.t0 = _context6[\"catch\"](0);\n	\n	                            if (!(!_context6.t0.apiResponse || !_context6.t0.apiResponse.response() || _context6.t0.apiResponse.response().status != 401)) {\n	                                _context6.next = 13;\n	                                break;\n	                            }\n	\n	                            throw _context6.t0;\n	\n	                        case 13:\n	\n	                            this._auth.cancelAccessToken();\n	\n	                            _context6.next = 16;\n	                            return this.sendRequest(request, options);\n	\n	                        case 16:\n	                            return _context6.abrupt(\"return\", _context6.sent);\n	\n	                        case 17:\n	                        case \"end\":\n	                            return _context6.stop();\n	                    }\n	                }\n	            }, _callee6, this, [[0, 9]]);\n	        }));\n	\n	        function sendRequest(_x4, _x5) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return sendRequest;\n	    }();\n	\n	    /**\n	     * General purpose function to send anything to server\n	     * @param {string} options.url\n	     * @param {object} [options.body]\n	     * @param {string} [options.method]\n	     * @param {object} [options.query]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.send = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {\n	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n	            return regeneratorRuntime.wrap(function _callee7$(_context7) {\n	                while (1) {\n	                    switch (_context7.prev = _context7.next) {\n	                        case 0:\n	\n	                            //FIXME https://github.com/bitinn/node-fetch/issues/43\n	                            options.url = this.createUrl(options.url, { addServer: true });\n	\n	                            _context7.next = 3;\n	                            return this.sendRequest(this._client.createRequest(options), options);\n	\n	                        case 3:\n	                            return _context7.abrupt(\"return\", _context7.sent);\n	\n	                        case 4:\n	                        case \"end\":\n	                            return _context7.stop();\n	                    }\n	                }\n	            }, _callee7, this);\n	        }));\n	\n	        function send(_x6) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return send;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {object} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.get = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(url, query, options) {\n	            return regeneratorRuntime.wrap(function _callee8$(_context8) {\n	                while (1) {\n	                    switch (_context8.prev = _context8.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'GET';\n	                            options.url = url;\n	                            options.query = query;\n	                            _context8.next = 6;\n	                            return this.send(options);\n	\n	                        case 6:\n	                            return _context8.abrupt(\"return\", _context8.sent);\n	\n	                        case 7:\n	                        case \"end\":\n	                            return _context8.stop();\n	                    }\n	                }\n	            }, _callee8, this);\n	        }));\n	\n	        function get(_x8, _x9, _x10) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return get;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {object} body\n	     * @param {object} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.post = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, body, query, options) {\n	            return regeneratorRuntime.wrap(function _callee9$(_context9) {\n	                while (1) {\n	                    switch (_context9.prev = _context9.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'POST';\n	                            options.url = url;\n	                            options.query = query;\n	                            options.body = body;\n	                            _context9.next = 7;\n	                            return this.send(options);\n	\n	                        case 7:\n	                            return _context9.abrupt(\"return\", _context9.sent);\n	\n	                        case 8:\n	                        case \"end\":\n	                            return _context9.stop();\n	                    }\n	                }\n	            }, _callee9, this);\n	        }));\n	\n	        function post(_x11, _x12, _x13, _x14) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return post;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {object} [body]\n	     * @param {object} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.put = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {\n	            return regeneratorRuntime.wrap(function _callee10$(_context10) {\n	                while (1) {\n	                    switch (_context10.prev = _context10.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'PUT';\n	                            options.url = url;\n	                            options.query = query;\n	                            options.body = body;\n	                            _context10.next = 7;\n	                            return this.send(options);\n	\n	                        case 7:\n	                            return _context10.abrupt(\"return\", _context10.sent);\n	\n	                        case 8:\n	                        case \"end\":\n	                            return _context10.stop();\n	                    }\n	                }\n	            }, _callee10, this);\n	        }));\n	\n	        function put(_x15, _x16, _x17, _x18) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return put;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {string} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype['delete'] = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, query, options) {\n	            return regeneratorRuntime.wrap(function _callee11$(_context11) {\n	                while (1) {\n	                    switch (_context11.prev = _context11.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'DELETE';\n	                            options.url = url;\n	                            options.query = query;\n	                            _context11.next = 6;\n	                            return this.send(options);\n	\n	                        case 6:\n	                            return _context11.abrupt(\"return\", _context11.sent);\n	\n	                        case 7:\n	                        case \"end\":\n	                            return _context11.stop();\n	                    }\n	                }\n	            }, _callee11, this);\n	        }));\n	\n	        function _delete(_x19, _x20, _x21) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _delete;\n	    }();\n	\n	    Platform.prototype._tokenRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(path, body) {\n	            return regeneratorRuntime.wrap(function _callee12$(_context12) {\n	                while (1) {\n	                    switch (_context12.prev = _context12.next) {\n	                        case 0:\n	                            _context12.next = 2;\n	                            return this.send({\n	                                url: path,\n	                                skipAuthCheck: true,\n	                                body: body,\n	                                method: 'POST',\n	                                headers: {\n	                                    'Authorization': 'Basic ' + this._apiKey(),\n	                                    'Content-Type': 'application/x-www-form-urlencoded'\n	                                }\n	                            });\n	\n	                        case 2:\n	                            return _context12.abrupt(\"return\", _context12.sent);\n	\n	                        case 3:\n	                        case \"end\":\n	                            return _context12.stop();\n	                    }\n	                }\n	            }, _callee12, this);\n	        }));\n	\n	        function _tokenRequest(_x22, _x23) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _tokenRequest;\n	    }();\n	\n	    Platform.prototype._ensureAuthentication = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {\n	            return regeneratorRuntime.wrap(function _callee13$(_context13) {\n	                while (1) {\n	                    switch (_context13.prev = _context13.next) {\n	                        case 0:\n	                            if (!this._isAccessTokenValid()) {\n	                                _context13.next = 2;\n	                                break;\n	                            }\n	\n	                            return _context13.abrupt(\"return\", null);\n	\n	                        case 2:\n	                            _context13.next = 4;\n	                            return this.refresh();\n	\n	                        case 4:\n	                            return _context13.abrupt(\"return\", _context13.sent);\n	\n	                        case 5:\n	                        case \"end\":\n	                            return _context13.stop();\n	                    }\n	                }\n	            }, _callee13, this);\n	        }));\n	\n	        function _ensureAuthentication() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _ensureAuthentication;\n	    }();\n	\n	    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {\n	\n	        return this._auth.accessTokenValid() && !this._queue.isPaused();\n	    };\n	\n	    Platform.prototype._apiKey = function _apiKey() {\n	        var apiKey = this._appKey + ':' + this._appSecret;\n	        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');\n	    };\n	\n	    Platform.prototype._authHeader = function _authHeader() {\n	        var token = this._auth.accessToken();\n	        return this._auth.tokenType() + (token ? ' ' + token : '');\n	    };\n	\n	    return Platform;\n	}(_Observable3.default);\n	\n	Platform._urlPrefix = '/restapi';\n	Platform._apiVersion = 'v1.0';\n	Platform._refreshTokenTtl = 10 * 60 * 60;\n	Platform._refreshTokenTtlRemember = 7 * 24 * 60 * 60;\n	Platform._tokenEndpoint = '/restapi/oauth/token';\n	Platform._revokeEndpoint = '/restapi/oauth/revoke';\n	Platform._authorizeEndpoint = '/restapi/oauth/authorize';\n	Platform._refreshDelayMs = 100;\n	Platform._cacheId = 'platform';\n	Platform._clearCacheOnRefreshError = false;\n	exports.default = Platform;\n	\n	/***/ },\n	/* 21 */\n	/***/ function(module, exports) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Auth = function () {\n	    function Auth(cache, cacheId) {\n	        _classCallCheck(this, Auth);\n	\n	        /** @type {Cache} */\n	        this._cache = cache;\n	        this._cacheId = cacheId;\n	    } // 1 minute\n	\n	\n	    Auth.prototype.accessToken = function accessToken() {\n	        return this.data().access_token;\n	    };\n	\n	    Auth.prototype.refreshToken = function refreshToken() {\n	        return this.data().refresh_token;\n	    };\n	\n	    Auth.prototype.tokenType = function tokenType() {\n	        return this.data().token_type;\n	    };\n	\n	    /**\n	     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}\n	     */\n	\n	\n	    Auth.prototype.data = function data() {\n	\n	        return this._cache.getItem(this._cacheId) || {\n	            token_type: '',\n	            access_token: '',\n	            expires_in: 0,\n	            refresh_token: '',\n	            refresh_token_expires_in: 0\n	        };\n	    };\n	\n	    /**\n	     * @param {object} newData\n	     * @return {Auth}\n	     */\n	\n	\n	    Auth.prototype.setData = function setData(newData) {\n	\n	        newData = newData || {};\n	\n	        var data = this.data();\n	\n	        Object.keys(newData).forEach(function (key) {\n	            data[key] = newData[key];\n	        });\n	\n	        data.expire_time = Date.now() + data.expires_in * 1000;\n	        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;\n	\n	        this._cache.setItem(this._cacheId, data);\n	\n	        return this;\n	    };\n	\n	    /**\n	     * Check if there is a valid (not expired) access token\n	     * @return {boolean}\n	     */\n	\n	\n	    Auth.prototype.accessTokenValid = function accessTokenValid() {\n	\n	        var authData = this.data();\n	        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();\n	    };\n	\n	    /**\n	     * Check if there is a valid (not expired) access token\n	     * @return {boolean}\n	     */\n	\n	\n	    Auth.prototype.refreshTokenValid = function refreshTokenValid() {\n	\n	        return this.data().refresh_token_expire_time > Date.now();\n	    };\n	\n	    /**\n	     * @return {Auth}\n	     */\n	\n	\n	    Auth.prototype.cancelAccessToken = function cancelAccessToken() {\n	\n	        return this.setData({\n	            access_token: '',\n	            expires_in: 0\n	        });\n	    };\n	\n	    /**\n	     * This method sets a special authentication mode used in Service Web\n	     * @return {Auth}\n	     */\n	\n	\n	    Auth.prototype.forceAuthentication = function forceAuthentication() {\n	\n	        this.setData({\n	            token_type: Auth.forcedTokenType,\n	            access_token: '',\n	            expires_in: 0,\n	            refresh_token: '',\n	            refresh_token_expires_in: 0\n	        });\n	\n	        return this;\n	    };\n	\n	    return Auth;\n	}();\n	\n	//export interface IAuthData {\n	//    remember?:boolean;\n	//    token_type?:string;\n	//    access_token?:string;\n	//    expires_in?:number; // actually it's string\n	//    expire_time?:number;\n	//    refresh_token?:string;\n	//    refresh_token_expires_in?:number; // actually it's string\n	//    refresh_token_expire_time?:number;\n	//    scope?:string;\n	//}\n	\n	\n	Auth.refreshHandicapMs = 60 * 1000;\n	Auth.forcedTokenType = 'forced';\n	exports.default = Auth;\n	\n	/***/ },\n	/* 22 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _PubnubMock = __webpack_require__(23);\n	\n	var _PubnubMock2 = _interopRequireDefault(_PubnubMock);\n	\n	var _Externals = __webpack_require__(4);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var PubnubMockFactory = function () {\n	    function PubnubMockFactory() {\n	        _classCallCheck(this, PubnubMockFactory);\n	\n	        this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n	    }\n	\n	    PubnubMockFactory.prototype.init = function init(options) {\n	        return new _PubnubMock2.default(options);\n	    };\n	\n	    return PubnubMockFactory;\n	}();\n	\n	exports.default = PubnubMockFactory;\n	\n	/***/ },\n	/* 23 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _Externals = __webpack_require__(4);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var PubnubMock = function (_Observable) {\n	    _inherits(PubnubMock, _Observable);\n	\n	    function PubnubMock(options) {\n	        _classCallCheck(this, PubnubMock);\n	\n	        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n	\n	        _this.options = options;\n	        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n	        return _this;\n	    }\n	\n	    PubnubMock.prototype.ready = function ready() {};\n	\n	    PubnubMock.prototype.subscribe = function subscribe(options) {\n	        this.on('message-' + options.channel, options.message);\n	    };\n	\n	    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {\n	        this.off('message-' + options.channel);\n	    };\n	\n	    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {\n	        this.emit('message-' + channel, msg, 'env', channel);\n	    };\n	\n	    return PubnubMock;\n	}(_Observable3.default);\n	\n	exports.default = PubnubMock;\n	\n	/***/ },\n	/* 24 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _Client = __webpack_require__(15);\n	\n	var _Client2 = _interopRequireDefault(_Client);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Subscription = function (_Observable) {\n	    _inherits(Subscription, _Observable);\n	\n	    function Subscription(pubnubFactory, platform) {\n	        _classCallCheck(this, Subscription);\n	\n	        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n	\n	        _this.events = {\n	            notification: 'notification',\n	            removeSuccess: 'removeSuccess',\n	            removeError: 'removeError',\n	            renewSuccess: 'renewSuccess',\n	            renewError: 'renewError',\n	            subscribeSuccess: 'subscribeSuccess',\n	            subscribeError: 'subscribeError'\n	        };\n	\n	\n	        _this._pubnubFactory = pubnubFactory;\n	        _this._platform = platform;\n	        _this._pubnub = null;\n	        _this._timeout = null;\n	        _this._subscription = {};\n	\n	        return _this;\n	    }\n	\n	    Subscription.prototype.subscribed = function subscribed() {\n	\n	        return !!(this._subscription.id && this._subscription.deliveryMode && this._subscription.deliveryMode.subscriberKey && this._subscription.deliveryMode.address);\n	    };\n	\n	    /**\n	     * @return {boolean}\n	     */\n	\n	\n	    Subscription.prototype.alive = function alive() {\n	        return this.subscribed() && Date.now() < this.expirationTime();\n	    };\n	\n	    Subscription.prototype.expirationTime = function expirationTime() {\n	        return new Date(this._subscription.expirationTime || 0).getTime() - Subscription._renewHandicapMs;\n	    };\n	\n	    Subscription.prototype.setSubscription = function setSubscription(subscription) {\n	\n	        subscription = subscription || {};\n	\n	        this._clearTimeout();\n	\n	        this._subscription = subscription;\n	\n	        if (!this._pubnub) this._subscribeAtPubnub();\n	\n	        this._setTimeout();\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype.subscription = function subscription() {\n	        return this._subscription;\n	    };\n	\n	    /**\n	     * Creates or updates subscription if there is an active one\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.register = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            if (!this.alive()) {\n	                                _context.next = 6;\n	                                break;\n	                            }\n	\n	                            _context.next = 3;\n	                            return this.renew();\n	\n	                        case 3:\n	                            return _context.abrupt('return', _context.sent);\n	\n	                        case 6:\n	                            _context.next = 8;\n	                            return this.subscribe();\n	\n	                        case 8:\n	                            return _context.abrupt('return', _context.sent);\n	\n	                        case 9:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function register() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return register;\n	    }();\n	\n	    Subscription.prototype.eventFilters = function eventFilters() {\n	        return this._subscription.eventFilters || [];\n	    };\n	\n	    /**\n	     * @param {string[]} events\n	     * @return {Subscription}\n	     */\n	\n	\n	    Subscription.prototype.addEventFilters = function addEventFilters(events) {\n	        this.setEventFilters(this.eventFilters().concat(events));\n	        return this;\n	    };\n	\n	    /**\n	     * @param {string[]} events\n	     * @return {Subscription}\n	     */\n	\n	\n	    Subscription.prototype.setEventFilters = function setEventFilters(events) {\n	        this._subscription.eventFilters = events;\n	        return this;\n	    };\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.subscribe = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n	            var response, json;\n	            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n	                while (1) {\n	                    switch (_context2.prev = _context2.next) {\n	                        case 0:\n	                            _context2.prev = 0;\n	\n	\n	                            this._clearTimeout();\n	\n	                            if (this.eventFilters().length) {\n	                                _context2.next = 4;\n	                                break;\n	                            }\n	\n	                            throw new Error('Events are undefined');\n	\n	                        case 4:\n	                            _context2.next = 6;\n	                            return this._platform.post('/restapi/v1.0/subscription', {\n	                                eventFilters: this._getFullEventFilters(),\n	                                deliveryMode: {\n	                                    transportType: 'PubNub'\n	                                }\n	                            });\n	\n	                        case 6:\n	                            response = _context2.sent;\n	                            json = response.json();\n	\n	\n	                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);\n	\n	                            return _context2.abrupt('return', response);\n	\n	                        case 12:\n	                            _context2.prev = 12;\n	                            _context2.t0 = _context2['catch'](0);\n	\n	\n	                            _context2.t0 = this._platform.client().makeError(_context2.t0);\n	\n	                            this.reset().emit(this.events.subscribeError, _context2.t0);\n	\n	                            throw _context2.t0;\n	\n	                        case 17:\n	                        case 'end':\n	                            return _context2.stop();\n	                    }\n	                }\n	            }, _callee2, this, [[0, 12]]);\n	        }));\n	\n	        function subscribe() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return subscribe;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.renew = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n	            var response, json;\n	            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n	                while (1) {\n	                    switch (_context3.prev = _context3.next) {\n	                        case 0:\n	                            _context3.prev = 0;\n	\n	\n	                            this._clearTimeout();\n	\n	                            if (this.subscribed()) {\n	                                _context3.next = 4;\n	                                break;\n	                            }\n	\n	                            throw new Error('No subscription');\n	\n	                        case 4:\n	                            if (this.eventFilters().length) {\n	                                _context3.next = 6;\n	                                break;\n	                            }\n	\n	                            throw new Error('Events are undefined');\n	\n	                        case 6:\n	                            _context3.next = 8;\n	                            return this._platform.put('/restapi/v1.0/subscription/' + this._subscription.id, {\n	                                eventFilters: this._getFullEventFilters()\n	                            });\n	\n	                        case 8:\n	                            response = _context3.sent;\n	                            json = response.json();\n	\n	\n	                            this.setSubscription(json).emit(this.events.renewSuccess, response);\n	\n	                            return _context3.abrupt('return', response);\n	\n	                        case 14:\n	                            _context3.prev = 14;\n	                            _context3.t0 = _context3['catch'](0);\n	\n	\n	                            _context3.t0 = this._platform.client().makeError(_context3.t0);\n	\n	                            this.reset().emit(this.events.renewError, _context3.t0);\n	\n	                            throw _context3.t0;\n	\n	                        case 19:\n	                        case 'end':\n	                            return _context3.stop();\n	                    }\n	                }\n	            }, _callee3, this, [[0, 14]]);\n	        }));\n	\n	        function renew() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return renew;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.remove = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n	            var response;\n	            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n	                while (1) {\n	                    switch (_context4.prev = _context4.next) {\n	                        case 0:\n	                            _context4.prev = 0;\n	\n	                            if (this.subscribed()) {\n	                                _context4.next = 3;\n	                                break;\n	                            }\n	\n	                            throw new Error('No subscription');\n	\n	                        case 3:\n	                            _context4.next = 5;\n	                            return this._platform.delete('/restapi/v1.0/subscription/' + this._subscription.id);\n	\n	                        case 5:\n	                            response = _context4.sent;\n	\n	\n	                            this.reset().emit(this.events.removeSuccess, response);\n	\n	                            return _context4.abrupt('return', response);\n	\n	                        case 10:\n	                            _context4.prev = 10;\n	                            _context4.t0 = _context4['catch'](0);\n	\n	\n	                            _context4.t0 = this._platform.client().makeError(_context4.t0);\n	\n	                            this.emit(this.events.removeError, _context4.t0);\n	\n	                            throw _context4.t0;\n	\n	                        case 15:\n	                        case 'end':\n	                            return _context4.stop();\n	                    }\n	                }\n	            }, _callee4, this, [[0, 10]]);\n	        }));\n	\n	        function remove() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return remove;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.resubscribe = function resubscribe() {\n	\n	        return this.reset().setEventFilters(this.eventFilters()).subscribe();\n	    };\n	\n	    /**\n	     * Remove subscription and disconnect from PUBNUB\n	     * This method resets subscription at client side but backend is not notified\n	     */\n	\n	\n	    Subscription.prototype.reset = function reset() {\n	        this._clearTimeout();\n	        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this._subscription.deliveryMode.address });\n	        this._subscription = {};\n	        return this;\n	    };\n	\n	    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {\n	        var _this2 = this;\n	\n	        return this.eventFilters().map(function (event) {\n	            return _this2._platform.createUrl(event);\n	        });\n	    };\n	\n	    Subscription.prototype._setTimeout = function _setTimeout() {\n	        var _this3 = this;\n	\n	        this._clearTimeout();\n	\n	        if (!this.alive()) throw new Error('Subscription is not alive');\n	\n	        (0, _Utils.poll)(function (next) {\n	\n	            if (_this3.alive()) return next();\n	\n	            _this3.renew();\n	        }, Subscription._pollInterval, this._timeout);\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype._clearTimeout = function _clearTimeout() {\n	\n	        (0, _Utils.stopPolling)(this._timeout);\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype._decrypt = function _decrypt(message) {\n	\n	        if (!this.subscribed()) throw new Error('No subscription');\n	\n	        if (this._subscription.deliveryMode.encryptionKey) {\n	\n	            var PUBNUB = this._pubnubFactory;\n	\n	            message = PUBNUB.crypto_obj.decrypt(message, this._subscription.deliveryMode.encryptionKey, {\n	                encryptKey: false,\n	                keyEncoding: 'base64',\n	                keyLength: 128,\n	                mode: 'ecb'\n	            });\n	        }\n	\n	        return message;\n	    };\n	\n	    Subscription.prototype._notify = function _notify(message) {\n	\n	        this.emit(this.events.notification, this._decrypt(message));\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {\n	\n	        if (!this.alive()) throw new Error('Subscription is not alive');\n	\n	        var PUBNUB = this._pubnubFactory;\n	\n	        this._pubnub = PUBNUB.init({\n	            ssl: true,\n	            subscribe_key: this._subscription.deliveryMode.subscriberKey\n	        });\n	\n	        this._pubnub.ready();\n	\n	        this._pubnub.subscribe({\n	            channel: this._subscription.deliveryMode.address,\n	            message: this._notify.bind(this),\n	            connect: function connect() {}\n	        });\n	\n	        return this;\n	    };\n	\n	    return Subscription;\n	}(_Observable3.default);\n	\n	//export interface ISubscription {\n	//    id?:string;\n	//    uri?: string;\n	//    eventFilters?:string[];\n	//    expirationTime?:string; // 2014-03-12T19:54:35.613Z\n	//    expiresIn?:number;\n	//    deliveryMode?: {\n	//        transportType?:string;\n	//        encryption?:boolean;\n	//        address?:string;\n	//        subscriberKey?:string;\n	//        encryptionKey?:string;\n	//        secretKey?:string;\n	//    };\n	//    creationTime?:string; // 2014-03-12T19:54:35.613Z\n	//    status?:string; // Active\n	//}\n	\n	\n	Subscription._renewHandicapMs = 2 * 60 * 1000;\n	Subscription._pollInterval = 10 * 1000;\n	exports.default = Subscription;\n	\n	/***/ },\n	/* 25 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n	\n	var _Subscription2 = __webpack_require__(24);\n	\n	var _Subscription3 = _interopRequireDefault(_Subscription2);\n	\n	var _Queue = __webpack_require__(14);\n	\n	var _Queue2 = _interopRequireDefault(_Queue);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var CachedSubscription = function (_Subscription) {\n	    _inherits(CachedSubscription, _Subscription);\n	\n	    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {\n	        _classCallCheck(this, CachedSubscription);\n	\n	        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));\n	\n	        _this._cache = cache;\n	        _this._cacheKey = cacheKey;\n	        _this._renewQueue = new _Queue2.default(_this._cache, cacheKey + '-renew');\n	        _this._resubscribeQueue = new _Queue2.default(_this._cache, cacheKey + '-resubscribe');\n	\n	        _this.events = _extends({}, _this.events, {\n	            queuedRenewSuccess: 'queuedRenewSuccess',\n	            queuedRenewError: 'queuedRenewError',\n	            queuedResubscribeSuccess: 'queuedResubscribeSuccess',\n	            queuedResubscribeError: 'queuedResubscribeError'\n	        });\n	\n	        _this.on(_this.events.renewError, function () {\n	            _this.resubscribe();\n	        });\n	\n	        _this.on([_this.events.subscribeSuccess, _this.events.renewSuccess], function () {\n	            _this._cache.setItem(_this._cacheKey, _this.subscription());\n	        });\n	\n	        _this.on(_this.events.removeSuccess, function () {\n	            _this._cache.removeItem(_this._cacheKey);\n	        });\n	\n	        return _this;\n	    }\n	\n	    /**\n	     * TODO Combine with Platform.refresh and move elsewhere\n	     * @param actionCb\n	     * @param queue\n	     * @param successEvent\n	     * @param errorEvent\n	     * @param errorMessage\n	     * @return {*}\n	     * @private\n	     */\n	\n	\n	    CachedSubscription.prototype._queue = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(actionCb, queue, successEvent, errorEvent, errorMessage) {\n	            var res;\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            _context.prev = 0;\n	\n	                            if (!queue.isPaused()) {\n	                                _context.next = 8;\n	                                break;\n	                            }\n	\n	                            _context.next = 4;\n	                            return queue.poll();\n	\n	                        case 4:\n	                            if (this.alive()) {\n	                                _context.next = 6;\n	                                break;\n	                            }\n	\n	                            throw new Error(errorMessage);\n	\n	                        case 6:\n	\n	                            this.emit(successEvent, null);\n	\n	                            return _context.abrupt('return', null);\n	\n	                        case 8:\n	\n	                            queue.pause();\n	\n	                            _context.next = 11;\n	                            return actionCb.call(this);\n	\n	                        case 11:\n	                            res = _context.sent;\n	\n	\n	                            queue.resume();\n	\n	                            this.emit(successEvent, res);\n	\n	                            return _context.abrupt('return', res);\n	\n	                        case 17:\n	                            _context.prev = 17;\n	                            _context.t0 = _context['catch'](0);\n	\n	\n	                            this.emit(errorEvent, _context.t0);\n	\n	                            throw _context.t0;\n	\n	                        case 21:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this, [[0, 17]]);\n	        }));\n	\n	        function _queue(_x, _x2, _x3, _x4, _x5) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _queue;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    CachedSubscription.prototype.renew = function renew() {\n	\n	        return this._queue(_Subscription.prototype.renew, this._renewQueue, this.events.queuedRenewSuccess, this.events.queuedRenewError, 'Subscription is not alive after renew timeout');\n	    };\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    CachedSubscription.prototype.resubscribe = function resubscribe() {\n	\n	        return this._queue(_Subscription.prototype.resubscribe, this._resubscribeQueue, this.events.queuedResubscribeSuccess, this.events.queuedResubscribeError, 'Subscription is not alive after resubscribe timeout');\n	    };\n	\n	    /**\n	     * @param {string[]} events\n	     * @return {CachedSubscription}\n	     */\n	\n	\n	    CachedSubscription.prototype.restore = function restore(events) {\n	\n	        var cachedSubscriptionData = this._cache.getItem(this._cacheKey);\n	\n	        if (cachedSubscriptionData) {\n	            try {\n	                this.setSubscription(cachedSubscriptionData);\n	            } catch (e) {}\n	        } else {\n	            this.setEventFilters(events);\n	        }\n	\n	        return this;\n	    };\n	\n	    return CachedSubscription;\n	}(_Subscription3.default);\n	\n	exports.default = CachedSubscription;\n	\n	/***/ }\n	/******/ ])\n	});\n	;\n	//# sourceMappingURL=ringcentral-bundle.js.map\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(7).Buffer))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n	// shim for using process in browser\n	\n	var process = module.exports = {};\n	var queue = [];\n	var draining = false;\n	var currentQueue;\n	var queueIndex = -1;\n	\n	function cleanUpNextTick() {\n	    draining = false;\n	    if (currentQueue.length) {\n	        queue = currentQueue.concat(queue);\n	    } else {\n	        queueIndex = -1;\n	    }\n	    if (queue.length) {\n	        drainQueue();\n	    }\n	}\n	\n	function drainQueue() {\n	    if (draining) {\n	        return;\n	    }\n	    var timeout = setTimeout(cleanUpNextTick);\n	    draining = true;\n	\n	    var len = queue.length;\n	    while(len) {\n	        currentQueue = queue;\n	        queue = [];\n	        while (++queueIndex < len) {\n	            if (currentQueue) {\n	                currentQueue[queueIndex].run();\n	            }\n	        }\n	        queueIndex = -1;\n	        len = queue.length;\n	    }\n	    currentQueue = null;\n	    draining = false;\n	    clearTimeout(timeout);\n	}\n	\n	process.nextTick = function (fun) {\n	    var args = new Array(arguments.length - 1);\n	    if (arguments.length > 1) {\n	        for (var i = 1; i < arguments.length; i++) {\n	            args[i - 1] = arguments[i];\n	        }\n	    }\n	    queue.push(new Item(fun, args));\n	    if (queue.length === 1 && !draining) {\n	        setTimeout(drainQueue, 0);\n	    }\n	};\n	\n	// v8 likes predictible objects\n	function Item(fun, array) {\n	    this.fun = fun;\n	    this.array = array;\n	}\n	Item.prototype.run = function () {\n	    this.fun.apply(null, this.array);\n	};\n	process.title = 'browser';\n	process.browser = true;\n	process.env = {};\n	process.argv = [];\n	process.version = ''; // empty string to avoid regexp issues\n	process.versions = {};\n	\n	function noop() {}\n	\n	process.on = noop;\n	process.addListener = noop;\n	process.once = noop;\n	process.off = noop;\n	process.removeListener = noop;\n	process.removeAllListeners = noop;\n	process.emit = noop;\n	\n	process.binding = function (name) {\n	    throw new Error('process.binding is not supported');\n	};\n	\n	process.cwd = function () { return '/' };\n	process.chdir = function (dir) {\n	    throw new Error('process.chdir is not supported');\n	};\n	process.umask = function() { return 0; };\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n	 * The buffer module from node.js, for the browser.\n	 *\n	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n	 * @license  MIT\n	 */\n	/* eslint-disable no-proto */\n	\n	'use strict'\n	\n	var base64 = __webpack_require__(8)\n	var ieee754 = __webpack_require__(9)\n	var isArray = __webpack_require__(10)\n	\n	exports.Buffer = Buffer\n	exports.SlowBuffer = SlowBuffer\n	exports.INSPECT_MAX_BYTES = 50\n	Buffer.poolSize = 8192 // not used by this implementation\n	\n	var rootParent = {}\n	\n	/**\n	 * If `Buffer.TYPED_ARRAY_SUPPORT`:\n	 *   === true    Use Uint8Array implementation (fastest)\n	 *   === false   Use Object implementation (most compatible, even IE6)\n	 *\n	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n	 * Opera 11.6+, iOS 4.2+.\n	 *\n	 * Due to various browser bugs, sometimes the Object implementation will be used even\n	 * when the browser supports typed arrays.\n	 *\n	 * Note:\n	 *\n	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n	 *\n	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n	 *     on objects.\n	 *\n	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n	 *\n	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n	 *     incorrect length in some situations.\n	\n	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n	 * get the Object implementation, which is slower but behaves correctly.\n	 */\n	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n	  ? global.TYPED_ARRAY_SUPPORT\n	  : typedArraySupport()\n	\n	function typedArraySupport () {\n	  function Bar () {}\n	  try {\n	    var arr = new Uint8Array(1)\n	    arr.foo = function () { return 42 }\n	    arr.constructor = Bar\n	    return arr.foo() === 42 && // typed array instances can be augmented\n	        arr.constructor === Bar && // constructor can be set\n	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n	  } catch (e) {\n	    return false\n	  }\n	}\n	\n	function kMaxLength () {\n	  return Buffer.TYPED_ARRAY_SUPPORT\n	    ? 0x7fffffff\n	    : 0x3fffffff\n	}\n	\n	/**\n	 * Class: Buffer\n	 * =============\n	 *\n	 * The Buffer constructor returns instances of `Uint8Array` that are augmented\n	 * with function properties for all the node `Buffer` API functions. We use\n	 * `Uint8Array` so that square bracket notation works as expected -- it returns\n	 * a single octet.\n	 *\n	 * By augmenting the instances, we can avoid modifying the `Uint8Array`\n	 * prototype.\n	 */\n	function Buffer (arg) {\n	  if (!(this instanceof Buffer)) {\n	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n	    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n	    return new Buffer(arg)\n	  }\n	\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n	    this.length = 0\n	    this.parent = undefined\n	  }\n	\n	  // Common case.\n	  if (typeof arg === 'number') {\n	    return fromNumber(this, arg)\n	  }\n	\n	  // Slightly less common case.\n	  if (typeof arg === 'string') {\n	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n	  }\n	\n	  // Unusual.\n	  return fromObject(this, arg)\n	}\n	\n	function fromNumber (that, length) {\n	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n	    for (var i = 0; i < length; i++) {\n	      that[i] = 0\n	    }\n	  }\n	  return that\n	}\n	\n	function fromString (that, string, encoding) {\n	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n	\n	  // Assumption: byteLength() return value is always < kMaxLength.\n	  var length = byteLength(string, encoding) | 0\n	  that = allocate(that, length)\n	\n	  that.write(string, encoding)\n	  return that\n	}\n	\n	function fromObject (that, object) {\n	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n	\n	  if (isArray(object)) return fromArray(that, object)\n	\n	  if (object == null) {\n	    throw new TypeError('must start with number, buffer, array or string')\n	  }\n	\n	  if (typeof ArrayBuffer !== 'undefined') {\n	    if (object.buffer instanceof ArrayBuffer) {\n	      return fromTypedArray(that, object)\n	    }\n	    if (object instanceof ArrayBuffer) {\n	      return fromArrayBuffer(that, object)\n	    }\n	  }\n	\n	  if (object.length) return fromArrayLike(that, object)\n	\n	  return fromJsonObject(that, object)\n	}\n	\n	function fromBuffer (that, buffer) {\n	  var length = checked(buffer.length) | 0\n	  that = allocate(that, length)\n	  buffer.copy(that, 0, 0, length)\n	  return that\n	}\n	\n	function fromArray (that, array) {\n	  var length = checked(array.length) | 0\n	  that = allocate(that, length)\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	// Duplicate of fromArray() to keep fromArray() monomorphic.\n	function fromTypedArray (that, array) {\n	  var length = checked(array.length) | 0\n	  that = allocate(that, length)\n	  // Truncating the elements is probably not what people expect from typed\n	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n	  // of the old Buffer constructor.\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	function fromArrayBuffer (that, array) {\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    // Return an augmented `Uint8Array` instance, for best performance\n	    array.byteLength\n	    that = Buffer._augment(new Uint8Array(array))\n	  } else {\n	    // Fallback: Return an object instance of the Buffer class\n	    that = fromTypedArray(that, new Uint8Array(array))\n	  }\n	  return that\n	}\n	\n	function fromArrayLike (that, array) {\n	  var length = checked(array.length) | 0\n	  that = allocate(that, length)\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n	// Returns a zero-length buffer for inputs that don't conform to the spec.\n	function fromJsonObject (that, object) {\n	  var array\n	  var length = 0\n	\n	  if (object.type === 'Buffer' && isArray(object.data)) {\n	    array = object.data\n	    length = checked(array.length) | 0\n	  }\n	  that = allocate(that, length)\n	\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	if (Buffer.TYPED_ARRAY_SUPPORT) {\n	  Buffer.prototype.__proto__ = Uint8Array.prototype\n	  Buffer.__proto__ = Uint8Array\n	} else {\n	  // pre-set for values that may exist in the future\n	  Buffer.prototype.length = undefined\n	  Buffer.prototype.parent = undefined\n	}\n	\n	function allocate (that, length) {\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    // Return an augmented `Uint8Array` instance, for best performance\n	    that = Buffer._augment(new Uint8Array(length))\n	    that.__proto__ = Buffer.prototype\n	  } else {\n	    // Fallback: Return an object instance of the Buffer class\n	    that.length = length\n	    that._isBuffer = true\n	  }\n	\n	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n	  if (fromPool) that.parent = rootParent\n	\n	  return that\n	}\n	\n	function checked (length) {\n	  // Note: cannot use `length < kMaxLength` here because that fails when\n	  // length is NaN (which is otherwise coerced to zero.)\n	  if (length >= kMaxLength()) {\n	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n	  }\n	  return length | 0\n	}\n	\n	function SlowBuffer (subject, encoding) {\n	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n	\n	  var buf = new Buffer(subject, encoding)\n	  delete buf.parent\n	  return buf\n	}\n	\n	Buffer.isBuffer = function isBuffer (b) {\n	  return !!(b != null && b._isBuffer)\n	}\n	\n	Buffer.compare = function compare (a, b) {\n	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n	    throw new TypeError('Arguments must be Buffers')\n	  }\n	\n	  if (a === b) return 0\n	\n	  var x = a.length\n	  var y = b.length\n	\n	  var i = 0\n	  var len = Math.min(x, y)\n	  while (i < len) {\n	    if (a[i] !== b[i]) break\n	\n	    ++i\n	  }\n	\n	  if (i !== len) {\n	    x = a[i]\n	    y = b[i]\n	  }\n	\n	  if (x < y) return -1\n	  if (y < x) return 1\n	  return 0\n	}\n	\n	Buffer.isEncoding = function isEncoding (encoding) {\n	  switch (String(encoding).toLowerCase()) {\n	    case 'hex':\n	    case 'utf8':\n	    case 'utf-8':\n	    case 'ascii':\n	    case 'binary':\n	    case 'base64':\n	    case 'raw':\n	    case 'ucs2':\n	    case 'ucs-2':\n	    case 'utf16le':\n	    case 'utf-16le':\n	      return true\n	    default:\n	      return false\n	  }\n	}\n	\n	Buffer.concat = function concat (list, length) {\n	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n	\n	  if (list.length === 0) {\n	    return new Buffer(0)\n	  }\n	\n	  var i\n	  if (length === undefined) {\n	    length = 0\n	    for (i = 0; i < list.length; i++) {\n	      length += list[i].length\n	    }\n	  }\n	\n	  var buf = new Buffer(length)\n	  var pos = 0\n	  for (i = 0; i < list.length; i++) {\n	    var item = list[i]\n	    item.copy(buf, pos)\n	    pos += item.length\n	  }\n	  return buf\n	}\n	\n	function byteLength (string, encoding) {\n	  if (typeof string !== 'string') string = '' + string\n	\n	  var len = string.length\n	  if (len === 0) return 0\n	\n	  // Use a for loop to avoid recursion\n	  var loweredCase = false\n	  for (;;) {\n	    switch (encoding) {\n	      case 'ascii':\n	      case 'binary':\n	      // Deprecated\n	      case 'raw':\n	      case 'raws':\n	        return len\n	      case 'utf8':\n	      case 'utf-8':\n	        return utf8ToBytes(string).length\n	      case 'ucs2':\n	      case 'ucs-2':\n	      case 'utf16le':\n	      case 'utf-16le':\n	        return len * 2\n	      case 'hex':\n	        return len >>> 1\n	      case 'base64':\n	        return base64ToBytes(string).length\n	      default:\n	        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n	        encoding = ('' + encoding).toLowerCase()\n	        loweredCase = true\n	    }\n	  }\n	}\n	Buffer.byteLength = byteLength\n	\n	function slowToString (encoding, start, end) {\n	  var loweredCase = false\n	\n	  start = start | 0\n	  end = end === undefined || end === Infinity ? this.length : end | 0\n	\n	  if (!encoding) encoding = 'utf8'\n	  if (start < 0) start = 0\n	  if (end > this.length) end = this.length\n	  if (end <= start) return ''\n	\n	  while (true) {\n	    switch (encoding) {\n	      case 'hex':\n	        return hexSlice(this, start, end)\n	\n	      case 'utf8':\n	      case 'utf-8':\n	        return utf8Slice(this, start, end)\n	\n	      case 'ascii':\n	        return asciiSlice(this, start, end)\n	\n	      case 'binary':\n	        return binarySlice(this, start, end)\n	\n	      case 'base64':\n	        return base64Slice(this, start, end)\n	\n	      case 'ucs2':\n	      case 'ucs-2':\n	      case 'utf16le':\n	      case 'utf-16le':\n	        return utf16leSlice(this, start, end)\n	\n	      default:\n	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n	        encoding = (encoding + '').toLowerCase()\n	        loweredCase = true\n	    }\n	  }\n	}\n	\n	Buffer.prototype.toString = function toString () {\n	  var length = this.length | 0\n	  if (length === 0) return ''\n	  if (arguments.length === 0) return utf8Slice(this, 0, length)\n	  return slowToString.apply(this, arguments)\n	}\n	\n	Buffer.prototype.equals = function equals (b) {\n	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n	  if (this === b) return true\n	  return Buffer.compare(this, b) === 0\n	}\n	\n	Buffer.prototype.inspect = function inspect () {\n	  var str = ''\n	  var max = exports.INSPECT_MAX_BYTES\n	  if (this.length > 0) {\n	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n	    if (this.length > max) str += ' ... '\n	  }\n	  return '<Buffer ' + str + '>'\n	}\n	\n	Buffer.prototype.compare = function compare (b) {\n	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n	  if (this === b) return 0\n	  return Buffer.compare(this, b)\n	}\n	\n	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {\n	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n	  byteOffset >>= 0\n	\n	  if (this.length === 0) return -1\n	  if (byteOffset >= this.length) return -1\n	\n	  // Negative offsets start from the end of the buffer\n	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n	\n	  if (typeof val === 'string') {\n	    if (val.length === 0) return -1 // special case: looking for empty string always fails\n	    return String.prototype.indexOf.call(this, val, byteOffset)\n	  }\n	  if (Buffer.isBuffer(val)) {\n	    return arrayIndexOf(this, val, byteOffset)\n	  }\n	  if (typeof val === 'number') {\n	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n	    }\n	    return arrayIndexOf(this, [ val ], byteOffset)\n	  }\n	\n	  function arrayIndexOf (arr, val, byteOffset) {\n	    var foundIndex = -1\n	    for (var i = 0; byteOffset + i < arr.length; i++) {\n	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n	        if (foundIndex === -1) foundIndex = i\n	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n	      } else {\n	        foundIndex = -1\n	      }\n	    }\n	    return -1\n	  }\n	\n	  throw new TypeError('val must be string, number or Buffer')\n	}\n	\n	// `get` is deprecated\n	Buffer.prototype.get = function get (offset) {\n	  console.log('.get() is deprecated. Access using array indexes instead.')\n	  return this.readUInt8(offset)\n	}\n	\n	// `set` is deprecated\n	Buffer.prototype.set = function set (v, offset) {\n	  console.log('.set() is deprecated. Access using array indexes instead.')\n	  return this.writeUInt8(v, offset)\n	}\n	\n	function hexWrite (buf, string, offset, length) {\n	  offset = Number(offset) || 0\n	  var remaining = buf.length - offset\n	  if (!length) {\n	    length = remaining\n	  } else {\n	    length = Number(length)\n	    if (length > remaining) {\n	      length = remaining\n	    }\n	  }\n	\n	  // must be an even number of digits\n	  var strLen = string.length\n	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n	\n	  if (length > strLen / 2) {\n	    length = strLen / 2\n	  }\n	  for (var i = 0; i < length; i++) {\n	    var parsed = parseInt(string.substr(i * 2, 2), 16)\n	    if (isNaN(parsed)) throw new Error('Invalid hex string')\n	    buf[offset + i] = parsed\n	  }\n	  return i\n	}\n	\n	function utf8Write (buf, string, offset, length) {\n	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n	}\n	\n	function asciiWrite (buf, string, offset, length) {\n	  return blitBuffer(asciiToBytes(string), buf, offset, length)\n	}\n	\n	function binaryWrite (buf, string, offset, length) {\n	  return asciiWrite(buf, string, offset, length)\n	}\n	\n	function base64Write (buf, string, offset, length) {\n	  return blitBuffer(base64ToBytes(string), buf, offset, length)\n	}\n	\n	function ucs2Write (buf, string, offset, length) {\n	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n	}\n	\n	Buffer.prototype.write = function write (string, offset, length, encoding) {\n	  // Buffer#write(string)\n	  if (offset === undefined) {\n	    encoding = 'utf8'\n	    length = this.length\n	    offset = 0\n	  // Buffer#write(string, encoding)\n	  } else if (length === undefined && typeof offset === 'string') {\n	    encoding = offset\n	    length = this.length\n	    offset = 0\n	  // Buffer#write(string, offset[, length][, encoding])\n	  } else if (isFinite(offset)) {\n	    offset = offset | 0\n	    if (isFinite(length)) {\n	      length = length | 0\n	      if (encoding === undefined) encoding = 'utf8'\n	    } else {\n	      encoding = length\n	      length = undefined\n	    }\n	  // legacy write(string, encoding, offset, length) - remove in v0.13\n	  } else {\n	    var swap = encoding\n	    encoding = offset\n	    offset = length | 0\n	    length = swap\n	  }\n	\n	  var remaining = this.length - offset\n	  if (length === undefined || length > remaining) length = remaining\n	\n	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n	    throw new RangeError('attempt to write outside buffer bounds')\n	  }\n	\n	  if (!encoding) encoding = 'utf8'\n	\n	  var loweredCase = false\n	  for (;;) {\n	    switch (encoding) {\n	      case 'hex':\n	        return hexWrite(this, string, offset, length)\n	\n	      case 'utf8':\n	      case 'utf-8':\n	        return utf8Write(this, string, offset, length)\n	\n	      case 'ascii':\n	        return asciiWrite(this, string, offset, length)\n	\n	      case 'binary':\n	        return binaryWrite(this, string, offset, length)\n	\n	      case 'base64':\n	        // Warning: maxLength not taken into account in base64Write\n	        return base64Write(this, string, offset, length)\n	\n	      case 'ucs2':\n	      case 'ucs-2':\n	      case 'utf16le':\n	      case 'utf-16le':\n	        return ucs2Write(this, string, offset, length)\n	\n	      default:\n	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n	        encoding = ('' + encoding).toLowerCase()\n	        loweredCase = true\n	    }\n	  }\n	}\n	\n	Buffer.prototype.toJSON = function toJSON () {\n	  return {\n	    type: 'Buffer',\n	    data: Array.prototype.slice.call(this._arr || this, 0)\n	  }\n	}\n	\n	function base64Slice (buf, start, end) {\n	  if (start === 0 && end === buf.length) {\n	    return base64.fromByteArray(buf)\n	  } else {\n	    return base64.fromByteArray(buf.slice(start, end))\n	  }\n	}\n	\n	function utf8Slice (buf, start, end) {\n	  end = Math.min(buf.length, end)\n	  var res = []\n	\n	  var i = start\n	  while (i < end) {\n	    var firstByte = buf[i]\n	    var codePoint = null\n	    var bytesPerSequence = (firstByte > 0xEF) ? 4\n	      : (firstByte > 0xDF) ? 3\n	      : (firstByte > 0xBF) ? 2\n	      : 1\n	\n	    if (i + bytesPerSequence <= end) {\n	      var secondByte, thirdByte, fourthByte, tempCodePoint\n	\n	      switch (bytesPerSequence) {\n	        case 1:\n	          if (firstByte < 0x80) {\n	            codePoint = firstByte\n	          }\n	          break\n	        case 2:\n	          secondByte = buf[i + 1]\n	          if ((secondByte & 0xC0) === 0x80) {\n	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n	            if (tempCodePoint > 0x7F) {\n	              codePoint = tempCodePoint\n	            }\n	          }\n	          break\n	        case 3:\n	          secondByte = buf[i + 1]\n	          thirdByte = buf[i + 2]\n	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n	              codePoint = tempCodePoint\n	            }\n	          }\n	          break\n	        case 4:\n	          secondByte = buf[i + 1]\n	          thirdByte = buf[i + 2]\n	          fourthByte = buf[i + 3]\n	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n	              codePoint = tempCodePoint\n	            }\n	          }\n	      }\n	    }\n	\n	    if (codePoint === null) {\n	      // we did not generate a valid codePoint so insert a\n	      // replacement char (U+FFFD) and advance only 1 byte\n	      codePoint = 0xFFFD\n	      bytesPerSequence = 1\n	    } else if (codePoint > 0xFFFF) {\n	      // encode to utf16 (surrogate pair dance)\n	      codePoint -= 0x10000\n	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n	      codePoint = 0xDC00 | codePoint & 0x3FF\n	    }\n	\n	    res.push(codePoint)\n	    i += bytesPerSequence\n	  }\n	\n	  return decodeCodePointsArray(res)\n	}\n	\n	// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n	// the lowest limit is Chrome, with 0x10000 args.\n	// We go 1 magnitude less, for safety\n	var MAX_ARGUMENTS_LENGTH = 0x1000\n	\n	function decodeCodePointsArray (codePoints) {\n	  var len = codePoints.length\n	  if (len <= MAX_ARGUMENTS_LENGTH) {\n	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n	  }\n	\n	  // Decode in chunks to avoid \"call stack size exceeded\".\n	  var res = ''\n	  var i = 0\n	  while (i < len) {\n	    res += String.fromCharCode.apply(\n	      String,\n	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n	    )\n	  }\n	  return res\n	}\n	\n	function asciiSlice (buf, start, end) {\n	  var ret = ''\n	  end = Math.min(buf.length, end)\n	\n	  for (var i = start; i < end; i++) {\n	    ret += String.fromCharCode(buf[i] & 0x7F)\n	  }\n	  return ret\n	}\n	\n	function binarySlice (buf, start, end) {\n	  var ret = ''\n	  end = Math.min(buf.length, end)\n	\n	  for (var i = start; i < end; i++) {\n	    ret += String.fromCharCode(buf[i])\n	  }\n	  return ret\n	}\n	\n	function hexSlice (buf, start, end) {\n	  var len = buf.length\n	\n	  if (!start || start < 0) start = 0\n	  if (!end || end < 0 || end > len) end = len\n	\n	  var out = ''\n	  for (var i = start; i < end; i++) {\n	    out += toHex(buf[i])\n	  }\n	  return out\n	}\n	\n	function utf16leSlice (buf, start, end) {\n	  var bytes = buf.slice(start, end)\n	  var res = ''\n	  for (var i = 0; i < bytes.length; i += 2) {\n	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n	  }\n	  return res\n	}\n	\n	Buffer.prototype.slice = function slice (start, end) {\n	  var len = this.length\n	  start = ~~start\n	  end = end === undefined ? len : ~~end\n	\n	  if (start < 0) {\n	    start += len\n	    if (start < 0) start = 0\n	  } else if (start > len) {\n	    start = len\n	  }\n	\n	  if (end < 0) {\n	    end += len\n	    if (end < 0) end = 0\n	  } else if (end > len) {\n	    end = len\n	  }\n	\n	  if (end < start) end = start\n	\n	  var newBuf\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    newBuf = Buffer._augment(this.subarray(start, end))\n	  } else {\n	    var sliceLen = end - start\n	    newBuf = new Buffer(sliceLen, undefined)\n	    for (var i = 0; i < sliceLen; i++) {\n	      newBuf[i] = this[i + start]\n	    }\n	  }\n	\n	  if (newBuf.length) newBuf.parent = this.parent || this\n	\n	  return newBuf\n	}\n	\n	/*\n	 * Need to make sure that buffer isn't trying to write out of bounds.\n	 */\n	function checkOffset (offset, ext, length) {\n	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n	}\n	\n	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkOffset(offset, byteLength, this.length)\n	\n	  var val = this[offset]\n	  var mul = 1\n	  var i = 0\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    val += this[offset + i] * mul\n	  }\n	\n	  return val\n	}\n	\n	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) {\n	    checkOffset(offset, byteLength, this.length)\n	  }\n	\n	  var val = this[offset + --byteLength]\n	  var mul = 1\n	  while (byteLength > 0 && (mul *= 0x100)) {\n	    val += this[offset + --byteLength] * mul\n	  }\n	\n	  return val\n	}\n	\n	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 1, this.length)\n	  return this[offset]\n	}\n	\n	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  return this[offset] | (this[offset + 1] << 8)\n	}\n	\n	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  return (this[offset] << 8) | this[offset + 1]\n	}\n	\n	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return ((this[offset]) |\n	      (this[offset + 1] << 8) |\n	      (this[offset + 2] << 16)) +\n	      (this[offset + 3] * 0x1000000)\n	}\n	\n	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return (this[offset] * 0x1000000) +\n	    ((this[offset + 1] << 16) |\n	    (this[offset + 2] << 8) |\n	    this[offset + 3])\n	}\n	\n	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkOffset(offset, byteLength, this.length)\n	\n	  var val = this[offset]\n	  var mul = 1\n	  var i = 0\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    val += this[offset + i] * mul\n	  }\n	  mul *= 0x80\n	\n	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n	\n	  return val\n	}\n	\n	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkOffset(offset, byteLength, this.length)\n	\n	  var i = byteLength\n	  var mul = 1\n	  var val = this[offset + --i]\n	  while (i > 0 && (mul *= 0x100)) {\n	    val += this[offset + --i] * mul\n	  }\n	  mul *= 0x80\n	\n	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n	\n	  return val\n	}\n	\n	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 1, this.length)\n	  if (!(this[offset] & 0x80)) return (this[offset])\n	  return ((0xff - this[offset] + 1) * -1)\n	}\n	\n	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  var val = this[offset] | (this[offset + 1] << 8)\n	  return (val & 0x8000) ? val | 0xFFFF0000 : val\n	}\n	\n	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  var val = this[offset + 1] | (this[offset] << 8)\n	  return (val & 0x8000) ? val | 0xFFFF0000 : val\n	}\n	\n	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return (this[offset]) |\n	    (this[offset + 1] << 8) |\n	    (this[offset + 2] << 16) |\n	    (this[offset + 3] << 24)\n	}\n	\n	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return (this[offset] << 24) |\n	    (this[offset + 1] << 16) |\n	    (this[offset + 2] << 8) |\n	    (this[offset + 3])\n	}\n	\n	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	  return ieee754.read(this, offset, true, 23, 4)\n	}\n	\n	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	  return ieee754.read(this, offset, false, 23, 4)\n	}\n	\n	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 8, this.length)\n	  return ieee754.read(this, offset, true, 52, 8)\n	}\n	\n	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 8, this.length)\n	  return ieee754.read(this, offset, false, 52, 8)\n	}\n	\n	function checkInt (buf, value, offset, ext, max, min) {\n	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n	  if (value > max || value < min) throw new RangeError('value is out of bounds')\n	  if (offset + ext > buf.length) throw new RangeError('index out of range')\n	}\n	\n	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n	\n	  var mul = 1\n	  var i = 0\n	  this[offset] = value & 0xFF\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    this[offset + i] = (value / mul) & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n	\n	  var i = byteLength - 1\n	  var mul = 1\n	  this[offset + i] = value & 0xFF\n	  while (--i >= 0 && (mul *= 0x100)) {\n	    this[offset + i] = (value / mul) & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n	  this[offset] = (value & 0xff)\n	  return offset + 1\n	}\n	\n	function objectWriteUInt16 (buf, value, offset, littleEndian) {\n	  if (value < 0) value = 0xffff + value + 1\n	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n	      (littleEndian ? i : 1 - i) * 8\n	  }\n	}\n	\n	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value & 0xff)\n	    this[offset + 1] = (value >>> 8)\n	  } else {\n	    objectWriteUInt16(this, value, offset, true)\n	  }\n	  return offset + 2\n	}\n	\n	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 8)\n	    this[offset + 1] = (value & 0xff)\n	  } else {\n	    objectWriteUInt16(this, value, offset, false)\n	  }\n	  return offset + 2\n	}\n	\n	function objectWriteUInt32 (buf, value, offset, littleEndian) {\n	  if (value < 0) value = 0xffffffff + value + 1\n	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n	  }\n	}\n	\n	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset + 3] = (value >>> 24)\n	    this[offset + 2] = (value >>> 16)\n	    this[offset + 1] = (value >>> 8)\n	    this[offset] = (value & 0xff)\n	  } else {\n	    objectWriteUInt32(this, value, offset, true)\n	  }\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 24)\n	    this[offset + 1] = (value >>> 16)\n	    this[offset + 2] = (value >>> 8)\n	    this[offset + 3] = (value & 0xff)\n	  } else {\n	    objectWriteUInt32(this, value, offset, false)\n	  }\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) {\n	    var limit = Math.pow(2, 8 * byteLength - 1)\n	\n	    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n	  }\n	\n	  var i = 0\n	  var mul = 1\n	  var sub = value < 0 ? 1 : 0\n	  this[offset] = value & 0xFF\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) {\n	    var limit = Math.pow(2, 8 * byteLength - 1)\n	\n	    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n	  }\n	\n	  var i = byteLength - 1\n	  var mul = 1\n	  var sub = value < 0 ? 1 : 0\n	  this[offset + i] = value & 0xFF\n	  while (--i >= 0 && (mul *= 0x100)) {\n	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n	  if (value < 0) value = 0xff + value + 1\n	  this[offset] = (value & 0xff)\n	  return offset + 1\n	}\n	\n	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value & 0xff)\n	    this[offset + 1] = (value >>> 8)\n	  } else {\n	    objectWriteUInt16(this, value, offset, true)\n	  }\n	  return offset + 2\n	}\n	\n	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 8)\n	    this[offset + 1] = (value & 0xff)\n	  } else {\n	    objectWriteUInt16(this, value, offset, false)\n	  }\n	  return offset + 2\n	}\n	\n	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value & 0xff)\n	    this[offset + 1] = (value >>> 8)\n	    this[offset + 2] = (value >>> 16)\n	    this[offset + 3] = (value >>> 24)\n	  } else {\n	    objectWriteUInt32(this, value, offset, true)\n	  }\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n	  if (value < 0) value = 0xffffffff + value + 1\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 24)\n	    this[offset + 1] = (value >>> 16)\n	    this[offset + 2] = (value >>> 8)\n	    this[offset + 3] = (value & 0xff)\n	  } else {\n	    objectWriteUInt32(this, value, offset, false)\n	  }\n	  return offset + 4\n	}\n	\n	function checkIEEE754 (buf, value, offset, ext, max, min) {\n	  if (value > max || value < min) throw new RangeError('value is out of bounds')\n	  if (offset + ext > buf.length) throw new RangeError('index out of range')\n	  if (offset < 0) throw new RangeError('index out of range')\n	}\n	\n	function writeFloat (buf, value, offset, littleEndian, noAssert) {\n	  if (!noAssert) {\n	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n	  }\n	  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n	  return writeFloat(this, value, offset, true, noAssert)\n	}\n	\n	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n	  return writeFloat(this, value, offset, false, noAssert)\n	}\n	\n	function writeDouble (buf, value, offset, littleEndian, noAssert) {\n	  if (!noAssert) {\n	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n	  }\n	  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n	  return offset + 8\n	}\n	\n	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n	  return writeDouble(this, value, offset, true, noAssert)\n	}\n	\n	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n	  return writeDouble(this, value, offset, false, noAssert)\n	}\n	\n	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n	Buffer.prototype.copy = function copy (target, targetStart, start, end) {\n	  if (!start) start = 0\n	  if (!end && end !== 0) end = this.length\n	  if (targetStart >= target.length) targetStart = target.length\n	  if (!targetStart) targetStart = 0\n	  if (end > 0 && end < start) end = start\n	\n	  // Copy 0 bytes; we're done\n	  if (end === start) return 0\n	  if (target.length === 0 || this.length === 0) return 0\n	\n	  // Fatal error conditions\n	  if (targetStart < 0) {\n	    throw new RangeError('targetStart out of bounds')\n	  }\n	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n	  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n	\n	  // Are we oob?\n	  if (end > this.length) end = this.length\n	  if (target.length - targetStart < end - start) {\n	    end = target.length - targetStart + start\n	  }\n	\n	  var len = end - start\n	  var i\n	\n	  if (this === target && start < targetStart && targetStart < end) {\n	    // descending copy from end\n	    for (i = len - 1; i >= 0; i--) {\n	      target[i + targetStart] = this[i + start]\n	    }\n	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n	    // ascending copy from start\n	    for (i = 0; i < len; i++) {\n	      target[i + targetStart] = this[i + start]\n	    }\n	  } else {\n	    target._set(this.subarray(start, start + len), targetStart)\n	  }\n	\n	  return len\n	}\n	\n	// fill(value, start=0, end=buffer.length)\n	Buffer.prototype.fill = function fill (value, start, end) {\n	  if (!value) value = 0\n	  if (!start) start = 0\n	  if (!end) end = this.length\n	\n	  if (end < start) throw new RangeError('end < start')\n	\n	  // Fill 0 bytes; we're done\n	  if (end === start) return\n	  if (this.length === 0) return\n	\n	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n	\n	  var i\n	  if (typeof value === 'number') {\n	    for (i = start; i < end; i++) {\n	      this[i] = value\n	    }\n	  } else {\n	    var bytes = utf8ToBytes(value.toString())\n	    var len = bytes.length\n	    for (i = start; i < end; i++) {\n	      this[i] = bytes[i % len]\n	    }\n	  }\n	\n	  return this\n	}\n	\n	/**\n	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n	 */\n	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {\n	  if (typeof Uint8Array !== 'undefined') {\n	    if (Buffer.TYPED_ARRAY_SUPPORT) {\n	      return (new Buffer(this)).buffer\n	    } else {\n	      var buf = new Uint8Array(this.length)\n	      for (var i = 0, len = buf.length; i < len; i += 1) {\n	        buf[i] = this[i]\n	      }\n	      return buf.buffer\n	    }\n	  } else {\n	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n	  }\n	}\n	\n	// HELPER FUNCTIONS\n	// ================\n	\n	var BP = Buffer.prototype\n	\n	/**\n	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n	 */\n	Buffer._augment = function _augment (arr) {\n	  arr.constructor = Buffer\n	  arr._isBuffer = true\n	\n	  // save reference to original Uint8Array set method before overwriting\n	  arr._set = arr.set\n	\n	  // deprecated\n	  arr.get = BP.get\n	  arr.set = BP.set\n	\n	  arr.write = BP.write\n	  arr.toString = BP.toString\n	  arr.toLocaleString = BP.toString\n	  arr.toJSON = BP.toJSON\n	  arr.equals = BP.equals\n	  arr.compare = BP.compare\n	  arr.indexOf = BP.indexOf\n	  arr.copy = BP.copy\n	  arr.slice = BP.slice\n	  arr.readUIntLE = BP.readUIntLE\n	  arr.readUIntBE = BP.readUIntBE\n	  arr.readUInt8 = BP.readUInt8\n	  arr.readUInt16LE = BP.readUInt16LE\n	  arr.readUInt16BE = BP.readUInt16BE\n	  arr.readUInt32LE = BP.readUInt32LE\n	  arr.readUInt32BE = BP.readUInt32BE\n	  arr.readIntLE = BP.readIntLE\n	  arr.readIntBE = BP.readIntBE\n	  arr.readInt8 = BP.readInt8\n	  arr.readInt16LE = BP.readInt16LE\n	  arr.readInt16BE = BP.readInt16BE\n	  arr.readInt32LE = BP.readInt32LE\n	  arr.readInt32BE = BP.readInt32BE\n	  arr.readFloatLE = BP.readFloatLE\n	  arr.readFloatBE = BP.readFloatBE\n	  arr.readDoubleLE = BP.readDoubleLE\n	  arr.readDoubleBE = BP.readDoubleBE\n	  arr.writeUInt8 = BP.writeUInt8\n	  arr.writeUIntLE = BP.writeUIntLE\n	  arr.writeUIntBE = BP.writeUIntBE\n	  arr.writeUInt16LE = BP.writeUInt16LE\n	  arr.writeUInt16BE = BP.writeUInt16BE\n	  arr.writeUInt32LE = BP.writeUInt32LE\n	  arr.writeUInt32BE = BP.writeUInt32BE\n	  arr.writeIntLE = BP.writeIntLE\n	  arr.writeIntBE = BP.writeIntBE\n	  arr.writeInt8 = BP.writeInt8\n	  arr.writeInt16LE = BP.writeInt16LE\n	  arr.writeInt16BE = BP.writeInt16BE\n	  arr.writeInt32LE = BP.writeInt32LE\n	  arr.writeInt32BE = BP.writeInt32BE\n	  arr.writeFloatLE = BP.writeFloatLE\n	  arr.writeFloatBE = BP.writeFloatBE\n	  arr.writeDoubleLE = BP.writeDoubleLE\n	  arr.writeDoubleBE = BP.writeDoubleBE\n	  arr.fill = BP.fill\n	  arr.inspect = BP.inspect\n	  arr.toArrayBuffer = BP.toArrayBuffer\n	\n	  return arr\n	}\n	\n	var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n	\n	function base64clean (str) {\n	  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n	  // Node converts strings with length < 2 to ''\n	  if (str.length < 2) return ''\n	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n	  while (str.length % 4 !== 0) {\n	    str = str + '='\n	  }\n	  return str\n	}\n	\n	function stringtrim (str) {\n	  if (str.trim) return str.trim()\n	  return str.replace(/^\\s+|\\s+$/g, '')\n	}\n	\n	function toHex (n) {\n	  if (n < 16) return '0' + n.toString(16)\n	  return n.toString(16)\n	}\n	\n	function utf8ToBytes (string, units) {\n	  units = units || Infinity\n	  var codePoint\n	  var length = string.length\n	  var leadSurrogate = null\n	  var bytes = []\n	\n	  for (var i = 0; i < length; i++) {\n	    codePoint = string.charCodeAt(i)\n	\n	    // is surrogate component\n	    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n	      // last char was a lead\n	      if (!leadSurrogate) {\n	        // no lead yet\n	        if (codePoint > 0xDBFF) {\n	          // unexpected trail\n	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	          continue\n	        } else if (i + 1 === length) {\n	          // unpaired lead\n	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	          continue\n	        }\n	\n	        // valid lead\n	        leadSurrogate = codePoint\n	\n	        continue\n	      }\n	\n	      // 2 leads in a row\n	      if (codePoint < 0xDC00) {\n	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	        leadSurrogate = codePoint\n	        continue\n	      }\n	\n	      // valid surrogate pair\n	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n	    } else if (leadSurrogate) {\n	      // valid bmp char, but last char was a lead\n	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	    }\n	\n	    leadSurrogate = null\n	\n	    // encode utf8\n	    if (codePoint < 0x80) {\n	      if ((units -= 1) < 0) break\n	      bytes.push(codePoint)\n	    } else if (codePoint < 0x800) {\n	      if ((units -= 2) < 0) break\n	      bytes.push(\n	        codePoint >> 0x6 | 0xC0,\n	        codePoint & 0x3F | 0x80\n	      )\n	    } else if (codePoint < 0x10000) {\n	      if ((units -= 3) < 0) break\n	      bytes.push(\n	        codePoint >> 0xC | 0xE0,\n	        codePoint >> 0x6 & 0x3F | 0x80,\n	        codePoint & 0x3F | 0x80\n	      )\n	    } else if (codePoint < 0x110000) {\n	      if ((units -= 4) < 0) break\n	      bytes.push(\n	        codePoint >> 0x12 | 0xF0,\n	        codePoint >> 0xC & 0x3F | 0x80,\n	        codePoint >> 0x6 & 0x3F | 0x80,\n	        codePoint & 0x3F | 0x80\n	      )\n	    } else {\n	      throw new Error('Invalid code point')\n	    }\n	  }\n	\n	  return bytes\n	}\n	\n	function asciiToBytes (str) {\n	  var byteArray = []\n	  for (var i = 0; i < str.length; i++) {\n	    // Node's code seems to be doing this and not & 0x7F..\n	    byteArray.push(str.charCodeAt(i) & 0xFF)\n	  }\n	  return byteArray\n	}\n	\n	function utf16leToBytes (str, units) {\n	  var c, hi, lo\n	  var byteArray = []\n	  for (var i = 0; i < str.length; i++) {\n	    if ((units -= 2) < 0) break\n	\n	    c = str.charCodeAt(i)\n	    hi = c >> 8\n	    lo = c % 256\n	    byteArray.push(lo)\n	    byteArray.push(hi)\n	  }\n	\n	  return byteArray\n	}\n	\n	function base64ToBytes (str) {\n	  return base64.toByteArray(base64clean(str))\n	}\n	\n	function blitBuffer (src, dst, offset, length) {\n	  for (var i = 0; i < length; i++) {\n	    if ((i + offset >= dst.length) || (i >= src.length)) break\n	    dst[i + offset] = src[i]\n	  }\n	  return i\n	}\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n	\n	;(function (exports) {\n		'use strict';\n	\n	  var Arr = (typeof Uint8Array !== 'undefined')\n	    ? Uint8Array\n	    : Array\n	\n		var PLUS   = '+'.charCodeAt(0)\n		var SLASH  = '/'.charCodeAt(0)\n		var NUMBER = '0'.charCodeAt(0)\n		var LOWER  = 'a'.charCodeAt(0)\n		var UPPER  = 'A'.charCodeAt(0)\n		var PLUS_URL_SAFE = '-'.charCodeAt(0)\n		var SLASH_URL_SAFE = '_'.charCodeAt(0)\n	\n		function decode (elt) {\n			var code = elt.charCodeAt(0)\n			if (code === PLUS ||\n			    code === PLUS_URL_SAFE)\n				return 62 // '+'\n			if (code === SLASH ||\n			    code === SLASH_URL_SAFE)\n				return 63 // '/'\n			if (code < NUMBER)\n				return -1 //no match\n			if (code < NUMBER + 10)\n				return code - NUMBER + 26 + 26\n			if (code < UPPER + 26)\n				return code - UPPER\n			if (code < LOWER + 26)\n				return code - LOWER + 26\n		}\n	\n		function b64ToByteArray (b64) {\n			var i, j, l, tmp, placeHolders, arr\n	\n			if (b64.length % 4 > 0) {\n				throw new Error('Invalid string. Length must be a multiple of 4')\n			}\n	\n			// the number of equal signs (place holders)\n			// if there are two placeholders, than the two characters before it\n			// represent one byte\n			// if there is only one, then the three characters before it represent 2 bytes\n			// this is just a cheap hack to not do indexOf twice\n			var len = b64.length\n			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n	\n			// base64 is 4/3 + up to two characters of the original data\n			arr = new Arr(b64.length * 3 / 4 - placeHolders)\n	\n			// if there are placeholders, only get up to the last complete 4 chars\n			l = placeHolders > 0 ? b64.length - 4 : b64.length\n	\n			var L = 0\n	\n			function push (v) {\n				arr[L++] = v\n			}\n	\n			for (i = 0, j = 0; i < l; i += 4, j += 3) {\n				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n				push((tmp & 0xFF0000) >> 16)\n				push((tmp & 0xFF00) >> 8)\n				push(tmp & 0xFF)\n			}\n	\n			if (placeHolders === 2) {\n				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n				push(tmp & 0xFF)\n			} else if (placeHolders === 1) {\n				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n				push((tmp >> 8) & 0xFF)\n				push(tmp & 0xFF)\n			}\n	\n			return arr\n		}\n	\n		function uint8ToBase64 (uint8) {\n			var i,\n				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n				output = \"\",\n				temp, length\n	\n			function encode (num) {\n				return lookup.charAt(num)\n			}\n	\n			function tripletToBase64 (num) {\n				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n			}\n	\n			// go through the array every three bytes, we'll deal with trailing stuff later\n			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n				output += tripletToBase64(temp)\n			}\n	\n			// pad the end with zeros, but make sure to not forget the extra bytes\n			switch (extraBytes) {\n				case 1:\n					temp = uint8[uint8.length - 1]\n					output += encode(temp >> 2)\n					output += encode((temp << 4) & 0x3F)\n					output += '=='\n					break\n				case 2:\n					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n					output += encode(temp >> 10)\n					output += encode((temp >> 4) & 0x3F)\n					output += encode((temp << 2) & 0x3F)\n					output += '='\n					break\n			}\n	\n			return output\n		}\n	\n		exports.toByteArray = b64ToByteArray\n		exports.fromByteArray = uint8ToBase64\n	}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n	exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n	  var e, m\n	  var eLen = nBytes * 8 - mLen - 1\n	  var eMax = (1 << eLen) - 1\n	  var eBias = eMax >> 1\n	  var nBits = -7\n	  var i = isLE ? (nBytes - 1) : 0\n	  var d = isLE ? -1 : 1\n	  var s = buffer[offset + i]\n	\n	  i += d\n	\n	  e = s & ((1 << (-nBits)) - 1)\n	  s >>= (-nBits)\n	  nBits += eLen\n	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n	\n	  m = e & ((1 << (-nBits)) - 1)\n	  e >>= (-nBits)\n	  nBits += mLen\n	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n	\n	  if (e === 0) {\n	    e = 1 - eBias\n	  } else if (e === eMax) {\n	    return m ? NaN : ((s ? -1 : 1) * Infinity)\n	  } else {\n	    m = m + Math.pow(2, mLen)\n	    e = e - eBias\n	  }\n	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n	}\n	\n	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n	  var e, m, c\n	  var eLen = nBytes * 8 - mLen - 1\n	  var eMax = (1 << eLen) - 1\n	  var eBias = eMax >> 1\n	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n	  var i = isLE ? 0 : (nBytes - 1)\n	  var d = isLE ? 1 : -1\n	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n	\n	  value = Math.abs(value)\n	\n	  if (isNaN(value) || value === Infinity) {\n	    m = isNaN(value) ? 1 : 0\n	    e = eMax\n	  } else {\n	    e = Math.floor(Math.log(value) / Math.LN2)\n	    if (value * (c = Math.pow(2, -e)) < 1) {\n	      e--\n	      c *= 2\n	    }\n	    if (e + eBias >= 1) {\n	      value += rt / c\n	    } else {\n	      value += rt * Math.pow(2, 1 - eBias)\n	    }\n	    if (value * c >= 2) {\n	      e++\n	      c /= 2\n	    }\n	\n	    if (e + eBias >= eMax) {\n	      m = 0\n	      e = eMax\n	    } else if (e + eBias >= 1) {\n	      m = (value * c - 1) * Math.pow(2, mLen)\n	      e = e + eBias\n	    } else {\n	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n	      e = 0\n	    }\n	  }\n	\n	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n	\n	  e = (e << mLen) | m\n	  eLen += mLen\n	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n	\n	  buffer[offset + i - d] |= s * 128\n	}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n	var toString = {}.toString;\n	\n	module.exports = Array.isArray || function (arr) {\n	  return toString.call(arr) == '[object Array]';\n	};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	var config = {\n	    key: '8mOtYiilT5OUPwwdeGgvpw',\n	    secret: 'cqNn89RmR2SR76Kpp8xJaAdNzNOqR8Qfmjb0B-gDOHTw',\n	\n	    incomingAudio: '../src/assets/audio/incoming.ogg',\n	    outgoingAudio: '../src/assets/audio/outgoing.ogg'\n	};\n	exports.default = config;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _rcWebphone = __webpack_require__(13);\n	\n	var _rcWebphone2 = _interopRequireDefault(_rcWebphone);\n	\n	var _rcConfig = __webpack_require__(11);\n	\n	var _rcConfig2 = _interopRequireDefault(_rcConfig);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var PhoneService = function () {\n	    var webPhone;\n	    var session;\n	    var handlers = {\n	        invite: [],\n	        accepted: [],\n	        progress: [],\n	        rejected: [],\n	        terminated: [],\n	        failed: [],\n	        bye: [],\n	        refer: []\n	    };\n	    function listen(session) {\n	        session.on('accepted', function () {\n	            handlers['accepted'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('progress', function () {\n	            handlers['progress'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('rejected', function () {\n	            handlers['rejected'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('terminated', function () {\n	            handlers['terminated'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('failed', function () {\n	            handlers['failed'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('bye', function () {\n	            handlers['bye'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('refer', function () {\n	            handlers['refer'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	    }\n	    return {\n	        init: function init(options) {\n	            return _rcSdk.RC.sdk.platform().post('/client-info/sip-provision', {\n	                sipInfo: [{\n	                    transport: 'WSS'\n	                }]\n	            }).then(function (res) {\n	                return new _rcWebphone2.default(res.json(), { // optional\n	                    appKey: _rcConfig2.default.key,\n	                    logLevel: 1,\n	                    audioHelper: {\n	                        enabled: true, // enables audio feedback when web phone is ringing or making a call\n	                        incoming: options.incomingAudio, // path to audio file for incoming call\n	                        outgoing: options.outgoingAudio // path to aduotfile for outgoing call\n	                    }\n	                });\n	            }).then(function (p) {\n	                webPhone = p;\n	                webPhone.userAgent.on('invite', function (s) {\n	                    session = s;\n	                    handlers['invite'].forEach(function (handler) {\n	                        return handler(session);\n	                    });\n	                    listen(session);\n	                });\n	            }).catch(function (e) {\n	                return console.error(e);\n	            });\n	        },\n	        on: function on(name, callback) {\n	            handlers[name].push(callback);\n	        },\n	        call: function call(fromNumber, toNumber, options) {\n	            console.log(webPhone);\n	            session = webPhone.userAgent.invite(toNumber, {\n	                media: {\n	                    render: {\n	                        remote: options.remoteVideo,\n	                        local: options.localVideo\n	                    }\n	                },\n	                fromNumber: fromNumber\n	            });\n	            listen(session);\n	        },\n	        accept: function accept(options) {\n	            console.log(session);\n	            if (session.accept && !session.startTime) return session.accept({\n	                media: {\n	                    render: {\n	                        remote: options.remoteVideo,\n	                        local: options.localVideo\n	                    }\n	                }\n	            });\n	            return null;\n	        },\n	        reject: function reject() {\n	            return session.reject();\n	        },\n	        hangup: function hangup() {\n	            return session.bye();\n	        },\n	        hold: function hold(flag) {\n	            if (flag) {\n	                return session.hold().then(function () {\n	                    return session;\n	                });\n	            }\n	            return session.unhold().then(function () {\n	                return session;\n	            });\n	        },\n	        mute: function mute(flag) {\n	            if (flag) session.mute();else session.unmute();\n	            return session;\n	        },\n	        flip: function flip(number) {\n	            return session.flip(number).then(function () {\n	                return session;\n	            });\n	        },\n	        forward: function forward(number) {\n	            return session.forward(number).then(function () {\n	                return session;\n	            });\n	        },\n	        transfer: function transfer(number) {\n	            return session.transfer(number).then(function () {\n	                return session;\n	            });\n	        },\n	        park: function park() {\n	            return session.park().then(function () {\n	                return session;\n	            });\n	        },\n	        dtmf: function dtmf(number) {\n	            return session.dtmf(number);\n	        },\n	        record: function record(flag) {\n	            if (flag) {\n	                return session.startRecord().then(function () {\n	                    return session;\n	                });\n	            } else {\n	                return session.stopRecord().then(function () {\n	                    return session;\n	                });\n	            }\n	        }\n	    };\n	}();\n	exports.default = PhoneService;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	  value: true\n	});\n	\n	var _ringcentralWebPhone = __webpack_require__(14);\n	\n	var _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);\n\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n	exports.default = _ringcentralWebPhone2.default;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n	    if (true) {\n	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {\n	            return factory(SIP);\n	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	    } else if (typeof module === 'object') {\n	        module.exports = factory(require('sip.js'));\n	        module.exports.default = module.exports; //ES6\n	    } else {\n	        root.RingCentral = root.RingCentral || {};\n	        root.RingCentral.WebPhone = factory(root.SIP);\n	    }\n	}(this, function(SIP) {\n	\n	    var messages = {\n	        park: {reqid: 1, command: 'callpark'},\n	        startRecord: {reqid: 2, command: 'startcallrecord'},\n	        stopRecord: {reqid: 3, command: 'stopcallrecord'},\n	        flip: {reqid: 3, command: 'callflip', target: ''},\n	        monitor: {reqid: 4, command: 'monitor'},\n	        barge: {reqid: 5, command: 'barge'},\n	        whisper: {reqid: 6, command: 'whisper'},\n	        takeover: {reqid: 7, command: 'takeover'}\n	    };\n	\n	    var responseTimeout = 10000;\n	\n	    function uuid() {\n	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n	            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n	            return v.toString(16);\n	        });\n	    }\n	\n	    function delay(ms) {\n	        return new Promise(function(resolve, reject) {\n	            setTimeout(resolve, ms);\n	        });\n	    }\n	\n	    function extend(dst, src) {\n	        src = src || {};\n	        dst = dst || {};\n	        Object.keys(src).forEach(function(k) {\n	            dst[k] = src[k];\n	        });\n	        return dst;\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @param options\n	     * @constructor\n	     */\n	    function AudioHelper(options) {\n	\n	        options = options || {};\n	\n	        this._enabled = !!options.enabled;\n	        this._incoming = options.incoming || '../audio/incoming.ogg';\n	        this._outgoing = options.outgoing || '../audio/outgoing.ogg';\n	        this._audio = {};\n	\n	    }\n	\n	    AudioHelper.prototype._playSound = function(url, val, volume) {\n	\n	        if (!this._enabled) return this;\n	\n	        if (!this._audio[url]) {\n	            if (val) {\n	                this._audio[url] = new Audio();\n	                this._audio[url].src = url;\n	                this._audio[url].loop = true;\n	                this._audio[url].volume = volume;\n	                this._audio[url].play();\n	            }\n	        } else {\n	            if (val) {\n	                this._audio[url].currentTime = 0;\n	                this._audio[url].play();\n	            } else {\n	                this._audio[url].pause();\n	            }\n	        }\n	\n	        return this;\n	\n	    };\n	\n	    AudioHelper.prototype.playIncoming = function(val) {\n	        return this._playSound(this._incoming, val, 0.5);\n	    };\n	\n	    AudioHelper.prototype.playOutgoing = function(val) {\n	        return this._playSound(this._outgoing, val, 1);\n	    };\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @param {object} regData\n	     * @param {object} [options]\n	     * @param {string} [options.uuid]\n	     * @param {string} [options.appKey]\n	     * @param {string} [options.appName]\n	     * @param {string} [options.appVersion]\n	     * @param {string} [options.audioHelper]\n	     * @param {string} [options.onSession] fired each time UserAgent starts working with session\n	     * @constructor\n	     */\n	    function WebPhone(regData, options) {\n	\n	        regData = regData || {};\n	        options = options || {};\n	\n	        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;\n	        this.sipFlags = regData.sipFlags;\n	\n	        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable\n	        localStorage.setItem('rc-webPhone-uuid', id);\n	\n	        this.endpointHeader = 'P-rc-endpoint-id: ' + id;\n	\n	        var configuration = {\n	            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,\n	            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport\n	                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy\n	                : this.sipInfo.wsServers,\n	            authorizationUser: this.sipInfo.authorizationId,\n	            password: this.sipInfo.password,\n	            traceSip: true,\n	            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?\n	            turnServers: [],\n	            log: {\n	                level: options.logLevel || 1 //FIXME LOG LEVEL 3\n	            },\n	            domain: this.sipInfo.domain,\n	            autostart: true,\n	            register: true,\n	            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000\n	        };\n	\n	        this.appKey = options.appKey;\n	        this.appName = options.appName;\n	        this.appVersion = options.appVersion;\n	        this.userAgentHeader = 'RC-User-Agent: ' +\n	                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +\n	                               'RCWEBPHONE/' + WebPhone.version;\n	\n	        this.clientIdHeader = 'Client-id:' + options.appKey;\n	\n	        this.userAgent = new SIP.UA(configuration).register({\n	            extraHeaders: [\n	                this.endpointHeader,\n	                this.userAgentHeader,\n	                this.clientIdHeader\n	            ]\n	        });\n	\n	        this.userAgent.endpointHeader = this.endpointHeader;\n	        this.userAgent.userAgentHeader = this.userAgentHeader;\n	        this.userAgent.clientIdHeader = this.clientIdHeader;\n	        this.userAgent.sipInfo = this.sipInfo;\n	\n	        this.userAgent.__invite = this.userAgent.invite;\n	        this.userAgent.invite = invite;\n	\n	        this.userAgent.on('invite', function(session) {\n	            this.userAgent.audioHelper.playIncoming(true);\n	            patchSession(session);\n	        }.bind(this));\n	\n	        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);\n	\n	        this.userAgent.onSession = options.onSession || null;\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    WebPhone.version = '0.3.1';\n	    WebPhone.uuid = uuid;\n	    WebPhone.delay = delay;\n	    WebPhone.extend = extend;\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    function patchSession(session) {\n	\n	        if (session.__patched) return session;\n	\n	        session.__patched = true;\n	\n	        session.__sendRequest = session.sendRequest;\n	        session.__receiveRequest = session.receiveRequest;\n	        session.__receiveInviteResponse = session.receiveInviteResponse;\n	        session.__receiveResponse = session.receiveResponse;\n	        session.__sendReinvite = session.sendReinvite;\n	        session.__accept = session.accept;\n	        session.__hold = session.hold;\n	        session.__unhold = session.unhold;\n	        session.__dtmf = session.dtmf;\n	\n	        session.sendRequest = sendRequest;\n	        session.receiveRequest = receiveRequest;\n	        session.receiveInviteResponse = receiveInviteResponse;\n	        session.receiveResponse = receiveResponse;\n	        session.sendReinvite = sendReinvite;\n	        session.accept = accept;\n	        session.hold = hold;\n	        session.unhold = unhold;\n	        session.dtmf = dtmf;\n	\n	        session.blindTransfer = blindTransfer;\n	        session.transfer = transfer;\n	        session.park = park;\n	        session.forward = forward;\n	        session.startRecord = startRecord;\n	        session.stopRecord = stopRecord;\n	        session.flip = flip;\n	\n	        session.on('replaced', patchSession);\n	        // session.on('connecting', onConnecting);\n	\n	        // Audio\n	        session.on('accepted', stopPlaying);\n	        session.on('rejected', stopPlaying);\n	        session.on('bye', stopPlaying);\n	        session.on('terminated', stopPlaying);\n	        session.on('cancel', stopPlaying);\n	        session.on('failed', stopPlaying);\n	        session.on('replaced', stopPlaying);\n	        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);\n	        session.mediaHandler.on('iceConnectionFailed', stopPlaying);\n	\n	        function stopPlaying() {\n	            session.ua.audioHelper.playOutgoing(false);\n	            session.ua.audioHelper.playIncoming(false);\n	            session.removeListener('accepted', stopPlaying);\n	            session.removeListener('rejected', stopPlaying);\n	            session.removeListener('bye', stopPlaying);\n	            session.removeListener('terminated', stopPlaying);\n	            session.removeListener('cancel', stopPlaying);\n	            session.removeListener('failed', stopPlaying);\n	            session.removeListener('replaced', stopPlaying);\n	            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);\n	            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);\n	        }\n	\n	        if (session.ua.onSession) session.ua.onSession(session);\n	\n	        return session;\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @private\n	     * @param {SIP.Session} session\n	     * @param {object} command\n	     * @param {object} [options]\n	     * @return {Promise}\n	     */\n	    function sendReceive(session, command, options) {\n	\n	        options = options || {};\n	\n	        extend(command, options);\n	\n	        var cseq = null;\n	\n	        return new Promise(function(resolve, reject) {\n	\n	            session.sendRequest(SIP.C.INFO, {\n	                body: JSON.stringify({\n	                    request: command\n	                }),\n	                extraHeaders: [\n	                    \"Content-Type: application/json;charset=utf-8\",\n	                    session.ua.userAgentHeader,\n	                    session.ua.endpointHeader,\n	                    session.ua.clientIdHeader\n	                ],\n	                receiveResponse: function(response) {\n	                    var timeout = null;\n	                    if (response.status_code === 200) {\n	                        cseq = response.cseq;\n	                        var onInfo = function(request) {\n	                            if (response.cseq === cseq) {\n	\n	                                var body = request && request.body || '{}';\n	                                var obj;\n	\n	                                try {\n	                                    obj = JSON.parse(body);\n	                                } catch (e) {\n	                                    obj = {};\n	                                }\n	\n	                                if (obj.response && obj.response.command === command.command) {\n	                                    if (obj.response.result) {\n	                                        if (obj.response.result.code == 0) {\n	                                            return resolve(obj.response.result);\n	                                        } else {\n	                                            return reject(obj.response.result);\n	                                        }\n	                                    }\n	                                }\n	                                timeout && clearTimeout(timeout);\n	                                session.removeListener('RC_SIP_INFO', onInfo);\n	                                resolve(null); //FIXME What to resolve\n	                            }\n	                        };\n	\n	                        timeout = setTimeout(function() {\n	                            reject(new Error('Timeout: no reply'));\n	                            session.removeListener('RC_SIP_INFO', onInfo);\n	                        }, responseTimeout);\n	                        session.on('RC_SIP_INFO', onInfo);\n	                    }\n	                    else {\n	                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));\n	                    }\n	                }\n	            });\n	\n	        });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    function sendRequest(type, config) {\n	        if (type == SIP.C.PRACK) {\n	            type = SIP.C.ACK;\n	        }\n	        return this.__sendRequest(type, config);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * Fired each time a provisional (100-199) response is received.\n	     * Early media is supported by SIP.js library\n	     * But in case it is sent without 100rel support we play it manually\n	     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n	     *\n	     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n	     * @param {SIP.Session} session\n	     * @param response\n	     * @param {funciton} cb\n	     */\n	    function patch100rel(session, response, cb) {\n	\n	        //Early media is supported by SIP.js library\n	        //But in case it is sent without 100rel support we play it manually\n	        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n	        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\\n') !== -1) {\n	            if (!response.hasHeader('require')) response.setHeader('require', '100rel');\n	        }\n	\n	        return cb.call(session, response);\n	\n	    }\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param response\n	     * @return {*}\n	     */\n	    function receiveInviteResponse(response) {\n	        return patch100rel(this, response, this.__receiveInviteResponse);\n	    }\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param response\n	     * @return {*}\n	     */\n	    function receiveResponse(response) {\n	        return patch100rel(this, response, this.__receiveResponse);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @private\n	     * @param {SIP.Session} session\n	     * @param {boolean} flag\n	     * @return {Promise}\n	     */\n	    function setRecord(session, flag) {\n	\n	        var message = !!flag\n	            ? messages.startRecord\n	            : messages.stopRecord;\n	\n	        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {\n	            return sendReceive(session, message)\n	                .then(function(data) {\n	                    session.__onRecord = !!flag;\n	                    return data;\n	                });\n	        }\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @private\n	     * @param {SIP.Session} session\n	     * @param {boolean} flag\n	     * @return {Promise}\n	     */\n	    function setHold(session, flag) {\n	        return new Promise(function(resolve, reject) {\n	\n	            function onSucceeded() {\n	                resolve();\n	                session.removeListener('RC_CALL_REINVITE_FAILED', onFailed);\n	            }\n	\n	            function onFailed(e) {\n	                reject(e);\n	                session.removeListener('RC_CALL_REINVITE_SUCCEEDED', onSucceeded);\n	            }\n	\n	            session.once('RC_CALL_REINVITE_SUCCEEDED', onSucceeded);\n	            session.once('RC_CALL_REINVITE_FAILED', onFailed);\n	\n	            if (flag) {\n	                session.__hold();\n	            } else {\n	                session.__unhold();\n	            }\n	\n	        });\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.UA}\n	     * @param number\n	     * @param options\n	     * @return {SIP.Session}\n	     */\n	    function invite(number, options) {\n	\n	        var ua = this;\n	\n	        options = options || {};\n	        options.extraHeaders = options.extraHeaders || [];\n	\n	        options.extraHeaders.push(ua.userAgentHeader);\n	        options.extraHeaders.push(ua.endpointHeader);\n	        options.extraHeaders.push(ua.clientIdHeader);\n	\n	        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number\n	\n	        //FIXME Backend should know it already\n	        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }\n	\n	        options.media = options.media || {};\n	        options.media.constraints = options.media.constraints || {audio: true, video: false};\n	\n	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n	\n	        ua.audioHelper.playOutgoing(true);\n	\n	        return patchSession(ua.__invite(number, options));\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * Monkey patching sendReinvite for better Hold handling\n	     * @this {SIP.Session}\n	     * @return {*}\n	     */\n	    function sendReinvite() {\n	        var session = this;\n	        var res = session.__sendReinvite.apply(session, arguments);\n	        var __reinviteSucceeded = session.reinviteSucceeded,\n	            __reinviteFailed = session.reinviteFailed;\n	        session.reinviteSucceeded = function() {\n	            session.emit('RC_CALL_REINVITE_SUCCEEDED', session);\n	            return __reinviteSucceeded.apply(session, arguments);\n	        };\n	        session.reinviteFailed = function() {\n	            session.emit('RC_CALL_REINVITE_FAILED', session);\n	            return __reinviteFailed.apply(session, arguments);\n	        };\n	        return res;\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param request\n	     * @return {*}\n	     */\n	    function receiveRequest(request) {\n	        var session = this;\n	        switch (request.method) {\n	            case SIP.C.INFO:\n	                session.emit('RC_SIP_INFO', request);\n	                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case\n	                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n	                    var contentType = request.getHeader('content-type');\n	                    if (contentType.match(/^application\\/json/i)) {\n	                        request.reply(200);\n	                        return session;\n	                    }\n	                }\n	                break;\n	            //Refresh invite should not be rejected with 488\n	            case SIP.C.INVITE:\n	                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {\n	                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {\n	                        //TODO: check that SDP did not change\n	                        session.logger.log('re-INVITE received');\n	                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;\n	                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {\n	                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;\n	                            session.setInvite2xxTimer(request, localSDP);\n	                            session.setACKTimer();\n	                        });\n	                        return session;\n	                    }\n	                    //else will be rejected with 488 by SIP.js\n	                }\n	                break;\n	            //We need to analize NOTIFY messages sometimes, so we fire an event\n	            case SIP.C.NOTIFY:\n	                session.emit('RC_SIP_NOTIFY', request);\n	                break;\n	        }\n	        return session.__receiveRequest.apply(session, arguments);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param {object} options\n	     * @return {Promise}\n	     */\n	    function accept(options) {\n	\n	        var session = this;\n	\n	        options = options || {};\n	        options.extraHeaders = options.extraHeaders || [];\n	\n	        options.extraHeaders.push(session.ua.userAgentHeader);\n	        options.extraHeaders.push(session.ua.endpointHeader);\n	        options.extraHeaders.push(session.ua.clientIdHeader);\n	\n	        options.media = options.media || {};\n	        options.media.constraints = options.media.constraints || {audio: true, video: false};\n	\n	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n	\n	        return new Promise(function(resolve, reject) {\n	\n	            function onAnswered() {\n	                resolve(session);\n	                session.removeListener('failed', onFail);\n	            }\n	\n	            function onFail(e) {\n	                reject(e);\n	                session.removeListener('accepted', onAnswered);\n	            }\n	\n	            //TODO More events?\n	            session.once('accepted', onAnswered);\n	            session.once('failed', onFail);\n	\n	            session.__accept(options);\n	\n	        });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @param {string} dtmf\n	     * @param {number} duration\n	     * @return {Promise}\n	     */\n	    function dtmf(dtmf, duration) {\n	        var session = this;\n	        duration = parseInt(duration) || 1000;\n	        var peer = session.mediaHandler.peerConnection;\n	        var stream = session.getLocalStreams()[0];\n	        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);\n	        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {\n	            return dtmfSender.insertDTMF(dtmf, duration);\n	        }\n	        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\\'t insert DTMF' : 'Unknown')));\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @return {Promise}\n	     */\n	    function hold() {\n	        return setHold(this, true);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @return {Promise}\n	     */\n	    function unhold() {\n	        return setHold(this, false);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @param {string} target\n	     * @param {object} options\n	     * @return {Promise}\n	     */\n	    function blindTransfer(target, options) {\n	\n	        options = options || {};\n	\n	        var session = this;\n	        var extraHeaders = options.extraHeaders || [];\n	        var originalTarget = target;\n	\n	        return new Promise(function(resolve, reject) {\n	            //Blind Transfer is taken from SIP.js source\n	\n	            // Check Session Status\n	            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {\n	                throw new SIP.Exceptions.InvalidStateError(session.status);\n	            }\n	\n	            // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n	            // so try to make one ahead of time\n	            try {\n	                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n	            } catch (e) {\n	                session.logger.debug(\".refer() cannot parse Refer_To from\", target);\n	                session.logger.debug(\"...falling through to normalizeTarget()\");\n	            }\n	\n	            // Check target validity\n	            target = session.ua.normalizeTarget(target);\n	            if (!target) {\n	                throw new TypeError('Invalid target: ' + originalTarget);\n	            }\n	\n	            extraHeaders.push('Contact: ' + session.contact);\n	            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n	            extraHeaders.push('Refer-To: ' + target);\n	            extraHeaders.push(session.ua.userAgentHeader);\n	            extraHeaders.push(session.ua.endpointHeader);\n	            extraHeaders.push(session.ua.clientIdHeader);\n	\n	            // Send the request\n	            session.sendRequest(SIP.C.REFER, {\n	                extraHeaders: extraHeaders,\n	                body: options.body,\n	                receiveResponse: function(response) {\n	                    var timeout = null;\n	                    if (response.status_code === 202) {\n	                        var callId = response.call_id;\n	\n	                        var onNotify = function(request) {\n	                            if (request.call_id === callId) {\n	                                var body = request && request.body || '';\n	                                switch (true) {\n	                                    case /1[0-9]{2}/.test(body):\n	                                        request.reply(200);\n	                                        break;\n	                                    case /2[0-9]{2}/.test(body):\n	                                        session.terminate();\n	                                        clearTimeout(timeout);\n	                                        session.removeListener('RC_SIP_NOTIFY', onNotify);\n	                                        resolve();\n	                                        break;\n	                                    default:\n	                                        reject(body);\n	                                        break;\n	                                }\n	                            }\n	                        };\n	\n	                        timeout = setTimeout(function() {\n	                            reject(new Error('Timeout: no reply'));\n	                            session.removeListener('RC_SIP_NOTIFY', onNotify);\n	                        }, responseTimeout);\n	                        session.on('RC_SIP_NOTIFY', onNotify);\n	                    }\n	                    else {\n	                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));\n	                    }\n	                }\n	            });\n	\n	        });\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param {string} target\n	     * @param {object} options\n	     * @return {Promise}\n	     */\n	    function transfer(target, options) {\n	\n	        var session = this;\n	\n	        return (session.isOnHold() ? Promise.resolve(null) : session.hold())\n	            .then(function() { return delay(300); })\n	            .then(function() {\n	                return session.blindTransfer(target, options);\n	            });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param {string} target\n	     * @param {object} acceptOptions\n	     * @param {object} [transferOptions]\n	     * @return {Promise}\n	     */\n	    function forward(target, acceptOptions, transferOptions) {\n	\n	        var interval = null,\n	            session = this;\n	\n	        return session.accept(acceptOptions)\n	            .then(function() {\n	\n	                return new Promise(function(resolve, reject) {\n	                    interval = setInterval(function() {\n	                        if (session.status === 12) {\n	                            clearInterval(interval);\n	                            session.mute();\n	                            setTimeout(function() {\n	                                resolve(session.transfer(target, transferOptions));\n	                            }, 700);\n	                        }\n	                    }, 50);\n	                });\n	\n	            });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @return {Promise}\n	     */\n	    function startRecord() {\n	        return setRecord(this, true);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @return {Promise}\n	     */\n	    function stopRecord() {\n	        return setRecord(this, false);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param target\n	     * @return {Promise}\n	     */\n	    function flip(target) {\n	        return sendReceive(this, messages.flip, {target: target});\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @return {Promise}\n	     */\n	    function park() {\n	        return sendReceive(this, messages.park);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    return WebPhone;\n	\n	}));\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	module.exports = __webpack_require__(16)(__webpack_require__(49));\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/**\n	 * @name SIP\n	 * @namespace\n	 */\n	\"use strict\";\n	\n	module.exports = function (environment) {\n	\n	var pkg = __webpack_require__(17);\n	\n	var SIP = Object.defineProperties({}, {\n	  version: {\n	    get: function(){ return pkg.version; }\n	  },\n	  name: {\n	    get: function(){ return pkg.title; }\n	  }\n	});\n	\n	__webpack_require__(18)(SIP, environment);\n	SIP.LoggerFactory = __webpack_require__(19)(environment.console);\n	SIP.EventEmitter = __webpack_require__(20)(environment.console);\n	SIP.C = __webpack_require__(22)(SIP.name, SIP.version);\n	SIP.Exceptions = __webpack_require__(23);\n	SIP.Timers = __webpack_require__(24)(environment.timers);\n	SIP.Transport = environment.Transport(SIP, environment.WebSocket);\n	__webpack_require__(25)(SIP);\n	__webpack_require__(26)(SIP);\n	__webpack_require__(27)(SIP);\n	__webpack_require__(28)(SIP);\n	__webpack_require__(29)(SIP);\n	__webpack_require__(30)(SIP);\n	__webpack_require__(32)(SIP);\n	__webpack_require__(33)(SIP);\n	SIP.MediaHandler = __webpack_require__(34)(SIP.EventEmitter);\n	__webpack_require__(35)(SIP);\n	__webpack_require__(36)(SIP);\n	__webpack_require__(37)(SIP, environment);\n	__webpack_require__(39)(SIP);\n	SIP.WebRTC = __webpack_require__(40)(SIP, environment);\n	__webpack_require__(43)(SIP, environment);\n	SIP.Hacks = __webpack_require__(44)(SIP);\n	__webpack_require__(45)(SIP);\n	SIP.DigestAuthentication = __webpack_require__(46)(SIP.Utils);\n	SIP.Grammar = __webpack_require__(47)(SIP);\n	\n	return SIP;\n	};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n	module.exports = {\n		\"_args\": [\n			[\n				\"sip.js@0.7.3\",\n				\"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\"\n			]\n		],\n		\"_from\": \"sip.js@0.7.3\",\n		\"_id\": \"sip.js@0.7.3\",\n		\"_inCache\": true,\n		\"_installable\": true,\n		\"_location\": \"/sip.js\",\n		\"_nodeVersion\": \"4.2.6\",\n		\"_npmUser\": {\n			\"email\": \"1212jtraceur@gmail.com\",\n			\"name\": \"josephfrazier\"\n		},\n		\"_npmVersion\": \"2.4.1\",\n		\"_phantomChildren\": {},\n		\"_requested\": {\n			\"name\": \"sip.js\",\n			\"raw\": \"sip.js@0.7.3\",\n			\"rawSpec\": \"0.7.3\",\n			\"scope\": null,\n			\"spec\": \"0.7.3\",\n			\"type\": \"version\"\n		},\n		\"_requiredBy\": [\n			\"/ringcentral-web-phone\"\n		],\n		\"_resolved\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.3.tgz\",\n		\"_shasum\": \"fc2ee6227d23a37a91976966f952d82c3da317b5\",\n		\"_shrinkwrap\": null,\n		\"_spec\": \"sip.js@0.7.3\",\n		\"_where\": \"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\",\n		\"author\": {\n			\"email\": \"will@onsip.com\",\n			\"name\": \"Will Mitchell\"\n		},\n		\"browser\": {\n			\"./src/environment.js\": \"./src/environment_browser.js\"\n		},\n		\"bugs\": {\n			\"url\": \"https://github.com/onsip/SIP.js/issues\"\n		},\n		\"contributors\": [\n			{\n				\"url\": \"http://sipjs.com/authors/\"\n			}\n		],\n		\"dependencies\": {\n			\"promiscuous\": \"^0.6.0\",\n			\"ws\": \"^0.6.4\"\n		},\n		\"description\": \"A simple, intuitive, and powerful JavaScript signaling library\",\n		\"devDependencies\": {\n			\"beefy\": \"^2.1.5\",\n			\"browserify\": \"^4.1.8\",\n			\"grunt\": \"~0.4.0\",\n			\"grunt-browserify\": \"^4.0.1\",\n			\"grunt-cli\": \"~0.1.6\",\n			\"grunt-contrib-copy\": \"^0.5.0\",\n			\"grunt-contrib-jasmine\": \"~0.8.0\",\n			\"grunt-contrib-jshint\": \">0.5.0\",\n			\"grunt-contrib-uglify\": \"~0.2.0\",\n			\"grunt-peg\": \"~1.3.1\",\n			\"grunt-trimtrailingspaces\": \"^0.4.0\",\n			\"pegjs\": \"^0.8.0\"\n		},\n		\"directories\": {},\n		\"dist\": {\n			\"shasum\": \"fc2ee6227d23a37a91976966f952d82c3da317b5\",\n			\"tarball\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.3.tgz\"\n		},\n		\"engines\": {\n			\"node\": \">=0.8\"\n		},\n		\"gitHead\": \"d9ae93c04d6aad5df37fc999cbdbc7d9060a2f06\",\n		\"homepage\": \"http://sipjs.com\",\n		\"keywords\": [\n			\"sip\",\n			\"websocket\",\n			\"webrtc\",\n			\"library\",\n			\"javascript\"\n		],\n		\"license\": \"MIT\",\n		\"main\": \"src/index.js\",\n		\"maintainers\": [\n			{\n				\"email\": \"eric.green@onsip.com\",\n				\"name\": \"egreen_onsip\"\n			},\n			{\n				\"email\": \"1212jtraceur@gmail.com\",\n				\"name\": \"josephfrazier\"\n			}\n		],\n		\"name\": \"sip.js\",\n		\"optionalDependencies\": {\n			\"promiscuous\": \"^0.6.0\"\n		},\n		\"readme\": \"ERROR: No README data found!\",\n		\"repository\": {\n			\"type\": \"git\",\n			\"url\": \"git+https://github.com/onsip/SIP.js.git\"\n		},\n		\"scripts\": {\n			\"build\": \"grunt build\",\n			\"prepublish\": \"cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js\",\n			\"repl\": \"beefy test/repl.js --open\",\n			\"test\": \"grunt travis --verbose\"\n		},\n		\"title\": \"SIP.js\",\n		\"version\": \"0.7.3\"\n	};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Utils\n	 */\n	\n	module.exports = function (SIP, environment) {\n	var Utils;\n	\n	Utils= {\n	\n	  Promise: environment.Promise,\n	\n	  defer: function defer () {\n	    var deferred = {};\n	    deferred.promise = new Utils.Promise(function (resolve, reject) {\n	      deferred.resolve = resolve;\n	      deferred.reject = reject;\n	    });\n	    return deferred;\n	  },\n	\n	  promisify: function promisify (object, methodName, callbacksFirst) {\n	    var oldMethod = object[methodName];\n	    return function promisifiedMethod (arg, onSuccess, onFailure) {\n	      return new Utils.Promise(function (resolve, reject) {\n	        var oldArgs = [arg, resolve, reject];\n	        if (callbacksFirst) {\n	          oldArgs = [resolve, reject, arg];\n	        }\n	        oldMethod.apply(object, oldArgs);\n	      }).then(onSuccess, onFailure);\n	    };\n	  },\n	\n	  augment: function (object, constructor, args, override) {\n	    var idx, proto;\n	\n	    // Add public properties from constructor's prototype onto object\n	    proto = constructor.prototype;\n	    for (idx in proto) {\n	      if (override || object[idx] === undefined) {\n	        object[idx] = proto[idx];\n	      }\n	    }\n	\n	    // Construct the object as though it were just created by constructor\n	    constructor.apply(object, args);\n	  },\n	\n	  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {\n	    if (isDeprecated && options[loser]) {\n	      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n	    }\n	\n	    if (options[winner] && options[loser]) {\n	      logger.warn(winner + ' overriding ' + loser);\n	    }\n	\n	    options[winner] = options[winner] || options[loser] || defaultValue;\n	  },\n	\n	  str_utf8_length: function(string) {\n	    return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n	  },\n	\n	  generateFakeSDP: function(body) {\n	    if (!body) {\n	      return;\n	    }\n	\n	    var start = body.indexOf('o=');\n	    var end = body.indexOf('\\r\\n', start);\n	\n	    return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n	  },\n	\n	  isFunction: function(fn) {\n	    if (fn !== undefined) {\n	      return Object.prototype.toString.call(fn) === '[object Function]';\n	    } else {\n	      return false;\n	    }\n	  },\n	\n	  isDecimal: function (num) {\n	    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));\n	  },\n	\n	  createRandomToken: function(size, base) {\n	    var i, r,\n	      token = '';\n	\n	    base = base || 32;\n	\n	    for( i=0; i < size; i++ ) {\n	      r = Math.random() * base|0;\n	      token += r.toString(base);\n	    }\n	\n	    return token;\n	  },\n	\n	  newTag: function() {\n	    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n	  },\n	\n	  // http://stackoverflow.com/users/109538/broofa\n	  newUUID: function() {\n	    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n	      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n	      return v.toString(16);\n	    });\n	\n	    return UUID;\n	  },\n	\n	  hostType: function(host) {\n	    if (!host) {\n	      return;\n	    } else {\n	      host = SIP.Grammar.parse(host,'host');\n	      if (host !== -1) {\n	        return host.host_type;\n	      }\n	    }\n	  },\n	\n	  /**\n	  * Normalize SIP URI.\n	  * NOTE: It does not allow a SIP URI without username.\n	  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n	  * Detects the domain part (if given) and properly hex-escapes the user portion.\n	  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n	  * @private\n	  * @param {String} target\n	  * @param {String} [domain]\n	  */\n	  normalizeTarget: function(target, domain) {\n	    var uri, target_array, target_user, target_domain;\n	\n	    // If no target is given then raise an error.\n	    if (!target) {\n	      return;\n	    // If a SIP.URI instance is given then return it.\n	    } else if (target instanceof SIP.URI) {\n	      return target;\n	\n	    // If a string is given split it by '@':\n	    // - Last fragment is the desired domain.\n	    // - Otherwise append the given domain argument.\n	    } else if (typeof target === 'string') {\n	      target_array = target.split('@');\n	\n	      switch(target_array.length) {\n	        case 1:\n	          if (!domain) {\n	            return;\n	          }\n	          target_user = target;\n	          target_domain = domain;\n	          break;\n	        case 2:\n	          target_user = target_array[0];\n	          target_domain = target_array[1];\n	          break;\n	        default:\n	          target_user = target_array.slice(0, target_array.length-1).join('@');\n	          target_domain = target_array[target_array.length-1];\n	      }\n	\n	      // Remove the URI scheme (if present).\n	      target_user = target_user.replace(/^(sips?|tel):/i, '');\n	\n	      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n	      if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n	        target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n	      }\n	\n	      // Build the complete SIP URI.\n	      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;\n	\n	      // Finally parse the resulting URI.\n	      if (uri = SIP.URI.parse(target)) {\n	        return uri;\n	      } else {\n	        return;\n	      }\n	    } else {\n	      return;\n	    }\n	  },\n	\n	  /**\n	  * Hex-escape a SIP URI user.\n	  * @private\n	  * @param {String} user\n	  */\n	  escapeUser: function(user) {\n	    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n	    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n	  },\n	\n	  headerize: function(string) {\n	    var exceptions = {\n	      'Call-Id': 'Call-ID',\n	      'Cseq': 'CSeq',\n	      'Min-Se': 'Min-SE',\n	      'Rack': 'RAck',\n	      'Rseq': 'RSeq',\n	      'Www-Authenticate': 'WWW-Authenticate'\n	      },\n	      name = string.toLowerCase().replace(/_/g,'-').split('-'),\n	      hname = '',\n	      parts = name.length, part;\n	\n	    for (part = 0; part < parts; part++) {\n	      if (part !== 0) {\n	        hname +='-';\n	      }\n	      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);\n	    }\n	    if (exceptions[hname]) {\n	      hname = exceptions[hname];\n	    }\n	    return hname;\n	  },\n	\n	  sipErrorCause: function(status_code) {\n	    var cause;\n	\n	    for (cause in SIP.C.SIP_ERROR_CAUSES) {\n	      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n	        return SIP.C.causes[cause];\n	      }\n	    }\n	\n	    return SIP.C.causes.SIP_FAILURE_CODE;\n	  },\n	\n	  getReasonPhrase: function getReasonPhrase (code, specific) {\n	    return specific || SIP.C.REASON_PHRASE[code] || '';\n	  },\n	\n	  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {\n	    reason = SIP.Utils.getReasonPhrase(code, reason);\n	    return 'SIP ;cause=' + code + ' ;text=\"' + reason + '\"';\n	  },\n	\n	  getCancelReason: function getCancelReason (code, reason) {\n	    if (code && code < 200 || code > 699) {\n	      throw new TypeError('Invalid status_code: ' + code);\n	    } else if (code) {\n	      return SIP.Utils.getReasonHeaderValue(code, reason);\n	    }\n	  },\n	\n	  buildStatusLine: function buildStatusLine (code, reason) {\n	    code = code || null;\n	    reason = reason || null;\n	\n	    // Validate code and reason values\n	    if (!code || (code < 100 || code > 699)) {\n	      throw new TypeError('Invalid status_code: '+ code);\n	    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n	      throw new TypeError('Invalid reason_phrase: '+ reason);\n	    }\n	\n	    reason = Utils.getReasonPhrase(code, reason);\n	\n	    return 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n	  },\n	\n	  /**\n	  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n	  * @private\n	  */\n	  getRandomTestNetIP: function() {\n	    function getOctet(from,to) {\n	      return Math.floor(Math.random()*(to-from+1)+from);\n	    }\n	    return '192.0.2.' + getOctet(1, 254);\n	  },\n	\n	  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info\n	  calculateMD5: function(string) {\n	    function RotateLeft(lValue, iShiftBits) {\n	      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n	    }\n	\n	    function AddUnsigned(lX,lY) {\n	      var lX4,lY4,lX8,lY8,lResult;\n	      lX8 = (lX & 0x80000000);\n	      lY8 = (lY & 0x80000000);\n	      lX4 = (lX & 0x40000000);\n	      lY4 = (lY & 0x40000000);\n	      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n	      if (lX4 & lY4) {\n	        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n	      }\n	      if (lX4 | lY4) {\n	        if (lResult & 0x40000000) {\n	          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n	        } else {\n	          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n	        }\n	      } else {\n	        return (lResult ^ lX8 ^ lY8);\n	      }\n	    }\n	\n	    function F(x,y,z) {\n	      return (x & y) | ((~x) & z);\n	    }\n	\n	    function G(x,y,z) {\n	      return (x & z) | (y & (~z));\n	    }\n	\n	    function H(x,y,z) {\n	      return (x ^ y ^ z);\n	    }\n	\n	    function I(x,y,z) {\n	      return (y ^ (x | (~z)));\n	    }\n	\n	    function FF(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function GG(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function HH(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function II(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function ConvertToWordArray(string) {\n	      var lWordCount;\n	      var lMessageLength = string.length;\n	      var lNumberOfWords_temp1=lMessageLength + 8;\n	      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n	      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n	      var lWordArray=Array(lNumberOfWords-1);\n	      var lBytePosition = 0;\n	      var lByteCount = 0;\n	      while ( lByteCount < lMessageLength ) {\n	        lWordCount = (lByteCount-(lByteCount % 4))/4;\n	        lBytePosition = (lByteCount % 4)*8;\n	        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n	        lByteCount++;\n	      }\n	      lWordCount = (lByteCount-(lByteCount % 4))/4;\n	      lBytePosition = (lByteCount % 4)*8;\n	      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n	      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n	      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n	      return lWordArray;\n	    }\n	\n	    function WordToHex(lValue) {\n	      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n	      for (lCount = 0;lCount<=3;lCount++) {\n	        lByte = (lValue>>>(lCount*8)) & 255;\n	        WordToHexValue_temp = \"0\" + lByte.toString(16);\n	        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n	      }\n	      return WordToHexValue;\n	    }\n	\n	    function Utf8Encode(string) {\n	      string = string.replace(/\\r\\n/g,\"\\n\");\n	      var utftext = \"\";\n	\n	      for (var n = 0; n < string.length; n++) {\n	        var c = string.charCodeAt(n);\n	\n	        if (c < 128) {\n	          utftext += String.fromCharCode(c);\n	        }\n	        else if((c > 127) && (c < 2048)) {\n	          utftext += String.fromCharCode((c >> 6) | 192);\n	          utftext += String.fromCharCode((c & 63) | 128);\n	        }\n	        else {\n	          utftext += String.fromCharCode((c >> 12) | 224);\n	          utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n	          utftext += String.fromCharCode((c & 63) | 128);\n	        }\n	      }\n	      return utftext;\n	    }\n	\n	    var x=[];\n	    var k,AA,BB,CC,DD,a,b,c,d;\n	    var S11=7, S12=12, S13=17, S14=22;\n	    var S21=5, S22=9 , S23=14, S24=20;\n	    var S31=4, S32=11, S33=16, S34=23;\n	    var S41=6, S42=10, S43=15, S44=21;\n	\n	    string = Utf8Encode(string);\n	\n	    x = ConvertToWordArray(string);\n	\n	    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n	\n	    for (k=0;k<x.length;k+=16) {\n	      AA=a; BB=b; CC=c; DD=d;\n	      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n	      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n	      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n	      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n	      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n	      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n	      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n	      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n	      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n	      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n	      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n	      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n	      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n	      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n	      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n	      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n	      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n	      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n	      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n	      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n	      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n	      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n	      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n	      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n	      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n	      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n	      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n	      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n	      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n	      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n	      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n	      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n	      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n	      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n	      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n	      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n	      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n	      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n	      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n	      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n	      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n	      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n	      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n	      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n	      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n	      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n	      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n	      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n	      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n	      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n	      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n	      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n	      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n	      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n	      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n	      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n	      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n	      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n	      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n	      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n	      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n	      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n	      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n	      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n	      a=AddUnsigned(a,AA);\n	      b=AddUnsigned(b,BB);\n	      c=AddUnsigned(c,CC);\n	      d=AddUnsigned(d,DD);\n	    }\n	\n	    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n	\n	    return temp.toLowerCase();\n	  }\n	};\n	\n	SIP.Utils = Utils;\n	};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	var levels = {\n	  'error': 0,\n	  'warn': 1,\n	  'log': 2,\n	  'debug': 3\n	};\n	\n	module.exports = function (console) {\n	\n	var LoggerFactory = function () {\n	  var logger,\n	    level = 2,\n	    builtinEnabled = true,\n	    connector = null;\n	\n	    this.loggers = {};\n	\n	    logger = this.getLogger('sip.loggerfactory');\n	\n	\n	  Object.defineProperties(this, {\n	    builtinEnabled: {\n	      get: function(){ return builtinEnabled; },\n	      set: function(value){\n	        if (typeof value === 'boolean') {\n	          builtinEnabled = value;\n	        } else {\n	          logger.error('invalid \"builtinEnabled\" parameter value: '+ JSON.stringify(value));\n	        }\n	      }\n	    },\n	\n	    level: {\n	      get: function() {return level; },\n	      set: function(value) {\n	        if (value >= 0 && value <=3) {\n	          level = value;\n	        } else if (value > 3) {\n	          level = 3;\n	        } else if (levels.hasOwnProperty(value)) {\n	          level = levels[value];\n	        } else {\n	          logger.error('invalid \"level\" parameter value: '+ JSON.stringify(value));\n	        }\n	      }\n	    },\n	\n	    connector: {\n	      get: function() {return connector; },\n	      set: function(value){\n	        if(value === null || value === \"\" || value === undefined) {\n	          connector = null;\n	        } else if (typeof value === 'function') {\n	          connector = value;\n	        } else {\n	          logger.error('invalid \"connector\" parameter value: '+ JSON.stringify(value));\n	        }\n	      }\n	    }\n	  });\n	};\n	\n	LoggerFactory.prototype.print = function(target, category, label, content) {\n	  if (typeof content === 'string') {\n	    var prefix = [new Date(), category];\n	    if (label) {\n	      prefix.push(label);\n	    }\n	    content = prefix.concat(content).join(' | ');\n	  }\n	  target.call(console, content);\n	};\n	\n	function Logger (logger, category, label) {\n	  this.logger = logger;\n	  this.category = category;\n	  this.label = label;\n	}\n	\n	Object.keys(levels).forEach(function (targetName) {\n	  Logger.prototype[targetName] = function (content) {\n	    this.logger[targetName](this.category, this.label, content);\n	  };\n	\n	  LoggerFactory.prototype[targetName] = function (category, label, content) {\n	    if (this.level >= levels[targetName]) {\n	      if (this.builtinEnabled) {\n	        this.print(console[targetName], category, label, content);\n	      }\n	\n	      if (this.connector) {\n	        this.connector(targetName, category, label, content);\n	      }\n	    }\n	  };\n	});\n	\n	LoggerFactory.prototype.getLogger = function(category, label) {\n	  var logger;\n	\n	  if (label && this.level === 3) {\n	    return new Logger(this, category, label);\n	  } else if (this.loggers[category]) {\n	    return this.loggers[category];\n	  } else {\n	    logger = new Logger(this, category);\n	    this.loggers[category] = logger;\n	    return logger;\n	  }\n	};\n	\n	return LoggerFactory;\n	};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	var NodeEventEmitter = __webpack_require__(21).EventEmitter;\n	\n	module.exports = function (console) {\n	\n	// Don't use `new SIP.EventEmitter()` for inheriting.\n	// Use Object.create(SIP.EventEmitter.prototoype);\n	function EventEmitter () {\n	  NodeEventEmitter.call(this);\n	}\n	\n	EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {\n	  constructor: {\n	    value: EventEmitter,\n	    enumerable: false,\n	    writable: true,\n	    configurable: true\n	  }\n	});\n	\n	EventEmitter.prototype.off = function off (eventName, listener) {\n	  var warning = '';\n	  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\\n';\n	  warning += 'Please use removeListener or removeAllListeners instead.\\n';\n	  warning += 'See here for more details:\\n';\n	  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';\n	  console.warn(warning);\n	\n	  if (arguments.length < 2) {\n	    return this.removeAllListeners.apply(this, arguments);\n	  } else {\n	    return this.removeListener(eventName, listener);\n	  }\n	};\n	\n	return EventEmitter;\n	\n	};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n	// Copyright Joyent, Inc. and other Node contributors.\n	//\n	// Permission is hereby granted, free of charge, to any person obtaining a\n	// copy of this software and associated documentation files (the\n	// \"Software\"), to deal in the Software without restriction, including\n	// without limitation the rights to use, copy, modify, merge, publish,\n	// distribute, sublicense, and/or sell copies of the Software, and to permit\n	// persons to whom the Software is furnished to do so, subject to the\n	// following conditions:\n	//\n	// The above copyright notice and this permission notice shall be included\n	// in all copies or substantial portions of the Software.\n	//\n	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n	// USE OR OTHER DEALINGS IN THE SOFTWARE.\n	\n	function EventEmitter() {\n	  this._events = this._events || {};\n	  this._maxListeners = this._maxListeners || undefined;\n	}\n	module.exports = EventEmitter;\n	\n	// Backwards-compat with node 0.10.x\n	EventEmitter.EventEmitter = EventEmitter;\n	\n	EventEmitter.prototype._events = undefined;\n	EventEmitter.prototype._maxListeners = undefined;\n	\n	// By default EventEmitters will print a warning if more than 10 listeners are\n	// added to it. This is a useful default which helps finding memory leaks.\n	EventEmitter.defaultMaxListeners = 10;\n	\n	// Obviously not all Emitters should be limited to 10. This function allows\n	// that to be increased. Set to zero for unlimited.\n	EventEmitter.prototype.setMaxListeners = function(n) {\n	  if (!isNumber(n) || n < 0 || isNaN(n))\n	    throw TypeError('n must be a positive number');\n	  this._maxListeners = n;\n	  return this;\n	};\n	\n	EventEmitter.prototype.emit = function(type) {\n	  var er, handler, len, args, i, listeners;\n	\n	  if (!this._events)\n	    this._events = {};\n	\n	  // If there is no 'error' event listener then throw.\n	  if (type === 'error') {\n	    if (!this._events.error ||\n	        (isObject(this._events.error) && !this._events.error.length)) {\n	      er = arguments[1];\n	      if (er instanceof Error) {\n	        throw er; // Unhandled 'error' event\n	      }\n	      throw TypeError('Uncaught, unspecified \"error\" event.');\n	    }\n	  }\n	\n	  handler = this._events[type];\n	\n	  if (isUndefined(handler))\n	    return false;\n	\n	  if (isFunction(handler)) {\n	    switch (arguments.length) {\n	      // fast cases\n	      case 1:\n	        handler.call(this);\n	        break;\n	      case 2:\n	        handler.call(this, arguments[1]);\n	        break;\n	      case 3:\n	        handler.call(this, arguments[1], arguments[2]);\n	        break;\n	      // slower\n	      default:\n	        args = Array.prototype.slice.call(arguments, 1);\n	        handler.apply(this, args);\n	    }\n	  } else if (isObject(handler)) {\n	    args = Array.prototype.slice.call(arguments, 1);\n	    listeners = handler.slice();\n	    len = listeners.length;\n	    for (i = 0; i < len; i++)\n	      listeners[i].apply(this, args);\n	  }\n	\n	  return true;\n	};\n	\n	EventEmitter.prototype.addListener = function(type, listener) {\n	  var m;\n	\n	  if (!isFunction(listener))\n	    throw TypeError('listener must be a function');\n	\n	  if (!this._events)\n	    this._events = {};\n	\n	  // To avoid recursion in the case that type === \"newListener\"! Before\n	  // adding it to the listeners, first emit \"newListener\".\n	  if (this._events.newListener)\n	    this.emit('newListener', type,\n	              isFunction(listener.listener) ?\n	              listener.listener : listener);\n	\n	  if (!this._events[type])\n	    // Optimize the case of one listener. Don't need the extra array object.\n	    this._events[type] = listener;\n	  else if (isObject(this._events[type]))\n	    // If we've already got an array, just append.\n	    this._events[type].push(listener);\n	  else\n	    // Adding the second element, need to change to array.\n	    this._events[type] = [this._events[type], listener];\n	\n	  // Check for listener leak\n	  if (isObject(this._events[type]) && !this._events[type].warned) {\n	    if (!isUndefined(this._maxListeners)) {\n	      m = this._maxListeners;\n	    } else {\n	      m = EventEmitter.defaultMaxListeners;\n	    }\n	\n	    if (m && m > 0 && this._events[type].length > m) {\n	      this._events[type].warned = true;\n	      console.error('(node) warning: possible EventEmitter memory ' +\n	                    'leak detected. %d listeners added. ' +\n	                    'Use emitter.setMaxListeners() to increase limit.',\n	                    this._events[type].length);\n	      if (typeof console.trace === 'function') {\n	        // not supported in IE 10\n	        console.trace();\n	      }\n	    }\n	  }\n	\n	  return this;\n	};\n	\n	EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n	\n	EventEmitter.prototype.once = function(type, listener) {\n	  if (!isFunction(listener))\n	    throw TypeError('listener must be a function');\n	\n	  var fired = false;\n	\n	  function g() {\n	    this.removeListener(type, g);\n	\n	    if (!fired) {\n	      fired = true;\n	      listener.apply(this, arguments);\n	    }\n	  }\n	\n	  g.listener = listener;\n	  this.on(type, g);\n	\n	  return this;\n	};\n	\n	// emits a 'removeListener' event iff the listener was removed\n	EventEmitter.prototype.removeListener = function(type, listener) {\n	  var list, position, length, i;\n	\n	  if (!isFunction(listener))\n	    throw TypeError('listener must be a function');\n	\n	  if (!this._events || !this._events[type])\n	    return this;\n	\n	  list = this._events[type];\n	  length = list.length;\n	  position = -1;\n	\n	  if (list === listener ||\n	      (isFunction(list.listener) && list.listener === listener)) {\n	    delete this._events[type];\n	    if (this._events.removeListener)\n	      this.emit('removeListener', type, listener);\n	\n	  } else if (isObject(list)) {\n	    for (i = length; i-- > 0;) {\n	      if (list[i] === listener ||\n	          (list[i].listener && list[i].listener === listener)) {\n	        position = i;\n	        break;\n	      }\n	    }\n	\n	    if (position < 0)\n	      return this;\n	\n	    if (list.length === 1) {\n	      list.length = 0;\n	      delete this._events[type];\n	    } else {\n	      list.splice(position, 1);\n	    }\n	\n	    if (this._events.removeListener)\n	      this.emit('removeListener', type, listener);\n	  }\n	\n	  return this;\n	};\n	\n	EventEmitter.prototype.removeAllListeners = function(type) {\n	  var key, listeners;\n	\n	  if (!this._events)\n	    return this;\n	\n	  // not listening for removeListener, no need to emit\n	  if (!this._events.removeListener) {\n	    if (arguments.length === 0)\n	      this._events = {};\n	    else if (this._events[type])\n	      delete this._events[type];\n	    return this;\n	  }\n	\n	  // emit removeListener for all listeners on all events\n	  if (arguments.length === 0) {\n	    for (key in this._events) {\n	      if (key === 'removeListener') continue;\n	      this.removeAllListeners(key);\n	    }\n	    this.removeAllListeners('removeListener');\n	    this._events = {};\n	    return this;\n	  }\n	\n	  listeners = this._events[type];\n	\n	  if (isFunction(listeners)) {\n	    this.removeListener(type, listeners);\n	  } else if (listeners) {\n	    // LIFO order\n	    while (listeners.length)\n	      this.removeListener(type, listeners[listeners.length - 1]);\n	  }\n	  delete this._events[type];\n	\n	  return this;\n	};\n	\n	EventEmitter.prototype.listeners = function(type) {\n	  var ret;\n	  if (!this._events || !this._events[type])\n	    ret = [];\n	  else if (isFunction(this._events[type]))\n	    ret = [this._events[type]];\n	  else\n	    ret = this._events[type].slice();\n	  return ret;\n	};\n	\n	EventEmitter.prototype.listenerCount = function(type) {\n	  if (this._events) {\n	    var evlistener = this._events[type];\n	\n	    if (isFunction(evlistener))\n	      return 1;\n	    else if (evlistener)\n	      return evlistener.length;\n	  }\n	  return 0;\n	};\n	\n	EventEmitter.listenerCount = function(emitter, type) {\n	  return emitter.listenerCount(type);\n	};\n	\n	function isFunction(arg) {\n	  return typeof arg === 'function';\n	}\n	\n	function isNumber(arg) {\n	  return typeof arg === 'number';\n	}\n	\n	function isObject(arg) {\n	  return typeof arg === 'object' && arg !== null;\n	}\n	\n	function isUndefined(arg) {\n	  return arg === void 0;\n	}\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Constants\n	 */\n	\n	/**\n	 * SIP Constants.\n	 * @augments SIP\n	 */\n	\n	module.exports = function (name, version) {\n	return {\n	  USER_AGENT: name +'/'+ version,\n	\n	  // SIP scheme\n	  SIP:  'sip',\n	  SIPS: 'sips',\n	\n	  // End and Failure causes\n	  causes: {\n	    // Generic error causes\n	    CONNECTION_ERROR:         'Connection Error',\n	    REQUEST_TIMEOUT:          'Request Timeout',\n	    SIP_FAILURE_CODE:         'SIP Failure Code',\n	    INTERNAL_ERROR:           'Internal Error',\n	\n	    // SIP error causes\n	    BUSY:                     'Busy',\n	    REJECTED:                 'Rejected',\n	    REDIRECTED:               'Redirected',\n	    UNAVAILABLE:              'Unavailable',\n	    NOT_FOUND:                'Not Found',\n	    ADDRESS_INCOMPLETE:       'Address Incomplete',\n	    INCOMPATIBLE_SDP:         'Incompatible SDP',\n	    AUTHENTICATION_ERROR:     'Authentication Error',\n	    DIALOG_ERROR:             'Dialog Error',\n	\n	    // Session error causes\n	    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',\n	    WEBRTC_ERROR:             'WebRTC Error',\n	    CANCELED:                 'Canceled',\n	    NO_ANSWER:                'No Answer',\n	    EXPIRES:                  'Expires',\n	    NO_ACK:                   'No ACK',\n	    NO_PRACK:                 'No PRACK',\n	    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n	    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',\n	    RTP_TIMEOUT:              'RTP Timeout'\n	  },\n	\n	  supported: {\n	    UNSUPPORTED:        'none',\n	    SUPPORTED:          'supported',\n	    REQUIRED:           'required'\n	  },\n	\n	  SIP_ERROR_CAUSES: {\n	    REDIRECTED: [300,301,302,305,380],\n	    BUSY: [486,600],\n	    REJECTED: [403,603],\n	    NOT_FOUND: [404,604],\n	    UNAVAILABLE: [480,410,408,430],\n	    ADDRESS_INCOMPLETE: [484],\n	    INCOMPATIBLE_SDP: [488,606],\n	    AUTHENTICATION_ERROR:[401,407]\n	  },\n	\n	  // SIP Methods\n	  ACK:        'ACK',\n	  BYE:        'BYE',\n	  CANCEL:     'CANCEL',\n	  INFO:       'INFO',\n	  INVITE:     'INVITE',\n	  MESSAGE:    'MESSAGE',\n	  NOTIFY:     'NOTIFY',\n	  OPTIONS:    'OPTIONS',\n	  REGISTER:   'REGISTER',\n	  UPDATE:     'UPDATE',\n	  SUBSCRIBE:  'SUBSCRIBE',\n	  REFER:      'REFER',\n	  PRACK:      'PRACK',\n	\n	  /* SIP Response Reasons\n	   * DOC: http://www.iana.org/assignments/sip-parameters\n	   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n	   */\n	  REASON_PHRASE: {\n	    100: 'Trying',\n	    180: 'Ringing',\n	    181: 'Call Is Being Forwarded',\n	    182: 'Queued',\n	    183: 'Session Progress',\n	    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199\n	    200: 'OK',\n	    202: 'Accepted',  // RFC 3265\n	    204: 'No Notification',  //RFC 5839\n	    300: 'Multiple Choices',\n	    301: 'Moved Permanently',\n	    302: 'Moved Temporarily',\n	    305: 'Use Proxy',\n	    380: 'Alternative Service',\n	    400: 'Bad Request',\n	    401: 'Unauthorized',\n	    402: 'Payment Required',\n	    403: 'Forbidden',\n	    404: 'Not Found',\n	    405: 'Method Not Allowed',\n	    406: 'Not Acceptable',\n	    407: 'Proxy Authentication Required',\n	    408: 'Request Timeout',\n	    410: 'Gone',\n	    412: 'Conditional Request Failed',  // RFC 3903\n	    413: 'Request Entity Too Large',\n	    414: 'Request-URI Too Long',\n	    415: 'Unsupported Media Type',\n	    416: 'Unsupported URI Scheme',\n	    417: 'Unknown Resource-Priority',  // RFC 4412\n	    420: 'Bad Extension',\n	    421: 'Extension Required',\n	    422: 'Session Interval Too Small',  // RFC 4028\n	    423: 'Interval Too Brief',\n	    428: 'Use Identity Header',  // RFC 4474\n	    429: 'Provide Referrer Identity',  // RFC 3892\n	    430: 'Flow Failed',  // RFC 5626\n	    433: 'Anonymity Disallowed',  // RFC 5079\n	    436: 'Bad Identity-Info',  // RFC 4474\n	    437: 'Unsupported Certificate',  // RFC 4744\n	    438: 'Invalid Identity Header',  // RFC 4744\n	    439: 'First Hop Lacks Outbound Support',  // RFC 5626\n	    440: 'Max-Breadth Exceeded',  // RFC 5393\n	    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events\n	    470: 'Consent Needed',  // RFC 5360\n	    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.\n	    480: 'Temporarily Unavailable',\n	    481: 'Call/Transaction Does Not Exist',\n	    482: 'Loop Detected',\n	    483: 'Too Many Hops',\n	    484: 'Address Incomplete',\n	    485: 'Ambiguous',\n	    486: 'Busy Here',\n	    487: 'Request Terminated',\n	    488: 'Not Acceptable Here',\n	    489: 'Bad Event',  // RFC 3265\n	    491: 'Request Pending',\n	    493: 'Undecipherable',\n	    494: 'Security Agreement Required',  // RFC 3329\n	    500: 'Internal Server Error',\n	    501: 'Not Implemented',\n	    502: 'Bad Gateway',\n	    503: 'Service Unavailable',\n	    504: 'Server Time-out',\n	    505: 'Version Not Supported',\n	    513: 'Message Too Large',\n	    580: 'Precondition Failure',  // RFC 3312\n	    600: 'Busy Everywhere',\n	    603: 'Decline',\n	    604: 'Does Not Exist Anywhere',\n	    606: 'Not Acceptable'\n	  },\n	\n	  /* SIP Option Tags\n	   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4\n	   */\n	  OPTION_TAGS: {\n	    '100rel':                   true,  // RFC 3262\n	    199:                        true,  // RFC 6228\n	    answermode:                 true,  // RFC 5373\n	    'early-session':            true,  // RFC 3959\n	    eventlist:                  true,  // RFC 4662\n	    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n	    'from-change':              true,  // RFC 4916\n	    'geolocation-http':         true,  // RFC 6442\n	    'geolocation-sip':          true,  // RFC 6442\n	    gin:                        true,  // RFC 6140\n	    gruu:                       true,  // RFC 5627\n	    histinfo:                   true,  // RFC 7044\n	    ice:                        true,  // RFC 5768\n	    join:                       true,  // RFC 3911\n	    'multiple-refer':           true,  // RFC 5368\n	    norefersub:                 true,  // RFC 4488\n	    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n	    outbound:                   true,  // RFC 5626\n	    path:                       true,  // RFC 3327\n	    policy:                     true,  // RFC 6794\n	    precondition:               true,  // RFC 3312\n	    pref:                       true,  // RFC 3840\n	    privacy:                    true,  // RFC 3323\n	    'recipient-list-invite':    true,  // RFC 5366\n	    'recipient-list-message':   true,  // RFC 5365\n	    'recipient-list-subscribe': true,  // RFC 5367\n	    replaces:                   true,  // RFC 3891\n	    'resource-priority':        true,  // RFC 4412\n	    'sdp-anat':                 true,  // RFC 4092\n	    'sec-agree':                true,  // RFC 3329\n	    tdialog:                    true,  // RFC 4538\n	    timer:                      true,  // RFC 4028\n	    uui:                        true   // RFC 7433\n	  }\n	};\n	};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Exceptions\n	 */\n	\n	/**\n	 * SIP Exceptions.\n	 * @augments SIP\n	 */\n	module.exports = {\n	  ConfigurationError: (function(){\n	    var exception = function(parameter, value) {\n	      this.code = 1;\n	      this.name = 'CONFIGURATION_ERROR';\n	      this.parameter = parameter;\n	      this.value = value;\n	      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter \"'+ this.parameter +'\"';\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }()),\n	\n	  InvalidStateError: (function(){\n	    var exception = function(status) {\n	      this.code = 2;\n	      this.name = 'INVALID_STATE_ERROR';\n	      this.status = status;\n	      this.message = 'Invalid status: ' + status;\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }()),\n	\n	  NotSupportedError: (function(){\n	    var exception = function(message) {\n	      this.code = 3;\n	      this.name = 'NOT_SUPPORTED_ERROR';\n	      this.message = message;\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }()),\n	\n	  GetDescriptionError: (function(){\n	    var exception = function(message) {\n	      this.code = 4;\n	      this.name = 'GET_DESCRIPTION_ERROR';\n	      this.message = message;\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }())\n	};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP TIMERS\n	 */\n	\n	/**\n	 * @augments SIP\n	 */\n	var\n	  T1 = 500,\n	  T2 = 4000,\n	  T4 = 5000;\n	module.exports = function (timers) {\n	  var Timers = {\n	    T1: T1,\n	    T2: T2,\n	    T4: T4,\n	    TIMER_B: 64 * T1,\n	    TIMER_D: 0  * T1,\n	    TIMER_F: 64 * T1,\n	    TIMER_H: 64 * T1,\n	    TIMER_I: 0  * T1,\n	    TIMER_J: 0  * T1,\n	    TIMER_K: 0  * T4,\n	    TIMER_L: 64 * T1,\n	    TIMER_M: 64 * T1,\n	    TIMER_N: 64 * T1,\n	    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1\n	  };\n	\n	  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']\n	  .forEach(function (name) {\n	    // can't just use timers[name].bind(timers) since it bypasses jasmine's\n	    // clock-mocking\n	    Timers[name] = function () {\n	      return timers[name].apply(timers, arguments);\n	    };\n	  });\n	\n	  return Timers;\n	};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Message Parser\n	 */\n	\n	/**\n	 * Extract and parse every header of a SIP message.\n	 * @augments SIP\n	 * @namespace\n	 */\n	module.exports = function (SIP) {\n	var Parser;\n	\n	function getHeader(data, headerStart) {\n	  var\n	    // 'start' position of the header.\n	    start = headerStart,\n	    // 'end' position of the header.\n	    end = 0,\n	    // 'partial end' position of the header.\n	    partialEnd = 0;\n	\n	  //End of message.\n	  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n	    return -2;\n	  }\n	\n	  while(end === 0) {\n	    // Partial End of Header.\n	    partialEnd = data.indexOf('\\r\\n', start);\n	\n	    // 'indexOf' returns -1 if the value to be found never occurs.\n	    if (partialEnd === -1) {\n	      return partialEnd;\n	    }\n	\n	    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n	      // Not the end of the message. Continue from the next position.\n	      start = partialEnd + 2;\n	    } else {\n	      end = partialEnd;\n	    }\n	  }\n	\n	  return end;\n	}\n	\n	function parseHeader(message, data, headerStart, headerEnd) {\n	  var header, idx, length, parsed,\n	    hcolonIndex = data.indexOf(':', headerStart),\n	    headerName = data.substring(headerStart, hcolonIndex).trim(),\n	    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n	\n	  // If header-field is well-known, parse it.\n	  switch(headerName.toLowerCase()) {\n	    case 'via':\n	    case 'v':\n	      message.addHeader('via', headerValue);\n	      if(message.getHeaders('via').length === 1) {\n	        parsed = message.parseHeader('Via');\n	        if(parsed) {\n	          message.via = parsed;\n	          message.via_branch = parsed.branch;\n	        }\n	      } else {\n	        parsed = 0;\n	      }\n	      break;\n	    case 'from':\n	    case 'f':\n	      message.setHeader('from', headerValue);\n	      parsed = message.parseHeader('from');\n	      if(parsed) {\n	        message.from = parsed;\n	        message.from_tag = parsed.getParam('tag');\n	      }\n	      break;\n	    case 'to':\n	    case 't':\n	      message.setHeader('to', headerValue);\n	      parsed = message.parseHeader('to');\n	      if(parsed) {\n	        message.to = parsed;\n	        message.to_tag = parsed.getParam('tag');\n	      }\n	      break;\n	    case 'record-route':\n	      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n	\n	      if (parsed === -1) {\n	        parsed = undefined;\n	        break;\n	      }\n	\n	      length = parsed.length;\n	      for (idx = 0; idx < length; idx++) {\n	        header = parsed[idx];\n	        message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n	        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n	      }\n	      break;\n	    case 'call-id':\n	    case 'i':\n	      message.setHeader('call-id', headerValue);\n	      parsed = message.parseHeader('call-id');\n	      if(parsed) {\n	        message.call_id = headerValue;\n	      }\n	      break;\n	    case 'contact':\n	    case 'm':\n	      parsed = SIP.Grammar.parse(headerValue, 'Contact');\n	\n	      if (parsed === -1) {\n	        parsed = undefined;\n	        break;\n	      }\n	\n	      length = parsed.length;\n	      for (idx = 0; idx < length; idx++) {\n	        header = parsed[idx];\n	        message.addHeader('contact', headerValue.substring(header.position, header.offset));\n	        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n	      }\n	      break;\n	    case 'content-length':\n	    case 'l':\n	      message.setHeader('content-length', headerValue);\n	      parsed = message.parseHeader('content-length');\n	      break;\n	    case 'content-type':\n	    case 'c':\n	      message.setHeader('content-type', headerValue);\n	      parsed = message.parseHeader('content-type');\n	      break;\n	    case 'cseq':\n	      message.setHeader('cseq', headerValue);\n	      parsed = message.parseHeader('cseq');\n	      if(parsed) {\n	        message.cseq = parsed.value;\n	      }\n	      if(message instanceof SIP.IncomingResponse) {\n	        message.method = parsed.method;\n	      }\n	      break;\n	    case 'max-forwards':\n	      message.setHeader('max-forwards', headerValue);\n	      parsed = message.parseHeader('max-forwards');\n	      break;\n	    case 'www-authenticate':\n	      message.setHeader('www-authenticate', headerValue);\n	      parsed = message.parseHeader('www-authenticate');\n	      break;\n	    case 'proxy-authenticate':\n	      message.setHeader('proxy-authenticate', headerValue);\n	      parsed = message.parseHeader('proxy-authenticate');\n	      break;\n	    case 'refer-to':\n	    case 'r':\n	      message.setHeader('refer-to', headerValue);\n	      parsed = message.parseHeader('refer-to');\n	      if (parsed) {\n	        message.refer_to = parsed;\n	      }\n	      break;\n	    default:\n	      // Do not parse this header.\n	      message.setHeader(headerName, headerValue);\n	      parsed = 0;\n	  }\n	\n	  if (parsed === undefined) {\n	    return {\n	      error: 'error parsing header \"'+ headerName +'\"'\n	    };\n	  } else {\n	    return true;\n	  }\n	}\n	\n	/** Parse SIP Message\n	 * @function\n	 * @param {String} message SIP message.\n	 * @param {Object} logger object.\n	 * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n	 */\n	Parser = {};\n	Parser.parseMessage = function(data, ua) {\n	  var message, firstLine, contentLength, bodyStart, parsed,\n	    headerStart = 0,\n	    headerEnd = data.indexOf('\\r\\n'),\n	    logger = ua.getLogger('sip.parser');\n	\n	  if(headerEnd === -1) {\n	    logger.warn('no CRLF found, not a SIP message, discarded');\n	    return;\n	  }\n	\n	  // Parse first line. Check if it is a Request or a Reply.\n	  firstLine = data.substring(0, headerEnd);\n	  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n	\n	  if(parsed === -1) {\n	    logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n	    return;\n	  } else if(!parsed.status_code) {\n	    message = new SIP.IncomingRequest(ua);\n	    message.method = parsed.method;\n	    message.ruri = parsed.uri;\n	  } else {\n	    message = new SIP.IncomingResponse(ua);\n	    message.status_code = parsed.status_code;\n	    message.reason_phrase = parsed.reason_phrase;\n	  }\n	\n	  message.data = data;\n	  headerStart = headerEnd + 2;\n	\n	  /* Loop over every line in data. Detect the end of each header and parse\n	  * it or simply add to the headers collection.\n	  */\n	  while(true) {\n	    headerEnd = getHeader(data, headerStart);\n	\n	    // The SIP message has normally finished.\n	    if(headerEnd === -2) {\n	      bodyStart = headerStart + 2;\n	      break;\n	    }\n	    // data.indexOf returned -1 due to a malformed message.\n	    else if(headerEnd === -1) {\n	      logger.error('malformed message');\n	      return;\n	    }\n	\n	    parsed = parseHeader(message, data, headerStart, headerEnd);\n	\n	    if(parsed !== true) {\n	      logger.error(parsed.error);\n	      return;\n	    }\n	\n	    headerStart = headerEnd + 2;\n	  }\n	\n	  /* RFC3261 18.3.\n	   * If there are additional bytes in the transport packet\n	   * beyond the end of the body, they MUST be discarded.\n	   */\n	  if(message.hasHeader('content-length')) {\n	    contentLength = message.getHeader('content-length');\n	    message.body = data.substr(bodyStart, contentLength);\n	  } else {\n	    message.body = data.substring(bodyStart);\n	  }\n	\n	  return message;\n	};\n	\n	SIP.Parser = Parser;\n	};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Message\n	 */\n	\n	module.exports = function (SIP) {\n	var\n	  OutgoingRequest,\n	  IncomingMessage,\n	  IncomingRequest,\n	  IncomingResponse;\n	\n	function getSupportedHeader (request) {\n	  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;\n	  var optionTags = [];\n	  var optionTagSet = {};\n	\n	  if (request.method === SIP.C.REGISTER) {\n	    optionTags.push('path', 'gruu');\n	  } else if (request.method === SIP.C.INVITE &&\n	             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {\n	    optionTags.push('gruu');\n	  }\n	\n	  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n	    optionTags.push('100rel');\n	  }\n	  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {\n	    optionTags.push('replaces');\n	  }\n	\n	  optionTags.push('outbound');\n	\n	  optionTags = optionTags.concat(request.ua.configuration.extraSupported);\n	\n	  optionTags = optionTags.filter(function(optionTag) {\n	    var registered = SIP.C.OPTION_TAGS[optionTag];\n	    var unique = !optionTagSet[optionTag];\n	    optionTagSet[optionTag] = true;\n	    return (registered || allowUnregistered) && unique;\n	  });\n	\n	  return 'Supported: ' + optionTags.join(', ') + '\\r\\n';\n	}\n	\n	/**\n	 * @augments SIP\n	 * @class Class for outgoing SIP request.\n	 * @param {String} method request method\n	 * @param {String} ruri request uri\n	 * @param {SIP.UA} ua\n	 * @param {Object} params parameters that will have priority over ua.configuration parameters:\n	 * <br>\n	 *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set\n	 * @param {Object} [headers] extra headers\n	 * @param {String} [body]\n	 */\n	OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {\n	  var\n	    to,\n	    from,\n	    call_id,\n	    cseq,\n	    to_uri,\n	    from_uri;\n	\n	  params = params || {};\n	\n	  // Mandatory parameters check\n	  if(!method || !ruri || !ua) {\n	    return null;\n	  }\n	\n	  this.logger = ua.getLogger('sip.sipmessage');\n	  this.ua = ua;\n	  this.headers = {};\n	  this.method = method;\n	  this.ruri = ruri;\n	  this.body = body;\n	  this.extraHeaders = (extraHeaders || []).slice();\n	  this.statusCode = params.status_code;\n	  this.reasonPhrase = params.reason_phrase;\n	\n	  // Fill the Common SIP Request Headers\n	\n	  // Route\n	  if (params.route_set) {\n	    this.setHeader('route', params.route_set);\n	  } else if (ua.configuration.usePreloadedRoute){\n	    this.setHeader('route', ua.transport.server.sip_uri);\n	  }\n	\n	  // Via\n	  // Empty Via header. Will be filled by the client transaction.\n	  this.setHeader('via', '');\n	\n	  // Max-Forwards\n	  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);\n	\n	  // To\n	  to_uri = params.to_uri || ruri;\n	  to = (params.to_displayName || params.to_displayName === 0) ? '\"' + params.to_displayName + '\" ' : '';\n	  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';\n	  to += params.to_tag ? ';tag=' + params.to_tag : '';\n	  this.to = new SIP.NameAddrHeader.parse(to);\n	  this.setHeader('to', to);\n	\n	  // From\n	  from_uri = params.from_uri || ua.configuration.uri;\n	  if (params.from_displayName || params.from_displayName === 0) {\n	    from = '\"' + params.from_displayName + '\" ';\n	  } else if (ua.configuration.displayName) {\n	    from = '\"' + ua.configuration.displayName + '\" ';\n	  } else {\n	    from = '';\n	  }\n	  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';\n	  from += params.from_tag || SIP.Utils.newTag();\n	  this.from = new SIP.NameAddrHeader.parse(from);\n	  this.setHeader('from', from);\n	\n	  // Call-ID\n	  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));\n	  this.call_id = call_id;\n	  this.setHeader('call-id', call_id);\n	\n	  // CSeq\n	  cseq = params.cseq || Math.floor(Math.random() * 10000);\n	  this.cseq = cseq;\n	  this.setHeader('cseq', cseq + ' ' + method);\n	};\n	\n	OutgoingRequest.prototype = {\n	  /**\n	   * Replace the the given header by the given value.\n	   * @param {String} name header name\n	   * @param {String | Array} value header value\n	   */\n	  setHeader: function(name, value) {\n	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n	  },\n	\n	  /**\n	   * Get the value of the given header name at the given position.\n	   * @param {String} name header name\n	   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.\n	   */\n	  getHeader: function(name) {\n	    var regexp, idx,\n	      length = this.extraHeaders.length,\n	      header = this.headers[SIP.Utils.headerize(name)];\n	\n	    if(header) {\n	      if(header[0]) {\n	        return header[0];\n	      }\n	    } else {\n	      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n	      for (idx = 0; idx < length; idx++) {\n	        header = this.extraHeaders[idx];\n	        if (regexp.test(header)) {\n	          return header.substring(header.indexOf(':')+1).trim();\n	        }\n	      }\n	    }\n	\n	    return;\n	  },\n	\n	  /**\n	   * Get the header/s of the given name.\n	   * @param {String} name header name\n	   * @returns {Array} Array with all the headers of the specified name.\n	   */\n	  getHeaders: function(name) {\n	    var idx, length, regexp,\n	      header = this.headers[SIP.Utils.headerize(name)],\n	      result = [];\n	\n	    if(header) {\n	      length = header.length;\n	      for (idx = 0; idx < length; idx++) {\n	        result.push(header[idx]);\n	      }\n	      return result;\n	    } else {\n	      length = this.extraHeaders.length;\n	      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n	      for (idx = 0; idx < length; idx++) {\n	        header = this.extraHeaders[idx];\n	        if (regexp.test(header)) {\n	          result.push(header.substring(header.indexOf(':')+1).trim());\n	        }\n	      }\n	      return result;\n	    }\n	  },\n	\n	  /**\n	   * Verify the existence of the given header.\n	   * @param {String} name header name\n	   * @returns {boolean} true if header with given name exists, false otherwise\n	   */\n	  hasHeader: function(name) {\n	    var regexp, idx,\n	      length = this.extraHeaders.length;\n	\n	    if (this.headers[SIP.Utils.headerize(name)]) {\n	      return true;\n	    } else {\n	      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n	      for (idx = 0; idx < length; idx++) {\n	        if (regexp.test(this.extraHeaders[idx])) {\n	          return true;\n	        }\n	      }\n	    }\n	\n	    return false;\n	  },\n	\n	  toString: function() {\n	    var msg = '', header, length, idx;\n	\n	    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\\r\\n';\n	\n	    for (header in this.headers) {\n	      length = this.headers[header].length;\n	      for (idx = 0; idx < length; idx++) {\n	        msg += header + ': ' + this.headers[header][idx] + '\\r\\n';\n	      }\n	    }\n	\n	    length = this.extraHeaders.length;\n	    for (idx = 0; idx < length; idx++) {\n	      msg += this.extraHeaders[idx].trim() +'\\r\\n';\n	    }\n	\n	    msg += getSupportedHeader(this);\n	    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n	\n	    if(this.body) {\n	      length = SIP.Utils.str_utf8_length(this.body);\n	      msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n	      msg += this.body;\n	    } else {\n	      msg += 'Content-Length: 0\\r\\n\\r\\n';\n	    }\n	\n	    return msg;\n	  }\n	};\n	\n	/**\n	 * @augments SIP\n	 * @class Class for incoming SIP message.\n	 */\n	IncomingMessage = function(){\n	  this.data = null;\n	  this.headers = null;\n	  this.method =  null;\n	  this.via = null;\n	  this.via_branch = null;\n	  this.call_id = null;\n	  this.cseq = null;\n	  this.from = null;\n	  this.from_tag = null;\n	  this.to = null;\n	  this.to_tag = null;\n	  this.body = null;\n	};\n	\n	IncomingMessage.prototype = {\n	  /**\n	  * Insert a header of the given name and value into the last position of the\n	  * header array.\n	  * @param {String} name header name\n	  * @param {String} value header value\n	  */\n	  addHeader: function(name, value) {\n	    var header = { raw: value };\n	\n	    name = SIP.Utils.headerize(name);\n	\n	    if(this.headers[name]) {\n	      this.headers[name].push(header);\n	    } else {\n	      this.headers[name] = [header];\n	    }\n	  },\n	\n	  /**\n	   * Get the value of the given header name at the given position.\n	   * @param {String} name header name\n	   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.\n	   */\n	  getHeader: function(name) {\n	    var header = this.headers[SIP.Utils.headerize(name)];\n	\n	    if(header) {\n	      if(header[0]) {\n	        return header[0].raw;\n	      }\n	    } else {\n	      return;\n	    }\n	  },\n	\n	  /**\n	   * Get the header/s of the given name.\n	   * @param {String} name header name\n	   * @returns {Array} Array with all the headers of the specified name.\n	   */\n	  getHeaders: function(name) {\n	    var idx, length,\n	      header = this.headers[SIP.Utils.headerize(name)],\n	      result = [];\n	\n	    if(!header) {\n	      return [];\n	    }\n	\n	    length = header.length;\n	    for (idx = 0; idx < length; idx++) {\n	      result.push(header[idx].raw);\n	    }\n	\n	    return result;\n	  },\n	\n	  /**\n	   * Verify the existence of the given header.\n	   * @param {String} name header name\n	   * @returns {boolean} true if header with given name exists, false otherwise\n	   */\n	  hasHeader: function(name) {\n	    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;\n	  },\n	\n	  /**\n	  * Parse the given header on the given index.\n	  * @param {String} name header name\n	  * @param {Number} [idx=0] header index\n	  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n	  */\n	  parseHeader: function(name, idx) {\n	    var header, value, parsed;\n	\n	    name = SIP.Utils.headerize(name);\n	\n	    idx = idx || 0;\n	\n	    if(!this.headers[name]) {\n	      this.logger.log('header \"' + name + '\" not present');\n	      return;\n	    } else if(idx >= this.headers[name].length) {\n	      this.logger.log('not so many \"' + name + '\" headers present');\n	      return;\n	    }\n	\n	    header = this.headers[name][idx];\n	    value = header.raw;\n	\n	    if(header.parsed) {\n	      return header.parsed;\n	    }\n	\n	    //substitute '-' by '_' for grammar rule matching.\n	    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));\n	\n	    if(parsed === -1) {\n	      this.headers[name].splice(idx, 1); //delete from headers\n	      this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n	      return;\n	    } else {\n	      header.parsed = parsed;\n	      return parsed;\n	    }\n	  },\n	\n	  /**\n	   * Message Header attribute selector. Alias of parseHeader.\n	   * @param {String} name header name\n	   * @param {Number} [idx=0] header index\n	   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n	   *\n	   * @example\n	   * message.s('via',3).port\n	   */\n	  s: function(name, idx) {\n	    return this.parseHeader(name, idx);\n	  },\n	\n	  /**\n	  * Replace the value of the given header by the value.\n	  * @param {String} name header name\n	  * @param {String} value header value\n	  */\n	  setHeader: function(name, value) {\n	    var header = { raw: value };\n	    this.headers[SIP.Utils.headerize(name)] = [header];\n	  },\n	\n	  toString: function() {\n	    return this.data;\n	  }\n	};\n	\n	/**\n	 * @augments IncomingMessage\n	 * @class Class for incoming SIP request.\n	 */\n	IncomingRequest = function(ua) {\n	  this.logger = ua.getLogger('sip.sipmessage');\n	  this.ua = ua;\n	  this.headers = {};\n	  this.ruri = null;\n	  this.transport = null;\n	  this.server_transaction = null;\n	};\n	IncomingRequest.prototype = new IncomingMessage();\n	\n	/**\n	* Stateful reply.\n	* @param {Number} code status code\n	* @param {String} reason reason phrase\n	* @param {Object} headers extra headers\n	* @param {String} body body\n	* @param {Function} [onSuccess] onSuccess callback\n	* @param {Function} [onFailure] onFailure callback\n	*/\n	IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {\n	  var rr, vias, length, idx, response,\n	    to = this.getHeader('To'),\n	    r = 0,\n	    v = 0;\n	\n	  response = SIP.Utils.buildStatusLine(code, reason);\n	  extraHeaders = (extraHeaders || []).slice();\n	\n	  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {\n	    rr = this.getHeaders('record-route');\n	    length = rr.length;\n	\n	    for(r; r < length; r++) {\n	      response += 'Record-Route: ' + rr[r] + '\\r\\n';\n	    }\n	  }\n	\n	  vias = this.getHeaders('via');\n	  length = vias.length;\n	\n	  for(v; v < length; v++) {\n	    response += 'Via: ' + vias[v] + '\\r\\n';\n	  }\n	\n	  if(!this.to_tag && code > 100) {\n	    to += ';tag=' + SIP.Utils.newTag();\n	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n	    to += ';tag=' + this.to_tag;\n	  }\n	\n	  response += 'To: ' + to + '\\r\\n';\n	  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n	  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n	\n	  length = extraHeaders.length;\n	  for (idx = 0; idx < length; idx++) {\n	    response += extraHeaders[idx].trim() +'\\r\\n';\n	  }\n	\n	  response += getSupportedHeader(this);\n	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n	\n	  if(body) {\n	    length = SIP.Utils.str_utf8_length(body);\n	    response += 'Content-Type: application/sdp\\r\\n';\n	    response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n	    response += body;\n	  } else {\n	    response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n	  }\n	\n	  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);\n	\n	  return response;\n	};\n	\n	/**\n	* Stateless reply.\n	* @param {Number} code status code\n	* @param {String} reason reason phrase\n	*/\n	IncomingRequest.prototype.reply_sl = function(code, reason) {\n	  var to, response,\n	    v = 0,\n	    vias = this.getHeaders('via'),\n	    length = vias.length;\n	\n	  response = SIP.Utils.buildStatusLine(code, reason);\n	\n	  for(v; v < length; v++) {\n	    response += 'Via: ' + vias[v] + '\\r\\n';\n	  }\n	\n	  to = this.getHeader('To');\n	\n	  if(!this.to_tag && code > 100) {\n	    to += ';tag=' + SIP.Utils.newTag();\n	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n	    to += ';tag=' + this.to_tag;\n	  }\n	\n	  response += 'To: ' + to + '\\r\\n';\n	  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n	  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n	  response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n	\n	  this.transport.send(response);\n	};\n	\n	\n	/**\n	 * @augments IncomingMessage\n	 * @class Class for incoming SIP response.\n	 */\n	IncomingResponse = function(ua) {\n	  this.logger = ua.getLogger('sip.sipmessage');\n	  this.headers = {};\n	  this.status_code = null;\n	  this.reason_phrase = null;\n	};\n	IncomingResponse.prototype = new IncomingMessage();\n	\n	SIP.OutgoingRequest = OutgoingRequest;\n	SIP.IncomingRequest = IncomingRequest;\n	SIP.IncomingResponse = IncomingResponse;\n	};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP URI\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP URI.\n	 *\n	 * @param {String} [scheme]\n	 * @param {String} [user]\n	 * @param {String} host\n	 * @param {String} [port]\n	 * @param {Object} [parameters]\n	 * @param {Object} [headers]\n	 *\n	 */\n	module.exports = function (SIP) {\n	var URI;\n	\n	URI = function(scheme, user, host, port, parameters, headers) {\n	  var param, header, raw, normal;\n	\n	  // Checks\n	  if(!host) {\n	    throw new TypeError('missing or invalid \"host\" parameter');\n	  }\n	\n	  // Initialize parameters\n	  scheme = scheme || SIP.C.SIP;\n	  this.parameters = {};\n	  this.headers = {};\n	\n	  for (param in parameters) {\n	    this.setParam(param, parameters[param]);\n	  }\n	\n	  for (header in headers) {\n	    this.setHeader(header, headers[header]);\n	  }\n	\n	  // Raw URI\n	  raw = {\n	    scheme: scheme,\n	    user: user,\n	    host: host,\n	    port: port\n	  };\n	\n	  // Normalized URI\n	  normal = {\n	    scheme: scheme.toLowerCase(),\n	    user: user,\n	    host: host.toLowerCase(),\n	    port: port\n	  };\n	\n	  Object.defineProperties(this, {\n	    _normal: {\n	      get: function() { return normal; }\n	    },\n	\n	    _raw: {\n	      get: function() { return raw; }\n	    },\n	\n	    scheme: {\n	      get: function() { return normal.scheme; },\n	      set: function(value) {\n	        raw.scheme = value;\n	        normal.scheme = value.toLowerCase();\n	      }\n	    },\n	\n	    user: {\n	      get: function() { return normal.user; },\n	      set: function(value) {\n	        normal.user = raw.user = value;\n	      }\n	    },\n	\n	    host: {\n	      get: function() { return normal.host; },\n	      set: function(value) {\n	        raw.host = value;\n	        normal.host = value.toLowerCase();\n	      }\n	    },\n	\n	    aor: {\n	      get: function() { return normal.user + '@' + normal.host; }\n	    },\n	\n	    port: {\n	      get: function() { return normal.port; },\n	      set: function(value) {\n	        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);\n	      }\n	    }\n	  });\n	};\n	\n	URI.prototype = {\n	  setParam: function(key, value) {\n	    if(key) {\n	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();\n	    }\n	  },\n	\n	  getParam: function(key) {\n	    if(key) {\n	      return this.parameters[key.toLowerCase()];\n	    }\n	  },\n	\n	  hasParam: function(key) {\n	    if(key) {\n	      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n	    }\n	  },\n	\n	  deleteParam: function(parameter) {\n	    var value;\n	    parameter = parameter.toLowerCase();\n	    if (this.parameters.hasOwnProperty(parameter)) {\n	      value = this.parameters[parameter];\n	      delete this.parameters[parameter];\n	      return value;\n	    }\n	  },\n	\n	  clearParams: function() {\n	    this.parameters = {};\n	  },\n	\n	  setHeader: function(name, value) {\n	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n	  },\n	\n	  getHeader: function(name) {\n	    if(name) {\n	      return this.headers[SIP.Utils.headerize(name)];\n	    }\n	  },\n	\n	  hasHeader: function(name) {\n	    if(name) {\n	      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;\n	    }\n	  },\n	\n	  deleteHeader: function(header) {\n	    var value;\n	    header = SIP.Utils.headerize(header);\n	    if(this.headers.hasOwnProperty(header)) {\n	      value = this.headers[header];\n	      delete this.headers[header];\n	      return value;\n	    }\n	  },\n	\n	  clearHeaders: function() {\n	    this.headers = {};\n	  },\n	\n	  clone: function() {\n	    return new URI(\n	      this._raw.scheme,\n	      this._raw.user,\n	      this._raw.host,\n	      this._raw.port,\n	      JSON.parse(JSON.stringify(this.parameters)),\n	      JSON.parse(JSON.stringify(this.headers)));\n	  },\n	\n	  toRaw: function() {\n	    return this._toString(this._raw);\n	  },\n	\n	  toString: function() {\n	    return this._toString(this._normal);\n	  },\n	\n	  _toString: function(uri) {\n	    var header, parameter, idx, uriString, headers = [];\n	\n	    uriString  = uri.scheme + ':';\n	    // add slashes if it's not a sip(s) URI\n	    if (!uri.scheme.toLowerCase().match(\"^sips?$\")) {\n	      uriString += \"//\";\n	    }\n	    if (uri.user) {\n	      uriString += SIP.Utils.escapeUser(uri.user) + '@';\n	    }\n	    uriString += uri.host;\n	    if (uri.port || uri.port === 0) {\n	      uriString += ':' + uri.port;\n	    }\n	\n	    for (parameter in this.parameters) {\n	      uriString += ';' + parameter;\n	\n	      if (this.parameters[parameter] !== null) {\n	        uriString += '='+ this.parameters[parameter];\n	      }\n	    }\n	\n	    for(header in this.headers) {\n	      for(idx in this.headers[header]) {\n	        headers.push(header + '=' + this.headers[header][idx]);\n	      }\n	    }\n	\n	    if (headers.length > 0) {\n	      uriString += '?' + headers.join('&');\n	    }\n	\n	    return uriString;\n	  }\n	};\n	\n	\n	/**\n	  * Parse the given string and returns a SIP.URI instance or undefined if\n	  * it is an invalid URI.\n	  * @public\n	  * @param {String} uri\n	  */\n	URI.parse = function(uri) {\n	  uri = SIP.Grammar.parse(uri,'SIP_URI');\n	\n	  if (uri !== -1) {\n	    return uri;\n	  } else {\n	    return undefined;\n	  }\n	};\n	\n	SIP.URI = URI;\n	};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP NameAddrHeader\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a Name Address SIP header.\n	 *\n	 * @param {SIP.URI} uri\n	 * @param {String} [displayName]\n	 * @param {Object} [parameters]\n	 *\n	 */\n	module.exports = function (SIP) {\n	var NameAddrHeader;\n	\n	NameAddrHeader = function(uri, displayName, parameters) {\n	  var param;\n	\n	  // Checks\n	  if(!uri || !(uri instanceof SIP.URI)) {\n	    throw new TypeError('missing or invalid \"uri\" parameter');\n	  }\n	\n	  // Initialize parameters\n	  this.uri = uri;\n	  this.parameters = {};\n	\n	  for (param in parameters) {\n	    this.setParam(param, parameters[param]);\n	  }\n	\n	  Object.defineProperties(this, {\n	    friendlyName: {\n	      get: function() { return this.displayName || uri.aor; }\n	    },\n	\n	    displayName: {\n	      get: function() { return displayName; },\n	      set: function(value) {\n	        displayName = (value === 0) ? '0' : value;\n	      }\n	    }\n	  });\n	};\n	NameAddrHeader.prototype = {\n	  setParam: function (key, value) {\n	    if(key) {\n	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n	    }\n	  },\n	  getParam: SIP.URI.prototype.getParam,\n	  hasParam: SIP.URI.prototype.hasParam,\n	  deleteParam: SIP.URI.prototype.deleteParam,\n	  clearParams: SIP.URI.prototype.clearParams,\n	\n	  clone: function() {\n	    return new NameAddrHeader(\n	      this.uri.clone(),\n	      this.displayName,\n	      JSON.parse(JSON.stringify(this.parameters)));\n	  },\n	\n	  toString: function() {\n	    var body, parameter;\n	\n	    body  = (this.displayName || this.displayName === 0) ? '\"' + this.displayName + '\" ' : '';\n	    body += '<' + this.uri.toString() + '>';\n	\n	    for (parameter in this.parameters) {\n	      body += ';' + parameter;\n	\n	      if (this.parameters[parameter] !== null) {\n	        body += '='+ this.parameters[parameter];\n	      }\n	    }\n	\n	    return body;\n	  }\n	};\n	\n	\n	/**\n	  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n	  * it is an invalid NameAddrHeader.\n	  * @public\n	  * @param {String} name_addr_header\n	  */\n	NameAddrHeader.parse = function(name_addr_header) {\n	  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');\n	\n	  if (name_addr_header !== -1) {\n	    return name_addr_header;\n	  } else {\n	    return undefined;\n	  }\n	};\n	\n	SIP.NameAddrHeader = NameAddrHeader;\n	};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Transactions\n	 */\n	\n	/**\n	 * SIP Transactions module.\n	 * @augments SIP\n	 */\n	module.exports = function (SIP) {\n	var\n	  C = {\n	    // Transaction states\n	    STATUS_TRYING:     1,\n	    STATUS_PROCEEDING: 2,\n	    STATUS_CALLING:    3,\n	    STATUS_ACCEPTED:   4,\n	    STATUS_COMPLETED:  5,\n	    STATUS_TERMINATED: 6,\n	    STATUS_CONFIRMED:  7,\n	\n	    // Transaction types\n	    NON_INVITE_CLIENT: 'nict',\n	    NON_INVITE_SERVER: 'nist',\n	    INVITE_CLIENT: 'ict',\n	    INVITE_SERVER: 'ist'\n	  };\n	\n	function buildViaHeader (request_sender, transport, id) {\n	  var via;\n	  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n	  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;\n	  if (request_sender.ua.configuration.forceRport) {\n	    via += ';rport';\n	  }\n	  return via;\n	}\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Non Invite Client Transaction\n	* @param {SIP.RequestSender} request_sender\n	* @param {SIP.OutgoingRequest} request\n	* @param {SIP.Transport} transport\n	*/\n	var NonInviteClientTransaction = function(request_sender, request, transport) {\n	  var via;\n	\n	  this.type = C.NON_INVITE_CLIENT;\n	  this.transport = transport;\n	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n	  this.request_sender = request_sender;\n	  this.request = request;\n	\n	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n	\n	  via = buildViaHeader(request_sender, transport, this.id);\n	  this.request.setHeader('via', via);\n	\n	  this.request_sender.ua.newTransaction(this);\n	};\n	NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	NonInviteClientTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	NonInviteClientTransaction.prototype.send = function() {\n	  var tr = this;\n	\n	  this.stateChanged(C.STATUS_TRYING);\n	  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n	\n	  if(!this.transport.send(this.request)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	NonInviteClientTransaction.prototype.onTransportError = function() {\n	  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n	  SIP.Timers.clearTimeout(this.F);\n	  SIP.Timers.clearTimeout(this.K);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	  this.request_sender.onTransportError();\n	};\n	\n	NonInviteClientTransaction.prototype.timer_F = function() {\n	  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	  this.request_sender.onRequestTimeout();\n	};\n	\n	NonInviteClientTransaction.prototype.timer_K = function() {\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	};\n	\n	NonInviteClientTransaction.prototype.receiveResponse = function(response) {\n	  var\n	    tr = this,\n	    status_code = response.status_code;\n	\n	  if(status_code < 200) {\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_PROCEEDING);\n	        this.request_sender.receiveResponse(response);\n	        break;\n	    }\n	  } else {\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_COMPLETED);\n	        SIP.Timers.clearTimeout(this.F);\n	\n	        if(status_code === 408) {\n	          this.request_sender.onRequestTimeout();\n	        } else {\n	          this.request_sender.receiveResponse(response);\n	        }\n	\n	        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n	        break;\n	      case C.STATUS_COMPLETED:\n	        break;\n	    }\n	  }\n	};\n	\n	\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Invite Client Transaction\n	* @param {SIP.RequestSender} request_sender\n	* @param {SIP.OutgoingRequest} request\n	* @param {SIP.Transport} transport\n	*/\n	var InviteClientTransaction = function(request_sender, request, transport) {\n	  var via,\n	    tr = this;\n	\n	  this.type = C.INVITE_CLIENT;\n	  this.transport = transport;\n	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n	  this.request_sender = request_sender;\n	  this.request = request;\n	\n	  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n	\n	  via = buildViaHeader(request_sender, transport, this.id);\n	  this.request.setHeader('via', via);\n	\n	  this.request_sender.ua.newTransaction(this);\n	\n	  // Add the cancel property to the request.\n	  //Will be called from the request instance, not the transaction itself.\n	  this.request.cancel = function(reason) {\n	    tr.cancel_request(tr, reason);\n	  };\n	};\n	InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	InviteClientTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	InviteClientTransaction.prototype.send = function() {\n	  var tr = this;\n	  this.stateChanged(C.STATUS_CALLING);\n	  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n	\n	  if(!this.transport.send(this.request)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	InviteClientTransaction.prototype.onTransportError = function() {\n	  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n	  SIP.Timers.clearTimeout(this.B);\n	  SIP.Timers.clearTimeout(this.D);\n	  SIP.Timers.clearTimeout(this.M);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	\n	  if (this.state !== C.STATUS_ACCEPTED) {\n	    this.request_sender.onTransportError();\n	  }\n	};\n	\n	// RFC 6026 7.2\n	InviteClientTransaction.prototype.timer_M = function() {\n	  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);\n	\n	  if(this.state === C.STATUS_ACCEPTED) {\n	    SIP.Timers.clearTimeout(this.B);\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.request_sender.ua.destroyTransaction(this);\n	  }\n	};\n	\n	// RFC 3261 17.1.1\n	InviteClientTransaction.prototype.timer_B = function() {\n	  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);\n	  if(this.state === C.STATUS_CALLING) {\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.request_sender.ua.destroyTransaction(this);\n	    this.request_sender.onRequestTimeout();\n	  }\n	};\n	\n	InviteClientTransaction.prototype.timer_D = function() {\n	  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);\n	  SIP.Timers.clearTimeout(this.B);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	};\n	\n	InviteClientTransaction.prototype.sendACK = function(response) {\n	  var tr = this;\n	\n	  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\\r\\n';\n	  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\\r\\n';\n	\n	  if(this.request.headers['Route']) {\n	    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\\r\\n';\n	  }\n	\n	  this.ack += 'To: ' + response.getHeader('to') + '\\r\\n';\n	  this.ack += 'From: ' + this.request.headers['From'].toString() + '\\r\\n';\n	  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\\r\\n';\n	  this.ack += 'Content-Length: 0\\r\\n';\n	  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];\n	  this.ack += ' ACK\\r\\n\\r\\n';\n	\n	  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);\n	\n	  this.transport.send(this.ack);\n	};\n	\n	InviteClientTransaction.prototype.cancel_request = function(tr, reason) {\n	  var request = tr.request;\n	\n	  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n	  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n	\n	  if(this.request.headers['Route']) {\n	    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n	  }\n	\n	  this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n	  this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n	  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n	  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +\n	  ' CANCEL\\r\\n';\n	\n	  if(reason) {\n	    this.cancel += 'Reason: ' + reason + '\\r\\n';\n	  }\n	\n	  this.cancel += 'Content-Length: 0\\r\\n\\r\\n';\n	\n	  // Send only if a provisional response (>100) has been received.\n	  if(this.state === C.STATUS_PROCEEDING) {\n	    this.transport.send(this.cancel);\n	  }\n	};\n	\n	InviteClientTransaction.prototype.receiveResponse = function(response) {\n	  var\n	  tr = this,\n	  status_code = response.status_code;\n	\n	  if(status_code >= 100 && status_code <= 199) {\n	    switch(this.state) {\n	      case C.STATUS_CALLING:\n	        this.stateChanged(C.STATUS_PROCEEDING);\n	        this.request_sender.receiveResponse(response);\n	        if(this.cancel) {\n	          this.transport.send(this.cancel);\n	        }\n	        break;\n	      case C.STATUS_PROCEEDING:\n	        this.request_sender.receiveResponse(response);\n	        break;\n	    }\n	  } else if(status_code >= 200 && status_code <= 299) {\n	    switch(this.state) {\n	      case C.STATUS_CALLING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_ACCEPTED);\n	        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n	        this.request_sender.receiveResponse(response);\n	        break;\n	      case C.STATUS_ACCEPTED:\n	        this.request_sender.receiveResponse(response);\n	        break;\n	    }\n	  } else if(status_code >= 300 && status_code <= 699) {\n	    switch(this.state) {\n	      case C.STATUS_CALLING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_COMPLETED);\n	        this.sendACK(response);\n	        this.request_sender.receiveResponse(response);\n	        break;\n	      case C.STATUS_COMPLETED:\n	        this.sendACK(response);\n	        break;\n	    }\n	  }\n	};\n	\n	\n	/**\n	 * @augments SIP.Transactions\n	 * @class ACK Client Transaction\n	 * @param {SIP.RequestSender} request_sender\n	 * @param {SIP.OutgoingRequest} request\n	 * @param {SIP.Transport} transport\n	 */\n	var AckClientTransaction = function(request_sender, request, transport) {\n	  var via;\n	\n	  this.transport = transport;\n	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n	  this.request_sender = request_sender;\n	  this.request = request;\n	\n	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n	\n	  via = buildViaHeader(request_sender, transport, this.id);\n	  this.request.setHeader('via', via);\n	};\n	AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	AckClientTransaction.prototype.send = function() {\n	  if(!this.transport.send(this.request)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	AckClientTransaction.prototype.onTransportError = function() {\n	  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n	  this.request_sender.onTransportError();\n	};\n	\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Non Invite Server Transaction\n	* @param {SIP.IncomingRequest} request\n	* @param {SIP.UA} ua\n	*/\n	var NonInviteServerTransaction = function(request, ua) {\n	  this.type = C.NON_INVITE_SERVER;\n	  this.id = request.via_branch;\n	  this.request = request;\n	  this.transport = request.transport;\n	  this.ua = ua;\n	  this.last_response = '';\n	  request.server_transaction = this;\n	\n	  this.logger = ua.getLogger('sip.transaction.nist', this.id);\n	\n	  this.state = C.STATUS_TRYING;\n	\n	  ua.newTransaction(this);\n	};\n	NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	NonInviteServerTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	NonInviteServerTransaction.prototype.timer_J = function() {\n	  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.ua.destroyTransaction(this);\n	};\n	\n	NonInviteServerTransaction.prototype.onTransportError = function() {\n	  if (!this.transportError) {\n	    this.transportError = true;\n	\n	    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n	\n	    SIP.Timers.clearTimeout(this.J);\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.ua.destroyTransaction(this);\n	  }\n	};\n	\n	NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n	  var tr = this;\n	  var deferred = SIP.Utils.defer();\n	\n	  if(status_code === 100) {\n	    /* RFC 4320 4.1\n	     * 'A SIP element MUST NOT\n	     * send any provisional response with a\n	     * Status-Code other than 100 to a non-INVITE request.'\n	     */\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	        this.stateChanged(C.STATUS_PROCEEDING);\n	        if(!this.transport.send(response))  {\n	          this.onTransportError();\n	        }\n	        break;\n	      case C.STATUS_PROCEEDING:\n	        this.last_response = response;\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	          deferred.reject();\n	        } else {\n	          deferred.resolve();\n	        }\n	        break;\n	    }\n	  } else if(status_code >= 200 && status_code <= 699) {\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_COMPLETED);\n	        this.last_response = response;\n	        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	          deferred.reject();\n	        } else {\n	          deferred.resolve();\n	        }\n	        break;\n	      case C.STATUS_COMPLETED:\n	        break;\n	    }\n	  }\n	\n	  return deferred.promise;\n	};\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Invite Server Transaction\n	* @param {SIP.IncomingRequest} request\n	* @param {SIP.UA} ua\n	*/\n	var InviteServerTransaction = function(request, ua) {\n	  this.type = C.INVITE_SERVER;\n	  this.id = request.via_branch;\n	  this.request = request;\n	  this.transport = request.transport;\n	  this.ua = ua;\n	  this.last_response = '';\n	  request.server_transaction = this;\n	\n	  this.logger = ua.getLogger('sip.transaction.ist', this.id);\n	\n	  this.state = C.STATUS_PROCEEDING;\n	\n	  ua.newTransaction(this);\n	\n	  this.resendProvisionalTimer = null;\n	\n	  request.reply(100);\n	};\n	InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	InviteServerTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	InviteServerTransaction.prototype.timer_H = function() {\n	  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);\n	\n	  if(this.state === C.STATUS_COMPLETED) {\n	    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n	  }\n	\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.ua.destroyTransaction(this);\n	};\n	\n	InviteServerTransaction.prototype.timer_I = function() {\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.ua.destroyTransaction(this);\n	};\n	\n	// RFC 6026 7.1\n	InviteServerTransaction.prototype.timer_L = function() {\n	  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);\n	\n	  if(this.state === C.STATUS_ACCEPTED) {\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.ua.destroyTransaction(this);\n	  }\n	};\n	\n	InviteServerTransaction.prototype.onTransportError = function() {\n	  if (!this.transportError) {\n	    this.transportError = true;\n	\n	    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n	\n	    if (this.resendProvisionalTimer !== null) {\n	      SIP.Timers.clearInterval(this.resendProvisionalTimer);\n	      this.resendProvisionalTimer = null;\n	    }\n	\n	    SIP.Timers.clearTimeout(this.L);\n	    SIP.Timers.clearTimeout(this.H);\n	    SIP.Timers.clearTimeout(this.I);\n	\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.ua.destroyTransaction(this);\n	  }\n	};\n	\n	InviteServerTransaction.prototype.resend_provisional = function() {\n	  if(!this.transport.send(this.last_response)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	// INVITE Server Transaction RFC 3261 17.2.1\n	InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n	  var tr = this;\n	  var deferred = SIP.Utils.defer();\n	\n	  if(status_code >= 100 && status_code <= 199) {\n	    switch(this.state) {\n	      case C.STATUS_PROCEEDING:\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	        }\n	        this.last_response = response;\n	        break;\n	    }\n	  }\n	\n	  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n	    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n	    if(this.resendProvisionalTimer === null) {\n	      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),\n	        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n	    }\n	  } else if(status_code >= 200 && status_code <= 299) {\n	    switch(this.state) {\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_ACCEPTED);\n	        this.last_response = response;\n	        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n	\n	        if (this.resendProvisionalTimer !== null) {\n	          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n	          this.resendProvisionalTimer = null;\n	        }\n	        /* falls through */\n	        case C.STATUS_ACCEPTED:\n	          // Note that this point will be reached for proceeding tr.state also.\n	          if(!this.transport.send(response)) {\n	            this.onTransportError();\n	            deferred.reject();\n	          } else {\n	            deferred.resolve();\n	          }\n	          break;\n	    }\n	  } else if(status_code >= 300 && status_code <= 699) {\n	    switch(this.state) {\n	      case C.STATUS_PROCEEDING:\n	        if (this.resendProvisionalTimer !== null) {\n	          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n	          this.resendProvisionalTimer = null;\n	        }\n	\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	          deferred.reject();\n	        } else {\n	          this.stateChanged(C.STATUS_COMPLETED);\n	          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n	          deferred.resolve();\n	        }\n	        break;\n	    }\n	  }\n	\n	  return deferred.promise;\n	};\n	\n	/**\n	 * @function\n	 * @param {SIP.UA} ua\n	 * @param {SIP.IncomingRequest} request\n	 *\n	 * @return {boolean}\n	 * INVITE:\n	 *  _true_ if retransmission\n	 *  _false_ new request\n	 *\n	 * ACK:\n	 *  _true_  ACK to non2xx response\n	 *  _false_ ACK must be passed to TU (accepted state)\n	 *          ACK to 2xx response\n	 *\n	 * CANCEL:\n	 *  _true_  no matching invite transaction\n	 *  _false_ matching invite transaction and no final response sent\n	 *\n	 * OTHER:\n	 *  _true_  retransmission\n	 *  _false_ new request\n	 */\n	var checkTransaction = function(ua, request) {\n	  var tr;\n	\n	  switch(request.method) {\n	    case SIP.C.INVITE:\n	      tr = ua.transactions.ist[request.via_branch];\n	      if(tr) {\n	        switch(tr.state) {\n	          case C.STATUS_PROCEEDING:\n	            tr.transport.send(tr.last_response);\n	            break;\n	\n	            // RFC 6026 7.1 Invite retransmission\n	            //received while in C.STATUS_ACCEPTED state. Absorb it.\n	          case C.STATUS_ACCEPTED:\n	            break;\n	        }\n	        return true;\n	      }\n	      break;\n	    case SIP.C.ACK:\n	      tr = ua.transactions.ist[request.via_branch];\n	\n	      // RFC 6026 7.1\n	      if(tr) {\n	        if(tr.state === C.STATUS_ACCEPTED) {\n	          return false;\n	        } else if(tr.state === C.STATUS_COMPLETED) {\n	          tr.state = C.STATUS_CONFIRMED;\n	          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n	          return true;\n	        }\n	      }\n	\n	      // ACK to 2XX Response.\n	      else {\n	        return false;\n	      }\n	      break;\n	    case SIP.C.CANCEL:\n	      tr = ua.transactions.ist[request.via_branch];\n	      if(tr) {\n	        request.reply_sl(200);\n	        if(tr.state === C.STATUS_PROCEEDING) {\n	          return false;\n	        } else {\n	          return true;\n	        }\n	      } else {\n	        request.reply_sl(481);\n	        return true;\n	      }\n	      break;\n	    default:\n	\n	      // Non-INVITE Server Transaction RFC 3261 17.2.2\n	      tr = ua.transactions.nist[request.via_branch];\n	      if(tr) {\n	        switch(tr.state) {\n	          case C.STATUS_TRYING:\n	            break;\n	          case C.STATUS_PROCEEDING:\n	          case C.STATUS_COMPLETED:\n	            tr.transport.send(tr.last_response);\n	            break;\n	        }\n	        return true;\n	      }\n	      break;\n	  }\n	};\n	\n	SIP.Transactions = {\n	  C: C,\n	  checkTransaction: checkTransaction,\n	  NonInviteClientTransaction: NonInviteClientTransaction,\n	  InviteClientTransaction: InviteClientTransaction,\n	  AckClientTransaction: AckClientTransaction,\n	  NonInviteServerTransaction: NonInviteServerTransaction,\n	  InviteServerTransaction: InviteServerTransaction\n	};\n	\n	};\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Dialog\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP dialog.\n	 * @param {SIP.RTCSession} owner\n	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message\n	 * @param {Enum} type UAC / UAS\n	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED\n	 */\n	module.exports = function (SIP) {\n	\n	var RequestSender = __webpack_require__(31)(SIP);\n	\n	var Dialog,\n	  C = {\n	    // Dialog states\n	    STATUS_EARLY:       1,\n	    STATUS_CONFIRMED:   2\n	  };\n	\n	// RFC 3261 12.1\n	Dialog = function(owner, message, type, state) {\n	  var contact;\n	\n	  this.uac_pending_reply = false;\n	  this.uas_pending_reply = false;\n	\n	  if(!message.hasHeader('contact')) {\n	    return {\n	      error: 'unable to create a Dialog without Contact header field'\n	    };\n	  }\n	\n	  if(message instanceof SIP.IncomingResponse) {\n	    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n	  } else {\n	    // Create confirmed dialog if state is not defined\n	    state = state || C.STATUS_CONFIRMED;\n	  }\n	\n	  contact = message.parseHeader('contact');\n	\n	  // RFC 3261 12.1.1\n	  if(type === 'UAS') {\n	    this.id = {\n	      call_id: message.call_id,\n	      local_tag: message.to_tag,\n	      remote_tag: message.from_tag,\n	      toString: function() {\n	        return this.call_id + this.local_tag + this.remote_tag;\n	      }\n	    };\n	    this.state = state;\n	    this.remote_seqnum = message.cseq;\n	    this.local_uri = message.parseHeader('to').uri;\n	    this.remote_uri = message.parseHeader('from').uri;\n	    this.remote_target = contact.uri;\n	    this.route_set = message.getHeaders('record-route');\n	    this.invite_seqnum = message.cseq;\n	    this.local_seqnum = message.cseq;\n	  }\n	  // RFC 3261 12.1.2\n	  else if(type === 'UAC') {\n	    this.id = {\n	      call_id: message.call_id,\n	      local_tag: message.from_tag,\n	      remote_tag: message.to_tag,\n	      toString: function() {\n	        return this.call_id + this.local_tag + this.remote_tag;\n	      }\n	    };\n	    this.state = state;\n	    this.invite_seqnum = message.cseq;\n	    this.local_seqnum = message.cseq;\n	    this.local_uri = message.parseHeader('from').uri;\n	    this.pracked = [];\n	    this.remote_uri = message.parseHeader('to').uri;\n	    this.remote_target = contact.uri;\n	    this.route_set = message.getHeaders('record-route').reverse();\n	\n	    //RENDERBODY\n	    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {\n	      this.mediaHandler = owner.mediaHandlerFactory(owner);\n	    }\n	  }\n	\n	  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());\n	  this.owner = owner;\n	  owner.ua.dialogs[this.id.toString()] = this;\n	  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));\n	  owner.emit('dialog', this);\n	};\n	\n	Dialog.prototype = {\n	  /**\n	   * @param {SIP.IncomingMessage} message\n	   * @param {Enum} UAC/UAS\n	   */\n	  update: function(message, type) {\n	    this.state = C.STATUS_CONFIRMED;\n	\n	    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');\n	\n	    if(type === 'UAC') {\n	      // RFC 3261 13.2.2.4\n	      this.route_set = message.getHeaders('record-route').reverse();\n	    }\n	  },\n	\n	  terminate: function() {\n	    this.logger.log('dialog ' + this.id.toString() + ' deleted');\n	    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {\n	      this.mediaHandler.peerConnection.close();\n	    }\n	    delete this.owner.ua.dialogs[this.id.toString()];\n	  },\n	\n	  /**\n	  * @param {String} method request method\n	  * @param {Object} extraHeaders extra headers\n	  * @returns {SIP.OutgoingRequest}\n	  */\n	\n	  // RFC 3261 12.2.1.1\n	  createRequest: function(method, extraHeaders, body) {\n	    var cseq, request;\n	    extraHeaders = (extraHeaders || []).slice();\n	\n	    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }\n	\n	    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;\n	\n	    request = new SIP.OutgoingRequest(\n	      method,\n	      this.remote_target,\n	      this.owner.ua, {\n	        'cseq': cseq,\n	        'call_id': this.id.call_id,\n	        'from_uri': this.local_uri,\n	        'from_tag': this.id.local_tag,\n	        'to_uri': this.remote_uri,\n	        'to_tag': this.id.remote_tag,\n	        'route_set': this.route_set\n	      }, extraHeaders, body);\n	\n	    request.dialog = this;\n	\n	    return request;\n	  },\n	\n	  /**\n	  * @param {SIP.IncomingRequest} request\n	  * @returns {Boolean}\n	  */\n	\n	  // RFC 3261 12.2.2\n	  checkInDialogRequest: function(request) {\n	    var self = this;\n	\n	    if(!this.remote_seqnum) {\n	      this.remote_seqnum = request.cseq;\n	    } else if(request.cseq < this.remote_seqnum) {\n	        //Do not try to reply to an ACK request.\n	        if (request.method !== SIP.C.ACK) {\n	          request.reply(500);\n	        }\n	        if (request.cseq === this.invite_seqnum) {\n	          return true;\n	        }\n	        return false;\n	    } else if(request.cseq > this.remote_seqnum) {\n	      this.remote_seqnum = request.cseq;\n	    }\n	\n	    switch(request.method) {\n	      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-\n	      case SIP.C.INVITE:\n	        if (this.uac_pending_reply === true) {\n	          request.reply(491);\n	        } else if (this.uas_pending_reply === true) {\n	          var retryAfter = (Math.random() * 10 | 0) + 1;\n	          request.reply(500, null, ['Retry-After:' + retryAfter]);\n	          return false;\n	        } else {\n	          this.uas_pending_reply = true;\n	          request.server_transaction.on('stateChanged', function stateChanged(){\n	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n	                this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n	                this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n	\n	              this.removeListener('stateChanged', stateChanged);\n	              self.uas_pending_reply = false;\n	\n	              if (self.uac_pending_reply === false) {\n	                self.owner.onReadyToReinvite();\n	              }\n	            }\n	          });\n	        }\n	\n	        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted\n	        if(request.hasHeader('contact')) {\n	          request.server_transaction.on('stateChanged', function(){\n	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {\n	              self.remote_target = request.parseHeader('contact').uri;\n	            }\n	          });\n	        }\n	        break;\n	      case SIP.C.NOTIFY:\n	        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted\n	        if(request.hasHeader('contact')) {\n	          request.server_transaction.on('stateChanged', function(){\n	            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {\n	              self.remote_target = request.parseHeader('contact').uri;\n	            }\n	          });\n	        }\n	        break;\n	    }\n	\n	    return true;\n	  },\n	\n	  sendRequest: function(applicant, method, options) {\n	    options = options || {};\n	\n	    var\n	      extraHeaders = (options.extraHeaders || []).slice(),\n	      body = options.body || null,\n	      request = this.createRequest(method, extraHeaders, body),\n	      request_sender = new RequestSender(this, applicant, request);\n	\n	    request_sender.send();\n	\n	    return request;\n	  },\n	\n	  /**\n	  * @param {SIP.IncomingRequest} request\n	  */\n	  receiveRequest: function(request) {\n	    //Check in-dialog request\n	    if(!this.checkInDialogRequest(request)) {\n	      return;\n	    }\n	\n	    this.owner.receiveRequest(request);\n	  }\n	};\n	\n	Dialog.C = C;\n	SIP.Dialog = Dialog;\n	};\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview In-Dialog Request Sender\n	 */\n	\n	/**\n	 * @augments SIP.Dialog\n	 * @class Class creating an In-dialog request sender.\n	 * @param {SIP.Dialog} dialog\n	 * @param {Object} applicant\n	 * @param {SIP.OutgoingRequest} request\n	 */\n	/**\n	 * @fileoverview in-Dialog Request Sender\n	 */\n	\n	module.exports = function (SIP) {\n	var RequestSender;\n	\n	RequestSender = function(dialog, applicant, request) {\n	\n	  this.dialog = dialog;\n	  this.applicant = applicant;\n	  this.request = request;\n	\n	  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n	  this.reattempt = false;\n	  this.reattemptTimer = null;\n	};\n	\n	RequestSender.prototype = {\n	  send: function() {\n	    var self = this,\n	      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);\n	\n	      request_sender.send();\n	\n	    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-\n	    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n	      this.dialog.uac_pending_reply = true;\n	      request_sender.clientTransaction.on('stateChanged', function stateChanged(){\n	        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n	            this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n	            this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n	\n	          this.removeListener('stateChanged', stateChanged);\n	          self.dialog.uac_pending_reply = false;\n	\n	          if (self.dialog.uas_pending_reply === false) {\n	            self.dialog.owner.onReadyToReinvite();\n	          }\n	        }\n	      });\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    this.applicant.onRequestTimeout();\n	  },\n	\n	  onTransportError: function() {\n	    this.applicant.onTransportError();\n	  },\n	\n	  receiveResponse: function(response) {\n	    var self = this;\n	\n	    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n	    if (response.status_code === 408 || response.status_code === 481) {\n	      this.applicant.onDialogError(response);\n	    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {\n	      if (this.reattempt) {\n	        this.applicant.receiveResponse(response);\n	      } else {\n	        this.request.cseq.value = this.dialog.local_seqnum += 1;\n	        this.reattemptTimer = SIP.Timers.setTimeout(\n	          function() {\n	            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {\n	              self.reattempt = true;\n	              self.request_sender.send();\n	            }\n	          },\n	          this.getReattemptTimeout()\n	        );\n	      }\n	    } else {\n	      this.applicant.receiveResponse(response);\n	    }\n	  }\n	};\n	\n	return RequestSender;\n	};\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview Request Sender\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a request sender.\n	 * @param {Object} applicant\n	 * @param {SIP.UA} ua\n	 */\n	module.exports = function (SIP) {\n	var RequestSender;\n	\n	RequestSender = function(applicant, ua) {\n	  this.logger = ua.getLogger('sip.requestsender');\n	  this.ua = ua;\n	  this.applicant = applicant;\n	  this.method = applicant.request.method;\n	  this.request = applicant.request;\n	  this.credentials = null;\n	  this.challenged = false;\n	  this.staled = false;\n	\n	  // If ua is in closing process or even closed just allow sending Bye and ACK\n	  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	/**\n	* Create the client transaction and send the message.\n	*/\n	RequestSender.prototype = {\n	  send: function() {\n	    switch(this.method) {\n	      case \"INVITE\":\n	        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n	        break;\n	      case \"ACK\":\n	        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n	        break;\n	      default:\n	        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n	    }\n	    this.clientTransaction.send();\n	\n	    return this.clientTransaction;\n	  },\n	\n	  /**\n	  * Callback fired when receiving a request timeout error from the client transaction.\n	  * To be re-defined by the applicant.\n	  * @event\n	  */\n	  onRequestTimeout: function() {\n	    this.applicant.onRequestTimeout();\n	  },\n	\n	  /**\n	  * Callback fired when receiving a transport error from the client transaction.\n	  * To be re-defined by the applicant.\n	  * @event\n	  */\n	  onTransportError: function() {\n	    this.applicant.onTransportError();\n	  },\n	\n	  /**\n	  * Called from client transaction when receiving a correct response to the request.\n	  * Authenticate request if needed or pass the response back to the applicant.\n	  * @param {SIP.IncomingResponse} response\n	  */\n	  receiveResponse: function(response) {\n	    var cseq, challenge, authorization_header_name,\n	      status_code = response.status_code;\n	\n	    /*\n	    * Authentication\n	    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n	    */\n	    if (status_code === 401 || status_code === 407) {\n	\n	      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n	      if (response.status_code === 401) {\n	        challenge = response.parseHeader('www-authenticate');\n	        authorization_header_name = 'authorization';\n	      } else {\n	        challenge = response.parseHeader('proxy-authenticate');\n	        authorization_header_name = 'proxy-authorization';\n	      }\n	\n	      // Verify it seems a valid challenge.\n	      if (! challenge) {\n	        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n	        this.applicant.receiveResponse(response);\n	        return;\n	      }\n	\n	      if (!this.challenged || (!this.staled && challenge.stale === true)) {\n	        if (!this.credentials) {\n	          this.credentials = this.ua.configuration.authenticationFactory(this.ua);\n	        }\n	\n	        // Verify that the challenge is really valid.\n	        if (!this.credentials.authenticate(this.request, challenge)) {\n	          this.applicant.receiveResponse(response);\n	          return;\n	        }\n	        this.challenged = true;\n	\n	        if (challenge.stale) {\n	          this.staled = true;\n	        }\n	\n	        if (response.method === SIP.C.REGISTER) {\n	          cseq = this.applicant.cseq += 1;\n	        } else if (this.request.dialog){\n	          cseq = this.request.dialog.local_seqnum += 1;\n	        } else {\n	          cseq = this.request.cseq + 1;\n	          this.request.cseq = cseq;\n	        }\n	        this.request.setHeader('cseq', cseq +' '+ this.method);\n	\n	        this.request.setHeader(authorization_header_name, this.credentials.toString());\n	        this.send();\n	      } else {\n	        this.applicant.receiveResponse(response);\n	      }\n	    } else {\n	      this.applicant.receiveResponse(response);\n	    }\n	  }\n	};\n	\n	SIP.RequestSender = RequestSender;\n	};\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	module.exports = function (SIP) {\n	\n	var RegisterContext;\n	\n	RegisterContext = function (ua) {\n	  var params = {},\n	      regId = 1;\n	\n	  this.registrar = ua.configuration.registrarServer;\n	  this.expires = ua.configuration.registerExpires;\n	\n	\n	  // Contact header\n	  this.contact = ua.contact.toString();\n	\n	  if(regId) {\n	    this.contact += ';reg-id='+ regId;\n	    this.contact += ';+sip.instance=\"<urn:uuid:'+ ua.configuration.instanceId+'>\"';\n	  }\n	\n	  // Call-ID and CSeq values RFC3261 10.2\n	  this.call_id = SIP.Utils.createRandomToken(22);\n	  this.cseq = 80;\n	\n	  this.to_uri = ua.configuration.uri;\n	\n	  params.to_uri = this.to_uri;\n	  params.to_displayName = ua.configuration.displayName;\n	  params.call_id = this.call_id;\n	  params.cseq = this.cseq;\n	\n	  // Extends ClientContext\n	  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);\n	\n	  this.registrationTimer = null;\n	  this.registrationExpiredTimer = null;\n	\n	  // Set status\n	  this.registered = false;\n	\n	  this.logger = ua.getLogger('sip.registercontext');\n	};\n	\n	RegisterContext.prototype = {\n	  register: function (options) {\n	    var self = this, extraHeaders;\n	\n	    // Handle Options\n	    this.options = options || {};\n	    extraHeaders = (this.options.extraHeaders || []).slice();\n	    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n	    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	    // Save original extraHeaders to be used in .close\n	    this.closeHeaders = this.options.closeWithHeaders ?\n	      (this.options.extraHeaders || []).slice() : [];\n	\n	    this.receiveResponse = function(response) {\n	      var contact, expires,\n	        contacts = response.getHeaders('contact').length,\n	        cause;\n	\n	      // Discard responses to older REGISTER/un-REGISTER requests.\n	      if(response.cseq !== this.cseq) {\n	        return;\n	      }\n	\n	      // Clear registration timer\n	      if (this.registrationTimer !== null) {\n	        SIP.Timers.clearTimeout(this.registrationTimer);\n	        this.registrationTimer = null;\n	      }\n	\n	      switch(true) {\n	        case /^1[0-9]{2}$/.test(response.status_code):\n	          this.emit('progress', response);\n	          break;\n	        case /^2[0-9]{2}$/.test(response.status_code):\n	          this.emit('accepted', response);\n	\n	          if(response.hasHeader('expires')) {\n	            expires = response.getHeader('expires');\n	          }\n	\n	          if (this.registrationExpiredTimer !== null) {\n	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n	            this.registrationExpiredTimer = null;\n	          }\n	\n	          // Search the Contact pointing to us and update the expires value accordingly.\n	          if (!contacts) {\n	            this.logger.warn('no Contact header in response to REGISTER, response ignored');\n	            break;\n	          }\n	\n	          while(contacts--) {\n	            contact = response.parseHeader('contact', contacts);\n	            if(contact.uri.user === this.ua.contact.uri.user) {\n	              expires = contact.getParam('expires');\n	              break;\n	            } else {\n	              contact = null;\n	            }\n	          }\n	\n	          if (!contact) {\n	            this.logger.warn('no Contact header pointing to us, response ignored');\n	            break;\n	          }\n	\n	          if(!expires) {\n	            expires = this.expires;\n	          }\n	\n	          // Re-Register before the expiration interval has elapsed.\n	          // For that, decrease the expires value. ie: 3 seconds\n	          this.registrationTimer = SIP.Timers.setTimeout(function() {\n	            self.registrationTimer = null;\n	            self.register(self.options);\n	          }, (expires * 1000) - 3000);\n	          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n	            self.logger.warn('registration expired');\n	            if (self.registered) {\n	              self.unregistered(null, SIP.C.causes.EXPIRES);\n	            }\n	          }, expires * 1000);\n	\n	          //Save gruu values\n	          if (contact.hasParam('temp-gruu')) {\n	            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g,''));\n	          }\n	          if (contact.hasParam('pub-gruu')) {\n	            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g,''));\n	          }\n	\n	          this.registered = true;\n	          this.emit('registered', response || null);\n	          break;\n	        // Interval too brief RFC3261 10.2.8\n	        case /^423$/.test(response.status_code):\n	          if(response.hasHeader('min-expires')) {\n	            // Increase our registration interval to the suggested minimum\n	            this.expires = response.getHeader('min-expires');\n	            // Attempt the registration again immediately\n	            this.register(this.options);\n	          } else { //This response MUST contain a Min-Expires header field\n	            this.logger.warn('423 response received for REGISTER without Min-Expires');\n	            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n	          }\n	          break;\n	        default:\n	          cause = SIP.Utils.sipErrorCause(response.status_code);\n	          this.registrationFailure(response, cause);\n	      }\n	    };\n	\n	    this.onRequestTimeout = function() {\n	      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    };\n	\n	    this.onTransportError = function() {\n	      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n	    };\n	\n	    this.cseq++;\n	    this.request.cseq = this.cseq;\n	    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n	    this.request.extraHeaders = extraHeaders;\n	    this.send();\n	  },\n	\n	  registrationFailure: function (response, cause) {\n	    this.emit('failed', response || null, cause || null);\n	  },\n	\n	  onTransportClosed: function() {\n	    this.registered_before = this.registered;\n	    if (this.registrationTimer !== null) {\n	      SIP.Timers.clearTimeout(this.registrationTimer);\n	      this.registrationTimer = null;\n	    }\n	\n	    if (this.registrationExpiredTimer !== null) {\n	      SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n	      this.registrationExpiredTimer = null;\n	    }\n	\n	    if(this.registered) {\n	      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onTransportConnected: function() {\n	    this.register(this.options);\n	  },\n	\n	  close: function() {\n	    var options = {\n	      all: false,\n	      extraHeaders: this.closeHeaders\n	    };\n	\n	    this.registered_before = this.registered;\n	    this.unregister(options);\n	  },\n	\n	  unregister: function(options) {\n	    var extraHeaders;\n	\n	    options = options || {};\n	\n	    if(!this.registered && !options.all) {\n	      this.logger.warn('already unregistered');\n	      return;\n	    }\n	\n	    extraHeaders = (options.extraHeaders || []).slice();\n	\n	    this.registered = false;\n	\n	    // Clear the registration timer.\n	    if (this.registrationTimer !== null) {\n	      SIP.Timers.clearTimeout(this.registrationTimer);\n	      this.registrationTimer = null;\n	    }\n	\n	    if(options.all) {\n	      extraHeaders.push('Contact: *');\n	      extraHeaders.push('Expires: 0');\n	    } else {\n	      extraHeaders.push('Contact: '+ this.contact + ';expires=0');\n	    }\n	\n	\n	    this.receiveResponse = function(response) {\n	      var cause;\n	\n	      switch(true) {\n	        case /^1[0-9]{2}$/.test(response.status_code):\n	          this.emit('progress', response);\n	          break;\n	        case /^2[0-9]{2}$/.test(response.status_code):\n	          this.emit('accepted', response);\n	          if (this.registrationExpiredTimer !== null) {\n	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n	            this.registrationExpiredTimer = null;\n	          }\n	          this.unregistered(response);\n	          break;\n	        default:\n	          cause = SIP.Utils.sipErrorCause(response.status_code);\n	          this.unregistered(response,cause);\n	      }\n	    };\n	\n	    this.onRequestTimeout = function() {\n	      // Not actually unregistered...\n	      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    };\n	\n	    this.onTransportError = function() {\n	      // Not actually unregistered...\n	      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n	    };\n	\n	    this.cseq++;\n	    this.request.cseq = this.cseq;\n	    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n	    this.request.extraHeaders = extraHeaders;\n	\n	    this.send();\n	  },\n	\n	  unregistered: function(response, cause) {\n	    this.registered = false;\n	    this.emit('unregistered', response || null, cause || null);\n	  }\n	\n	};\n	\n	\n	SIP.RegisterContext = RegisterContext;\n	};\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview MediaHandler\n	 */\n	\n	/* MediaHandler\n	 * @class PeerConnection helper Class.\n	 * @param {SIP.Session} session\n	 * @param {Object} [options]\n	 */\n	module.exports = function (EventEmitter) {\n	var MediaHandler = function(session, options) {\n	  // keep jshint happy\n	  session = session;\n	  options = options;\n	};\n	\n	MediaHandler.prototype = Object.create(EventEmitter.prototype, {\n	  isReady: {value: function isReady () {}},\n	\n	  close: {value: function close () {}},\n	\n	  /**\n	   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.\n	   */\n	  getDescription: {value: function getDescription (mediaHint) {\n	    // keep jshint happy\n	    mediaHint = mediaHint;\n	  }},\n	\n	  /**\n	  * Message reception.\n	  * @param {String} type\n	  * @param {String} description\n	  */\n	  setDescription: {value: function setDescription (description) {\n	    // keep jshint happy\n	    description = description;\n	  }}\n	});\n	\n	return MediaHandler;\n	};\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	module.exports = function (SIP) {\n	var ClientContext;\n	\n	ClientContext = function (ua, method, target, options) {\n	  var originalTarget = target;\n	\n	  // Validate arguments\n	  if (target === undefined) {\n	    throw new TypeError('Not enough arguments');\n	  }\n	\n	  this.ua = ua;\n	  this.logger = ua.getLogger('sip.clientcontext');\n	  this.method = method;\n	  target = ua.normalizeTarget(target);\n	  if (!target) {\n	    throw new TypeError('Invalid target: ' + originalTarget);\n	  }\n	\n	  /* Options\n	   * - extraHeaders\n	   * - params\n	   * - contentType\n	   * - body\n	   */\n	  options = Object.create(options || Object.prototype);\n	  options.extraHeaders = (options.extraHeaders || []).slice();\n	\n	  if (options.contentType) {\n	    this.contentType = options.contentType;\n	    options.extraHeaders.push('Content-Type: ' + this.contentType);\n	  }\n	\n	  // Build the request\n	  this.request = new SIP.OutgoingRequest(this.method,\n	                                         target,\n	                                         this.ua,\n	                                         options.params,\n	                                         options.extraHeaders);\n	  if (options.body) {\n	    this.body = options.body;\n	    this.request.body = this.body;\n	  }\n	\n	  /* Set other properties from the request */\n	  this.localIdentity = this.request.from;\n	  this.remoteIdentity = this.request.to;\n	\n	  this.data = {};\n	};\n	ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	ClientContext.prototype.send = function () {\n	  (new SIP.RequestSender(this, this.ua)).send();\n	  return this;\n	};\n	\n	ClientContext.prototype.cancel = function (options) {\n	  options = options || {};\n	\n	  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n	  this.request.cancel(cancel_reason);\n	\n	  this.emit('cancel');\n	};\n	\n	ClientContext.prototype.receiveResponse = function (response) {\n	  var cause = SIP.Utils.getReasonPhrase(response.status_code);\n	\n	  switch(true) {\n	    case /^1[0-9]{2}$/.test(response.status_code):\n	      this.emit('progress', response, cause);\n	      break;\n	\n	    case /^2[0-9]{2}$/.test(response.status_code):\n	      if(this.ua.applicants[this]) {\n	        delete this.ua.applicants[this];\n	      }\n	      this.emit('accepted', response, cause);\n	      break;\n	\n	    default:\n	      if(this.ua.applicants[this]) {\n	        delete this.ua.applicants[this];\n	      }\n	      this.emit('rejected', response, cause);\n	      this.emit('failed', response, cause);\n	      break;\n	  }\n	\n	};\n	\n	ClientContext.prototype.onRequestTimeout = function () {\n	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n	};\n	\n	ClientContext.prototype.onTransportError = function () {\n	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n	};\n	\n	SIP.ClientContext = ClientContext;\n	};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	module.exports = function (SIP) {\n	var ServerContext;\n	\n	ServerContext = function (ua, request) {\n	  this.ua = ua;\n	  this.logger = ua.getLogger('sip.servercontext');\n	  this.request = request;\n	  if (request.method === SIP.C.INVITE) {\n	    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);\n	  } else {\n	    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);\n	  }\n	\n	  if (request.body) {\n	    this.body = request.body;\n	  }\n	  if (request.hasHeader('Content-Type')) {\n	    this.contentType = request.getHeader('Content-Type');\n	  }\n	  this.method = request.method;\n	\n	  this.data = {};\n	\n	  this.localIdentity = request.to;\n	  this.remoteIdentity = request.from;\n	};\n	\n	ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	ServerContext.prototype.progress = function (options) {\n	  options = Object.create(options || Object.prototype);\n	  options.statusCode || (options.statusCode = 180);\n	  options.minCode = 100;\n	  options.maxCode = 199;\n	  options.events = ['progress'];\n	  return this.reply(options);\n	};\n	\n	ServerContext.prototype.accept = function (options) {\n	  options = Object.create(options || Object.prototype);\n	  options.statusCode || (options.statusCode = 200);\n	  options.minCode = 200;\n	  options.maxCode = 299;\n	  options.events = ['accepted'];\n	  return this.reply(options);\n	};\n	\n	ServerContext.prototype.reject = function (options) {\n	  options = Object.create(options || Object.prototype);\n	  options.statusCode || (options.statusCode = 480);\n	  options.minCode = 300;\n	  options.maxCode = 699;\n	  options.events = ['rejected', 'failed'];\n	  return this.reply(options);\n	};\n	\n	ServerContext.prototype.reply = function (options) {\n	  options = options || {}; // This is okay, so long as we treat options as read-only in this method\n	  var\n	    statusCode = options.statusCode || 100,\n	    minCode = options.minCode || 100,\n	    maxCode = options.maxCode || 699,\n	    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),\n	    extraHeaders = options.extraHeaders || [],\n	    body = options.body,\n	    events = options.events || [],\n	    response;\n	\n	  if (statusCode < minCode || statusCode > maxCode) {\n	    throw new TypeError('Invalid statusCode: ' + statusCode);\n	  }\n	  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n	  events.forEach(function (event) {\n	    this.emit(event, response, reasonPhrase);\n	  }, this);\n	\n	  return this;\n	};\n	\n	ServerContext.prototype.onRequestTimeout = function () {\n	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n	};\n	\n	ServerContext.prototype.onTransportError = function () {\n	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n	};\n	\n	SIP.ServerContext = ServerContext;\n	};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	module.exports = function (SIP, environment) {\n	\n	var DTMF = __webpack_require__(38)(SIP);\n	\n	var Session, InviteServerContext, InviteClientContext,\n	 C = {\n	    //Session states\n	    STATUS_NULL:                        0,\n	    STATUS_INVITE_SENT:                 1,\n	    STATUS_1XX_RECEIVED:                2,\n	    STATUS_INVITE_RECEIVED:             3,\n	    STATUS_WAITING_FOR_ANSWER:          4,\n	    STATUS_ANSWERED:                    5,\n	    STATUS_WAITING_FOR_PRACK:           6,\n	    STATUS_WAITING_FOR_ACK:             7,\n	    STATUS_CANCELED:                    8,\n	    STATUS_TERMINATED:                  9,\n	    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n	    STATUS_EARLY_MEDIA:                11,\n	    STATUS_CONFIRMED:                  12\n	  };\n	\n	/*\n	 * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]\n	 *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)\n	 */\n	Session = function (mediaHandlerFactory) {\n	  this.status = C.STATUS_NULL;\n	  this.dialog = null;\n	  this.earlyDialogs = {};\n	  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;\n	  // this.mediaHandler gets set by ICC/ISC constructors\n	  this.hasOffer = false;\n	  this.hasAnswer = false;\n	\n	  // Session Timers\n	  this.timers = {\n	    ackTimer: null,\n	    expiresTimer: null,\n	    invite2xxTimer: null,\n	    userNoAnswerTimer: null,\n	    rel1xxTimer: null,\n	    prackTimer: null\n	  };\n	\n	  // Session info\n	  this.startTime = null;\n	  this.endTime = null;\n	  this.tones = null;\n	\n	  // Mute/Hold state\n	  this.local_hold = false;\n	  this.remote_hold = false;\n	\n	  this.pending_actions = {\n	    actions: [],\n	\n	    length: function() {\n	      return this.actions.length;\n	    },\n	\n	    isPending: function(name){\n	      var\n	      idx = 0,\n	      length = this.actions.length;\n	\n	      for (idx; idx<length; idx++) {\n	        if (this.actions[idx].name === name) {\n	          return true;\n	        }\n	      }\n	      return false;\n	    },\n	\n	    shift: function() {\n	      return this.actions.shift();\n	    },\n	\n	    push: function(name) {\n	      this.actions.push({\n	        name: name\n	      });\n	    },\n	\n	    pop: function(name) {\n	      var\n	      idx = 0,\n	      length = this.actions.length;\n	\n	      for (idx; idx<length; idx++) {\n	        if (this.actions[idx].name === name) {\n	          this.actions.splice(idx,1);\n	          length --;\n	          idx--;\n	        }\n	      }\n	    }\n	   };\n	\n	  this.early_sdp = null;\n	  this.rel100 = SIP.C.supported.UNSUPPORTED;\n	};\n	\n	Session.prototype = {\n	  dtmf: function(tones, options) {\n	    var tone, dtmfs = [],\n	        self = this;\n	\n	    options = options || {};\n	\n	    if (tones === undefined) {\n	      throw new TypeError('Not enough arguments');\n	    }\n	\n	    // Check Session Status\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    // Check tones\n	    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n	      throw new TypeError('Invalid tones: '+ tones);\n	    }\n	\n	    tones = tones.toString().split('');\n	\n	    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }\n	\n	    if (this.tones) {\n	      // Tones are already queued, just add to the queue\n	      this.tones =  this.tones.concat(dtmfs);\n	      return this;\n	    }\n	\n	    var sendDTMF = function () {\n	      var dtmf, timeout;\n	\n	      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n	        // Stop sending DTMF\n	        self.tones = null;\n	        return this;\n	      }\n	\n	      dtmf = self.tones.shift();\n	\n	      if (tone === ',') {\n	        timeout = 2000;\n	      } else {\n	        dtmf.on('failed', function(){self.tones = null;});\n	        dtmf.send(options);\n	        timeout = dtmf.duration + dtmf.interToneGap;\n	      }\n	\n	      // Set timeout for the next tone\n	      SIP.Timers.setTimeout(sendDTMF, timeout);\n	    };\n	\n	    this.tones = dtmfs;\n	    sendDTMF();\n	    return this;\n	  },\n	\n	  bye: function(options) {\n	    options = Object.create(options || Object.prototype);\n	    var statusCode = options.statusCode;\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_TERMINATED) {\n	      this.logger.error('Error: Attempted to send BYE in a terminated session.');\n	      return this;\n	    }\n	\n	    this.logger.log('terminating Session');\n	\n	    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n	      throw new TypeError('Invalid statusCode: '+ statusCode);\n	    }\n	\n	    options.receiveResponse = function () {};\n	\n	    return this.\n	      sendRequest(SIP.C.BYE, options).\n	      terminated();\n	  },\n	\n	  refer: function(target, options) {\n	    options = options || {};\n	    var extraHeaders = (options.extraHeaders || []).slice(),\n	        withReplaces =\n	          target instanceof SIP.InviteServerContext ||\n	          target instanceof SIP.InviteClientContext,\n	        originalTarget = target;\n	\n	    if (target === undefined) {\n	      throw new TypeError('Not enough arguments');\n	    }\n	\n	    // Check Session Status\n	    if (this.status !== C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    // transform `target` so that it can be a Refer-To header value\n	    if (withReplaces) {\n	      //Attended Transfer\n	      // B.transfer(C)\n	      target = '\"' + target.remoteIdentity.friendlyName + '\" ' +\n	        '<' + target.dialog.remote_target.toString() +\n	        '?Replaces=' + target.dialog.id.call_id +\n	        '%3Bto-tag%3D' + target.dialog.id.remote_tag +\n	        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';\n	    } else {\n	      //Blind Transfer\n	      // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n	      // so try to make one ahead of time\n	      try {\n	        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n	      } catch (e) {\n	        this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n	        this.logger.debug(\"...falling through to normalizeTarget()\");\n	      }\n	\n	      // Check target validity\n	      target = this.ua.normalizeTarget(target);\n	      if (!target) {\n	        throw new TypeError('Invalid target: ' + originalTarget);\n	      }\n	    }\n	\n	    extraHeaders.push('Contact: '+ this.contact);\n	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	    extraHeaders.push('Refer-To: '+ target);\n	\n	    // Send the request\n	    this.sendRequest(SIP.C.REFER, {\n	      extraHeaders: extraHeaders,\n	      body: options.body,\n	      receiveResponse: function (response) {\n	        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {\n	          return;\n	        }\n	        // hang up only if we transferred to a SIP address\n	        if (withReplaces || (target.scheme && target.scheme.match(\"^sips?$\"))) {\n	          this.terminate();\n	        }\n	      }.bind(this)\n	    });\n	    return this;\n	  },\n	\n	  followRefer: function followRefer (callback) {\n	    return function referListener (callback, request) {\n	      // open non-SIP URIs if possible and keep session open\n	      var referTo = request.parseHeader('refer-to');\n	      var target = referTo.uri;\n	      if (!target.scheme.match(\"^sips?$\")) {\n	        var targetString = target.toString();\n	        if (typeof environment.open === \"function\") {\n	          environment.open(targetString);\n	        } else {\n	          this.logger.warn(\"referred to non-SIP URI but `open` isn't in the environment: \" + targetString);\n	        }\n	        return;\n	      }\n	\n	      var extraHeaders = [];\n	\n	      /* Copy the Replaces query into a Replaces header */\n	      /* TODO - make sure we don't copy a poorly formatted header? */\n	      var replaces = target.getHeader('Replaces');\n	      if (replaces !== undefined) {\n	        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));\n	      }\n	\n	      // don't embed headers into Request-URI of INVITE\n	      target.clearHeaders();\n	\n	      /*\n	        Harmless race condition.  Both sides of REFER\n	        may send a BYE, but in the end the dialogs are destroyed.\n	      */\n	      var getReferMedia = this.mediaHandler.getReferMedia;\n	      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;\n	\n	      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);\n	\n	      var referSession = this.ua.invite(target, {\n	        media: mediaHint,\n	        params: {\n	          to_displayName: referTo.friendlyName\n	        },\n	        extraHeaders: extraHeaders\n	      });\n	\n	      callback.call(this, request, referSession);\n	\n	      this.terminate();\n	    }.bind(this, callback);\n	  },\n	\n	  sendRequest: function(method,options) {\n	    options = options || {};\n	    var self = this;\n	\n	    var request = new SIP.OutgoingRequest(\n	      method,\n	      this.dialog.remote_target,\n	      this.ua,\n	      {\n	        cseq: options.cseq || (this.dialog.local_seqnum += 1),\n	        call_id: this.dialog.id.call_id,\n	        from_uri: this.dialog.local_uri,\n	        from_tag: this.dialog.id.local_tag,\n	        to_uri: this.dialog.remote_uri,\n	        to_tag: this.dialog.id.remote_tag,\n	        route_set: this.dialog.route_set,\n	        statusCode: options.statusCode,\n	        reasonPhrase: options.reasonPhrase\n	      },\n	      options.extraHeaders || [],\n	      options.body\n	    );\n	\n	    new SIP.RequestSender({\n	      request: request,\n	      onRequestTimeout: function() {\n	        self.onRequestTimeout();\n	      },\n	      onTransportError: function() {\n	        self.onTransportError();\n	      },\n	      receiveResponse: options.receiveResponse || function(response) {\n	        self.receiveNonInviteResponse(response);\n	      }\n	    }, this.ua).send();\n	\n	    // Emit the request event\n	    this.emit(method.toLowerCase(), request);\n	\n	    return this;\n	  },\n	\n	  close: function() {\n	    var idx;\n	\n	    if(this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    this.logger.log('closing INVITE session ' + this.id);\n	\n	    // 1st Step. Terminate media.\n	    if (this.mediaHandler){\n	      this.mediaHandler.close();\n	    }\n	\n	    // 2nd Step. Terminate signaling.\n	\n	    // Clear session timers\n	    for(idx in this.timers) {\n	      SIP.Timers.clearTimeout(this.timers[idx]);\n	    }\n	\n	    // Terminate dialogs\n	\n	    // Terminate confirmed dialog\n	    if(this.dialog) {\n	      this.dialog.terminate();\n	      delete this.dialog;\n	    }\n	\n	    // Terminate early dialogs\n	    for(idx in this.earlyDialogs) {\n	      this.earlyDialogs[idx].terminate();\n	      delete this.earlyDialogs[idx];\n	    }\n	\n	    this.status = C.STATUS_TERMINATED;\n	\n	    delete this.ua.sessions[this.id];\n	    return this;\n	  },\n	\n	  createDialog: function(message, type, early) {\n	    var dialog, early_dialog,\n	      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],\n	      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],\n	      id = message.call_id + local_tag + remote_tag;\n	\n	    early_dialog = this.earlyDialogs[id];\n	\n	    // Early Dialog\n	    if (early) {\n	      if (early_dialog) {\n	        return true;\n	      } else {\n	        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);\n	\n	        // Dialog has been successfully created.\n	        if(early_dialog.error) {\n	          this.logger.error(early_dialog.error);\n	          this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n	          return false;\n	        } else {\n	          this.earlyDialogs[id] = early_dialog;\n	          return true;\n	        }\n	      }\n	    }\n	    // Confirmed Dialog\n	    else {\n	      // In case the dialog is in _early_ state, update it\n	      if (early_dialog) {\n	        early_dialog.update(message, type);\n	        this.dialog = early_dialog;\n	        delete this.earlyDialogs[id];\n	        for (var dia in this.earlyDialogs) {\n	          this.earlyDialogs[dia].terminate();\n	          delete this.earlyDialogs[dia];\n	        }\n	        return true;\n	      }\n	\n	      // Otherwise, create a _confirmed_ dialog\n	      dialog = new SIP.Dialog(this, message, type);\n	\n	      if(dialog.error) {\n	        this.logger.error(dialog.error);\n	        this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n	        return false;\n	      } else {\n	        this.to_tag = message.to_tag;\n	        this.dialog = dialog;\n	        return true;\n	      }\n	    }\n	  },\n	\n	  /**\n	  * Check if Session is ready for a re-INVITE\n	  *\n	  * @returns {Boolean}\n	  */\n	  isReadyToReinvite: function() {\n	    return this.mediaHandler.isReady() &&\n	      !this.dialog.uac_pending_reply &&\n	      !this.dialog.uas_pending_reply;\n	  },\n	\n	  /**\n	   * Mute\n	   */\n	  mute: function(options) {\n	    var ret = this.mediaHandler.mute(options);\n	    if (ret) {\n	      this.onmute(ret);\n	    }\n	  },\n	\n	  /**\n	   * Unmute\n	   */\n	  unmute: function(options) {\n	    var ret = this.mediaHandler.unmute(options);\n	    if (ret) {\n	      this.onunmute(ret);\n	    }\n	  },\n	\n	  /**\n	   * Hold\n	   */\n	  hold: function() {\n	\n	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.mediaHandler.hold();\n	\n	    // Check if RTCSession is ready to send a reINVITE\n	    if (!this.isReadyToReinvite()) {\n	      /* If there is a pending 'unhold' action, cancel it and don't queue this one\n	       * Else, if there isn't any 'hold' action, add this one to the queue\n	       * Else, if there is already a 'hold' action, skip\n	       */\n	      if (this.pending_actions.isPending('unhold')) {\n	        this.pending_actions.pop('unhold');\n	      } else if (!this.pending_actions.isPending('hold')) {\n	        this.pending_actions.push('hold');\n	      }\n	      return;\n	    } else if (this.local_hold === true) {\n	        return;\n	    }\n	\n	    this.onhold('local');\n	\n	    this.sendReinvite({\n	      mangle: function(body){\n	\n	        // Don't receive media\n	        // TODO - This will break for media streams with different directions.\n	        if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {\n	          body = body.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n	        } else {\n	          body = body.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n	          body = body.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n	        }\n	\n	        return body;\n	      }\n	    });\n	  },\n	\n	  /**\n	   * Unhold\n	   */\n	  unhold: function() {\n	\n	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.mediaHandler.unhold();\n	\n	    if (!this.isReadyToReinvite()) {\n	      /* If there is a pending 'hold' action, cancel it and don't queue this one\n	       * Else, if there isn't any 'unhold' action, add this one to the queue\n	       * Else, if there is already a 'unhold' action, skip\n	       */\n	      if (this.pending_actions.isPending('hold')) {\n	        this.pending_actions.pop('hold');\n	      } else if (!this.pending_actions.isPending('unhold')) {\n	        this.pending_actions.push('unhold');\n	      }\n	      return;\n	    } else if (this.local_hold === false) {\n	      return;\n	    }\n	\n	    this.onunhold('local');\n	\n	    this.sendReinvite();\n	  },\n	\n	  /**\n	   * isOnHold\n	   */\n	  isOnHold: function() {\n	    return {\n	      local: this.local_hold,\n	      remote: this.remote_hold\n	    };\n	  },\n	\n	  /**\n	   * In dialog INVITE Reception\n	   * @private\n	   */\n	  receiveReinvite: function(request) {\n	    var self = this;\n	\n	    if (!request.body) {\n	      return;\n	    }\n	\n	    if (request.getHeader('Content-Type') !== 'application/sdp') {\n	      this.logger.warn('invalid Content-Type');\n	      request.reply(415);\n	      return;\n	    }\n	\n	    this.mediaHandler.setDescription(request.body)\n	    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n	    .then(function(body) {\n	      request.reply(200, null, ['Contact: ' + self.contact], body,\n	        function() {\n	          self.status = C.STATUS_WAITING_FOR_ACK;\n	          self.setInvite2xxTimer(request, body);\n	          self.setACKTimer();\n	\n	          // Are we holding?\n	          var hold = (/a=(sendonly|inactive)/).test(request.body);\n	\n	          if (self.remote_hold && !hold) {\n	            self.onunhold('remote');\n	          } else if (!self.remote_hold && hold) {\n	            self.onhold('remote');\n	          }\n	        });\n	    })\n	    .catch(function onFailure (e) {\n	      var statusCode;\n	      if (e instanceof SIP.Exceptions.GetDescriptionError) {\n	        statusCode = 500;\n	      } else {\n	        self.logger.error(e);\n	        statusCode = 488;\n	      }\n	      request.reply(statusCode);\n	    });\n	  },\n	\n	  sendReinvite: function(options) {\n	    options = options || {};\n	\n	    var\n	      self = this,\n	       extraHeaders = (options.extraHeaders || []).slice(),\n	       eventHandlers = options.eventHandlers || {},\n	       mangle = options.mangle || null;\n	\n	    if (eventHandlers.succeeded) {\n	      this.reinviteSucceeded = eventHandlers.succeeded;\n	    } else {\n	      this.reinviteSucceeded = function(){\n	        SIP.Timers.clearTimeout(self.timers.ackTimer);\n	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n	        self.status = C.STATUS_CONFIRMED;\n	      };\n	    }\n	    if (eventHandlers.failed) {\n	      this.reinviteFailed = eventHandlers.failed;\n	    } else {\n	      this.reinviteFailed = function(){};\n	    }\n	\n	    extraHeaders.push('Contact: ' + this.contact);\n	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	    extraHeaders.push('Content-Type: application/sdp');\n	\n	    this.receiveResponse = this.receiveReinviteResponse;\n	    //REVISIT\n	    this.mediaHandler.getDescription(self.mediaHint)\n	    .then(mangle)\n	    .then(\n	      function(body){\n	        self.dialog.sendRequest(self, SIP.C.INVITE, {\n	          extraHeaders: extraHeaders,\n	          body: body\n	        });\n	      },\n	      function() {\n	        if (self.isReadyToReinvite()) {\n	          self.onReadyToReinvite();\n	        }\n	        self.reinviteFailed();\n	      }\n	    );\n	  },\n	\n	  receiveRequest: function (request) {\n	    switch (request.method) {\n	      case SIP.C.BYE:\n	        request.reply(200);\n	        if(this.status === C.STATUS_CONFIRMED) {\n	          this.emit('bye', request);\n	          this.terminated(request, SIP.C.causes.BYE);\n	        }\n	        break;\n	      case SIP.C.INVITE:\n	        if(this.status === C.STATUS_CONFIRMED) {\n	          this.logger.log('re-INVITE received');\n	          this.receiveReinvite(request);\n	        }\n	        break;\n	      case SIP.C.INFO:\n	        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {\n	          var body, tone, duration,\n	              contentType = request.getHeader('content-type'),\n	              reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/,\n	              reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n	\n	          if (contentType) {\n	            if (contentType.match(/^application\\/dtmf-relay/i)) {\n	              if (request.body) {\n	                body = request.body.split('\\r\\n', 2);\n	                if (body.length === 2) {\n	                  if (reg_tone.test(body[0])) {\n	                    tone = body[0].replace(reg_tone,\"$2\");\n	                  }\n	                  if (reg_duration.test(body[1])) {\n	                    duration = parseInt(body[1].replace(reg_duration,\"$2\"), 10);\n	                  }\n	                }\n	              }\n	\n	              new DTMF(this, tone, {duration: duration}).init_incoming(request);\n	            } else {\n	              request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n	            }\n	          }\n	        }\n	        break;\n	      case SIP.C.REFER:\n	        if(this.status ===  C.STATUS_CONFIRMED) {\n	          this.logger.log('REFER received');\n	          request.reply(202, 'Accepted');\n	          var\n	            hasReferListener = this.listeners('refer').length,\n	            notifyBody = hasReferListener ?\n	              'SIP/2.0 100 Trying' :\n	              // RFC 3515.2.4.2: 'the UA MAY decline the request.'\n	              'SIP/2.0 603 Declined'\n	          ;\n	\n	          this.sendRequest(SIP.C.NOTIFY, {\n	            extraHeaders:[\n	              'Event: refer',\n	              'Subscription-State: terminated',\n	              'Content-Type: message/sipfrag'\n	            ],\n	            body: notifyBody,\n	            receiveResponse: function() {}\n	          });\n	\n	          if (hasReferListener) {\n	            this.emit('refer', request);\n	          }\n	        }\n	        break;\n	      case SIP.C.NOTIFY:\n	        request.reply(200, 'OK');\n	        this.emit('notify', request);\n	        break;\n	    }\n	  },\n	\n	  /**\n	   * Reception of Response for in-dialog INVITE\n	   * @private\n	   */\n	  receiveReinviteResponse: function(response) {\n	    var self = this,\n	        contentType = response.getHeader('Content-Type');\n	\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return;\n	    }\n	\n	    switch(true) {\n	      case /^1[0-9]{2}$/.test(response.status_code):\n	        break;\n	      case /^2[0-9]{2}$/.test(response.status_code):\n	        this.status = C.STATUS_CONFIRMED;\n	\n	        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});\n	\n	        if(!response.body) {\n	          this.reinviteFailed();\n	          break;\n	        } else if (contentType !== 'application/sdp') {\n	          this.reinviteFailed();\n	          break;\n	        }\n	\n	        //REVISIT\n	        this.mediaHandler.setDescription(response.body)\n	        .then(\n	          function onSuccess () {\n	            self.reinviteSucceeded();\n	          },\n	          function onFailure () {\n	            self.reinviteFailed();\n	          }\n	        );\n	        break;\n	      default:\n	        this.reinviteFailed();\n	    }\n	  },\n	\n	  acceptAndTerminate: function(response, status_code, reason_phrase) {\n	    var extraHeaders = [];\n	\n	    if (status_code) {\n	      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));\n	    }\n	\n	    // An error on dialog creation will fire 'failed' event\n	    if (this.dialog || this.createDialog(response, 'UAC')) {\n	      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n	      this.sendRequest(SIP.C.BYE, {\n	        extraHeaders: extraHeaders\n	      });\n	    }\n	\n	    return this;\n	  },\n	\n	  /**\n	   * RFC3261 13.3.1.4\n	   * Response retransmissions cannot be accomplished by transaction layer\n	   *  since it is destroyed when receiving the first 2xx answer\n	   */\n	  setInvite2xxTimer: function(request, body) {\n	    var self = this,\n	        timeout = SIP.Timers.T1;\n	\n	    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n	      if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n	        return;\n	      }\n	\n	      self.logger.log('no ACK received, attempting to retransmit OK');\n	\n	      request.reply(200, null, ['Contact: ' + self.contact], body);\n	\n	      timeout = Math.min(timeout * 2, SIP.Timers.T2);\n	\n	      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n	    }, timeout);\n	  },\n	\n	  /**\n	   * RFC3261 14.2\n	   * If a UAS generates a 2xx response and never receives an ACK,\n	   *  it SHOULD generate a BYE to terminate the dialog.\n	   */\n	  setACKTimer: function() {\n	    var self = this;\n	\n	    this.timers.ackTimer = SIP.Timers.setTimeout(function() {\n	      if(self.status === C.STATUS_WAITING_FOR_ACK) {\n	        self.logger.log('no ACK received for an extended period of time, terminating the call');\n	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n	        self.sendRequest(SIP.C.BYE);\n	        self.terminated(null, SIP.C.causes.NO_ACK);\n	      }\n	    }, SIP.Timers.TIMER_H);\n	  },\n	\n	  /*\n	   * @private\n	   */\n	  onReadyToReinvite: function() {\n	    var action = this.pending_actions.shift();\n	\n	    if (!action || !this[action.name]) {\n	      return;\n	    }\n	\n	    this[action.name]();\n	  },\n	\n	  onTransportError: function() {\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    }\n	  },\n	\n	  onDialogError: function(response) {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(response, SIP.C.causes.DIALOG_ERROR);\n	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n	    }\n	  },\n	\n	  /**\n	   * @private\n	   */\n	  onhold: function(originator) {\n	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;\n	    this.emit('hold', { originator: originator });\n	  },\n	\n	  /**\n	   * @private\n	   */\n	  onunhold: function(originator) {\n	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;\n	    this.emit('unhold', { originator: originator });\n	  },\n	\n	  /*\n	   * @private\n	   */\n	  onmute: function(options) {\n	    this.emit('muted', {\n	      audio: options.audio,\n	      video: options.video\n	    });\n	  },\n	\n	  /*\n	   * @private\n	   */\n	  onunmute: function(options) {\n	    this.emit('unmuted', {\n	      audio: options.audio,\n	      video: options.video\n	    });\n	  },\n	\n	  failed: function(response, cause) {\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	    this.emit('failed', response || null, cause || null);\n	    return this;\n	  },\n	\n	  rejected: function(response, cause) {\n	    this.emit('rejected',\n	      response || null,\n	      cause || null\n	    );\n	    return this;\n	  },\n	\n	  canceled: function() {\n	    this.emit('cancel');\n	    return this;\n	  },\n	\n	  accepted: function(response, cause) {\n	    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);\n	\n	    this.startTime = new Date();\n	\n	    if (this.replacee) {\n	      this.replacee.emit('replaced', this);\n	      this.replacee.terminate();\n	    }\n	    this.emit('accepted', response, cause);\n	    return this;\n	  },\n	\n	  terminated: function(message, cause) {\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    this.endTime = new Date();\n	\n	    this.close();\n	    this.emit('terminated',\n	      message || null,\n	      cause || null\n	    );\n	    return this;\n	  },\n	\n	  connecting: function(request) {\n	    this.emit('connecting', { request: request });\n	    return this;\n	  }\n	};\n	\n	Session.desugar = function desugar(options) {\n	  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {\n	    options = {\n	      media: {\n	        constraints: {\n	          audio: true,\n	          video: options.tagName === 'VIDEO'\n	        },\n	        render: {\n	          remote: options\n	        }\n	      }\n	    };\n	  }\n	  return options || {};\n	};\n	\n	\n	Session.C = C;\n	SIP.Session = Session;\n	\n	\n	InviteServerContext = function(ua, request) {\n	  var expires,\n	    self = this,\n	    contentType = request.getHeader('Content-Type'),\n	    contentDisp = request.parseHeader('Content-Disposition');\n	\n	  // Check body and content type\n	  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {\n	    this.renderbody = request.body;\n	    this.rendertype = contentType;\n	  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {\n	    request.reply(415);\n	    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it\n	    return;\n	  }\n	\n	  //TODO: move this into media handler\n	  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n	  SIP.Hacks.AllBrowsers.maskDtls(request);\n	\n	  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n	\n	  this.status = C.STATUS_INVITE_RECEIVED;\n	  this.from_tag = request.from_tag;\n	  this.id = request.call_id + this.from_tag;\n	  this.request = request;\n	  this.contact = this.ua.contact.toString();\n	\n	  this.receiveNonInviteResponse = function () {}; // intentional no-op\n	\n	  this.logger = ua.getLogger('sip.inviteservercontext', this.id);\n	\n	  //Save the session into the ua sessions collection.\n	  this.ua.sessions[this.id] = this;\n	\n	  //Get the Expires header value if exists\n	  if(request.hasHeader('expires')) {\n	    expires = request.getHeader('expires') * 1000;\n	  }\n	\n	  //Set 100rel if necessary\n	  function set100rel(h,c) {\n	    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n	      self.rel100 = c;\n	    }\n	  }\n	  set100rel('require', SIP.C.supported.REQUIRED);\n	  set100rel('supported', SIP.C.supported.SUPPORTED);\n	\n	  /* Set the to_tag before\n	   * replying a response code that will create a dialog.\n	   */\n	  request.to_tag = SIP.Utils.newTag();\n	\n	  // An error on dialog creation will fire 'failed' event\n	  if(!this.createDialog(request, 'UAS', true)) {\n	    request.reply(500, 'Missing Contact header field');\n	    return;\n	  }\n	\n	  //Initialize Media Session\n	  this.mediaHandler = this.mediaHandlerFactory(this, {\n	    RTCConstraints: {\"optional\": [{'DtlsSrtpKeyAgreement': 'true'}]}\n	  });\n	\n	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n	  }\n	\n	  function fireNewSession() {\n	    var options = {extraHeaders: ['Contact: ' + self.contact]};\n	\n	    if (self.rel100 !== SIP.C.supported.REQUIRED) {\n	      self.progress(options);\n	    }\n	    self.status = C.STATUS_WAITING_FOR_ANSWER;\n	\n	    // Set userNoAnswerTimer\n	    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {\n	      request.reply(408);\n	      self.failed(request, SIP.C.causes.NO_ANSWER);\n	      self.terminated(request, SIP.C.causes.NO_ANSWER);\n	    }, self.ua.configuration.noAnswerTimeout);\n	\n	    /* Set expiresTimer\n	     * RFC3261 13.3.1\n	     */\n	    if (expires) {\n	      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {\n	        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {\n	          request.reply(487);\n	          self.failed(request, SIP.C.causes.EXPIRES);\n	          self.terminated(request, SIP.C.causes.EXPIRES);\n	        }\n	      }, expires);\n	    }\n	\n	    self.emit('invite',request);\n	  }\n	\n	  if (!request.body || this.renderbody) {\n	    SIP.Timers.setTimeout(fireNewSession, 0);\n	  } else {\n	    this.hasOffer = true;\n	    this.mediaHandler.setDescription(request.body)\n	    .then(\n	      fireNewSession,\n	      function onFailure (e) {\n	        self.logger.warn('invalid SDP');\n	        self.logger.warn(e);\n	        request.reply(488);\n	      }\n	    );\n	  }\n	};\n	\n	InviteServerContext.prototype = {\n	  reject: function(options) {\n	    // Check Session Status\n	    if (this.status === C.STATUS_TERMINATED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.logger.log('rejecting RTCSession');\n	\n	    SIP.ServerContext.prototype.reject.call(this, options);\n	    return this.terminated();\n	  },\n	\n	  terminate: function(options) {\n	    options = options || {};\n	\n	    var\n	    extraHeaders = (options.extraHeaders || []).slice(),\n	    body = options.body,\n	    dialog,\n	    self = this;\n	\n	    if (this.status === C.STATUS_WAITING_FOR_ACK &&\n	       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n	      dialog = this.dialog;\n	\n	      this.receiveRequest = function(request) {\n	        if (request.method === SIP.C.ACK) {\n	          this.request(SIP.C.BYE, {\n	            extraHeaders: extraHeaders,\n	            body: body\n	          });\n	          dialog.terminate();\n	        }\n	      };\n	\n	      this.request.server_transaction.on('stateChanged', function(){\n	        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n	          this.request = new SIP.OutgoingRequest(\n	            SIP.C.BYE,\n	            this.dialog.remote_target,\n	            this.ua,\n	            {\n	              'cseq': this.dialog.local_seqnum+=1,\n	              'call_id': this.dialog.id.call_id,\n	              'from_uri': this.dialog.local_uri,\n	              'from_tag': this.dialog.id.local_tag,\n	              'to_uri': this.dialog.remote_uri,\n	              'to_tag': this.dialog.id.remote_tag,\n	              'route_set': this.dialog.route_set\n	            },\n	            extraHeaders,\n	            body\n	          );\n	\n	          new SIP.RequestSender(\n	            {\n	              request: this.request,\n	              onRequestTimeout: function() {\n	                self.onRequestTimeout();\n	              },\n	              onTransportError: function() {\n	                self.onTransportError();\n	              },\n	              receiveResponse: function() {\n	                return;\n	              }\n	            },\n	            this.ua\n	          ).send();\n	          dialog.terminate();\n	        }\n	      });\n	\n	      this.emit('bye', this.request);\n	      this.terminated();\n	\n	      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n	      this.dialog = dialog;\n	\n	      // Restore the dialog into 'ua' so the ACK can reach 'this' session\n	      this.ua.dialogs[dialog.id.toString()] = dialog;\n	\n	    } else if (this.status === C.STATUS_CONFIRMED) {\n	      this.bye(options);\n	    } else {\n	      this.reject(options);\n	    }\n	\n	    return this;\n	  },\n	\n	  /*\n	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	   */\n	  progress: function (options) {\n	    options = options || {};\n	    var\n	      statusCode = options.statusCode || 180,\n	      reasonPhrase = options.reasonPhrase,\n	      extraHeaders = (options.extraHeaders || []).slice(),\n	      iceServers,\n	      stunServers = options.stunServers || null,\n	      turnServers = options.turnServers || null,\n	      body = options.body,\n	      response;\n	\n	    if (statusCode < 100 || statusCode > 199) {\n	      throw new TypeError('Invalid statusCode: ' + statusCode);\n	    }\n	\n	    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    if (stunServers || turnServers) {\n	      if (stunServers) {\n	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid stunServers: '+ stunServers);\n	        } else {\n	          this.stunServers = iceServers;\n	        }\n	      }\n	\n	      if (turnServers) {\n	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid turnServers: '+ turnServers);\n	        } else {\n	          this.turnServers = iceServers;\n	        }\n	      }\n	\n	      this.mediaHandler.updateIceServers({\n	        stunServers: this.stunServers,\n	        turnServers: this.turnServers\n	      });\n	    }\n	\n	    function do100rel() {\n	      /* jshint validthis: true */\n	      statusCode = options.statusCode || 183;\n	\n	      // Set status and add extra headers\n	      this.status = C.STATUS_WAITING_FOR_PRACK;\n	      extraHeaders.push('Contact: '+ this.contact);\n	      extraHeaders.push('Require: 100rel');\n	      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));\n	\n	      // Save media hint for later (referred sessions)\n	      this.mediaHint = options.media;\n	\n	      // Get the session description to add to preaccept with\n	      this.mediaHandler.getDescription(options.media)\n	      .then(\n	        function onSuccess (body) {\n	          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n	            return;\n	          }\n	\n	          this.early_sdp = body;\n	          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;\n	\n	          // Retransmit until we get a response or we time out (see prackTimer below)\n	          var timeout = SIP.Timers.T1;\n	          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n	            this.request.reply(statusCode, null, extraHeaders, body);\n	            timeout *= 2;\n	            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n	          }.bind(this), timeout);\n	\n	          // Timeout and reject INVITE if no response\n	          this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n	            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n	              return;\n	            }\n	\n	            this.logger.log('no PRACK received, rejecting the call');\n	            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n	            this.request.reply(504);\n	            this.terminated(null, SIP.C.causes.NO_PRACK);\n	          }.bind(this), SIP.Timers.T1 * 64);\n	\n	          // Send the initial response\n	          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n	          this.emit('progress', response, reasonPhrase);\n	        }.bind(this),\n	\n	        function onFailure () {\n	          this.request.reply(480);\n	          this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	        }.bind(this)\n	      );\n	    } // end do100rel\n	\n	    function normalReply() {\n	      /* jshint validthis:true */\n	      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n	      this.emit('progress', response, reasonPhrase);\n	    }\n	\n	    if (options.statusCode !== 100 &&\n	        (this.rel100 === SIP.C.supported.REQUIRED ||\n	         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||\n	         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {\n	      do100rel.apply(this);\n	    } else {\n	      normalReply.apply(this);\n	    }\n	    return this;\n	  },\n	\n	  /*\n	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	   */\n	  accept: function(options) {\n	    options = Object.create(Session.desugar(options));\n	    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n	    this.mediaHint = options.media;\n	\n	    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21\n	    var\n	      //idx, length, hasAudio, hasVideo,\n	      self = this,\n	      request = this.request,\n	      extraHeaders = (options.extraHeaders || []).slice(),\n	    //mediaStream = options.mediaStream || null,\n	      iceServers,\n	      stunServers = options.stunServers || null,\n	      turnServers = options.turnServers || null,\n	      sdpCreationSucceeded = function(body) {\n	        var\n	          response,\n	          // run for reply success callback\n	          replySucceeded = function() {\n	            self.status = C.STATUS_WAITING_FOR_ACK;\n	\n	            self.setInvite2xxTimer(request, body);\n	            self.setACKTimer();\n	          },\n	\n	          // run for reply failure callback\n	          replyFailed = function() {\n	            self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n	          };\n	\n	        // Chrome might call onaddstream before accept() is called, which means\n	        // mediaHandler.render() was called without a renderHint, so we need to\n	        // re-render now that mediaHint.render has been set.\n	        //\n	        // Chrome seems to be in the right regarding this, see\n	        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream\n	        self.mediaHandler.render();\n	\n	        extraHeaders.push('Contact: ' + self.contact);\n	        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	        if(!self.hasOffer) {\n	          self.hasOffer = true;\n	        } else {\n	          self.hasAnswer = true;\n	        }\n	        response = request.reply(200, null, extraHeaders,\n	                      body,\n	                      replySucceeded,\n	                      replyFailed\n	                     );\n	        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail\n	          self.accepted(response, SIP.Utils.getReasonPhrase(200));\n	        }\n	      },\n	\n	      sdpCreationFailed = function() {\n	        if (self.status === C.STATUS_TERMINATED) {\n	          return;\n	        }\n	        // TODO - fail out on error\n	        self.request.reply(480);\n	        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n	        self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	      };\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n	      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n	      return this;\n	    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n	      this.status = C.STATUS_ANSWERED;\n	    } else if (this.status !== C.STATUS_EARLY_MEDIA) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    if ((stunServers || turnServers) &&\n	        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {\n	      if (stunServers) {\n	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid stunServers: '+ stunServers);\n	        } else {\n	          this.stunServers = iceServers;\n	        }\n	      }\n	\n	      if (turnServers) {\n	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid turnServers: '+ turnServers);\n	        } else {\n	          this.turnServers = iceServers;\n	        }\n	      }\n	\n	      this.mediaHandler.updateIceServers({\n	        stunServers: this.stunServers,\n	        turnServers: this.turnServers\n	      });\n	    }\n	\n	    // An error on dialog creation will fire 'failed' event\n	    if(!this.createDialog(request, 'UAS')) {\n	      request.reply(500, 'Missing Contact header field');\n	      return this;\n	    }\n	\n	    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);\n	\n	    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21\n	    /*\n	    length = this.getRemoteStreams().length;\n	\n	    for (idx = 0; idx < length; idx++) {\n	      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {\n	        hasVideo = true;\n	      }\n	      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {\n	        hasAudio = true;\n	      }\n	    }\n	\n	    if (!hasAudio && this.mediaConstraints.audio === true) {\n	      this.mediaConstraints.audio = false;\n	      if (mediaStream) {\n	        length = mediaStream.getAudioTracks().length;\n	        for (idx = 0; idx < length; idx++) {\n	          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);\n	        }\n	      }\n	    }\n	\n	    if (!hasVideo && this.mediaConstraints.video === true) {\n	      this.mediaConstraints.video = false;\n	      if (mediaStream) {\n	        length = mediaStream.getVideoTracks().length;\n	        for (idx = 0; idx < length; idx++) {\n	          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);\n	        }\n	      }\n	    }\n	    */\n	\n	    if (this.status === C.STATUS_EARLY_MEDIA) {\n	      sdpCreationSucceeded();\n	    } else {\n	      this.mediaHandler.getDescription(self.mediaHint)\n	      .then(\n	        sdpCreationSucceeded,\n	        sdpCreationFailed\n	      );\n	    }\n	\n	    return this;\n	  },\n	\n	  receiveRequest: function(request) {\n	\n	    // ISC RECEIVE REQUEST\n	\n	    function confirmSession() {\n	      /* jshint validthis:true */\n	      var contentType;\n	\n	      SIP.Timers.clearTimeout(this.timers.ackTimer);\n	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n	      this.status = C.STATUS_CONFIRMED;\n	      this.unmute();\n	\n	      // TODO - this logic assumes Content-Disposition defaults\n	      contentType = request.getHeader('Content-Type');\n	      if (contentType !== 'application/sdp') {\n	        this.renderbody = request.body;\n	        this.rendertype = contentType;\n	      }\n	    }\n	\n	    switch(request.method) {\n	    case SIP.C.CANCEL:\n	      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n	       * was in progress and that the UAC MAY continue with the session established by\n	       * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n	       * established session. So the CANCEL is processed only if the session is not yet\n	       * established.\n	       */\n	\n	      /*\n	       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n	       *request opening the session.\n	       */\n	      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||\n	         this.status === C.STATUS_WAITING_FOR_PRACK ||\n	         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||\n	         this.status === C.STATUS_EARLY_MEDIA ||\n	         this.status === C.STATUS_ANSWERED) {\n	\n	        this.status = C.STATUS_CANCELED;\n	        this.request.reply(487);\n	        this.canceled(request);\n	        this.rejected(request, SIP.C.causes.CANCELED);\n	        this.failed(request, SIP.C.causes.CANCELED);\n	        this.terminated(request, SIP.C.causes.CANCELED);\n	      }\n	      break;\n	    case SIP.C.ACK:\n	      if(this.status === C.STATUS_WAITING_FOR_ACK) {\n	        if (!this.hasAnswer) {\n	          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n	            // ACK contains answer to an INVITE w/o SDP negotiation\n	            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n	            SIP.Hacks.AllBrowsers.maskDtls(request);\n	\n	            this.hasAnswer = true;\n	            this.mediaHandler.setDescription(request.body)\n	            .then(\n	              confirmSession.bind(this),\n	              function onFailure (e) {\n	                this.logger.warn(e);\n	                this.terminate({\n	                  statusCode: '488',\n	                  reasonPhrase: 'Bad Media Description'\n	                });\n	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              }.bind(this)\n	            );\n	          } else if (this.early_sdp) {\n	            confirmSession.apply(this);\n	          } else {\n	            //TODO: Pass to mediahandler\n	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	          }\n	        } else {\n	          confirmSession.apply(this);\n	        }\n	      }\n	      break;\n	    case SIP.C.PRACK:\n	      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n	        //localMedia = session.mediaHandler.localMedia;\n	        if(!this.hasAnswer) {\n	          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n	            this.hasAnswer = true;\n	            this.mediaHandler.setDescription(request.body)\n	            .then(\n	              function onSuccess () {\n	                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n	                SIP.Timers.clearTimeout(this.timers.prackTimer);\n	                request.reply(200);\n	                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n	                  this.status = C.STATUS_EARLY_MEDIA;\n	                  this.accept();\n	                }\n	                this.status = C.STATUS_EARLY_MEDIA;\n	                //REVISIT\n	                this.mute();\n	              }.bind(this),\n	              function onFailure (e) {\n	                //TODO: Send to media handler\n	                this.logger.warn(e);\n	                this.terminate({\n	                  statusCode: '488',\n	                  reasonPhrase: 'Bad Media Description'\n	                });\n	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              }.bind(this)\n	            );\n	          } else {\n	            this.terminate({\n	              statusCode: '488',\n	              reasonPhrase: 'Bad Media Description'\n	            });\n	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	          }\n	        } else {\n	          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n	          SIP.Timers.clearTimeout(this.timers.prackTimer);\n	          request.reply(200);\n	\n	          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n	            this.status = C.STATUS_EARLY_MEDIA;\n	            this.accept();\n	          }\n	          this.status = C.STATUS_EARLY_MEDIA;\n	          //REVISIT\n	          this.mute();\n	        }\n	      } else if(this.status === C.STATUS_EARLY_MEDIA) {\n	        request.reply(200);\n	      }\n	      break;\n	    default:\n	      Session.prototype.receiveRequest.apply(this, [request]);\n	      break;\n	    }\n	  },\n	\n	  onTransportError: function() {\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    }\n	  }\n	\n	};\n	\n	SIP.InviteServerContext = InviteServerContext;\n	\n	InviteClientContext = function(ua, target, options) {\n	  options = Object.create(Session.desugar(options));\n	  options.params = Object.create(options.params || Object.prototype);\n	\n	  var iceServers,\n	    extraHeaders = (options.extraHeaders || []).slice(),\n	    stunServers = options.stunServers || null,\n	    turnServers = options.turnServers || null,\n	    isMediaSupported = ua.configuration.mediaHandlerFactory.isSupported;\n	\n	  // Check WebRTC support\n	  if (isMediaSupported && !isMediaSupported()) {\n	    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n	  }\n	\n	  this.RTCConstraints = options.RTCConstraints || {};\n	  this.inviteWithoutSdp = options.inviteWithoutSdp || false;\n	\n	  // Set anonymous property\n	  this.anonymous = options.anonymous || false;\n	\n	  // Custom data to be sent either in INVITE or in ACK\n	  this.renderbody = options.renderbody || null;\n	  this.rendertype = options.rendertype || 'text/plain';\n	\n	  options.params.from_tag = this.from_tag;\n	\n	  /* Do not add ;ob in initial forming dialog requests if the registration over\n	   *  the current connection got a GRUU URI.\n	   */\n	  this.contact = ua.contact.toString({\n	    anonymous: this.anonymous,\n	    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n	  });\n	\n	  if (this.anonymous) {\n	    options.params.from_displayName = 'Anonymous';\n	    options.params.from_uri = 'sip:anonymous@anonymous.invalid';\n	\n	    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());\n	    extraHeaders.push('Privacy: id');\n	  }\n	  extraHeaders.push('Contact: '+ this.contact);\n	  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	  if (!this.inviteWithoutSdp) {\n	    extraHeaders.push('Content-Type: application/sdp');\n	  } else if (this.renderbody) {\n	    extraHeaders.push('Content-Type: ' + this.rendertype);\n	    extraHeaders.push('Content-Disposition: render;handling=optional');\n	  }\n	\n	  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n	    extraHeaders.push('Require: 100rel');\n	  }\n	  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {\n	    extraHeaders.push('Require: replaces');\n	  }\n	\n	  options.extraHeaders = extraHeaders;\n	\n	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n	\n	  // Check Session Status\n	  if (this.status !== C.STATUS_NULL) {\n	    throw new SIP.Exceptions.InvalidStateError(this.status);\n	  }\n	\n	  // Session parameter initialization\n	  this.from_tag = SIP.Utils.newTag();\n	\n	  // OutgoingSession specific parameters\n	  this.isCanceled = false;\n	  this.received_100 = false;\n	\n	  this.method = SIP.C.INVITE;\n	\n	  this.receiveNonInviteResponse = this.receiveResponse;\n	  this.receiveResponse = this.receiveInviteResponse;\n	\n	  this.logger = ua.getLogger('sip.inviteclientcontext');\n	\n	  if (stunServers) {\n	    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n	    if (!iceServers) {\n	      throw new TypeError('Invalid stunServers: '+ stunServers);\n	    } else {\n	      this.stunServers = iceServers;\n	    }\n	  }\n	\n	  if (turnServers) {\n	    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n	    if (!iceServers) {\n	      throw new TypeError('Invalid turnServers: '+ turnServers);\n	    } else {\n	      this.turnServers = iceServers;\n	    }\n	  }\n	\n	  ua.applicants[this] = this;\n	\n	  this.id = this.request.call_id + this.from_tag;\n	\n	  //Initialize Media Session\n	  this.mediaHandler = this.mediaHandlerFactory(this, {\n	    RTCConstraints: this.RTCConstraints,\n	    stunServers: this.stunServers,\n	    turnServers: this.turnServers\n	  });\n	\n	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n	  }\n	\n	  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n	  this.mediaHint = options.media;\n	};\n	\n	InviteClientContext.prototype = {\n	  invite: function () {\n	    var self = this;\n	\n	    //Save the session into the ua sessions collection.\n	    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n	    this.ua.sessions[this.id] = this;\n	\n	    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level\n	    // and hand sip.js a stream as the mediaHint\n	    if (this.inviteWithoutSdp) {\n	      //just send an invite with no sdp...\n	      this.request.body = self.renderbody;\n	      this.status = C.STATUS_INVITE_SENT;\n	      this.send();\n	    } else {\n	      this.mediaHandler.getDescription(self.mediaHint)\n	      .then(\n	        function onSuccess(offer) {\n	          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n	            return;\n	          }\n	          self.hasOffer = true;\n	          self.request.body = offer;\n	          self.status = C.STATUS_INVITE_SENT;\n	          self.send();\n	        },\n	        function onFailure() {\n	          if (self.status === C.STATUS_TERMINATED) {\n	            return;\n	          }\n	          // TODO...fail out\n	          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n	          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	          self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	        }\n	      );\n	    }\n	\n	    return this;\n	  },\n	\n	  receiveInviteResponse: function(response) {\n	    var cause, //localMedia,\n	      session = this,\n	      id = response.call_id + response.from_tag + response.to_tag,\n	      extraHeaders = [],\n	      options = {};\n	\n	    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n	      return;\n	    }\n	\n	    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {\n	      if (id !== this.dialog.id.toString() ) {\n	        if (!this.createDialog(response, 'UAC', true)) {\n	          return;\n	        }\n	        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,\n	                                          {\n	                                            body: SIP.Utils.generateFakeSDP(response.body)\n	                                          });\n	        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n	\n	        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n	         * leg (due to peerConnection limitations) has been answered first. If your forking\n	         * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n	         */\n	        if(this.status !== C.STATUS_CONFIRMED) {\n	          this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n	          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);\n	        }\n	        return;\n	      } else if (this.status === C.STATUS_CONFIRMED) {\n	        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n	        return;\n	      } else if (!this.hasAnswer) {\n	        // invite w/o sdp is waiting for callback\n	        //an invite with sdp must go on, and hasAnswer is true\n	        return;\n	      }\n	    }\n	\n	    if (this.dialog && response.status_code < 200) {\n	      /*\n	        Early media has been set up with at least one other different branch,\n	        but a final 2xx response hasn't been received\n	      */\n	      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n	          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {\n	        return;\n	      }\n	\n	      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n	        return;\n	      }\n	\n	      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n	          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n	        return;\n	      }\n	\n	      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n	\n	      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n	        extraHeaders: extraHeaders,\n	        body: SIP.Utils.generateFakeSDP(response.body)\n	      });\n	      return;\n	    }\n	\n	    // Proceed to cancellation if the user requested.\n	    if(this.isCanceled) {\n	      if(response.status_code >= 100 && response.status_code < 200) {\n	        this.request.cancel(this.cancelReason);\n	        this.canceled(null);\n	      } else if(response.status_code >= 200 && response.status_code < 299) {\n	        this.acceptAndTerminate(response);\n	        this.emit('bye', this.request);\n	      } else if (response.status_code >= 300) {\n	        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;\n	        this.rejected(response, cause);\n	        this.failed(response, cause);\n	        this.terminated(response, cause);\n	      }\n	      return;\n	    }\n	\n	    switch(true) {\n	      case /^100$/.test(response.status_code):\n	        this.received_100 = true;\n	        this.emit('progress', response);\n	        break;\n	      case (/^1[0-9]{2}$/.test(response.status_code)):\n	        // Do nothing with 1xx responses without To tag.\n	        if(!response.to_tag) {\n	          this.logger.warn('1xx response received without to tag');\n	          break;\n	        }\n	\n	        // Create Early Dialog if 1XX comes with contact\n	        if(response.hasHeader('contact')) {\n	          // An error on dialog creation will fire 'failed' event\n	          if (!this.createDialog(response, 'UAC', true)) {\n	            break;\n	          }\n	        }\n	\n	        this.status = C.STATUS_1XX_RECEIVED;\n	\n	        if(response.hasHeader('require') &&\n	           response.getHeader('require').indexOf('100rel') !== -1) {\n	\n	          // Do nothing if this.dialog is already confirmed\n	          if (this.dialog || !this.earlyDialogs[id]) {\n	            break;\n	          }\n	\n	          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n	              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n	            return;\n	          }\n	\n	          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n	          SIP.Hacks.AllBrowsers.maskDtls(response);\n	\n	          if (!response.body) {\n	            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n	            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n	              extraHeaders: extraHeaders\n	            });\n	            this.emit('progress', response);\n	\n	          } else if (this.hasOffer) {\n	            if (!this.createDialog(response, 'UAC')) {\n	              break;\n	            }\n	            this.hasAnswer = true;\n	            this.dialog.pracked.push(response.getHeader('rseq'));\n	\n	            this.mediaHandler.setDescription(response.body)\n	            .then(\n	              function onSuccess () {\n	                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	\n	                session.sendRequest(SIP.C.PRACK, {\n	                  extraHeaders: extraHeaders,\n	                  receiveResponse: function() {}\n	                });\n	                session.status = C.STATUS_EARLY_MEDIA;\n	                session.mute();\n	                session.emit('progress', response);\n	                /*\n	                if (session.status === C.STATUS_EARLY_MEDIA) {\n	                  localMedia = session.mediaHandler.localMedia;\n	                  if (localMedia.getAudioTracks().length > 0) {\n	                    localMedia.getAudioTracks()[0].enabled = false;\n	                  }\n	                  if (localMedia.getVideoTracks().length > 0) {\n	                    localMedia.getVideoTracks()[0].enabled = false;\n	                  }\n	                }*/\n	              },\n	              function onFailure (e) {\n	                session.logger.warn(e);\n	                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n	                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              }\n	            );\n	          } else {\n	            var earlyDialog = this.earlyDialogs[id];\n	            var earlyMedia = earlyDialog.mediaHandler;\n	\n	            earlyDialog.pracked.push(response.getHeader('rseq'));\n	\n	            earlyMedia.setDescription(response.body)\n	            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))\n	            .then(function onSuccess(sdp) {\n	              extraHeaders.push('Content-Type: application/sdp');\n	              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	              earlyDialog.sendRequest(session, SIP.C.PRACK, {\n	                extraHeaders: extraHeaders,\n	                body: sdp\n	              });\n	              session.status = C.STATUS_EARLY_MEDIA;\n	              session.emit('progress', response);\n	            })\n	            .catch(function onFailure(e) {\n	              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n	                earlyDialog.pracked.push(response.getHeader('rseq'));\n	                if (session.status === C.STATUS_TERMINATED) {\n	                  return;\n	                }\n	                // TODO - fail out on error\n	                // session.failed(gum error);\n	                session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	              } else {\n	                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);\n	                // Could not set remote description\n	                session.logger.warn('invalid SDP');\n	                session.logger.warn(e);\n	              }\n	            });\n	          }\n	        } else {\n	          this.emit('progress', response);\n	        }\n	        break;\n	      case /^2[0-9]{2}$/.test(response.status_code):\n	        var cseq = this.request.cseq + ' ' + this.request.method;\n	        if (cseq !== response.getHeader('cseq')) {\n	          break;\n	        }\n	\n	        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n	          this.status = C.STATUS_CONFIRMED;\n	          this.unmute();\n	          /*localMedia = this.mediaHandler.localMedia;\n	          if (localMedia.getAudioTracks().length > 0) {\n	            localMedia.getAudioTracks()[0].enabled = true;\n	          }\n	          if (localMedia.getVideoTracks().length > 0) {\n	            localMedia.getVideoTracks()[0].enabled = true;\n	          }*/\n	          options = {};\n	          if (this.renderbody) {\n	            extraHeaders.push('Content-Type: ' + this.rendertype);\n	            options.extraHeaders = extraHeaders;\n	            options.body = this.renderbody;\n	          }\n	          options.cseq = response.cseq;\n	          this.sendRequest(SIP.C.ACK, options);\n	          this.accepted(response);\n	          break;\n	        }\n	        // Do nothing if this.dialog is already confirmed\n	        if (this.dialog) {\n	          break;\n	        }\n	\n	        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n	        SIP.Hacks.AllBrowsers.maskDtls(response);\n	\n	        // This is an invite without sdp\n	        if (!this.hasOffer) {\n	          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {\n	            //REVISIT\n	            this.hasOffer = true;\n	            this.hasAnswer = true;\n	            this.mediaHandler = this.earlyDialogs[id].mediaHandler;\n	            if (!this.createDialog(response, 'UAC')) {\n	              break;\n	            }\n	            this.status = C.STATUS_CONFIRMED;\n	            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});\n	\n	            this.unmute();\n	            /*\n	            localMedia = session.mediaHandler.localMedia;\n	            if (localMedia.getAudioTracks().length > 0) {\n	              localMedia.getAudioTracks()[0].enabled = true;\n	            }\n	            if (localMedia.getVideoTracks().length > 0) {\n	              localMedia.getVideoTracks()[0].enabled = true;\n	            }*/\n	            this.accepted(response);\n	          } else {\n	            if(!response.body) {\n	              this.acceptAndTerminate(response, 400, 'Missing session description');\n	              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              break;\n	            }\n	            if (!this.createDialog(response, 'UAC')) {\n	              break;\n	            }\n	            this.hasOffer = true;\n	            this.mediaHandler.setDescription(response.body)\n	            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n	            .then(function onSuccess(sdp) {\n	              //var localMedia;\n	              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {\n	                return;\n	              }\n	\n	              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);\n	\n	              session.status = C.STATUS_CONFIRMED;\n	              session.hasAnswer = true;\n	\n	              session.unmute();\n	              /*localMedia = session.mediaHandler.localMedia;\n	              if (localMedia.getAudioTracks().length > 0) {\n	                localMedia.getAudioTracks()[0].enabled = true;\n	              }\n	              if (localMedia.getVideoTracks().length > 0) {\n	                localMedia.getVideoTracks()[0].enabled = true;\n	              }*/\n	              session.sendRequest(SIP.C.ACK,{\n	                body: sdp,\n	                extraHeaders:['Content-Type: application/sdp'],\n	                cseq:response.cseq\n	              });\n	              session.accepted(response);\n	            })\n	            .catch(function onFailure(e) {\n	              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n	                // TODO do something here\n	                session.logger.warn(\"there was a problem\");\n	              } else {\n	                session.logger.warn('invalid SDP');\n	                session.logger.warn(e);\n	                response.reply(488);\n	              }\n	            });\n	          }\n	        } else if (this.hasAnswer){\n	          if (this.renderbody) {\n	            extraHeaders.push('Content-Type: ' + session.rendertype);\n	            options.extraHeaders = extraHeaders;\n	            options.body = this.renderbody;\n	          }\n	          this.sendRequest(SIP.C.ACK, options);\n	        } else {\n	          if(!response.body) {\n	            this.acceptAndTerminate(response, 400, 'Missing session description');\n	            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            break;\n	          }\n	          if (!this.createDialog(response, 'UAC')) {\n	            break;\n	          }\n	          this.hasAnswer = true;\n	          this.mediaHandler.setDescription(response.body)\n	          .then(\n	            function onSuccess () {\n	              var options = {};//,localMedia;\n	              session.status = C.STATUS_CONFIRMED;\n	              session.unmute();\n	              /*localMedia = session.mediaHandler.localMedia;\n	              if (localMedia.getAudioTracks().length > 0) {\n	                localMedia.getAudioTracks()[0].enabled = true;\n	              }\n	              if (localMedia.getVideoTracks().length > 0) {\n	                localMedia.getVideoTracks()[0].enabled = true;\n	              }*/\n	              if (session.renderbody) {\n	                extraHeaders.push('Content-Type: ' + session.rendertype);\n	                options.extraHeaders = extraHeaders;\n	                options.body = session.renderbody;\n	              }\n	              options.cseq = response.cseq;\n	              session.sendRequest(SIP.C.ACK, options);\n	              session.accepted(response);\n	            },\n	            function onFailure (e) {\n	              session.logger.warn(e);\n	              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n	              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            }\n	          );\n	        }\n	        break;\n	      default:\n	        cause = SIP.Utils.sipErrorCause(response.status_code);\n	        this.rejected(response, cause);\n	        this.failed(response, cause);\n	        this.terminated(response, cause);\n	    }\n	  },\n	\n	  cancel: function(options) {\n	    options = options || {};\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.logger.log('canceling RTCSession');\n	\n	    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_NULL ||\n	        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {\n	      this.isCanceled = true;\n	      this.cancelReason = cancel_reason;\n	    } else if (this.status === C.STATUS_INVITE_SENT ||\n	               this.status === C.STATUS_1XX_RECEIVED ||\n	               this.status === C.STATUS_EARLY_MEDIA) {\n	      this.request.cancel(cancel_reason);\n	    }\n	\n	    return this.canceled();\n	  },\n	\n	  terminate: function(options) {\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n	      this.bye(options);\n	    } else {\n	      this.cancel(options);\n	    }\n	\n	    return this;\n	  },\n	\n	  receiveRequest: function(request) {\n	    // ICC RECEIVE REQUEST\n	\n	    // Reject CANCELs\n	    if (request.method === SIP.C.CANCEL) {\n	      // TODO; make this a switch when it gets added\n	    }\n	\n	    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n	      SIP.Timers.clearTimeout(this.timers.ackTimer);\n	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n	      this.status = C.STATUS_CONFIRMED;\n	      this.unmute();\n	\n	      this.accepted();\n	    }\n	\n	    return Session.prototype.receiveRequest.apply(this, [request]);\n	  },\n	\n	  onTransportError: function() {\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    }\n	  }\n	\n	};\n	\n	SIP.InviteClientContext = InviteClientContext;\n	\n	};\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview DTMF\n	 */\n	\n	/**\n	 * @class DTMF\n	 * @param {SIP.Session} session\n	 */\n	module.exports = function (SIP) {\n	\n	var DTMF,\n	  C = {\n	    MIN_DURATION:            70,\n	    MAX_DURATION:            6000,\n	    DEFAULT_DURATION:        100,\n	    MIN_INTER_TONE_GAP:      50,\n	    DEFAULT_INTER_TONE_GAP:  500\n	  };\n	\n	DTMF = function(session, tone, options) {\n	  var duration, interToneGap;\n	\n	  if (tone === undefined) {\n	    throw new TypeError('Not enough arguments');\n	  }\n	\n	  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n	  this.owner = session;\n	  this.direction = null;\n	\n	  options = options || {};\n	  duration = options.duration || null;\n	  interToneGap = options.interToneGap || null;\n	\n	  // Check tone type\n	  if (typeof tone === 'string' ) {\n	    tone = tone.toUpperCase();\n	  } else if (typeof tone === 'number') {\n	    tone = tone.toString();\n	  } else {\n	    throw new TypeError('Invalid tone: '+ tone);\n	  }\n	\n	  // Check tone value\n	  if (!tone.match(/^[0-9A-D#*]$/)) {\n	    throw new TypeError('Invalid tone: '+ tone);\n	  } else {\n	    this.tone = tone;\n	  }\n	\n	  // Check duration\n	  if (duration && !SIP.Utils.isDecimal(duration)) {\n	    throw new TypeError('Invalid tone duration: '+ duration);\n	  } else if (!duration) {\n	    duration = DTMF.C.DEFAULT_DURATION;\n	  } else if (duration < DTMF.C.MIN_DURATION) {\n	    this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');\n	    duration = DTMF.C.MIN_DURATION;\n	  } else if (duration > DTMF.C.MAX_DURATION) {\n	    this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');\n	    duration = DTMF.C.MAX_DURATION;\n	  } else {\n	    duration = Math.abs(duration);\n	  }\n	  this.duration = duration;\n	\n	  // Check interToneGap\n	  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n	    throw new TypeError('Invalid interToneGap: '+ interToneGap);\n	  } else if (!interToneGap) {\n	    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;\n	  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {\n	    this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');\n	    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;\n	  } else {\n	    interToneGap = Math.abs(interToneGap);\n	  }\n	  this.interToneGap = interToneGap;\n	};\n	DTMF.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	\n	DTMF.prototype.send = function(options) {\n	  var extraHeaders, body;\n	\n	  this.direction = 'outgoing';\n	\n	  // Check RTCSession Status\n	  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&\n	    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n	    throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n	  }\n	\n	  // Get DTMF options\n	  options = options || {};\n	  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n	\n	  extraHeaders.push('Content-Type: application/dtmf-relay');\n	\n	  body = \"Signal= \" + this.tone + \"\\r\\n\";\n	  body += \"Duration= \" + this.duration;\n	\n	  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n	    extraHeaders: extraHeaders,\n	    body: body\n	  });\n	\n	  this.owner.emit('dtmf', this.request, this);\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.receiveResponse = function(response) {\n	  var cause;\n	\n	  switch(true) {\n	    case /^1[0-9]{2}$/.test(response.status_code):\n	      // Ignore provisional responses.\n	      break;\n	\n	    case /^2[0-9]{2}$/.test(response.status_code):\n	      this.emit('succeeded', {\n	        originator: 'remote',\n	        response: response\n	      });\n	      break;\n	\n	    default:\n	      cause = SIP.Utils.sipErrorCause(response.status_code);\n	      this.emit('failed', response, cause);\n	      break;\n	  }\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.onRequestTimeout = function() {\n	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n	  this.owner.onRequestTimeout();\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.onTransportError = function() {\n	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n	  this.owner.onTransportError();\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.onDialogError = function(response) {\n	  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n	  this.owner.onDialogError(response);\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.init_incoming = function(request) {\n	  this.direction = 'incoming';\n	  this.request = request;\n	\n	  request.reply(200);\n	\n	  if (!this.tone || !this.duration) {\n	    this.logger.warn('invalid INFO DTMF received, discarded');\n	  } else {\n	    this.owner.emit('dtmf', request, this);\n	  }\n	};\n	\n	DTMF.C = C;\n	return DTMF;\n	};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP Subscription.\n	 */\n	module.exports = function (SIP) {\n	SIP.Subscription = function (ua, target, event, options) {\n	  options = Object.create(options || Object.prototype);\n	  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();\n	\n	  this.id = null;\n	  this.state = 'init';\n	\n	  if (!event) {\n	    throw new TypeError('Event necessary to create a subscription.');\n	  } else {\n	    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n	    //The check may need to/should probably occur on the other side,\n	    this.event = event;\n	  }\n	\n	  if(typeof options.expires !== 'number'){\n	    ua.logger.warn('expires must be a number. Using default of 3600.');\n	    this.expires = 3600;\n	  } else {\n	    this.expires = options.expires;\n	  }\n	\n	  options.extraHeaders.push('Event: ' + this.event);\n	  options.extraHeaders.push('Expires: ' + this.expires);\n	\n	  if (options.body) {\n	    this.body = options.body;\n	  }\n	\n	  this.contact = ua.contact.toString();\n	\n	  options.extraHeaders.push('Contact: '+ this.contact);\n	  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n	\n	  this.logger = ua.getLogger('sip.subscription');\n	\n	  this.dialog = null;\n	  this.timers = {N: null, sub_duration: null};\n	  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];\n	};\n	\n	SIP.Subscription.prototype = {\n	  subscribe: function() {\n	    var sub = this;\n	\n	     //these states point to an existing subscription, no subscribe is necessary\n	    if (this.state === 'active') {\n	      this.refresh();\n	      return this;\n	    } else if (this.state === 'notify_wait') {\n	      return this;\n	    }\n	\n	    SIP.Timers.clearTimeout(this.timers.sub_duration);\n	    SIP.Timers.clearTimeout(this.timers.N);\n	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n	\n	    this.send();\n	\n	    this.state = 'notify_wait';\n	\n	    return this;\n	  },\n	\n	  refresh: function () {\n	    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {\n	      return;\n	    }\n	\n	    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {\n	      extraHeaders: this.extraHeaders,\n	      body: this.body\n	    });\n	  },\n	\n	  receiveResponse: function(response) {\n	    var expires, sub = this,\n	        cause = SIP.Utils.getReasonPhrase(response.status_code);\n	\n	    if ((this.state === 'notify_wait' && response.status_code >= 300) ||\n	        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {\n	      this.failed(response, null);\n	    } else if (/^2[0-9]{2}$/.test(response.status_code)){\n	      expires = response.getHeader('Expires');\n	      SIP.Timers.clearTimeout(this.timers.N);\n	\n	      if (this.createConfirmedDialog(response,'UAC')) {\n	        this.id = this.dialog.id.toString();\n	        this.ua.subscriptions[this.id] = this;\n	        this.emit('accepted', response, cause);\n	        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n	      }\n	\n	      if (expires && expires <= this.expires) {\n	        // Preserve new expires value for subsequent requests\n	        this.expires = expires;\n	        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);\n	      } else {\n	        if (!expires) {\n	          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n	          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n	        } else {\n	          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n	          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n	        }\n	      }\n	    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx\n	  },\n	\n	  unsubscribe: function() {\n	    var extraHeaders = [], sub = this;\n	\n	    this.state = 'terminated';\n	\n	    extraHeaders.push('Event: ' + this.event);\n	    extraHeaders.push('Expires: 0');\n	\n	    extraHeaders.push('Contact: '+ this.contact);\n	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	    //makes sure expires isn't set, and other typical resubscribe behavior\n	    this.receiveResponse = function(){};\n	\n	    this.dialog.sendRequest(this, this.method, {\n	      extraHeaders: extraHeaders,\n	      body: this.body\n	    });\n	\n	    SIP.Timers.clearTimeout(this.timers.sub_duration);\n	    SIP.Timers.clearTimeout(this.timers.N);\n	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  timer_fire: function(){\n	    if (this.state === 'terminated') {\n	      this.terminateDialog();\n	      SIP.Timers.clearTimeout(this.timers.N);\n	      SIP.Timers.clearTimeout(this.timers.sub_duration);\n	\n	      delete this.ua.subscriptions[this.id];\n	    } else if (this.state === 'pending' || this.state === 'notify_wait') {\n	      this.close();\n	    } else {\n	      this.refresh();\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  close: function() {\n	    if(this.state !== 'notify_wait' && this.state !== 'terminated') {\n	      this.unsubscribe();\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  createConfirmedDialog: function(message, type) {\n	    var dialog;\n	\n	    this.terminateDialog();\n	    dialog = new SIP.Dialog(this, message, type);\n	\n	    if(!dialog.error) {\n	      this.dialog = dialog;\n	      return true;\n	    }\n	    // Dialog not created due to an error\n	    else {\n	      return false;\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  terminateDialog: function() {\n	    if(this.dialog) {\n	      delete this.ua.subscriptions[this.id];\n	      this.dialog.terminate();\n	      delete this.dialog;\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  receiveRequest: function(request) {\n	    var sub_state, sub = this;\n	\n	    function setExpiresTimeout() {\n	      if (sub_state.expires) {\n	        SIP.Timers.clearTimeout(sub.timers.sub_duration);\n	        sub_state.expires = Math.min(sub.expires,\n	                                     Math.max(sub_state.expires, 0));\n	        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),\n	                                                    sub_state.expires * 900);\n	      }\n	    }\n	\n	    if (!this.matchEvent(request)) { //checks event and subscription_state headers\n	      request.reply(489);\n	      return;\n	    }\n	\n	    sub_state = request.parseHeader('Subscription-State');\n	\n	    request.reply(200, SIP.C.REASON_200);\n	\n	    SIP.Timers.clearTimeout(this.timers.N);\n	\n	    this.emit('notify', {request: request});\n	\n	    // if we've set state to terminated, no further processing should take place\n	    // and we are only interested in cleaning up after the appropriate NOTIFY\n	    if (this.state === 'terminated') {\n	      if (sub_state.state === 'terminated') {\n	        this.terminateDialog();\n	        SIP.Timers.clearTimeout(this.timers.N);\n	        SIP.Timers.clearTimeout(this.timers.sub_duration);\n	\n	        delete this.ua.subscriptions[this.id];\n	      }\n	      return;\n	    }\n	\n	    switch (sub_state.state) {\n	      case 'active':\n	        this.state = 'active';\n	        setExpiresTimeout();\n	        break;\n	      case 'pending':\n	        if (this.state === 'notify_wait') {\n	          setExpiresTimeout();\n	        }\n	        this.state = 'pending';\n	        break;\n	      case 'terminated':\n	        SIP.Timers.clearTimeout(this.timers.sub_duration);\n	        if (sub_state.reason) {\n	          this.logger.log('terminating subscription with reason '+ sub_state.reason);\n	          switch (sub_state.reason) {\n	            case 'deactivated':\n	            case 'timeout':\n	              this.subscribe();\n	              return;\n	            case 'probation':\n	            case 'giveup':\n	              if(sub_state.params && sub_state.params['retry-after']) {\n	                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n	              } else {\n	                this.subscribe();\n	              }\n	              return;\n	            case 'rejected':\n	            case 'noresource':\n	            case 'invariant':\n	              break;\n	          }\n	        }\n	        this.close();\n	        break;\n	    }\n	  },\n	\n	  failed: function(response, cause) {\n	    this.close();\n	    this.emit('failed', response, cause);\n	    return this;\n	  },\n	\n	  onDialogError: function(response) {\n	    this.failed(response, SIP.C.causes.DIALOG_ERROR);\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  matchEvent: function(request) {\n	    var event;\n	\n	    // Check mandatory header Event\n	    if (!request.hasHeader('Event')) {\n	      this.logger.warn('missing Event header');\n	      return false;\n	    }\n	    // Check mandatory header Subscription-State\n	    if (!request.hasHeader('Subscription-State')) {\n	      this.logger.warn('missing Subscription-State header');\n	      return false;\n	    }\n	\n	    // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n	    event = request.parseHeader('event').event;\n	\n	    if (this.event !== event) {\n	      this.logger.warn('event match failed');\n	      request.reply(481, 'Event Match Failed');\n	      return false;\n	    } else {\n	      return true;\n	    }\n	  }\n	};\n	};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview WebRTC\n	 */\n	\n	module.exports = function (SIP, environment) {\n	var WebRTC;\n	\n	WebRTC = {};\n	\n	WebRTC.MediaHandler = __webpack_require__(41)(SIP);\n	WebRTC.MediaStreamManager = __webpack_require__(42)(SIP, environment);\n	\n	var _isSupported;\n	\n	WebRTC.isSupported = function () {\n	  if (_isSupported !== undefined) {\n	    return _isSupported;\n	  }\n	\n	  WebRTC.MediaStream = environment.MediaStream;\n	  WebRTC.getUserMedia = environment.getUserMedia;\n	  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;\n	  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;\n	\n	  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {\n	    if (WebRTC.getUserMedia) {\n	      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');\n	    }\n	    _isSupported = true;\n	  }\n	  else {\n	    _isSupported = false;\n	  }\n	  return _isSupported;\n	};\n	\n	return WebRTC;\n	};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview MediaHandler\n	 */\n	\n	/* MediaHandler\n	 * @class PeerConnection helper Class.\n	 * @param {SIP.Session} session\n	 * @param {Object} [options]\n	 * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]\n	 *        The MediaStreamManager to acquire/release streams from/to.\n	 *        If not provided, a default MediaStreamManager will be used.\n	 */\n	module.exports = function (SIP) {\n	\n	var MediaHandler = function(session, options) {\n	  options = options || {};\n	\n	  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);\n	  this.session = session;\n	  this.localMedia = null;\n	  this.ready = true;\n	  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);\n	  this.audioMuted = false;\n	  this.videoMuted = false;\n	\n	  // old init() from here on\n	  var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n	  this.RTCConstraints = options.RTCConstraints || {};\n	\n	  this.initPeerConnection(servers, this.RTCConstraints);\n	\n	  function selfEmit(mh, event) {\n	    if (mh.mediaStreamManager.on) {\n	      mh.mediaStreamManager.on(event, function () {\n	        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));\n	      });\n	    }\n	  }\n	\n	  selfEmit(this, 'userMediaRequest');\n	  selfEmit(this, 'userMedia');\n	  selfEmit(this, 'userMediaFailed');\n	};\n	\n	MediaHandler.defaultFactory = function defaultFactory (session, options) {\n	  return new MediaHandler(session, options);\n	};\n	MediaHandler.defaultFactory.isSupported = function () {\n	  return SIP.WebRTC.isSupported();\n	};\n	\n	MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {\n	// Functions the session can use\n	  isReady: {writable: true, value: function isReady () {\n	    return this.ready;\n	  }},\n	\n	  close: {writable: true, value: function close () {\n	    this.logger.log('closing PeerConnection');\n	    this._remoteStreams = [];\n	    // have to check signalingState since this.close() gets called multiple times\n	    // TODO figure out why that happens\n	    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n	      this.peerConnection.close();\n	\n	      if(this.localMedia) {\n	        this.mediaStreamManager.release(this.localMedia);\n	      }\n	    }\n	  }},\n	\n	  /**\n	   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]\n	   *        the MediaStream (or the constraints describing it) to be used for the session\n	   */\n	  getDescription: {writable: true, value: function getDescription (mediaHint) {\n	    var self = this;\n	    var acquire = self.mediaStreamManager.acquire;\n	    if (acquire.length > 1) {\n	      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);\n	    }\n	    mediaHint = mediaHint || {};\n	    if (mediaHint.dataChannel === true) {\n	      mediaHint.dataChannel = {};\n	    }\n	    this.mediaHint = mediaHint;\n	\n	    /*\n	     * 1. acquire streams (skip if MediaStreams passed in)\n	     * 2. addStreams\n	     * 3. createOffer/createAnswer\n	     */\n	\n	    var streamPromise;\n	    if (self.localMedia) {\n	      self.logger.log('already have local media');\n	      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);\n	    }\n	    else {\n	      self.logger.log('acquiring local media');\n	      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)\n	        .then(function acquireSucceeded(streams) {\n	          self.logger.log('acquired local media streams');\n	          self.localMedia = streams;\n	          self.session.connecting();\n	          return streams;\n	        }, function acquireFailed(err) {\n	          self.logger.error('unable to acquire streams');\n	          self.logger.error(err);\n	          self.session.connecting();\n	          throw err;\n	        })\n	        .then(this.addStreams.bind(this))\n	      ;\n	    }\n	\n	    return streamPromise\n	      .then(function streamAdditionSucceeded() {\n	        if (self.hasOffer('remote')) {\n	          self.peerConnection.ondatachannel = function (evt) {\n	            self.dataChannel = evt.channel;\n	            self.emit('dataChannel', self.dataChannel);\n	          };\n	        } else if (mediaHint.dataChannel &&\n	                   self.peerConnection.createDataChannel) {\n	          self.dataChannel = self.peerConnection.createDataChannel(\n	            'sipjs',\n	            mediaHint.dataChannel\n	          );\n	          self.emit('dataChannel', self.dataChannel);\n	        }\n	\n	        self.render();\n	        return self.createOfferOrAnswer(self.RTCConstraints);\n	      })\n	    ;\n	  }},\n	\n	  /**\n	  * Message reception.\n	  * @param {String} type\n	  * @param {String} sdp\n	  */\n	  setDescription: {writable: true, value: function setDescription (sdp) {\n	    var rawDescription = {\n	      type: this.hasOffer('local') ? 'answer' : 'offer',\n	      sdp: sdp\n	    };\n	\n	    this.emit('setDescription', rawDescription);\n	\n	    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);\n	    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);\n	  }},\n	\n	  /**\n	   * If the Session associated with this MediaHandler were to be referred,\n	   * what mediaHint should be provided to the UA's invite method?\n	   */\n	  getReferMedia: {writable: true, value: function getReferMedia () {\n	    function hasTracks (trackGetter, stream) {\n	      return stream[trackGetter]().length > 0;\n	    }\n	\n	    function bothHaveTracks (trackGetter) {\n	      /* jshint validthis:true */\n	      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&\n	             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));\n	    }\n	\n	    return {\n	      constraints: {\n	        audio: bothHaveTracks.call(this, 'getAudioTracks'),\n	        video: bothHaveTracks.call(this, 'getVideoTracks')\n	      }\n	    };\n	  }},\n	\n	  updateIceServers: {writeable:true, value: function (options) {\n	    var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n	    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;\n	\n	    this.initPeerConnection(servers, this.RTCConstraints);\n	\n	    /* once updateIce is implemented correctly, this is better than above\n	    //no op if browser does not support this\n	    if (!this.peerConnection.updateIce) {\n	      return;\n	    }\n	\n	    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);\n	    */\n	  }},\n	\n	// Functions the session can use, but only because it's convenient for the application\n	  isMuted: {writable: true, value: function isMuted () {\n	    return {\n	      audio: this.audioMuted,\n	      video: this.videoMuted\n	    };\n	  }},\n	\n	  mute: {writable: true, value: function mute (options) {\n	    if (this.getLocalStreams().length === 0) {\n	      return;\n	    }\n	\n	    options = options || {\n	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n	      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n	    };\n	\n	    var audioMuted = false,\n	        videoMuted = false;\n	\n	    if (options.audio && !this.audioMuted) {\n	      audioMuted = true;\n	      this.audioMuted = true;\n	      this.toggleMuteAudio(true);\n	    }\n	\n	    if (options.video && !this.videoMuted) {\n	      videoMuted = true;\n	      this.videoMuted = true;\n	      this.toggleMuteVideo(true);\n	    }\n	\n	    //REVISIT\n	    if (audioMuted || videoMuted) {\n	      return {\n	        audio: audioMuted,\n	        video: videoMuted\n	      };\n	      /*this.session.onmute({\n	        audio: audioMuted,\n	        video: videoMuted\n	      });*/\n	    }\n	  }},\n	\n	  unmute: {writable: true, value: function unmute (options) {\n	    if (this.getLocalStreams().length === 0) {\n	      return;\n	    }\n	\n	    options = options || {\n	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n	      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n	    };\n	\n	    var audioUnMuted = false,\n	        videoUnMuted = false;\n	\n	    if (options.audio && this.audioMuted) {\n	      audioUnMuted = true;\n	      this.audioMuted = false;\n	      this.toggleMuteAudio(false);\n	    }\n	\n	    if (options.video && this.videoMuted) {\n	      videoUnMuted = true;\n	      this.videoMuted = false;\n	      this.toggleMuteVideo(false);\n	    }\n	\n	    //REVISIT\n	    if (audioUnMuted || videoUnMuted) {\n	      return {\n	        audio: audioUnMuted,\n	        video: videoUnMuted\n	      };\n	      /*this.session.onunmute({\n	        audio: audioUnMuted,\n	        video: videoUnMuted\n	      });*/\n	    }\n	  }},\n	\n	  hold: {writable: true, value: function hold () {\n	    this.toggleMuteAudio(true);\n	    this.toggleMuteVideo(true);\n	  }},\n	\n	  unhold: {writable: true, value: function unhold () {\n	    if (!this.audioMuted) {\n	      this.toggleMuteAudio(false);\n	    }\n	\n	    if (!this.videoMuted) {\n	      this.toggleMuteVideo(false);\n	    }\n	  }},\n	\n	// Functions the application can use, but not the session\n	  getLocalStreams: {writable: true, value: function getLocalStreams () {\n	    var pc = this.peerConnection;\n	    if (pc && pc.signalingState === 'closed') {\n	      this.logger.warn('peerConnection is closed, getLocalStreams returning []');\n	      return [];\n	    }\n	    return (pc.getLocalStreams && pc.getLocalStreams()) ||\n	      pc.localStreams || [];\n	  }},\n	\n	  getRemoteStreams: {writable: true, value: function getRemoteStreams () {\n	    var pc = this.peerConnection;\n	    if (pc && pc.signalingState === 'closed') {\n	      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');\n	      return this._remoteStreams;\n	    }\n	    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||\n	      pc.remoteStreams || [];\n	  }},\n	\n	  render: {writable: true, value: function render (renderHint) {\n	    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);\n	    if (!renderHint) {\n	      return false;\n	    }\n	    var streamGetters = {\n	      local: 'getLocalStreams',\n	      remote: 'getRemoteStreams'\n	    };\n	    Object.keys(streamGetters).forEach(function (loc) {\n	      var streamGetter = streamGetters[loc];\n	      var streams = this[streamGetter]();\n	      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);\n	    }.bind(this));\n	  }},\n	\n	// Internal functions\n	  hasOffer: {writable: true, value: function hasOffer (where) {\n	    var offerState = 'have-' + where + '-offer';\n	    return this.peerConnection.signalingState === offerState;\n	    // TODO consider signalingStates with 'pranswer'?\n	  }},\n	\n	  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {\n	    var idx, jdx, length, server,\n	      servers = [],\n	      config = this.session.ua.configuration;\n	\n	    stunServers = stunServers || null;\n	    turnServers = turnServers || null;\n	\n	    if (!stunServers) {\n	      stunServers = config.stunServers;\n	    }\n	\n	    if(!turnServers) {\n	      turnServers = config.turnServers;\n	    }\n	\n	    /* Change 'url' to 'urls' whenever this issue is solved:\n	     * https://code.google.com/p/webrtc/issues/detail?id=2096\n	     */\n	    [].concat(stunServers).forEach(function (server) {\n	      servers.push({'url': server});\n	    });\n	\n	    length = turnServers.length;\n	    for (idx = 0; idx < length; idx++) {\n	      server = turnServers[idx];\n	      for (jdx = 0; jdx < server.urls.length; jdx++) {\n	        servers.push({\n	          'url': server.urls[jdx],\n	          'username': server.username,\n	          'credential': server.password\n	        });\n	      }\n	    }\n	\n	    return servers;\n	  }},\n	\n	  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {\n	    var self = this,\n	      config = this.session.ua.configuration;\n	\n	    this.onIceCompleted = SIP.Utils.defer();\n	    this.onIceCompleted.promise.then(function(pc) {\n	      self.emit('iceGatheringComplete', pc);\n	      if (self.iceCheckingTimer) {\n	        SIP.Timers.clearTimeout(self.iceCheckingTimer);\n	        self.iceCheckingTimer = null;\n	      }\n	    });\n	\n	    if (this.peerConnection) {\n	      this.peerConnection.close();\n	    }\n	\n	    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);\n	\n	    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams\n	    // even if peerConnection.onaddstream was just called. In order to make\n	    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually\n	    this._remoteStreams = [];\n	\n	    this.peerConnection.onaddstream = function(e) {\n	      self.logger.log('stream added: '+ e.stream.id);\n	      self._remoteStreams.push(e.stream);\n	      self.render();\n	      self.emit('addStream', e);\n	    };\n	\n	    this.peerConnection.onremovestream = function(e) {\n	      self.logger.log('stream removed: '+ e.stream.id);\n	    };\n	\n	    this.startIceCheckingTimer = function () {\n	      if (!self.iceCheckingTimer) {\n	        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {\n	          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');\n	          self.onIceCompleted.resolve(this);\n	        }.bind(this.peerConnection), config.iceCheckingTimeout);\n	      }\n	    };\n	\n	    this.peerConnection.onicecandidate = function(e) {\n	      self.emit('iceCandidate', e);\n	      if (e.candidate) {\n	        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n	        self.startIceCheckingTimer();\n	      } else {\n	        self.onIceCompleted.resolve(this);\n	      }\n	    };\n	\n	    this.peerConnection.onicegatheringstatechange = function () {\n	      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n	      if (this.iceGatheringState === 'gathering') {\n	        self.emit('iceGathering', this);\n	      }\n	      if (this.iceGatheringState === 'complete') {\n	        self.onIceCompleted.resolve(this);\n	      }\n	    };\n	\n	    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case\n	      var stateEvent;\n	\n	      if (this.iceConnectionState === 'checking') {\n	        self.startIceCheckingTimer();\n	      }\n	\n	      switch (this.iceConnectionState) {\n	      case 'new':\n	        stateEvent = 'iceConnection';\n	        break;\n	      case 'checking':\n	        stateEvent = 'iceConnectionChecking';\n	        break;\n	      case 'connected':\n	        stateEvent = 'iceConnectionConnected';\n	        break;\n	      case 'completed':\n	        stateEvent = 'iceConnectionCompleted';\n	        break;\n	      case 'failed':\n	        stateEvent = 'iceConnectionFailed';\n	        break;\n	      case 'disconnected':\n	        stateEvent = 'iceConnectionDisconnected';\n	        break;\n	      case 'closed':\n	        stateEvent = 'iceConnectionClosed';\n	        break;\n	      default:\n	        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);\n	        return;\n	      }\n	      self.emit(stateEvent, this);\n	\n	      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated\n	      //normal calls switch from failed to connected in some cases, so checking for failed and terminated\n	      /*if (this.iceConnectionState === 'failed') {\n	        self.session.terminate({\n	        cause: SIP.C.causes.RTP_TIMEOUT,\n	        status_code: 200,\n	        reason_phrase: SIP.C.causes.RTP_TIMEOUT\n	      });\n	      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {\n	      self.onIceCompleted(this);\n	      }*/\n	    };\n	\n	    this.peerConnection.onstatechange = function() {\n	      self.logger.log('PeerConnection state changed to \"'+ this.readyState +'\"');\n	    };\n	  }},\n	\n	  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {\n	    var self = this;\n	    var methodName;\n	    var pc = self.peerConnection;\n	\n	    self.ready = false;\n	    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n	\n	    return SIP.Utils.promisify(pc, methodName, true)(constraints)\n	      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))\n	      .then(function onSetLocalDescriptionSuccess() {\n	        var deferred = SIP.Utils.defer();\n	        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {\n	          deferred.resolve();\n	        } else {\n	          self.onIceCompleted.promise.then(deferred.resolve);\n	        }\n	        return deferred.promise;\n	      })\n	      .then(function readySuccess () {\n	        var sdp = pc.localDescription.sdp;\n	\n	        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);\n	        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);\n	\n	        var sdpWrapper = {\n	          type: methodName === 'createOffer' ? 'offer' : 'answer',\n	          sdp: sdp\n	        };\n	\n	        self.emit('getDescription', sdpWrapper);\n	\n	        self.ready = true;\n	        return sdpWrapper.sdp;\n	      })\n	      .catch(function methodFailed (e) {\n	        self.logger.error(e);\n	        self.ready = true;\n	        throw new SIP.Exceptions.GetDescriptionError(e);\n	      })\n	    ;\n	  }},\n	\n	  addStreams: {writable: true, value: function addStreams (streams) {\n	    try {\n	      streams = [].concat(streams);\n	      streams.forEach(function (stream) {\n	        this.peerConnection.addStream(stream);\n	      }, this);\n	    } catch(e) {\n	      this.logger.error('error adding stream');\n	      this.logger.error(e);\n	      return SIP.Utils.Promise.reject(e);\n	    }\n	\n	    return SIP.Utils.Promise.resolve();\n	  }},\n	\n	  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {\n	    this.getLocalStreams().forEach(function (stream) {\n	      stream[trackGetter]().forEach(function (track) {\n	        track.enabled = !mute;\n	      });\n	    });\n	  }},\n	\n	  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {\n	    this.toggleMuteHelper('getAudioTracks', mute);\n	  }},\n	\n	  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {\n	    this.toggleMuteHelper('getVideoTracks', mute);\n	  }}\n	});\n	\n	// Return since it will be assigned to a variable.\n	return MediaHandler;\n	};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview MediaStreamManager\n	 */\n	\n	/* MediaStreamManager\n	 * @class Manages the acquisition and release of MediaStreams.\n	 * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()\n	 */\n	module.exports = function (SIP, environment) {\n	\n	// Default MediaStreamManager provides single-use streams created with getUserMedia\n	var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {\n	  if (!SIP.WebRTC.isSupported()) {\n	    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n	  }\n	\n	  this.mediaHint = defaultMediaHint || {\n	    constraints: {audio: true, video: true}\n	  };\n	\n	  // map of streams to acquisition manner:\n	  // true -> passed in as mediaHint.stream\n	  // false -> getUserMedia\n	  this.acquisitions = {};\n	};\n	MediaStreamManager.streamId = function (stream) {\n	  return stream.getAudioTracks().concat(stream.getVideoTracks())\n	    .map(function trackId (track) {\n	      return track.id;\n	    })\n	    .join('');\n	};\n	\n	/**\n	 * @param {(Array of) MediaStream} streams - The streams to render\n	 *\n	 * @param {(Array of) HTMLMediaElement} elements\n	 *        - The <audio>/<video> element(s) that should render the streams\n	 *\n	 * Each stream in streams renders to the corresponding element in elements,\n	 * wrapping around elements if needed.\n	 */\n	MediaStreamManager.render = function render (streams, elements) {\n	  if (!elements) {\n	    return false;\n	  }\n	  if (Array.isArray(elements) && !elements.length) {\n	    throw new TypeError('elements must not be empty');\n	  }\n	\n	  function attachMediaStream(element, stream) {\n	    if (typeof element.src !== 'undefined') {\n	      environment.revokeObjectURL(element.src);\n	      element.src = environment.createObjectURL(stream);\n	    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {\n	      element.srcObject = element.mozSrcObject = stream;\n	    } else {\n	      return false;\n	    }\n	\n	    return true;\n	  }\n	\n	  function ensureMediaPlaying (mediaElement) {\n	    var interval = 100;\n	    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {\n	      if (mediaElement.paused) {\n	        mediaElement.play();\n	      }\n	      else {\n	        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);\n	      }\n	    }, interval);\n	  }\n	\n	  function attachAndPlay (elements, stream, index) {\n	    if (typeof elements === 'function') {\n	      elements = elements();\n	    }\n	    var element = elements[index % elements.length];\n	    (environment.attachMediaStream || attachMediaStream)(element, stream);\n	    ensureMediaPlaying(element);\n	  }\n	\n	  // [].concat \"casts\" `elements` into an array\n	  // so forEach works even if `elements` was a single element\n	  elements = [].concat(elements);\n	  [].concat(streams).forEach(attachAndPlay.bind(null, elements));\n	};\n	\n	MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {\n	  'acquire': {writable: true, value: function acquire (mediaHint) {\n	    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;\n	\n	    var saveSuccess = function (isHintStream, streams) {\n	      streams = [].concat(streams);\n	      streams.forEach(function (stream) {\n	        var streamId = MediaStreamManager.streamId(stream);\n	        this.acquisitions[streamId] = !!isHintStream;\n	      }, this);\n	      return SIP.Utils.Promise.resolve(streams);\n	    }.bind(this);\n	\n	    if (mediaHint.stream) {\n	      return saveSuccess(true, mediaHint.stream);\n	    } else {\n	      // Fallback to audio/video enabled if no mediaHint can be found.\n	      var constraints = mediaHint.constraints ||\n	        (this.mediaHint && this.mediaHint.constraints) ||\n	        {audio: true, video: true};\n	\n	      var deferred = SIP.Utils.defer();\n	\n	      /*\n	       * Make the call asynchronous, so that ICCs have a chance\n	       * to define callbacks to `userMediaRequest`\n	       */\n	      SIP.Timers.setTimeout(function () {\n	        this.emit('userMediaRequest', constraints);\n	\n	        var emitThenCall = function (eventName, callback) {\n	          var callbackArgs = Array.prototype.slice.call(arguments, 2);\n	          // Emit with all of the arguments from the real callback.\n	          var newArgs = [eventName].concat(callbackArgs);\n	\n	          this.emit.apply(this, newArgs);\n	\n	          return callback.apply(null, callbackArgs);\n	        }.bind(this);\n	\n	        if (constraints.audio || constraints.video) {\n	          deferred.resolve(\n	            SIP.WebRTC.getUserMedia(constraints)\n	            .then(\n	              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),\n	              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})\n	            )\n	          );\n	        } else {\n	          // Local streams were explicitly excluded.\n	          deferred.resolve([]);\n	        }\n	      }.bind(this), 0);\n	\n	      return deferred.promise;\n	    }\n	  }},\n	\n	  'release': {writable: true, value: function release (streams) {\n	    streams = [].concat(streams);\n	    streams.forEach(function (stream) {\n	      var streamId = MediaStreamManager.streamId(stream);\n	      if (this.acquisitions[streamId] === false) {\n	        stream.getTracks().forEach(function (track) {\n	          track.stop();\n	        });\n	      }\n	      delete this.acquisitions[streamId];\n	    }, this);\n	  }},\n	});\n	\n	// Return since it will be assigned to a variable.\n	return MediaStreamManager;\n	};\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n	/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP User Agent.\n	 * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]\n	 *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.\n	 *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.\n	 *\n	 * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	 */\n	module.exports = function (SIP, environment) {\n	var UA,\n	  C = {\n	    // UA status codes\n	    STATUS_INIT:                0,\n	    STATUS_STARTING:            1,\n	    STATUS_READY:               2,\n	    STATUS_USER_CLOSED:         3,\n	    STATUS_NOT_READY:           4,\n	\n	    // UA error codes\n	    CONFIGURATION_ERROR:  1,\n	    NETWORK_ERROR:        2,\n	\n	    ALLOWED_METHODS: [\n	      'ACK',\n	      'CANCEL',\n	      'INVITE',\n	      'MESSAGE',\n	      'BYE',\n	      'OPTIONS',\n	      'INFO',\n	      'NOTIFY'\n	    ],\n	\n	    ACCEPTED_BODY_TYPES: [\n	      'application/sdp',\n	      'application/dtmf-relay'\n	    ],\n	\n	    MAX_FORWARDS: 70,\n	    TAG_LENGTH: 10\n	  };\n	\n	UA = function(configuration) {\n	  var self = this;\n	\n	  // Helper function for forwarding events\n	  function selfEmit(type) {\n	    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n	    return self.emit.bind(self, type);\n	  }\n	\n	  // Set Accepted Body Types\n	  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n	\n	  this.log = new SIP.LoggerFactory();\n	  this.logger = this.getLogger('sip.ua');\n	\n	  this.cache = {\n	    credentials: {}\n	  };\n	\n	  this.configuration = {};\n	  this.dialogs = {};\n	\n	  //User actions outside any session/dialog (MESSAGE)\n	  this.applicants = {};\n	\n	  this.data = {};\n	  this.sessions = {};\n	  this.subscriptions = {};\n	  this.transport = null;\n	  this.contact = null;\n	  this.status = C.STATUS_INIT;\n	  this.error = null;\n	  this.transactions = {\n	    nist: {},\n	    nict: {},\n	    ist: {},\n	    ict: {}\n	  };\n	\n	  this.transportRecoverAttempts = 0;\n	  this.transportRecoveryTimer = null;\n	\n	  Object.defineProperties(this, {\n	    transactionsCount: {\n	      get: function() {\n	        var type,\n	          transactions = ['nist','nict','ist','ict'],\n	          count = 0;\n	\n	        for (type in transactions) {\n	          count += Object.keys(this.transactions[transactions[type]]).length;\n	        }\n	\n	        return count;\n	      }\n	    },\n	\n	    nictTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['nict']).length;\n	      }\n	    },\n	\n	    nistTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['nist']).length;\n	      }\n	    },\n	\n	    ictTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['ict']).length;\n	      }\n	    },\n	\n	    istTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['ist']).length;\n	      }\n	    }\n	  });\n	\n	  /**\n	   * Load configuration\n	   *\n	   * @throws {SIP.Exceptions.ConfigurationError}\n	   * @throws {TypeError}\n	   */\n	\n	  if(configuration === undefined) {\n	    configuration = {};\n	  } else if (typeof configuration === 'string' || configuration instanceof String) {\n	    configuration = {\n	      uri: configuration\n	    };\n	  }\n	\n	  // Apply log configuration if present\n	  if (configuration.log) {\n	    if (configuration.log.hasOwnProperty('builtinEnabled')) {\n	      this.log.builtinEnabled = configuration.log.builtinEnabled;\n	    }\n	\n	    if (configuration.log.hasOwnProperty('level')) {\n	      this.log.level = configuration.log.level;\n	    }\n	\n	    if (configuration.log.hasOwnProperty('connector')) {\n	      this.log.connector = configuration.log.connector;\n	    }\n	  }\n	\n	  try {\n	    this.loadConfig(configuration);\n	  } catch(e) {\n	    this.status = C.STATUS_NOT_READY;\n	    this.error = C.CONFIGURATION_ERROR;\n	    throw e;\n	  }\n	\n	  // Initialize registerContext\n	  this.registerContext = new SIP.RegisterContext(this);\n	  this.registerContext.on('failed', selfEmit('registrationFailed'));\n	  this.registerContext.on('registered', selfEmit('registered'));\n	  this.registerContext.on('unregistered', selfEmit('unregistered'));\n	\n	  if(this.configuration.autostart) {\n	    this.start();\n	  }\n	\n	  if (typeof environment.addEventListener === 'function') {\n	    // Google Chrome Packaged Apps don't allow 'unload' listeners:\n	    // unload is not available in packaged apps\n	    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {\n	      environment.addEventListener('unload', this.stop.bind(this));\n	    }\n	  }\n	};\n	UA.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	//=================\n	//  High Level API\n	//=================\n	\n	UA.prototype.register = function(options) {\n	  this.configuration.register = true;\n	  this.registerContext.register(options);\n	\n	  return this;\n	};\n	\n	/**\n	 * Unregister.\n	 *\n	 * @param {Boolean} [all] unregister all user bindings.\n	 *\n	 */\n	UA.prototype.unregister = function(options) {\n	  this.configuration.register = false;\n	\n	  var context = this.registerContext;\n	  this.afterConnected(context.unregister.bind(context, options));\n	\n	  return this;\n	};\n	\n	UA.prototype.isRegistered = function() {\n	  return this.registerContext.registered;\n	};\n	\n	/**\n	 * Connection state.\n	 * @param {Boolean}\n	 */\n	UA.prototype.isConnected = function() {\n	  return this.transport ? this.transport.connected : false;\n	};\n	\n	UA.prototype.afterConnected = function afterConnected (callback) {\n	  if (this.isConnected()) {\n	    callback();\n	  } else {\n	    this.once('connected', callback);\n	  }\n	};\n	\n	/**\n	 * Make an outgoing call.\n	 *\n	 * @param {String} target\n	 * @param {Object} views\n	 * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	 *\n	 * @throws {TypeError}\n	 *\n	 */\n	UA.prototype.invite = function(target, options) {\n	  var context = new SIP.InviteClientContext(this, target, options);\n	\n	  this.afterConnected(context.invite.bind(context));\n	  return context;\n	};\n	\n	UA.prototype.subscribe = function(target, event, options) {\n	  var sub = new SIP.Subscription(this, target, event, options);\n	\n	  this.afterConnected(sub.subscribe.bind(sub));\n	  return sub;\n	};\n	\n	/**\n	 * Send a message.\n	 *\n	 * @param {String} target\n	 * @param {String} body\n	 * @param {Object} [options]\n	 *\n	 * @throws {TypeError}\n	 *\n	 */\n	UA.prototype.message = function(target, body, options) {\n	  if (body === undefined) {\n	    throw new TypeError('Not enough arguments');\n	  }\n	\n	  // There is no Message module, so it is okay that the UA handles defaults here.\n	  options = Object.create(options || Object.prototype);\n	  options.contentType || (options.contentType = 'text/plain');\n	  options.body = body;\n	\n	  return this.request(SIP.C.MESSAGE, target, options);\n	};\n	\n	UA.prototype.request = function (method, target, options) {\n	  var req = new SIP.ClientContext(this, method, target, options);\n	\n	  this.afterConnected(req.send.bind(req));\n	  return req;\n	};\n	\n	/**\n	 * Gracefully close.\n	 *\n	 */\n	UA.prototype.stop = function() {\n	  var session, subscription, applicant,\n	    ua = this;\n	\n	  function transactionsListener() {\n	    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n	        ua.removeListener('transactionDestroyed', transactionsListener);\n	        ua.transport.disconnect();\n	    }\n	  }\n	\n	  this.logger.log('user requested closure...');\n	\n	  if(this.status === C.STATUS_USER_CLOSED) {\n	    this.logger.warn('UA already closed');\n	    return this;\n	  }\n	\n	  // Clear transportRecoveryTimer\n	  SIP.Timers.clearTimeout(this.transportRecoveryTimer);\n	\n	  // Close registerContext\n	  this.logger.log('closing registerContext');\n	  this.registerContext.close();\n	\n	  // Run  _terminate_ on every Session\n	  for(session in this.sessions) {\n	    this.logger.log('closing session ' + session);\n	    this.sessions[session].terminate();\n	  }\n	\n	  //Run _close_ on every Subscription\n	  for(subscription in this.subscriptions) {\n	    this.logger.log('unsubscribing from subscription ' + subscription);\n	    this.subscriptions[subscription].close();\n	  }\n	\n	  // Run  _close_ on every applicant\n	  for(applicant in this.applicants) {\n	    this.applicants[applicant].close();\n	  }\n	\n	  this.status = C.STATUS_USER_CLOSED;\n	\n	  /*\n	   * If the remaining transactions are all INVITE transactions, there is no need to\n	   * wait anymore because every session has already been closed by this method.\n	   * - locally originated sessions where terminated (CANCEL or BYE)\n	   * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n	   * Remaining INVITE transactions belong tho sessions that where answered. This are in\n	   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n	   */\n	  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n	    this.transport.disconnect();\n	  } else {\n	    this.on('transactionDestroyed', transactionsListener);\n	  }\n	\n	  return this;\n	};\n	\n	/**\n	 * Connect to the WS server if status = STATUS_INIT.\n	 * Resume UA after being closed.\n	 *\n	 */\n	UA.prototype.start = function() {\n	  var server;\n	\n	  this.logger.log('user requested startup...');\n	  if (this.status === C.STATUS_INIT) {\n	    server = this.getNextWsServer();\n	    this.status = C.STATUS_STARTING;\n	    new SIP.Transport(this, server);\n	  } else if(this.status === C.STATUS_USER_CLOSED) {\n	    this.logger.log('resuming');\n	    this.status = C.STATUS_READY;\n	    this.transport.connect();\n	  } else if (this.status === C.STATUS_STARTING) {\n	    this.logger.log('UA is in STARTING status, not opening new connection');\n	  } else if (this.status === C.STATUS_READY) {\n	    this.logger.log('UA is in READY status, not resuming');\n	  } else {\n	    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n	  }\n	\n	  return this;\n	};\n	\n	/**\n	 * Normalize a string into a valid SIP request URI\n	 *\n	 * @param {String} target\n	 *\n	 * @returns {SIP.URI|undefined}\n	 */\n	UA.prototype.normalizeTarget = function(target) {\n	  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n	};\n	\n	\n	//===============================\n	//  Private (For internal use)\n	//===============================\n	\n	UA.prototype.saveCredentials = function(credentials) {\n	  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n	  this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n	\n	  return this;\n	};\n	\n	UA.prototype.getCredentials = function(request) {\n	  var realm, credentials;\n	\n	  realm = request.ruri.host;\n	\n	  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n	    credentials = this.cache.credentials[realm][request.ruri];\n	    credentials.method = request.method;\n	  }\n	\n	  return credentials;\n	};\n	\n	UA.prototype.getLogger = function(category, label) {\n	  return this.log.getLogger(category, label);\n	};\n	\n	\n	//==============================\n	// Event Handlers\n	//==============================\n	\n	/**\n	 * Transport Close event\n	 * @private\n	 * @event\n	 * @param {SIP.Transport} transport.\n	 */\n	UA.prototype.onTransportClosed = function(transport) {\n	  // Run _onTransportError_ callback on every client transaction using _transport_\n	  var type, idx, length,\n	    client_transactions = ['nict', 'ict', 'nist', 'ist'];\n	\n	  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;\n	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);\n	\n	  length = client_transactions.length;\n	  for (type = 0; type < length; type++) {\n	    for(idx in this.transactions[client_transactions[type]]) {\n	      this.transactions[client_transactions[type]][idx].onTransportError();\n	    }\n	  }\n	\n	  // Close sessions if GRUU is not being used\n	  if (!this.contact.pub_gruu) {\n	    this.closeSessionsOnTransportError();\n	  }\n	\n	};\n	\n	/**\n	 * Unrecoverable transport event.\n	 * Connection reattempt logic has been done and didn't success.\n	 * @private\n	 * @event\n	 * @param {SIP.Transport} transport.\n	 */\n	UA.prototype.onTransportError = function(transport) {\n	  var server;\n	\n	  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);\n	\n	  // Close sessions.\n	  //Mark this transport as 'down'\n	  transport.server.status = SIP.Transport.C.STATUS_ERROR;\n	\n	  this.emit('disconnected', {\n	    transport: transport\n	  });\n	\n	  // try the next transport if the UA isn't closed\n	  if(this.status === C.STATUS_USER_CLOSED) {\n	    return;\n	  }\n	\n	  server = this.getNextWsServer();\n	\n	  if(server) {\n	    new SIP.Transport(this, server);\n	  }else {\n	    this.closeSessionsOnTransportError();\n	    if (!this.error || this.error !== C.NETWORK_ERROR) {\n	      this.status = C.STATUS_NOT_READY;\n	      this.error = C.NETWORK_ERROR;\n	    }\n	    // Transport Recovery process\n	    this.recoverTransport();\n	  }\n	};\n	\n	/**\n	 * Transport connection event.\n	 * @private\n	 * @event\n	 * @param {SIP.Transport} transport.\n	 */\n	UA.prototype.onTransportConnected = function(transport) {\n	  this.transport = transport;\n	\n	  // Reset transport recovery counter\n	  this.transportRecoverAttempts = 0;\n	\n	  transport.server.status = SIP.Transport.C.STATUS_READY;\n	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);\n	\n	  if(this.status === C.STATUS_USER_CLOSED) {\n	    return;\n	  }\n	\n	  this.status = C.STATUS_READY;\n	  this.error = null;\n	\n	  if(this.configuration.register) {\n	    this.configuration.authenticationFactory.initialize().then(function () {\n	      this.registerContext.onTransportConnected();\n	    }.bind(this));\n	  }\n	\n	  this.emit('connected', {\n	    transport: transport\n	  });\n	};\n	\n	\n	/**\n	 * Transport connecting event\n	 * @private\n	 * @param {SIP.Transport} transport.\n	 * #param {Integer} attempts.\n	 */\n	  UA.prototype.onTransportConnecting = function(transport, attempts) {\n	    this.emit('connecting', {\n	      transport: transport,\n	      attempts: attempts\n	    });\n	  };\n	\n	\n	/**\n	 * new Transaction\n	 * @private\n	 * @param {SIP.Transaction} transaction.\n	 */\n	UA.prototype.newTransaction = function(transaction) {\n	  this.transactions[transaction.type][transaction.id] = transaction;\n	  this.emit('newTransaction', {transaction: transaction});\n	};\n	\n	\n	/**\n	 * destroy Transaction\n	 * @private\n	 * @param {SIP.Transaction} transaction.\n	 */\n	UA.prototype.destroyTransaction = function(transaction) {\n	  delete this.transactions[transaction.type][transaction.id];\n	  this.emit('transactionDestroyed', {\n	    transaction: transaction\n	  });\n	};\n	\n	\n	//=========================\n	// receiveRequest\n	//=========================\n	\n	/**\n	 * Request reception\n	 * @private\n	 * @param {SIP.IncomingRequest} request.\n	 */\n	UA.prototype.receiveRequest = function(request) {\n	  var dialog, session, message,\n	    method = request.method,\n	    transaction,\n	    replaces,\n	    replacedDialog,\n	    self = this;\n	\n	  function ruriMatches (uri) {\n	    return uri && uri.user === request.ruri.user;\n	  }\n	\n	  // Check that request URI points to us\n	  if(!(ruriMatches(this.configuration.uri) ||\n	       ruriMatches(this.contact.uri) ||\n	       ruriMatches(this.contact.pub_gruu) ||\n	       ruriMatches(this.contact.temp_gruu))) {\n	    this.logger.warn('Request-URI does not point to us');\n	    if (request.method !== SIP.C.ACK) {\n	      request.reply_sl(404);\n	    }\n	    return;\n	  }\n	\n	  // Check request URI scheme\n	  if(request.ruri.scheme === SIP.C.SIPS) {\n	    request.reply_sl(416);\n	    return;\n	  }\n	\n	  // Check transaction\n	  if(SIP.Transactions.checkTransaction(this, request)) {\n	    return;\n	  }\n	\n	  /* RFC3261 12.2.2\n	   * Requests that do not change in any way the state of a dialog may be\n	   * received within a dialog (for example, an OPTIONS request).\n	   * They are processed as if they had been received outside the dialog.\n	   */\n	  if(method === SIP.C.OPTIONS) {\n	    new SIP.Transactions.NonInviteServerTransaction(request, this);\n	    request.reply(200, null, [\n	      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),\n	      'Accept: '+ C.ACCEPTED_BODY_TYPES\n	    ]);\n	  } else if (method === SIP.C.MESSAGE) {\n	    message = new SIP.ServerContext(this, request);\n	    message.body = request.body;\n	    message.content_type = request.getHeader('Content-Type') || 'text/plain';\n	\n	    request.reply(200, null);\n	    this.emit('message', message);\n	  } else if (method !== SIP.C.INVITE &&\n	             method !== SIP.C.ACK) {\n	    // Let those methods pass through to normal processing for now.\n	    transaction = new SIP.ServerContext(this, request);\n	  }\n	\n	  // Initial Request\n	  if(!request.to_tag) {\n	    switch(method) {\n	      case SIP.C.INVITE:\n	        replaces =\n	          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&\n	          request.parseHeader('replaces');\n	\n	        if (replaces) {\n	          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];\n	\n	          if (!replacedDialog) {\n	            //Replaced header without a matching dialog, reject\n	            request.reply_sl(481, null);\n	            return;\n	          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {\n	            request.reply_sl(603, null);\n	            return;\n	          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {\n	            request.reply_sl(486, null);\n	            return;\n	          }\n	        }\n	\n	        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;\n	        if(!isMediaSupported || isMediaSupported()) {\n	          session = new SIP.InviteServerContext(this, request);\n	          session.replacee = replacedDialog && replacedDialog.owner;\n	          session.on('invite', function() {\n	            self.emit('invite', this);\n	          });\n	        } else {\n	          this.logger.warn('INVITE received but WebRTC is not supported');\n	          request.reply(488);\n	        }\n	        break;\n	      case SIP.C.BYE:\n	        // Out of dialog BYE received\n	        request.reply(481);\n	        break;\n	      case SIP.C.CANCEL:\n	        session = this.findSession(request);\n	        if(session) {\n	          session.receiveRequest(request);\n	        } else {\n	          this.logger.warn('received CANCEL request for a non existent session');\n	        }\n	        break;\n	      case SIP.C.ACK:\n	        /* Absorb it.\n	         * ACK request without a corresponding Invite Transaction\n	         * and without To tag.\n	         */\n	        break;\n	      default:\n	        request.reply(405);\n	        break;\n	    }\n	  }\n	  // In-dialog request\n	  else {\n	    dialog = this.findDialog(request);\n	\n	    if(dialog) {\n	      if (method === SIP.C.INVITE) {\n	        new SIP.Transactions.InviteServerTransaction(request, this);\n	      }\n	      dialog.receiveRequest(request);\n	    } else if (method === SIP.C.NOTIFY) {\n	      session = this.findSession(request);\n	      if(session) {\n	        session.receiveRequest(request);\n	      } else {\n	        this.logger.warn('received NOTIFY request for a non existent session');\n	        request.reply(481, 'Subscription does not exist');\n	      }\n	    }\n	    /* RFC3261 12.2.2\n	     * Request with to tag, but no matching dialog found.\n	     * Exception: ACK for an Invite request for which a dialog has not\n	     * been created.\n	     */\n	    else {\n	      if(method !== SIP.C.ACK) {\n	        request.reply(481);\n	      }\n	    }\n	  }\n	};\n	\n	//=================\n	// Utils\n	//=================\n	\n	/**\n	 * Get the session to which the request belongs to, if any.\n	 * @private\n	 * @param {SIP.IncomingRequest} request.\n	 * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n	 */\n	UA.prototype.findSession = function(request) {\n	  return this.sessions[request.call_id + request.from_tag] ||\n	          this.sessions[request.call_id + request.to_tag] ||\n	          null;\n	};\n	\n	/**\n	 * Get the dialog to which the request belongs to, if any.\n	 * @private\n	 * @param {SIP.IncomingRequest}\n	 * @returns {SIP.Dialog|null}\n	 */\n	UA.prototype.findDialog = function(request) {\n	  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||\n	          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||\n	          null;\n	};\n	\n	/**\n	 * Retrieve the next server to which connect.\n	 * @private\n	 * @returns {Object} ws_server\n	 */\n	UA.prototype.getNextWsServer = function() {\n	  // Order servers by weight\n	  var idx, length, ws_server,\n	    candidates = [];\n	\n	  length = this.configuration.wsServers.length;\n	  for (idx = 0; idx < length; idx++) {\n	    ws_server = this.configuration.wsServers[idx];\n	\n	    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {\n	      continue;\n	    } else if (candidates.length === 0) {\n	      candidates.push(ws_server);\n	    } else if (ws_server.weight > candidates[0].weight) {\n	      candidates = [ws_server];\n	    } else if (ws_server.weight === candidates[0].weight) {\n	      candidates.push(ws_server);\n	    }\n	  }\n	\n	  idx = Math.floor(Math.random() * candidates.length);\n	\n	  return candidates[idx];\n	};\n	\n	/**\n	 * Close all sessions on transport error.\n	 * @private\n	 */\n	UA.prototype.closeSessionsOnTransportError = function() {\n	  var idx;\n	\n	  // Run _transportError_ for every Session\n	  for(idx in this.sessions) {\n	    this.sessions[idx].onTransportError();\n	  }\n	  // Call registerContext _onTransportClosed_\n	  this.registerContext.onTransportClosed();\n	};\n	\n	UA.prototype.recoverTransport = function(ua) {\n	  var idx, length, k, nextRetry, count, server;\n	\n	  ua = ua || this;\n	  count = ua.transportRecoverAttempts;\n	\n	  length = ua.configuration.wsServers.length;\n	  for (idx = 0; idx < length; idx++) {\n	    ua.configuration.wsServers[idx].status = 0;\n	  }\n	\n	  server = ua.getNextWsServer();\n	\n	  k = Math.floor((Math.random() * Math.pow(2,count)) +1);\n	  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;\n	\n	  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {\n	    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');\n	    nextRetry = ua.configuration.connectionRecoveryMinInterval;\n	    count = 0;\n	  }\n	\n	  this.logger.log('next connection attempt in '+ nextRetry +' seconds');\n	\n	  this.transportRecoveryTimer = SIP.Timers.setTimeout(\n	    function(){\n	      ua.transportRecoverAttempts = count + 1;\n	      new SIP.Transport(ua, server);\n	    }, nextRetry * 1000);\n	};\n	\n	function checkAuthenticationFactory (authenticationFactory) {\n	  if (!(authenticationFactory instanceof Function)) {\n	    return;\n	  }\n	  if (!authenticationFactory.initialize) {\n	    authenticationFactory.initialize = function initialize () {\n	      return SIP.Utils.Promise.resolve();\n	    };\n	  }\n	  return authenticationFactory;\n	}\n	\n	/**\n	 * Configuration load.\n	 * @private\n	 * returns {Boolean}\n	 */\n	UA.prototype.loadConfig = function(configuration) {\n	  // Settings and default values\n	  var parameter, value, checked_value, hostportParams, registrarServer,\n	    settings = {\n	      /* Host address\n	      * Value to be set in Via sent_by and host part of Contact FQDN\n	      */\n	      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n	\n	      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n	      wsServers: [{\n	        scheme: 'WSS',\n	        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n	        status: 0,\n	        weight: 0,\n	        ws_uri: 'wss://edge.sip.onsip.com'\n	      }],\n	\n	      // Password\n	      password: null,\n	\n	      // Registration parameters\n	      registerExpires: 600,\n	      register: true,\n	      registrarServer: null,\n	\n	      // Transport related parameters\n	      wsServerMaxReconnection: 3,\n	      wsServerReconnectionTimeout: 4,\n	\n	      connectionRecoveryMinInterval: 2,\n	      connectionRecoveryMaxInterval: 30,\n	\n	      keepAliveInterval: 0,\n	\n	      extraSupported: [],\n	\n	      usePreloadedRoute: false,\n	\n	      //string to be inserted into User-Agent request header\n	      userAgentString: SIP.C.USER_AGENT,\n	\n	      // Session parameters\n	      iceCheckingTimeout: 5000,\n	      noAnswerTimeout: 60,\n	      stunServers: ['stun:stun.l.google.com:19302'],\n	      turnServers: [],\n	\n	      // Logging parameters\n	      traceSip: false,\n	\n	      // Hacks\n	      hackViaTcp: false,\n	      hackIpInContact: false,\n	      hackWssInTransport: false,\n	      hackAllowUnregisteredOptionTags: false,\n	\n	      contactTransport: 'ws',\n	      forceRport: false,\n	\n	      //autostarting\n	      autostart: true,\n	\n	      //Reliable Provisional Responses\n	      rel100: SIP.C.supported.UNSUPPORTED,\n	\n	      // Replaces header (RFC 3891)\n	      // http://tools.ietf.org/html/rfc3891\n	      replaces: SIP.C.supported.UNSUPPORTED,\n	\n	      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,\n	\n	      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {\n	        return new SIP.DigestAuthentication(ua);\n	      })\n	    };\n	\n	  // Pre-Configuration\n	  function aliasUnderscored (parameter, logger) {\n	    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n	      return m[0] + '_' + m[1].toLowerCase();\n	    });\n	\n	    if (parameter === underscored) {\n	      return;\n	    }\n	\n	    var hasParameter = configuration.hasOwnProperty(parameter);\n	    if (configuration.hasOwnProperty(underscored)) {\n	      logger.warn(underscored + ' is deprecated, please use ' + parameter);\n	      if (hasParameter) {\n	        logger.warn(parameter + ' overriding ' + underscored);\n	      }\n	    }\n	\n	    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n	  }\n	\n	  // Check Mandatory parameters\n	  for(parameter in UA.configuration_check.mandatory) {\n	    aliasUnderscored(parameter, this.logger);\n	    if(!configuration.hasOwnProperty(parameter)) {\n	      throw new SIP.Exceptions.ConfigurationError(parameter);\n	    } else {\n	      value = configuration[parameter];\n	      checked_value = UA.configuration_check.mandatory[parameter](value);\n	      if (checked_value !== undefined) {\n	        settings[parameter] = checked_value;\n	      } else {\n	        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n	      }\n	    }\n	  }\n	\n	  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);\n	\n	  var emptyArraysAllowed = ['stunServers', 'turnServers'];\n	\n	  // Check Optional parameters\n	  for(parameter in UA.configuration_check.optional) {\n	    aliasUnderscored(parameter, this.logger);\n	    if(configuration.hasOwnProperty(parameter)) {\n	      value = configuration[parameter];\n	\n	      // If the parameter value is an empty array, but shouldn't be, apply its default value.\n	      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }\n	\n	      // If the parameter value is null, empty string, or undefined then apply its default value.\n	      if(value === null || value === \"\" || value === undefined) { continue; }\n	      // If it's a number with NaN value then also apply its default value.\n	      // NOTE: JS does not allow \"value === NaN\", the following does the work:\n	      else if(typeof(value) === 'number' && isNaN(value)) { continue; }\n	\n	      checked_value = UA.configuration_check.optional[parameter](value);\n	      if (checked_value !== undefined) {\n	        settings[parameter] = checked_value;\n	      } else {\n	        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n	      }\n	    }\n	  }\n	\n	  // Sanity Checks\n	\n	  // Connection recovery intervals\n	  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {\n	    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);\n	  }\n	\n	  // Post Configuration Process\n	\n	  // Allow passing 0 number as displayName.\n	  if (settings.displayName === 0) {\n	    settings.displayName = '0';\n	  }\n	\n	  // Instance-id for GRUU\n	  if (!settings.instanceId) {\n	    settings.instanceId = SIP.Utils.newUUID();\n	  }\n	\n	  // sipjsId instance parameter. Static random tag of length 5\n	  settings.sipjsId = SIP.Utils.createRandomToken(5);\n	\n	  // String containing settings.uri without scheme and user.\n	  hostportParams = settings.uri.clone();\n	  hostportParams.user = null;\n	  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');\n	\n	  /* Check whether authorizationUser is explicitly defined.\n	   * Take 'settings.uri.user' value if not.\n	   */\n	  if (!settings.authorizationUser) {\n	    settings.authorizationUser = settings.uri.user;\n	  }\n	\n	  /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n	  if (!settings.registrarServer) {\n	    registrarServer = settings.uri.clone();\n	    registrarServer.user = null;\n	    settings.registrarServer = registrarServer;\n	  }\n	\n	  // User noAnswerTimeout\n	  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;\n	\n	  // Via Host\n	  if (settings.hackIpInContact) {\n	    if (typeof settings.hackIpInContact === 'boolean') {\n	      settings.viaHost = SIP.Utils.getRandomTestNetIP();\n	    }\n	    else if (typeof settings.hackIpInContact === 'string') {\n	      settings.viaHost = settings.hackIpInContact;\n	    }\n	  }\n	\n	  // Contact transport parameter\n	  if (settings.hackWssInTransport) {\n	    settings.contactTransport = 'wss';\n	  }\n	\n	  this.contact = {\n	    pub_gruu: null,\n	    temp_gruu: null,\n	    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),\n	    toString: function(options){\n	      options = options || {};\n	\n	      var\n	        anonymous = options.anonymous || null,\n	        outbound = options.outbound || null,\n	        contact = '<';\n	\n	      if (anonymous) {\n	        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();\n	      } else {\n	        contact += (this.pub_gruu || this.uri).toString();\n	      }\n	\n	      if (outbound) {\n	        contact += ';ob';\n	      }\n	\n	      contact += '>';\n	\n	      return contact;\n	    }\n	  };\n	\n	  // media overrides mediaConstraints\n	  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);\n	\n	  // Fill the value of the configuration_skeleton\n	  for(parameter in settings) {\n	    UA.configuration_skeleton[parameter].value = settings[parameter];\n	  }\n	\n	  Object.defineProperties(this.configuration, UA.configuration_skeleton);\n	\n	  // Clean UA.configuration_skeleton\n	  for(parameter in settings) {\n	    UA.configuration_skeleton[parameter].value = '';\n	  }\n	\n	  this.logger.log('configuration parameters after validation:');\n	  for(parameter in settings) {\n	    switch(parameter) {\n	      case 'uri':\n	      case 'registrarServer':\n	      case 'mediaHandlerFactory':\n	        this.logger.log(' ' + parameter + ': ' + settings[parameter]);\n	        break;\n	      case 'password':\n	        this.logger.log(' ' + parameter + ': ' + 'NOT SHOWN');\n	        break;\n	      default:\n	        this.logger.log(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n	    }\n	  }\n	\n	  return;\n	};\n	\n	/**\n	 * Configuration Object skeleton.\n	 * @private\n	 */\n	UA.configuration_skeleton = (function() {\n	  var idx,  parameter,\n	    skeleton = {},\n	    parameters = [\n	      // Internal parameters\n	      \"sipjsId\",\n	      \"hostportParams\",\n	\n	      // Optional user configurable parameters\n	      \"uri\",\n	      \"wsServers\",\n	      \"authorizationUser\",\n	      \"connectionRecoveryMaxInterval\",\n	      \"connectionRecoveryMinInterval\",\n	      \"keepAliveInterval\",\n	      \"extraSupported\",\n	      \"displayName\",\n	      \"hackViaTcp\", // false.\n	      \"hackIpInContact\", //false\n	      \"hackWssInTransport\", //false\n	      \"hackAllowUnregisteredOptionTags\", //false\n	      \"contactTransport\", // 'ws'\n	      \"forceRport\", // false\n	      \"iceCheckingTimeout\",\n	      \"instanceId\",\n	      \"noAnswerTimeout\", // 30 seconds.\n	      \"password\",\n	      \"registerExpires\", // 600 seconds.\n	      \"registrarServer\",\n	      \"reliable\",\n	      \"rel100\",\n	      \"replaces\",\n	      \"userAgentString\", //SIP.C.USER_AGENT\n	      \"autostart\",\n	      \"stunServers\",\n	      \"traceSip\",\n	      \"turnServers\",\n	      \"usePreloadedRoute\",\n	      \"wsServerMaxReconnection\",\n	      \"wsServerReconnectionTimeout\",\n	      \"mediaHandlerFactory\",\n	      \"media\",\n	      \"mediaConstraints\",\n	      \"authenticationFactory\",\n	\n	      // Post-configuration generated parameters\n	      \"via_core_value\",\n	      \"viaHost\"\n	    ];\n	\n	  for(idx in parameters) {\n	    parameter = parameters[idx];\n	    skeleton[parameter] = {\n	      value: '',\n	      writable: false,\n	      configurable: false\n	    };\n	  }\n	\n	  skeleton['register'] = {\n	    value: '',\n	    writable: true,\n	    configurable: false\n	  };\n	\n	  return skeleton;\n	}());\n	\n	/**\n	 * Configuration checker.\n	 * @private\n	 * @return {Boolean}\n	 */\n	UA.configuration_check = {\n	  mandatory: {\n	  },\n	\n	  optional: {\n	\n	    uri: function(uri) {\n	      var parsed;\n	\n	      if (!(/^sip:/i).test(uri)) {\n	        uri = SIP.C.SIP + ':' + uri;\n	      }\n	      parsed = SIP.URI.parse(uri);\n	\n	      if(!parsed) {\n	        return;\n	      } else if(!parsed.user) {\n	        return;\n	      } else {\n	        return parsed;\n	      }\n	    },\n	\n	    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n	    wsServers: function(wsServers) {\n	      var idx, length, url;\n	\n	      /* Allow defining wsServers parameter as:\n	       *  String: \"host\"\n	       *  Array of Strings: [\"host1\", \"host2\"]\n	       *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n	       *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n	       */\n	      if (typeof wsServers === 'string') {\n	        wsServers = [{ws_uri: wsServers}];\n	      } else if (wsServers instanceof Array) {\n	        length = wsServers.length;\n	        for (idx = 0; idx < length; idx++) {\n	          if (typeof wsServers[idx] === 'string'){\n	            wsServers[idx] = {ws_uri: wsServers[idx]};\n	          }\n	        }\n	      } else {\n	        return;\n	      }\n	\n	      if (wsServers.length === 0) {\n	        return false;\n	      }\n	\n	      length = wsServers.length;\n	      for (idx = 0; idx < length; idx++) {\n	        if (!wsServers[idx].ws_uri) {\n	          return;\n	        }\n	        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {\n	          return;\n	        }\n	\n	        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');\n	\n	        if(url === -1) {\n	          return;\n	        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {\n	          return;\n	        } else {\n	          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';\n	\n	          if (!wsServers[idx].weight) {\n	            wsServers[idx].weight = 0;\n	          }\n	\n	          wsServers[idx].status = 0;\n	          wsServers[idx].scheme = url.scheme.toUpperCase();\n	        }\n	      }\n	      return wsServers;\n	    },\n	\n	    authorizationUser: function(authorizationUser) {\n	      if(SIP.Grammar.parse('\"'+ authorizationUser +'\"', 'quoted_string') === -1) {\n	        return;\n	      } else {\n	        return authorizationUser;\n	      }\n	    },\n	\n	    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {\n	      var value;\n	      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {\n	        value = Number(connectionRecoveryMaxInterval);\n	        if(value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {\n	      var value;\n	      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {\n	        value = Number(connectionRecoveryMinInterval);\n	        if(value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    displayName: function(displayName) {\n	      if(SIP.Grammar.parse('\"' + displayName + '\"', 'displayName') === -1) {\n	        return;\n	      } else {\n	        return displayName;\n	      }\n	    },\n	\n	    hackViaTcp: function(hackViaTcp) {\n	      if (typeof hackViaTcp === 'boolean') {\n	        return hackViaTcp;\n	      }\n	    },\n	\n	    hackIpInContact: function(hackIpInContact) {\n	      if (typeof hackIpInContact === 'boolean') {\n	        return hackIpInContact;\n	      }\n	      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {\n	        return hackIpInContact;\n	      }\n	    },\n	\n	    iceCheckingTimeout: function(iceCheckingTimeout) {\n	      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {\n	        return Math.max(500, iceCheckingTimeout);\n	      }\n	    },\n	\n	    hackWssInTransport: function(hackWssInTransport) {\n	      if (typeof hackWssInTransport === 'boolean') {\n	        return hackWssInTransport;\n	      }\n	    },\n	\n	    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {\n	      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {\n	        return hackAllowUnregisteredOptionTags;\n	      }\n	    },\n	\n	    contactTransport: function(contactTransport) {\n	      if (typeof contactTransport === 'string') {\n	        return contactTransport;\n	      }\n	    },\n	\n	    forceRport: function(forceRport) {\n	      if (typeof forceRport === 'boolean') {\n	        return forceRport;\n	      }\n	    },\n	\n	    instanceId: function(instanceId) {\n	      if(typeof instanceId !== 'string') {\n	        return;\n	      }\n	\n	      if ((/^uuid:/i.test(instanceId))) {\n	        instanceId = instanceId.substr(5);\n	      }\n	\n	      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {\n	        return;\n	      } else {\n	        return instanceId;\n	      }\n	    },\n	\n	    keepAliveInterval: function(keepAliveInterval) {\n	      var value;\n	      if (SIP.Utils.isDecimal(keepAliveInterval)) {\n	        value = Number(keepAliveInterval);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    extraSupported: function(optionTags) {\n	      var idx, length;\n	\n	      if (!(optionTags instanceof Array)) {\n	        return;\n	      }\n	\n	      length = optionTags.length;\n	      for (idx = 0; idx < length; idx++) {\n	        if (typeof optionTags[idx] !== 'string') {\n	          return;\n	        }\n	      }\n	\n	      return optionTags;\n	    },\n	\n	    noAnswerTimeout: function(noAnswerTimeout) {\n	      var value;\n	      if (SIP.Utils.isDecimal(noAnswerTimeout)) {\n	        value = Number(noAnswerTimeout);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    password: function(password) {\n	      return String(password);\n	    },\n	\n	    rel100: function(rel100) {\n	      if(rel100 === SIP.C.supported.REQUIRED) {\n	        return SIP.C.supported.REQUIRED;\n	      } else if (rel100 === SIP.C.supported.SUPPORTED) {\n	        return SIP.C.supported.SUPPORTED;\n	      } else  {\n	        return SIP.C.supported.UNSUPPORTED;\n	      }\n	    },\n	\n	    replaces: function(replaces) {\n	      if(replaces === SIP.C.supported.REQUIRED) {\n	        return SIP.C.supported.REQUIRED;\n	      } else if (replaces === SIP.C.supported.SUPPORTED) {\n	        return SIP.C.supported.SUPPORTED;\n	      } else  {\n	        return SIP.C.supported.UNSUPPORTED;\n	      }\n	    },\n	\n	    register: function(register) {\n	      if (typeof register === 'boolean') {\n	        return register;\n	      }\n	    },\n	\n	    registerExpires: function(registerExpires) {\n	      var value;\n	      if (SIP.Utils.isDecimal(registerExpires)) {\n	        value = Number(registerExpires);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    registrarServer: function(registrarServer) {\n	      var parsed;\n	\n	      if(typeof registrarServer !== 'string') {\n	        return;\n	      }\n	\n	      if (!/^sip:/i.test(registrarServer)) {\n	        registrarServer = SIP.C.SIP + ':' + registrarServer;\n	      }\n	      parsed = SIP.URI.parse(registrarServer);\n	\n	      if(!parsed) {\n	        return;\n	      } else if(parsed.user) {\n	        return;\n	      } else {\n	        return parsed;\n	      }\n	    },\n	\n	    stunServers: function(stunServers) {\n	      var idx, length, stun_server;\n	\n	      if (typeof stunServers === 'string') {\n	        stunServers = [stunServers];\n	      } else if (!(stunServers instanceof Array)) {\n	        return;\n	      }\n	\n	      length = stunServers.length;\n	      for (idx = 0; idx < length; idx++) {\n	        stun_server = stunServers[idx];\n	        if (!(/^stuns?:/.test(stun_server))) {\n	          stun_server = 'stun:' + stun_server;\n	        }\n	\n	        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {\n	          return;\n	        } else {\n	          stunServers[idx] = stun_server;\n	        }\n	      }\n	      return stunServers;\n	    },\n	\n	    traceSip: function(traceSip) {\n	      if (typeof traceSip === 'boolean') {\n	        return traceSip;\n	      }\n	    },\n	\n	    turnServers: function(turnServers) {\n	      var idx, jdx, length, turn_server, num_turn_server_urls, url;\n	\n	      if (turnServers instanceof Array) {\n	        // Do nothing\n	      } else {\n	        turnServers = [turnServers];\n	      }\n	\n	      length = turnServers.length;\n	      for (idx = 0; idx < length; idx++) {\n	        turn_server = turnServers[idx];\n	        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.\n	        if (turn_server.server) {\n	          turn_server.urls = [turn_server.server];\n	        }\n	\n	        if (!turn_server.urls || !turn_server.username || !turn_server.password) {\n	          return;\n	        }\n	\n	        if (turn_server.urls instanceof Array) {\n	          num_turn_server_urls = turn_server.urls.length;\n	        } else {\n	          turn_server.urls = [turn_server.urls];\n	          num_turn_server_urls = 1;\n	        }\n	\n	        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {\n	          url = turn_server.urls[jdx];\n	\n	          if (!(/^turns?:/.test(url))) {\n	            url = 'turn:' + url;\n	          }\n	\n	          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {\n	            return;\n	          }\n	        }\n	      }\n	      return turnServers;\n	    },\n	\n	    userAgentString: function(userAgentString) {\n	      if (typeof userAgentString === 'string') {\n	        return userAgentString;\n	      }\n	    },\n	\n	    usePreloadedRoute: function(usePreloadedRoute) {\n	      if (typeof usePreloadedRoute === 'boolean') {\n	        return usePreloadedRoute;\n	      }\n	    },\n	\n	    wsServerMaxReconnection: function(wsServerMaxReconnection) {\n	      var value;\n	      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {\n	        value = Number(wsServerMaxReconnection);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {\n	      var value;\n	      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {\n	        value = Number(wsServerReconnectionTimeout);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    autostart: function(autostart) {\n	      if (typeof autostart === 'boolean') {\n	        return autostart;\n	      }\n	    },\n	\n	    mediaHandlerFactory: function(mediaHandlerFactory) {\n	      if (mediaHandlerFactory instanceof Function) {\n	        var promisifiedFactory = function promisifiedFactory () {\n	          var mediaHandler = mediaHandlerFactory.apply(this, arguments);\n	\n	          function patchMethod (methodName) {\n	            var method = mediaHandler[methodName];\n	            if (method.length > 1) {\n	              var callbacksFirst = methodName === 'getDescription';\n	              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);\n	            }\n	          }\n	\n	          patchMethod('getDescription');\n	          patchMethod('setDescription');\n	\n	          return mediaHandler;\n	        };\n	\n	        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;\n	        return promisifiedFactory;\n	      }\n	    },\n	\n	    authenticationFactory: checkAuthenticationFactory\n	  }\n	};\n	\n	UA.C = C;\n	SIP.UA = UA;\n	};\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Hacks - This file contains all of the things we\n	 * wish we didn't have to do, just for interop.  It is similar to\n	 * Utils, which provides actually useful and relevant functions for\n	 * a SIP library. Methods in this file are grouped by vendor, so\n	 * as to most easily track when particular hacks may not be necessary anymore.\n	 */\n	\n	module.exports = function (SIP) {\n	\n	//keep to quiet jshint, and remain consistent with other files\n	SIP = SIP;\n	\n	var Hacks = {\n	  AllBrowsers: {\n	    maskDtls: function (message) {\n	      if (message.body) {\n	        message.body = message.body.replace(/ UDP\\/TLS\\/RTP\\/SAVP/gmi, \" RTP/SAVP\");\n	      }\n	    },\n	    unmaskDtls: function (sdp) {\n	      /**\n	       * Chrome does not handle DTLS correctly (Canaray does, but not production)\n	       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)\n	       *\n	       * UPDATE: May 21, 2014\n	       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES\n	       *\n	       * UPDATE: 2014-09-24\n	       * Opera now supports DTLS by default as well.\n	       *\n	       **/\n	      return sdp.replace(/ RTP\\/SAVP/gmi, \" UDP/TLS/RTP/SAVP\");\n	    }\n	  },\n	  Firefox: {\n	    /* Condition to detect if hacks are applicable */\n	    isFirefox: function () {\n	      return typeof mozRTCPeerConnection !== 'undefined';\n	    },\n	\n	    cannotHandleExtraWhitespace: function (message) {\n	      if (this.isFirefox() && message.body) {\n	        message.body = message.body.replace(/ \\r\\n/g, \"\\r\\n\");\n	      }\n	    },\n	\n	    hasMissingCLineInSDP: function (sdp) {\n	      /*\n	       * This is a Firefox hack to insert valid sdp when getDescription is\n	       * called with the constraint offerToReceiveVideo = false.\n	       * We search for either a c-line at the top of the sdp above all\n	       * m-lines. If that does not exist then we search for a c-line\n	       * beneath each m-line. If it is missing a c-line, we insert\n	       * a fake c-line with the ip address 0.0.0.0. This is then valid\n	       * sdp and no media will be sent for that m-line.\n	       *\n	       * Valid SDP is:\n	       * m=\n	       * i=\n	       * c=\n	       */\n	      var insertAt, mlines;\n	      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {\n	\n	        // Find all m= lines\n	        mlines = sdp.match(/m=.*\\r\\n.*/g);\n	        for (var i=0; i<mlines.length; i++) {\n	\n	          // If it has an i= line, check if the next line is the c= line\n	          if (mlines[i].toString().search(/i=.*/) >= 0) {\n	            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;\n	            if (sdp.substr(insertAt,2)!=='c=') {\n	              sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n	            }\n	\n	          // else add the C line if it's missing\n	          } else if (mlines[i].toString().search(/c=.*/) < 0) {\n	            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;\n	            sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n	          }\n	        }\n	      }\n	      return sdp;\n	    },\n	  },\n	\n	  Chrome: {\n	    needsExplicitlyInactiveSDP: function (sdp) {\n	      var sub, index;\n	\n	      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending\n	        index = sdp.indexOf('m=video 0');\n	        if (index !== -1) {\n	          sub = sdp.substr(index);\n	          sub = sub.replace(/\\r\\nc=IN IP4.*\\r\\n$/,\n	                            '\\r\\nc=IN IP4 0.0.0.0\\r\\na=inactive\\r\\n');\n	          return sdp.substr(0, index) + sub;\n	        }\n	      }\n	      return sdp;\n	    },\n	\n	    getsConfusedAboutGUM: function (session) {\n	      if (session.mediaHandler) {\n	        session.mediaHandler.close();\n	      }\n	    }\n	  }\n	};\n	return Hacks;\n	};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Incoming SIP Message Sanity Check\n	 */\n	\n	/**\n	 * SIP message sanity check.\n	 * @augments SIP\n	 * @function\n	 * @param {SIP.IncomingMessage} message\n	 * @param {SIP.UA} ua\n	 * @param {SIP.Transport} transport\n	 * @returns {Boolean}\n	 */\n	module.exports = function (SIP) {\n	var sanityCheck,\n	 logger,\n	 message, ua, transport,\n	 requests = [],\n	 responses = [],\n	 all = [];\n	\n	// Reply\n	function reply(status_code) {\n	  var to,\n	    response = SIP.Utils.buildStatusLine(status_code),\n	    vias = message.getHeaders('via'),\n	    length = vias.length,\n	    idx = 0;\n	\n	  for(idx; idx < length; idx++) {\n	    response += \"Via: \" + vias[idx] + \"\\r\\n\";\n	  }\n	\n	  to = message.getHeader('To');\n	\n	  if(!message.to_tag) {\n	    to += ';tag=' + SIP.Utils.newTag();\n	  }\n	\n	  response += \"To: \" + to + \"\\r\\n\";\n	  response += \"From: \" + message.getHeader('From') + \"\\r\\n\";\n	  response += \"Call-ID: \" + message.call_id + \"\\r\\n\";\n	  response += \"CSeq: \" + message.cseq + \" \" + message.method + \"\\r\\n\";\n	  response += \"\\r\\n\";\n	\n	  transport.send(response);\n	}\n	\n	/*\n	 * Sanity Check for incoming Messages\n	 *\n	 * Requests:\n	 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n	 *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n	 *   Does not look at via sent-by but at sipjsId, which is inserted as\n	 *   a prefix in all initial requests generated by the ua\n	 *  - _rfc3261_18_3_request_ Body Content-Length\n	 *  - _rfc3261_8_2_2_2_ Merged Requests\n	 *\n	 * Responses:\n	 *  - _rfc3261_8_1_3_3_ Multiple Via headers\n	 *  - _rfc3261_18_1_2_ sent-by mismatch\n	 *  - _rfc3261_18_3_response_ Body Content-Length\n	 *\n	 * All:\n	 *  - Minimum headers in a SIP message\n	 */\n	\n	// Sanity Check functions for requests\n	function rfc3261_8_2_2_1() {\n	  if(!message.ruri || message.ruri.scheme !== 'sip') {\n	    reply(416);\n	    return false;\n	  }\n	}\n	\n	function rfc3261_16_3_4() {\n	  if(!message.to_tag) {\n	    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {\n	      reply(482);\n	      return false;\n	    }\n	  }\n	}\n	\n	function rfc3261_18_3_request() {\n	  var len = SIP.Utils.str_utf8_length(message.body),\n	  contentLength = message.getHeader('content-length');\n	\n	  if(len < contentLength) {\n	    reply(400);\n	    return false;\n	  }\n	}\n	\n	function rfc3261_8_2_2_2() {\n	  var tr, idx,\n	    fromTag = message.from_tag,\n	    call_id = message.call_id,\n	    cseq = message.cseq;\n	\n	  if(!message.to_tag) {\n	    if(message.method === SIP.C.INVITE) {\n	      tr = ua.transactions.ist[message.via_branch];\n	      if(tr) {\n	        return;\n	      } else {\n	        for(idx in ua.transactions.ist) {\n	          tr = ua.transactions.ist[idx];\n	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n	            reply(482);\n	            return false;\n	          }\n	        }\n	      }\n	    } else {\n	      tr = ua.transactions.nist[message.via_branch];\n	      if(tr) {\n	        return;\n	      } else {\n	        for(idx in ua.transactions.nist) {\n	          tr = ua.transactions.nist[idx];\n	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n	            reply(482);\n	            return false;\n	          }\n	        }\n	      }\n	    }\n	  }\n	}\n	\n	// Sanity Check functions for responses\n	function rfc3261_8_1_3_3() {\n	  if(message.getHeaders('via').length > 1) {\n	    logger.warn('More than one Via header field present in the response. Dropping the response');\n	    return false;\n	  }\n	}\n	\n	function rfc3261_18_1_2() {\n	  var viaHost = ua.configuration.viaHost;\n	  if(message.via.host !== viaHost || message.via.port !== undefined) {\n	    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');\n	    return false;\n	  }\n	}\n	\n	function rfc3261_18_3_response() {\n	  var\n	    len = SIP.Utils.str_utf8_length(message.body),\n	    contentLength = message.getHeader('content-length');\n	\n	    if(len < contentLength) {\n	      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');\n	      return false;\n	    }\n	}\n	\n	// Sanity Check functions for requests and responses\n	function minimumHeaders() {\n	  var\n	    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],\n	    idx = mandatoryHeaders.length;\n	\n	  while(idx--) {\n	    if(!message.hasHeader(mandatoryHeaders[idx])) {\n	      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');\n	      return false;\n	    }\n	  }\n	}\n	\n	requests.push(rfc3261_8_2_2_1);\n	requests.push(rfc3261_16_3_4);\n	requests.push(rfc3261_18_3_request);\n	requests.push(rfc3261_8_2_2_2);\n	\n	responses.push(rfc3261_8_1_3_3);\n	responses.push(rfc3261_18_1_2);\n	responses.push(rfc3261_18_3_response);\n	\n	all.push(minimumHeaders);\n	\n	sanityCheck = function(m, u, t) {\n	  var len, pass;\n	\n	  message = m;\n	  ua = u;\n	  transport = t;\n	\n	  logger = ua.getLogger('sip.sanitycheck');\n	\n	  len = all.length;\n	  while(len--) {\n	    pass = all[len](message);\n	    if(pass === false) {\n	      return false;\n	    }\n	  }\n	\n	  if(message instanceof SIP.IncomingRequest) {\n	    len = requests.length;\n	    while(len--) {\n	      pass = requests[len](message);\n	      if(pass === false) {\n	        return false;\n	      }\n	    }\n	  }\n	\n	  else if(message instanceof SIP.IncomingResponse) {\n	    len = responses.length;\n	    while(len--) {\n	      pass = responses[len](message);\n	      if(pass === false) {\n	        return false;\n	      }\n	    }\n	  }\n	\n	  //Everything is OK\n	  return true;\n	};\n	\n	SIP.sanityCheck = sanityCheck;\n	};\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview SIP Digest Authentication\n	 */\n	\n	/**\n	 * SIP Digest Authentication.\n	 * @augments SIP.\n	 * @function Digest Authentication\n	 * @param {SIP.UA} ua\n	 */\n	module.exports = function (Utils) {\n	var DigestAuthentication;\n	\n	DigestAuthentication = function(ua) {\n	  this.logger = ua.getLogger('sipjs.digestauthentication');\n	  this.username = ua.configuration.authorizationUser;\n	  this.password = ua.configuration.password;\n	  this.cnonce = null;\n	  this.nc = 0;\n	  this.ncHex = '00000000';\n	  this.response = null;\n	};\n	\n	\n	/**\n	* Performs Digest authentication given a SIP request and the challenge\n	* received in a response to that request.\n	* Returns true if credentials were successfully generated, false otherwise.\n	*\n	* @param {SIP.OutgoingRequest} request\n	* @param {Object} challenge\n	*/\n	DigestAuthentication.prototype.authenticate = function(request, challenge) {\n	  // Inspect and validate the challenge.\n	\n	  this.algorithm = challenge.algorithm;\n	  this.realm = challenge.realm;\n	  this.nonce = challenge.nonce;\n	  this.opaque = challenge.opaque;\n	  this.stale = challenge.stale;\n	\n	  if (this.algorithm) {\n	    if (this.algorithm !== 'MD5') {\n	      this.logger.warn('challenge with Digest algorithm different than \"MD5\", authentication aborted');\n	      return false;\n	    }\n	  } else {\n	    this.algorithm = 'MD5';\n	  }\n	\n	  if (! this.realm) {\n	    this.logger.warn('challenge without Digest realm, authentication aborted');\n	    return false;\n	  }\n	\n	  if (! this.nonce) {\n	    this.logger.warn('challenge without Digest nonce, authentication aborted');\n	    return false;\n	  }\n	\n	  // 'qop' can contain a list of values (Array). Let's choose just one.\n	  if (challenge.qop) {\n	    if (challenge.qop.indexOf('auth') > -1) {\n	      this.qop = 'auth';\n	    } else if (challenge.qop.indexOf('auth-int') > -1) {\n	      this.qop = 'auth-int';\n	    } else {\n	      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n	      this.logger.warn('challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n	      return false;\n	    }\n	  } else {\n	    this.qop = null;\n	  }\n	\n	  // Fill other attributes.\n	\n	  this.method = request.method;\n	  this.uri = request.ruri;\n	  this.cnonce = Utils.createRandomToken(12);\n	  this.nc += 1;\n	  this.updateNcHex();\n	\n	  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n	  if (this.nc === 4294967296) {\n	    this.nc = 1;\n	    this.ncHex = '00000001';\n	  }\n	\n	  // Calculate the Digest \"response\" value.\n	  this.calculateResponse();\n	\n	  return true;\n	};\n	\n	\n	/**\n	* Generate Digest 'response' value.\n	* @private\n	*/\n	DigestAuthentication.prototype.calculateResponse = function() {\n	  var ha1, ha2;\n	\n	  // HA1 = MD5(A1) = MD5(username:realm:password)\n	  ha1 = Utils.calculateMD5(this.username + \":\" + this.realm + \":\" + this.password);\n	\n	  if (this.qop === 'auth') {\n	    // HA2 = MD5(A2) = MD5(method:digestURI)\n	    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n	    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n	\n	  } else if (this.qop === 'auth-int') {\n	    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n	    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri + \":\" + Utils.calculateMD5(this.body ? this.body : \"\"));\n	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n	    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n	\n	  } else if (this.qop === null) {\n	    // HA2 = MD5(A2) = MD5(method:digestURI)\n	    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n	    // response = MD5(HA1:nonce:HA2)\n	    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n	  }\n	};\n	\n	\n	/**\n	* Return the Proxy-Authorization or WWW-Authorization header value.\n	*/\n	DigestAuthentication.prototype.toString = function() {\n	  var auth_params = [];\n	\n	  if (! this.response) {\n	    throw new Error('response field does not exist, cannot generate Authorization header');\n	  }\n	\n	  auth_params.push('algorithm=' + this.algorithm);\n	  auth_params.push('username=\"' + this.username + '\"');\n	  auth_params.push('realm=\"' + this.realm + '\"');\n	  auth_params.push('nonce=\"' + this.nonce + '\"');\n	  auth_params.push('uri=\"' + this.uri + '\"');\n	  auth_params.push('response=\"' + this.response + '\"');\n	  if (this.opaque) {\n	    auth_params.push('opaque=\"' + this.opaque + '\"');\n	  }\n	  if (this.qop) {\n	    auth_params.push('qop=' + this.qop);\n	    auth_params.push('cnonce=\"' + this.cnonce + '\"');\n	    auth_params.push('nc=' + this.ncHex);\n	  }\n	\n	  return 'Digest ' + auth_params.join(', ');\n	};\n	\n	\n	/**\n	* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n	* @private\n	*/\n	DigestAuthentication.prototype.updateNcHex = function() {\n	  var hex = Number(this.nc).toString(16);\n	  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;\n	};\n	\n	return DigestAuthentication;\n	};\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	var Grammar = __webpack_require__(48);\n	\n	module.exports = function (SIP) {\n	\n	return {\n	  parse: function parseCustom (input, startRule) {\n	    var options = {startRule: startRule, SIP: SIP};\n	    try {\n	      Grammar.parse(input, options);\n	    } catch (e) {\n	      options.data = -1;\n	    }\n	    return options.data;\n	  }\n	};\n	\n	};\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n	module.exports = (function() {\n	  /*\n	   * Generated by PEG.js 0.8.0.\n	   *\n	   * http://pegjs.majda.cz/\n	   */\n	\n	  function peg$subclass(child, parent) {\n	    function ctor() { this.constructor = child; }\n	    ctor.prototype = parent.prototype;\n	    child.prototype = new ctor();\n	  }\n	\n	  function SyntaxError(message, expected, found, offset, line, column) {\n	    this.message  = message;\n	    this.expected = expected;\n	    this.found    = found;\n	    this.offset   = offset;\n	    this.line     = line;\n	    this.column   = column;\n	\n	    this.name     = \"SyntaxError\";\n	  }\n	\n	  peg$subclass(SyntaxError, Error);\n	\n	  function parse(input) {\n	    var options = arguments.length > 1 ? arguments[1] : {},\n	\n	        peg$FAILED = {},\n	\n	        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },\n	        peg$startRuleIndex   = 118,\n	\n	        peg$consts = [\n	          \"\\r\\n\",\n	          { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n	          /^[0-9]/,\n	          { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n	          /^[a-zA-Z]/,\n	          { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n	          /^[0-9a-fA-F]/,\n	          { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n	          /^[\\0-\\xFF]/,\n	          { type: \"class\", value: \"[\\\\0-\\\\xFF]\", description: \"[\\\\0-\\\\xFF]\" },\n	          /^[\"]/,\n	          { type: \"class\", value: \"[\\\"]\", description: \"[\\\"]\" },\n	          \" \",\n	          { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n	          \"\\t\",\n	          { type: \"literal\", value: \"\\t\", description: \"\\\"\\\\t\\\"\" },\n	          /^[a-zA-Z0-9]/,\n	          { type: \"class\", value: \"[a-zA-Z0-9]\", description: \"[a-zA-Z0-9]\" },\n	          \";\",\n	          { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n	          \"/\",\n	          { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n	          \"?\",\n	          { type: \"literal\", value: \"?\", description: \"\\\"?\\\"\" },\n	          \":\",\n	          { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n	          \"@\",\n	          { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n	          \"&\",\n	          { type: \"literal\", value: \"&\", description: \"\\\"&\\\"\" },\n	          \"=\",\n	          { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n	          \"+\",\n	          { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n	          \"$\",\n	          { type: \"literal\", value: \"$\", description: \"\\\"$\\\"\" },\n	          \",\",\n	          { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n	          \"-\",\n	          { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n	          \"_\",\n	          { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n	          \".\",\n	          { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n	          \"!\",\n	          { type: \"literal\", value: \"!\", description: \"\\\"!\\\"\" },\n	          \"~\",\n	          { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n	          \"*\",\n	          { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n	          \"'\",\n	          { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\n	          \"(\",\n	          { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n	          \")\",\n	          { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n	          peg$FAILED,\n	          \"%\",\n	          { type: \"literal\", value: \"%\", description: \"\\\"%\\\"\" },\n	          null,\n	          [],\n	          function() {return \" \"; },\n	          function() {return ':'; },\n	          /^[!-~]/,\n	          { type: \"class\", value: \"[!-~]\", description: \"[!-~]\" },\n	          /^[\\x80-\\uFFFF]/,\n	          { type: \"class\", value: \"[\\\\x80-\\\\uFFFF]\", description: \"[\\\\x80-\\\\uFFFF]\" },\n	          /^[\\x80-\\xBF]/,\n	          { type: \"class\", value: \"[\\\\x80-\\\\xBF]\", description: \"[\\\\x80-\\\\xBF]\" },\n	          /^[a-f]/,\n	          { type: \"class\", value: \"[a-f]\", description: \"[a-f]\" },\n	          \"`\",\n	          { type: \"literal\", value: \"`\", description: \"\\\"`\\\"\" },\n	          \"<\",\n	          { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n	          \">\",\n	          { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n	          \"\\\\\",\n	          { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n	          \"[\",\n	          { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n	          \"]\",\n	          { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n	          \"{\",\n	          { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n	          \"}\",\n	          { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n	          function() {return \"*\"; },\n	          function() {return \"/\"; },\n	          function() {return \"=\"; },\n	          function() {return \"(\"; },\n	          function() {return \")\"; },\n	          function() {return \">\"; },\n	          function() {return \"<\"; },\n	          function() {return \",\"; },\n	          function() {return \";\"; },\n	          function() {return \":\"; },\n	          function() {return \"\\\"\"; },\n	          /^[!-']/,\n	          { type: \"class\", value: \"[!-']\", description: \"[!-']\" },\n	          /^[*-[]/,\n	          { type: \"class\", value: \"[*-[]\", description: \"[*-[]\" },\n	          /^[\\]-~]/,\n	          { type: \"class\", value: \"[\\\\]-~]\", description: \"[\\\\]-~]\" },\n	          function(contents) {\n	                                  return contents; },\n	          /^[#-[]/,\n	          { type: \"class\", value: \"[#-[]\", description: \"[#-[]\" },\n	          /^[\\0-\\t]/,\n	          { type: \"class\", value: \"[\\\\0-\\\\t]\", description: \"[\\\\0-\\\\t]\" },\n	          /^[\\x0B-\\f]/,\n	          { type: \"class\", value: \"[\\\\x0B-\\\\f]\", description: \"[\\\\x0B-\\\\f]\" },\n	          /^[\\x0E-]/,\n	          { type: \"class\", value: \"[\\\\x0E-]\", description: \"[\\\\x0E-]\" },\n	          function() {\n	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);\n	                                  delete options.data.scheme;\n	                                  delete options.data.user;\n	                                  delete options.data.host;\n	                                  delete options.data.host_type;\n	                                  delete options.data.port;\n	                                },\n	          function() {\n	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n	                                  delete options.data.scheme;\n	                                  delete options.data.user;\n	                                  delete options.data.host;\n	                                  delete options.data.host_type;\n	                                  delete options.data.port;\n	                                  delete options.data.uri_params;\n	\n	                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}\n	                                },\n	          \"sips\",\n	          { type: \"literal\", value: \"sips\", description: \"\\\"sips\\\"\" },\n	          \"sip\",\n	          { type: \"literal\", value: \"sip\", description: \"\\\"sip\\\"\" },\n	          function(uri_scheme) {\n	                              options.data.scheme = uri_scheme; },\n	          function() {\n	                              options.data.user = decodeURIComponent(text().slice(0, -1));},\n	          function() {\n	                              options.data.password = text(); },\n	          function() {\n	                              options.data.host = text();\n	                              return options.data.host; },\n	          function() {\n	                            options.data.host_type = 'domain';\n	                            return text(); },\n	          /^[a-zA-Z0-9_\\-]/,\n	          { type: \"class\", value: \"[a-zA-Z0-9_\\\\-]\", description: \"[a-zA-Z0-9_\\\\-]\" },\n	          /^[a-zA-Z0-9\\-]/,\n	          { type: \"class\", value: \"[a-zA-Z0-9\\\\-]\", description: \"[a-zA-Z0-9\\\\-]\" },\n	          function() {\n	                              options.data.host_type = 'IPv6';\n	                              return text(); },\n	          \"::\",\n	          { type: \"literal\", value: \"::\", description: \"\\\"::\\\"\" },\n	          function() {\n	                            options.data.host_type = 'IPv6';\n	                            return text(); },\n	          function() {\n	                              options.data.host_type = 'IPv4';\n	                              return text(); },\n	          \"25\",\n	          { type: \"literal\", value: \"25\", description: \"\\\"25\\\"\" },\n	          /^[0-5]/,\n	          { type: \"class\", value: \"[0-5]\", description: \"[0-5]\" },\n	          \"2\",\n	          { type: \"literal\", value: \"2\", description: \"\\\"2\\\"\" },\n	          /^[0-4]/,\n	          { type: \"class\", value: \"[0-4]\", description: \"[0-4]\" },\n	          \"1\",\n	          { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n	          /^[1-9]/,\n	          { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n	          function(port) {\n	                              port = parseInt(port.join(''));\n	                              options.data.port = port;\n	                              return port; },\n	          \"transport=\",\n	          { type: \"literal\", value: \"transport=\", description: \"\\\"transport=\\\"\" },\n	          \"udp\",\n	          { type: \"literal\", value: \"udp\", description: \"\\\"udp\\\"\" },\n	          \"tcp\",\n	          { type: \"literal\", value: \"tcp\", description: \"\\\"tcp\\\"\" },\n	          \"sctp\",\n	          { type: \"literal\", value: \"sctp\", description: \"\\\"sctp\\\"\" },\n	          \"tls\",\n	          { type: \"literal\", value: \"tls\", description: \"\\\"tls\\\"\" },\n	          function(transport) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['transport'] = transport.toLowerCase(); },\n	          \"user=\",\n	          { type: \"literal\", value: \"user=\", description: \"\\\"user=\\\"\" },\n	          \"phone\",\n	          { type: \"literal\", value: \"phone\", description: \"\\\"phone\\\"\" },\n	          \"ip\",\n	          { type: \"literal\", value: \"ip\", description: \"\\\"ip\\\"\" },\n	          function(user) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['user'] = user.toLowerCase(); },\n	          \"method=\",\n	          { type: \"literal\", value: \"method=\", description: \"\\\"method=\\\"\" },\n	          function(method) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['method'] = method; },\n	          \"ttl=\",\n	          { type: \"literal\", value: \"ttl=\", description: \"\\\"ttl=\\\"\" },\n	          function(ttl) {\n	                                if(!options.data.params) options.data.params={};\n	                                options.data.params['ttl'] = ttl; },\n	          \"maddr=\",\n	          { type: \"literal\", value: \"maddr=\", description: \"\\\"maddr=\\\"\" },\n	          function(maddr) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['maddr'] = maddr; },\n	          \"lr\",\n	          { type: \"literal\", value: \"lr\", description: \"\\\"lr\\\"\" },\n	          function() {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['lr'] = undefined; },\n	          function(param, value) {\n	                                if(!options.data.uri_params) options.data.uri_params = {};\n	                                if (value === null){\n	                                  value = undefined;\n	                                }\n	                                else {\n	                                  value = value[1];\n	                                }\n	                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},\n	          function(hname, hvalue) {\n	                                hname = hname.join('').toLowerCase();\n	                                hvalue = hvalue.join('');\n	                                if(!options.data.uri_headers) options.data.uri_headers = {};\n	                                if (!options.data.uri_headers[hname]) {\n	                                  options.data.uri_headers[hname] = [hvalue];\n	                                } else {\n	                                  options.data.uri_headers[hname].push(hvalue);\n	                                }},\n	          function() {\n	                                // lots of tests fail if this isn't guarded...\n	                                if (options.startRule === 'Refer_To') {\n	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n	                                  delete options.data.scheme;\n	                                  delete options.data.user;\n	                                  delete options.data.host;\n	                                  delete options.data.host_type;\n	                                  delete options.data.port;\n	                                  delete options.data.uri_params;\n	                                }\n	                              },\n	          \"//\",\n	          { type: \"literal\", value: \"//\", description: \"\\\"//\\\"\" },\n	          function() {\n	                              options.data.scheme= text(); },\n	          { type: \"literal\", value: \"SIP\", description: \"\\\"SIP\\\"\" },\n	          function() {\n	                              options.data.sip_version = text(); },\n	          \"INVITE\",\n	          { type: \"literal\", value: \"INVITE\", description: \"\\\"INVITE\\\"\" },\n	          \"ACK\",\n	          { type: \"literal\", value: \"ACK\", description: \"\\\"ACK\\\"\" },\n	          \"VXACH\",\n	          { type: \"literal\", value: \"VXACH\", description: \"\\\"VXACH\\\"\" },\n	          \"OPTIONS\",\n	          { type: \"literal\", value: \"OPTIONS\", description: \"\\\"OPTIONS\\\"\" },\n	          \"BYE\",\n	          { type: \"literal\", value: \"BYE\", description: \"\\\"BYE\\\"\" },\n	          \"CANCEL\",\n	          { type: \"literal\", value: \"CANCEL\", description: \"\\\"CANCEL\\\"\" },\n	          \"REGISTER\",\n	          { type: \"literal\", value: \"REGISTER\", description: \"\\\"REGISTER\\\"\" },\n	          \"SUBSCRIBE\",\n	          { type: \"literal\", value: \"SUBSCRIBE\", description: \"\\\"SUBSCRIBE\\\"\" },\n	          \"NOTIFY\",\n	          { type: \"literal\", value: \"NOTIFY\", description: \"\\\"NOTIFY\\\"\" },\n	          \"REFER\",\n	          { type: \"literal\", value: \"REFER\", description: \"\\\"REFER\\\"\" },\n	          function() {\n	\n	                              options.data.method = text();\n	                              return options.data.method; },\n	          function(status_code) {\n	                            options.data.status_code = parseInt(status_code.join('')); },\n	          function() {\n	                            options.data.reason_phrase = text(); },\n	          function() {\n	                        options.data = text(); },\n	          function() {\n	                                  var idx, length;\n	                                  length = options.data.multi_header.length;\n	                                  for (idx = 0; idx < length; idx++) {\n	                                    if (options.data.multi_header[idx].parsed === null) {\n	                                      options.data = null;\n	                                      break;\n	                                    }\n	                                  }\n	                                  if (options.data !== null) {\n	                                    options.data = options.data.multi_header;\n	                                  } else {\n	                                    options.data = -1;\n	                                  }},\n	          function() {\n	                                  var header;\n	                                  if(!options.data.multi_header) options.data.multi_header = [];\n	                                  try {\n	                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                                    delete options.data.uri;\n	                                    delete options.data.displayName;\n	                                    delete options.data.params;\n	                                  } catch(e) {\n	                                    header = null;\n	                                  }\n	                                  options.data.multi_header.push( { 'position': peg$currPos,\n	                                                            'offset': offset(),\n	                                                            'parsed': header\n	                                                          });},\n	          function(displayName) {\n	                                  displayName = text().trim();\n	                                  if (displayName[0] === '\\\"') {\n	                                    displayName = displayName.substring(1, displayName.length-1);\n	                                  }\n	                                  options.data.displayName = displayName; },\n	          \"q\",\n	          { type: \"literal\", value: \"q\", description: \"\\\"q\\\"\" },\n	          function(q) {\n	                                  if(!options.data.params) options.data.params = {};\n	                                  options.data.params['q'] = q; },\n	          \"expires\",\n	          { type: \"literal\", value: \"expires\", description: \"\\\"expires\\\"\" },\n	          function(expires) {\n	                                  if(!options.data.params) options.data.params = {};\n	                                  options.data.params['expires'] = expires; },\n	          function(delta_seconds) {\n	                                  return parseInt(delta_seconds.join('')); },\n	          \"0\",\n	          { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n	          function() {\n	                                  return parseFloat(text()); },\n	          function(param, value) {\n	                                  if(!options.data.params) options.data.params = {};\n	                                  if (value === null){\n	                                    value = undefined;\n	                                  }\n	                                  else {\n	                                    value = value[1];\n	                                  }\n	                                  options.data.params[param.toLowerCase()] = value;},\n	          \"render\",\n	          { type: \"literal\", value: \"render\", description: \"\\\"render\\\"\" },\n	          \"session\",\n	          { type: \"literal\", value: \"session\", description: \"\\\"session\\\"\" },\n	          \"icon\",\n	          { type: \"literal\", value: \"icon\", description: \"\\\"icon\\\"\" },\n	          \"alert\",\n	          { type: \"literal\", value: \"alert\", description: \"\\\"alert\\\"\" },\n	          function() {\n	                                      if (options.startRule === 'Content_Disposition') {\n	                                        options.data.type = text().toLowerCase();\n	                                      }\n	                                    },\n	          \"handling\",\n	          { type: \"literal\", value: \"handling\", description: \"\\\"handling\\\"\" },\n	          \"optional\",\n	          { type: \"literal\", value: \"optional\", description: \"\\\"optional\\\"\" },\n	          \"required\",\n	          { type: \"literal\", value: \"required\", description: \"\\\"required\\\"\" },\n	          function(length) {\n	                                  options.data = parseInt(length.join('')); },\n	          function() {\n	                                  options.data = text(); },\n	          \"text\",\n	          { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n	          \"image\",\n	          { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n	          \"audio\",\n	          { type: \"literal\", value: \"audio\", description: \"\\\"audio\\\"\" },\n	          \"video\",\n	          { type: \"literal\", value: \"video\", description: \"\\\"video\\\"\" },\n	          \"application\",\n	          { type: \"literal\", value: \"application\", description: \"\\\"application\\\"\" },\n	          \"message\",\n	          { type: \"literal\", value: \"message\", description: \"\\\"message\\\"\" },\n	          \"multipart\",\n	          { type: \"literal\", value: \"multipart\", description: \"\\\"multipart\\\"\" },\n	          \"x-\",\n	          { type: \"literal\", value: \"x-\", description: \"\\\"x-\\\"\" },\n	          function(cseq_value) {\n	                            options.data.value=parseInt(cseq_value.join('')); },\n	          function(expires) {options.data = expires; },\n	          function(event_type) {\n	                                 options.data.event = event_type.toLowerCase(); },\n	          function() {\n	                          var tag = options.data.tag;\n	                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                            if (tag) {options.data.setParam('tag',tag)}\n	                          },\n	          \"tag\",\n	          { type: \"literal\", value: \"tag\", description: \"\\\"tag\\\"\" },\n	          function(tag) {options.data.tag = tag; },\n	          function(forwards) {\n	                            options.data = parseInt(forwards.join('')); },\n	          function(min_expires) {options.data = min_expires; },\n	          function() {\n	                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                                },\n	          \"digest\",\n	          { type: \"literal\", value: \"Digest\", description: \"\\\"Digest\\\"\" },\n	          \"realm\",\n	          { type: \"literal\", value: \"realm\", description: \"\\\"realm\\\"\" },\n	          function(realm) { options.data.realm = realm; },\n	          \"domain\",\n	          { type: \"literal\", value: \"domain\", description: \"\\\"domain\\\"\" },\n	          \"nonce\",\n	          { type: \"literal\", value: \"nonce\", description: \"\\\"nonce\\\"\" },\n	          function(nonce) { options.data.nonce=nonce; },\n	          \"opaque\",\n	          { type: \"literal\", value: \"opaque\", description: \"\\\"opaque\\\"\" },\n	          function(opaque) { options.data.opaque=opaque; },\n	          \"stale\",\n	          { type: \"literal\", value: \"stale\", description: \"\\\"stale\\\"\" },\n	          \"true\",\n	          { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\n	          function() { options.data.stale=true; },\n	          \"false\",\n	          { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\n	          function() { options.data.stale=false; },\n	          \"algorithm\",\n	          { type: \"literal\", value: \"algorithm\", description: \"\\\"algorithm\\\"\" },\n	          \"md5\",\n	          { type: \"literal\", value: \"MD5\", description: \"\\\"MD5\\\"\" },\n	          \"md5-sess\",\n	          { type: \"literal\", value: \"MD5-sess\", description: \"\\\"MD5-sess\\\"\" },\n	          function(algorithm) {\n	                                options.data.algorithm=algorithm.toUpperCase(); },\n	          \"qop\",\n	          { type: \"literal\", value: \"qop\", description: \"\\\"qop\\\"\" },\n	          \"auth-int\",\n	          { type: \"literal\", value: \"auth-int\", description: \"\\\"auth-int\\\"\" },\n	          \"auth\",\n	          { type: \"literal\", value: \"auth\", description: \"\\\"auth\\\"\" },\n	          function(qop_value) {\n	                                  options.data.qop || (options.data.qop=[]);\n	                                  options.data.qop.push(qop_value.toLowerCase()); },\n	          function(rack_value) {\n	                            options.data.value=parseInt(rack_value.join('')); },\n	          function() {\n	                            var idx, length;\n	                            length = options.data.multi_header.length;\n	                            for (idx = 0; idx < length; idx++) {\n	                              if (options.data.multi_header[idx].parsed === null) {\n	                                options.data = null;\n	                                break;\n	                              }\n	                            }\n	                            if (options.data !== null) {\n	                              options.data = options.data.multi_header;\n	                            } else {\n	                              options.data = -1;\n	                            }},\n	          function() {\n	                            var header;\n	                            if(!options.data.multi_header) options.data.multi_header = [];\n	                            try {\n	                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                              delete options.data.uri;\n	                              delete options.data.displayName;\n	                              delete options.data.params;\n	                            } catch(e) {\n	                              header = null;\n	                            }\n	                            options.data.multi_header.push( { 'position': peg$currPos,\n	                                                      'offset': offset(),\n	                                                      'parsed': header\n	                                                    });},\n	          function() {\n	                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                      },\n	          function() {\n	                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {\n	                                  options.data = -1;\n	                                }\n	                              },\n	          function() {\n	                                options.data = {\n	                                  call_id: options.data\n	                                };\n	                              },\n	          \"from-tag\",\n	          { type: \"literal\", value: \"from-tag\", description: \"\\\"from-tag\\\"\" },\n	          function(from_tag) {\n	                                options.data.replaces_from_tag = from_tag;\n	                              },\n	          \"to-tag\",\n	          { type: \"literal\", value: \"to-tag\", description: \"\\\"to-tag\\\"\" },\n	          function(to_tag) {\n	                                options.data.replaces_to_tag = to_tag;\n	                              },\n	          \"early-only\",\n	          { type: \"literal\", value: \"early-only\", description: \"\\\"early-only\\\"\" },\n	          function() {\n	                                options.data.early_only = true;\n	                              },\n	          function(r) {return r;},\n	          function(first, rest) { return list(first, rest); },\n	          function(value) {\n	                          if (options.startRule === 'Require') {\n	                            options.data = value || [];\n	                          }\n	                        },\n	          function(rseq_value) {\n	                            options.data.value=parseInt(rseq_value.join('')); },\n	          \"active\",\n	          { type: \"literal\", value: \"active\", description: \"\\\"active\\\"\" },\n	          \"pending\",\n	          { type: \"literal\", value: \"pending\", description: \"\\\"pending\\\"\" },\n	          \"terminated\",\n	          { type: \"literal\", value: \"terminated\", description: \"\\\"terminated\\\"\" },\n	          function() {\n	                                  options.data.state = text(); },\n	          \"reason\",\n	          { type: \"literal\", value: \"reason\", description: \"\\\"reason\\\"\" },\n	          function(reason) {\n	                                  if (typeof reason !== 'undefined') options.data.reason = reason; },\n	          function(expires) {\n	                                  if (typeof expires !== 'undefined') options.data.expires = expires; },\n	          \"retry_after\",\n	          { type: \"literal\", value: \"retry_after\", description: \"\\\"retry_after\\\"\" },\n	          function(retry_after) {\n	                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },\n	          \"deactivated\",\n	          { type: \"literal\", value: \"deactivated\", description: \"\\\"deactivated\\\"\" },\n	          \"probation\",\n	          { type: \"literal\", value: \"probation\", description: \"\\\"probation\\\"\" },\n	          \"rejected\",\n	          { type: \"literal\", value: \"rejected\", description: \"\\\"rejected\\\"\" },\n	          \"timeout\",\n	          { type: \"literal\", value: \"timeout\", description: \"\\\"timeout\\\"\" },\n	          \"giveup\",\n	          { type: \"literal\", value: \"giveup\", description: \"\\\"giveup\\\"\" },\n	          \"noresource\",\n	          { type: \"literal\", value: \"noresource\", description: \"\\\"noresource\\\"\" },\n	          \"invariant\",\n	          { type: \"literal\", value: \"invariant\", description: \"\\\"invariant\\\"\" },\n	          function(value) {\n	                          if (options.startRule === 'Supported') {\n	                            options.data = value || [];\n	                          }\n	                        },\n	          function() {\n	                        var tag = options.data.tag;\n	                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                          if (tag) {options.data.setParam('tag',tag)}\n	                        },\n	          \"ttl\",\n	          { type: \"literal\", value: \"ttl\", description: \"\\\"ttl\\\"\" },\n	          function(via_ttl_value) {\n	                                options.data.ttl = via_ttl_value; },\n	          \"maddr\",\n	          { type: \"literal\", value: \"maddr\", description: \"\\\"maddr\\\"\" },\n	          function(via_maddr) {\n	                                options.data.maddr = via_maddr; },\n	          \"received\",\n	          { type: \"literal\", value: \"received\", description: \"\\\"received\\\"\" },\n	          function(via_received) {\n	                                options.data.received = via_received; },\n	          \"branch\",\n	          { type: \"literal\", value: \"branch\", description: \"\\\"branch\\\"\" },\n	          function(via_branch) {\n	                                options.data.branch = via_branch; },\n	          \"rport\",\n	          { type: \"literal\", value: \"rport\", description: \"\\\"rport\\\"\" },\n	          function() {\n	                                if(typeof response_port !== 'undefined')\n	                                  options.data.rport = response_port.join(''); },\n	          function(via_protocol) {\n	                                options.data.protocol = via_protocol; },\n	          { type: \"literal\", value: \"UDP\", description: \"\\\"UDP\\\"\" },\n	          { type: \"literal\", value: \"TCP\", description: \"\\\"TCP\\\"\" },\n	          { type: \"literal\", value: \"TLS\", description: \"\\\"TLS\\\"\" },\n	          { type: \"literal\", value: \"SCTP\", description: \"\\\"SCTP\\\"\" },\n	          function(via_transport) {\n	                                options.data.transport = via_transport; },\n	          function() {\n	                                options.data.host = text(); },\n	          function(via_sent_by_port) {\n	                                options.data.port = parseInt(via_sent_by_port.join('')); },\n	          function(ttl) {\n	                                return parseInt(ttl.join('')); },\n	          function(deltaSeconds) {\n	                                if (options.startRule === 'Session_Expires') {\n	                                  options.data.deltaSeconds = deltaSeconds;\n	                                }\n	                              },\n	          \"refresher\",\n	          { type: \"literal\", value: \"refresher\", description: \"\\\"refresher\\\"\" },\n	          \"uas\",\n	          { type: \"literal\", value: \"uas\", description: \"\\\"uas\\\"\" },\n	          \"uac\",\n	          { type: \"literal\", value: \"uac\", description: \"\\\"uac\\\"\" },\n	          function(endpoint) {\n	                                if (options.startRule === 'Session_Expires') {\n	                                  options.data.refresher = endpoint;\n	                                }\n	                              },\n	          function(deltaSeconds) {\n	                                if (options.startRule === 'Min_SE') {\n	                                  options.data = deltaSeconds;\n	                                }\n	                              },\n	          \"stuns\",\n	          { type: \"literal\", value: \"stuns\", description: \"\\\"stuns\\\"\" },\n	          \"stun\",\n	          { type: \"literal\", value: \"stun\", description: \"\\\"stun\\\"\" },\n	          function(scheme) {\n	                                options.data.scheme = scheme; },\n	          function(host) {\n	                                options.data.host = host; },\n	          \"?transport=\",\n	          { type: \"literal\", value: \"?transport=\", description: \"\\\"?transport=\\\"\" },\n	          \"turns\",\n	          { type: \"literal\", value: \"turns\", description: \"\\\"turns\\\"\" },\n	          \"turn\",\n	          { type: \"literal\", value: \"turn\", description: \"\\\"turn\\\"\" },\n	          function() {\n	                                options.data.transport = transport; },\n	          function() {\n	                            options.data = text(); }\n	        ],\n	\n	        peg$bytecode = [\n	          peg$decode(\". \\\"\\\"2 3!\"),\n	          peg$decode(\"0\\\"\\\"\\\"1!3#\"),\n	          peg$decode(\"0$\\\"\\\"1!3%\"),\n	          peg$decode(\"0&\\\"\\\"1!3'\"),\n	          peg$decode(\"7'*# \\\"7(\"),\n	          peg$decode(\"0(\\\"\\\"1!3)\"),\n	          peg$decode(\"0*\\\"\\\"1!3+\"),\n	          peg$decode(\".,\\\"\\\"2,3-\"),\n	          peg$decode(\"..\\\"\\\"2.3/\"),\n	          peg$decode(\"00\\\"\\\"1!31\"),\n	          peg$decode(\".2\\\"\\\"2233*\\x89 \\\".4\\\"\\\"2435*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n	          peg$decode(\"7)*# \\\"7,\"),\n	          peg$decode(\".F\\\"\\\"2F3G*} \\\".H\\\"\\\"2H3I*q \\\".J\\\"\\\"2J3K*e \\\".L\\\"\\\"2L3M*Y \\\".N\\\"\\\"2N3O*M \\\".P\\\"\\\"2P3Q*A \\\".R\\\"\\\"2R3S*5 \\\".T\\\"\\\"2T3U*) \\\".V\\\"\\\"2V3W\"),\n	          peg$decode(\"!!.Y\\\"\\\"2Y3Z+7$7#+-%7#+#%'#%$## X$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"!! \\\\7$,#&7$\\\"+-$7 +#%'\\\"%$\\\"# X\\\"# X*# \\\" [+@$ \\\\7$+&$,#&7$\\\"\\\"\\\" X+'%4\\\"6]\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7.*# \\\" [\"),\n	          peg$decode(\"! \\\\7'*# \\\"7(,)&7'*# \\\"7(\\\"+A$.8\\\"\\\"2839+1%7/+'%4#6^# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!! \\\\72+&$,#&72\\\"\\\"\\\" X+o$ \\\\! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X,@&! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"0_\\\"\\\"1!3`*# \\\"73\"),\n	          peg$decode(\"0a\\\"\\\"1!3b\"),\n	          peg$decode(\"0c\\\"\\\"1!3d\"),\n	          peg$decode(\"7!*) \\\"0e\\\"\\\"1!3f\"),\n	          peg$decode(\"! \\\\7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x9E$,\\x9B&7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"! \\\\7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x92$,\\x8F&7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\".T\\\"\\\"2T3U*\\xE3 \\\".V\\\"\\\"2V3W*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".k\\\"\\\"2k3l*\\xBF \\\".:\\\"\\\"2:3;*\\xB3 \\\".D\\\"\\\"2D3E*\\xA7 \\\".2\\\"\\\"2233*\\x9B \\\".8\\\"\\\"2839*\\x8F \\\".m\\\"\\\"2m3n*\\x83 \\\"7&*} \\\".4\\\"\\\"2435*q \\\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".6\\\"\\\"2637*M \\\".>\\\"\\\"2>3?*A \\\".s\\\"\\\"2s3t*5 \\\".u\\\"\\\"2u3v*) \\\"7'*# \\\"7(\"),\n	          peg$decode(\"! \\\\7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v+\\u0134$,\\u0131&7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"!7/+A$.P\\\"\\\"2P3Q+1%7/+'%4#6w# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.4\\\"\\\"2435+1%7/+'%4#6x# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.>\\\"\\\"2>3?+1%7/+'%4#6y# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.T\\\"\\\"2T3U+1%7/+'%4#6z# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.V\\\"\\\"2V3W+1%7/+'%4#6{# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.k\\\"\\\"2k3l+1$7/+'%4\\\"6|\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+7$.i\\\"\\\"2i3j+'%4\\\"6}\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.D\\\"\\\"2D3E+1%7/+'%4#6~# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.2\\\"\\\"2233+1%7/+'%4#6# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.8\\\"\\\"2839+1%7/+'%4#6\\x80# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+1$7&+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7&+1$7/+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7=+W$ \\\\7G*) \\\"7K*# \\\"7F,/&7G*) \\\"7K*# \\\"7F\\\"+-%7>+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"0\\x82\\\"\\\"1!3\\x83*A \\\"0\\x84\\\"\\\"1!3\\x85*5 \\\"0\\x86\\\"\\\"1!3\\x87*) \\\"73*# \\\"7.\"),\n	          peg$decode(\"!!7/+U$7&+K% \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+-%7&+#%'$%$$# X$## X$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"!7/+`$7&+V%! \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+! (%+2%7&+(%4$6\\x88$!!%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7.*G \\\".L\\\"\\\"2L3M*; \\\"0\\x89\\\"\\\"1!3\\x8A*/ \\\"0\\x86\\\"\\\"1!3\\x87*# \\\"73\"),\n	          peg$decode(\"!.m\\\"\\\"2m3n+K$0\\x8B\\\"\\\"1!3\\x8C*5 \\\"0\\x8D\\\"\\\"1!3\\x8E*) \\\"0\\x8F\\\"\\\"1!3\\x90+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7N+Q$.8\\\"\\\"2839+A%7O*# \\\" [+1%7S+'%4$6\\x91$ %$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7N+k$.8\\\"\\\"2839+[%7O*# \\\" [+K%7S+A%7_+7%7l*# \\\" [+'%4&6\\x92& %$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\x93\\\"\\\"1$3\\x94*) \\\"/\\x95\\\"\\\"1#3\\x96+' 4!6\\x97!! %\"),\n	          peg$decode(\"!7P+b$!.8\\\"\\\"2839+-$7R+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+7%.:\\\"\\\"2:3;+'%4#6\\x98# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\7+*) \\\"7-*# \\\"7Q+2$,/&7+*) \\\"7-*# \\\"7Q\\\"\\\"\\\" X\"),\n	          peg$decode(\".<\\\"\\\"2<3=*q \\\".>\\\"\\\"2>3?*e \\\".@\\\"\\\"2@3A*Y \\\".B\\\"\\\"2B3C*M \\\".D\\\"\\\"2D3E*A \\\".2\\\"\\\"2233*5 \\\".6\\\"\\\"2637*) \\\".4\\\"\\\"2435\"),\n	          peg$decode(\"! \\\\7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E,e&7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\\\"+& 4!6\\x99! %\"),\n	          peg$decode(\"!7T+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\x9A! %\"),\n	          peg$decode(\"! \\\\!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X,>&!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X\\\"+G$7W+=%.J\\\"\\\"2J3K*# \\\" [+'%4#6\\x9B# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\0\\x9C\\\"\\\"1!3\\x9D+,$,)&0\\x9C\\\"\\\"1!3\\x9D\\\"\\\"\\\" X\"),\n	          peg$decode(\"!0$\\\"\\\"1!3%+A$ \\\\0\\x9E\\\"\\\"1!3\\x9F,)&0\\x9E\\\"\\\"1!3\\x9F\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.o\\\"\\\"2o3p+A$7Y+7%.q\\\"\\\"2q3r+'%4#6\\xA0# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!!7Z+\\xBF$.8\\\"\\\"2839+\\xAF%7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0838 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\xAF$7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0795 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95$7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u070C \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+{$7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u069D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+a$7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0648 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+G$7Z+=%.8\\\"\\\"2839+-%7[+#%'$%$$# X$## X$\\\"# X\\\"# X*\\u060D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7[+#%'\\\"%$\\\"# X\\\"# X*\\u05EC \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7Z+#%'\\\"%$\\\"# X\\\"# X*\\u05CB \\\"!7Z+\\xA5$.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0538 \\\"!7Z+\\xB6$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x8B%.\\xA1\\\"\\\"2\\xA13\\xA2+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0494 \\\"!7Z+\\xC7$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x9C%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+q%.\\xA1\\\"\\\"2\\xA13\\xA2+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u03DF \\\"!7Z+\\xD8$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xAD%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x82%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+W%.\\xA1\\\"\\\"2\\xA13\\xA2+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0319 \\\"!7Z+\\xE9$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0242 \\\"!7Z+\\u0114$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xE9%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0140 \\\"!7Z+\\u0135$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\u010A%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xDF%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xB4%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x89%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+^%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+3%.\\xA1\\\"\\\"2\\xA13\\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X+& 4!6\\xA3! %\"),\n	          peg$decode(\"!7#+S$7#*# \\\" [+C%7#*# \\\" [+3%7#*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7Z+=$.8\\\"\\\"2839+-%7Z+#%'#%$## X$\\\"# X\\\"# X*# \\\"7\\\\\"),\n	          peg$decode(\"!7]+u$.J\\\"\\\"2J3K+e%7]+[%.J\\\"\\\"2J3K+K%7]+A%.J\\\"\\\"2J3K+1%7]+'%4'6\\xA4' %$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.\\xA5\\\"\\\"2\\xA53\\xA6+3$0\\xA7\\\"\\\"1!3\\xA8+#%'\\\"%$\\\"# X\\\"# X*\\xA0 \\\"!.\\xA9\\\"\\\"2\\xA93\\xAA+=$0\\xAB\\\"\\\"1!3\\xAC+-%7!+#%'#%$## X$\\\"# X\\\"# X*o \\\"!.\\xAD\\\"\\\"2\\xAD3\\xAE+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X*D \\\"!0\\xAF\\\"\\\"1!3\\xB0+-$7!+#%'\\\"%$\\\"# X\\\"# X*# \\\"7!\"),\n	          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\xB1!! %\"),\n	          peg$decode(\" \\\\!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X\\\"\"),\n	          peg$decode(\"7a*A \\\"7b*; \\\"7c*5 \\\"7d*/ \\\"7e*) \\\"7f*# \\\"7g\"),\n	          peg$decode(\"!/\\xB2\\\"\\\"1*3\\xB3+b$/\\xB4\\\"\\\"1#3\\xB5*G \\\"/\\xB6\\\"\\\"1#3\\xB7*; \\\"/\\xB8\\\"\\\"1$3\\xB9*/ \\\"/\\xBA\\\"\\\"1#3\\xBB*# \\\"76+(%4\\\"6\\xBC\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xBD\\\"\\\"1%3\\xBE+J$/\\xBF\\\"\\\"1%3\\xC0*/ \\\"/\\xC1\\\"\\\"1\\\"3\\xC2*# \\\"76+(%4\\\"6\\xC3\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xC4\\\"\\\"1'3\\xC5+2$7\\x8F+(%4\\\"6\\xC6\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xC7\\\"\\\"1$3\\xC8+2$7\\xEF+(%4\\\"6\\xC9\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xCA\\\"\\\"1&3\\xCB+2$7T+(%4\\\"6\\xCC\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xCD\\\"\\\"1\\\"3\\xCE+R$!.>\\\"\\\"2>3?+-$76+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xCF\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7h+T$!.>\\\"\\\"2>3?+-$7i+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xD0\\\"\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"7k*) \\\"7+*# \\\"7-\"),\n	          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".8\\\"\\\"2839*A \\\".<\\\"\\\"2<3=*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n	          peg$decode(\"!.6\\\"\\\"2637+u$7m+k% \\\\!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X,>&!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7n+C$.>\\\"\\\"2>3?+3%7o+)%4#6\\xD1#\\\"\\\" %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-+2$,/&7p*) \\\"7+*# \\\"7-\\\"\\\"\\\" X\"),\n	          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-,/&7p*) \\\"7+*# \\\"7-\\\"\"),\n	          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".6\\\"\\\"2637*A \\\".8\\\"\\\"2839*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n	          peg$decode(\"7\\x90*# \\\"7r\"),\n	          peg$decode(\"!7\\x8F+K$7'+A%7s+7%7'+-%7\\x84+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7M*# \\\"7t\"),\n	          peg$decode(\"!7+G$.8\\\"\\\"2839+7%7u*# \\\"7x+'%4#6\\xD2# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7v*# \\\"7w+N$!.6\\\"\\\"2637+-$7\\x83+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.\\xD3\\\"\\\"2\\xD33\\xD4+=$7\\x80+3%7w*# \\\" [+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.4\\\"\\\"2435+-$7{+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7z+5$ \\\\7y,#&7y\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"7**) \\\"7+*# \\\"7-\"),\n	          peg$decode(\"7+*\\x8F \\\"7-*\\x89 \\\".2\\\"\\\"2233*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n	          peg$decode(\"!7|+k$ \\\\!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X,>&!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7~,#&7~\\\"+k$ \\\\!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\7~,#&7~\\\"\"),\n	          peg$decode(\"7+*w \\\"7-*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n	          peg$decode(\"!7\\\"+\\x8D$ \\\\7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K,M&7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K\\\"+'%4\\\"6\\xD5\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\x81*# \\\"7\\x82\"),\n	          peg$decode(\"!!7O+3$.:\\\"\\\"2:3;+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+-$7S+#%'\\\"%$\\\"# X\\\"# X*# \\\" [\"),\n	          peg$decode(\" \\\\7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A+\\x8C$,\\x89&7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A\\\"\\\"\\\" X\"),\n	          peg$decode(\" \\\\7y,#&7y\\\"\"),\n	          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6+y$.4\\\"\\\"2435+i% \\\\7!+&$,#&7!\\\"\\\"\\\" X+P%.J\\\"\\\"2J3K+@% \\\\7!+&$,#&7!\\\"\\\"\\\" X+'%4%6\\xD7% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\".\\xD8\\\"\\\"2\\xD83\\xD9\"),\n	          peg$decode(\".\\xDA\\\"\\\"2\\xDA3\\xDB\"),\n	          peg$decode(\".\\xDC\\\"\\\"2\\xDC3\\xDD\"),\n	          peg$decode(\".\\xDE\\\"\\\"2\\xDE3\\xDF\"),\n	          peg$decode(\".\\xE0\\\"\\\"2\\xE03\\xE1\"),\n	          peg$decode(\".\\xE2\\\"\\\"2\\xE23\\xE3\"),\n	          peg$decode(\".\\xE4\\\"\\\"2\\xE43\\xE5\"),\n	          peg$decode(\".\\xE6\\\"\\\"2\\xE63\\xE7\"),\n	          peg$decode(\".\\xE8\\\"\\\"2\\xE83\\xE9\"),\n	          peg$decode(\".\\xEA\\\"\\\"2\\xEA3\\xEB\"),\n	          peg$decode(\"!7\\x85*S \\\"7\\x86*M \\\"7\\x88*G \\\"7\\x89*A \\\"7\\x8A*; \\\"7\\x8B*5 \\\"7\\x8C*/ \\\"7\\x8D*) \\\"7\\x8E*# \\\"76+& 4!6\\xEC! %\"),\n	          peg$decode(\"!7\\x84+K$7'+A%7\\x91+7%7'+-%7\\x93+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x92+' 4!6\\xED!! %\"),\n	          peg$decode(\"!7!+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(,G&7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(\\\"+& 4!6\\xEE! %\"),\n	          peg$decode(\"!7\\xB5+_$ \\\\!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!79+R$!.:\\\"\\\"2:3;+-$79+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xEF\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7:*j \\\"!7\\x97+_$ \\\\!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+& 4!6\\xF0! %\"),\n	          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\xF1\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x99*# \\\" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!!76+_$ \\\\!7.+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7.+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\"7H+' 4!6\\xF2!! %\"),\n	          peg$decode(\"7\\x9B*) \\\"7\\x9C*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\xF3\\\"\\\"1!3\\xF4+<$7<+2%7\\x9E+(%4#6\\xF5#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\xF8#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\xF9!! %\"),\n	          peg$decode(\"!.\\xFA\\\"\\\"2\\xFA3\\xFB+x$!.J\\\"\\\"2J3K+S$7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xFC\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+N$!7<+-$7\\xA0+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xFD\\\"\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"76*) \\\"7T*# \\\"7H\"),\n	          peg$decode(\"!7\\xA2+_$ \\\\!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xFE\\\"\\\"1&3\\xFF*G \\\"/\\u0100\\\"\\\"1'3\\u0101*; \\\"/\\u0102\\\"\\\"1$3\\u0103*/ \\\"/\\u0104\\\"\\\"1%3\\u0105*# \\\"76+& 4!6\\u0106! %\"),\n	          peg$decode(\"7\\xA4*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\u0107\\\"\\\"1(3\\u0108+O$7<+E%/\\u0109\\\"\\\"1(3\\u010A*/ \\\"/\\u010B\\\"\\\"1(3\\u010C*# \\\"76+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u010D!! %\"),\n	          peg$decode(\"!7\\xA8+& 4!6\\u010E! %\"),\n	          peg$decode(\"!7\\xA9+s$7;+i%7\\xAE+_% \\\\!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xAA*# \\\"7\\xAB\"),\n	          peg$decode(\"/\\u010F\\\"\\\"1$3\\u0110*S \\\"/\\u0111\\\"\\\"1%3\\u0112*G \\\"/\\u0113\\\"\\\"1%3\\u0114*; \\\"/\\u0115\\\"\\\"1%3\\u0116*/ \\\"/\\u0117\\\"\\\"1+3\\u0118*# \\\"7\\xAC\"),\n	          peg$decode(\"/\\u0119\\\"\\\"1'3\\u011A*/ \\\"/\\u011B\\\"\\\"1)3\\u011C*# \\\"7\\xAC\"),\n	          peg$decode(\"76*# \\\"7\\xAD\"),\n	          peg$decode(\"!/\\u011D\\\"\\\"1\\\"3\\u011E+-$76+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xAC*# \\\"76\"),\n	          peg$decode(\"!76+7$7<+-%7\\xB0+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"76*# \\\"7H\"),\n	          peg$decode(\"!7\\xB2+7$7.+-%7\\x8F+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u011F!! %\"),\n	          peg$decode(\"!7\\x9D+' 4!6\\u0120!! %\"),\n	          peg$decode(\"!7\\xB5+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0121\\\"!!%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!!77+k$ \\\\!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X,>&!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0122\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\u0123\\\"\\\"1#3\\u0124+<$7<+2%76+(%4#6\\u0125#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0126!! %\"),\n	          peg$decode(\"!7\\x9D+' 4!6\\u0127!! %\"),\n	          peg$decode(\"! \\\\7\\x99,#&7\\x99\\\"+\\x81$7@+w%7M+m%7?+c% \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4%6\\u0128% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xBD\"),\n	          peg$decode(\"!/\\u0129\\\"\\\"1&3\\u012A+s$7.+i%7\\xC0+_% \\\\!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\"7\\xBE\"),\n	          peg$decode(\"!76+s$7.+i%7\\xBF+_% \\\\!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+=$7<+3%76*# \\\"7H+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xC1*G \\\"7\\xC3*A \\\"7\\xC5*; \\\"7\\xC7*5 \\\"7\\xC8*/ \\\"7\\xC9*) \\\"7\\xCA*# \\\"7\\xBF\"),\n	          peg$decode(\"!/\\u012B\\\"\\\"1%3\\u012C+7$7<+-%7\\xC2+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7I+' 4!6\\u012D!! %\"),\n	          peg$decode(\"!/\\u012E\\\"\\\"1&3\\u012F+\\xA5$7<+\\x9B%7D+\\x91%7\\xC4+\\x87% \\\\! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X,G&! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X\\\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7t*# \\\"7w\"),\n	          peg$decode(\"!/\\u0130\\\"\\\"1%3\\u0131+7$7<+-%7\\xC6+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7I+' 4!6\\u0132!! %\"),\n	          peg$decode(\"!/\\u0133\\\"\\\"1&3\\u0134+<$7<+2%7I+(%4#6\\u0135#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0136\\\"\\\"1%3\\u0137+_$7<+U%!/\\u0138\\\"\\\"1$3\\u0139+& 4!6\\u013A! %*4 \\\"!/\\u013B\\\"\\\"1%3\\u013C+& 4!6\\u013D! %+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u013E\\\"\\\"1)3\\u013F+T$7<+J%/\\u0140\\\"\\\"1#3\\u0141*/ \\\"/\\u0142\\\"\\\"1(3\\u0143*# \\\"76+(%4#6\\u0144#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0145\\\"\\\"1#3\\u0146+\\x9E$7<+\\x94%7D+\\x8A%!7\\xCB+k$ \\\\!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X,>&!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+-%7E+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0147\\\"\\\"1(3\\u0148*/ \\\"/\\u0149\\\"\\\"1$3\\u014A*# \\\"76+' 4!6\\u014B!! %\"),\n	          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xCE+K$7.+A%7\\xCE+7%7.+-%7\\x8F+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u014C!! %\"),\n	          peg$decode(\"!7\\xD0+c$ \\\\!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014D\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x98+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014E\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7L*T \\\"7\\x98*N \\\"!7@*# \\\" [+=$7t+3%7?*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014F\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xD3+c$ \\\\!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0150\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x95+& 4!6\\u0151! %\"),\n	          peg$decode(\"!/\\u0152\\\"\\\"1(3\\u0153+<$7<+2%76+(%4#6\\u0154#! %$## X$\\\"# X\\\"# X*j \\\"!/\\u0155\\\"\\\"1&3\\u0156+<$7<+2%76+(%4#6\\u0157#! %$## X$\\\"# X\\\"# X*: \\\"!/\\u0158\\\"\\\"1*3\\u0159+& 4!6\\u015A! %*# \\\"7\\x9F\"),\n	          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u015D!! %\"),\n	          peg$decode(\"!7\\xD7+_$ \\\\!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x98+_$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u015E!! %\"),\n	          peg$decode(\"!7\\xDA+_$ \\\\!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u015F\\\"\\\"1&3\\u0160*; \\\"/\\u0161\\\"\\\"1'3\\u0162*/ \\\"/\\u0163\\\"\\\"1*3\\u0164*# \\\"76+& 4!6\\u0165! %\"),\n	          peg$decode(\"!/\\u0166\\\"\\\"1&3\\u0167+<$7<+2%7\\xDC+(%4#6\\u0168#! %$## X$\\\"# X\\\"# X*\\x83 \\\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\u0169#! %$## X$\\\"# X\\\"# X*S \\\"!/\\u016A\\\"\\\"1+3\\u016B+<$7<+2%7\\x9D+(%4#6\\u016C#! %$## X$\\\"# X\\\"# X*# \\\"7\\x9F\"),\n	          peg$decode(\"/\\u016D\\\"\\\"1+3\\u016E*k \\\"/\\u016F\\\"\\\"1)3\\u0170*_ \\\"/\\u0171\\\"\\\"1(3\\u0172*S \\\"/\\u0173\\\"\\\"1'3\\u0174*G \\\"/\\u0175\\\"\\\"1&3\\u0176*; \\\"/\\u0177\\\"\\\"1*3\\u0178*/ \\\"/\\u0179\\\"\\\"1)3\\u017A*# \\\"76\"),\n	          peg$decode(\"71*# \\\" [\"),\n	          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u017B!! %\"),\n	          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u017C\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n	          peg$decode(\"!7\\xE2+_$ \\\\!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xE9+s$7.+i%7\\xEC+_% \\\\!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xE4*; \\\"7\\xE5*5 \\\"7\\xE6*/ \\\"7\\xE7*) \\\"7\\xE8*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\u017D\\\"\\\"1#3\\u017E+<$7<+2%7\\xEF+(%4#6\\u017F#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0180\\\"\\\"1%3\\u0181+<$7<+2%7T+(%4#6\\u0182#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0183\\\"\\\"1(3\\u0184+B$7<+8%7\\\\*# \\\"7Y+(%4#6\\u0185#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0186\\\"\\\"1&3\\u0187+<$7<+2%76+(%4#6\\u0188#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0189\\\"\\\"1%3\\u018A+T$!7<+5$ \\\\7!,#&7!\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\u018B\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xEA+K$7;+A%76+7%7;+-%7\\xEB+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6*# \\\"76+' 4!6\\u018C!! %\"),\n	          peg$decode(\"!/\\xB4\\\"\\\"1#3\\u018D*G \\\"/\\xB6\\\"\\\"1#3\\u018E*; \\\"/\\xBA\\\"\\\"1#3\\u018F*/ \\\"/\\xB8\\\"\\\"1$3\\u0190*# \\\"76+' 4!6\\u0191!! %\"),\n	          peg$decode(\"!7\\xED+H$!7C+-$7\\xEE+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\u0192! %\"),\n	          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\u0193!! %\"),\n	          peg$decode(\"!!7!+C$7!*# \\\" [+3%7!*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+' 4!6\\u0194!! %\"),\n	          peg$decode(\"7\\xBD\"),\n	          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0195\\\"!!%$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xF3*# \\\"7\\x9F\"),\n	          peg$decode(\"!.\\u0196\\\"\\\"2\\u01963\\u0197+N$7<+D%.\\u0198\\\"\\\"2\\u01983\\u0199*) \\\".\\u019A\\\"\\\"2\\u019A3\\u019B+(%4#6\\u019C#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u019D\\\"!!%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+7$70+-%7\\xF6+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\72*) \\\"74*# \\\"7.,/&72*) \\\"74*# \\\"7.\\\"\"),\n	          peg$decode(\" \\\\7%,#&7%\\\"\"),\n	          peg$decode(\"!7\\xF9+=$.8\\\"\\\"2839+-%7\\xFA+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u019E\\\"\\\"1%3\\u019F*) \\\"/\\u01A0\\\"\\\"1$3\\u01A1+' 4!6\\u01A2!! %\"),\n	          peg$decode(\"!7\\xFB+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\\\*) \\\"7X*# \\\"7\\x82+' 4!6\\u01A3!! %\"),\n	          peg$decode(\"! \\\\7\\xFD*) \\\"7-*# \\\"7\\xFE,/&7\\xFD*) \\\"7-*# \\\"7\\xFE\\\"+! (%\"),\n	          peg$decode(\"7\\\"*S \\\"7!*M \\\".F\\\"\\\"2F3G*A \\\".J\\\"\\\"2J3K*5 \\\".H\\\"\\\"2H3I*) \\\".N\\\"\\\"2N3O\"),\n	          peg$decode(\".L\\\"\\\"2L3M*\\x95 \\\".B\\\"\\\"2B3C*\\x89 \\\".<\\\"\\\"2<3=*} \\\".R\\\"\\\"2R3S*q \\\".T\\\"\\\"2T3U*e \\\".V\\\"\\\"2V3W*Y \\\".P\\\"\\\"2P3Q*M \\\".@\\\"\\\"2@3A*A \\\".D\\\"\\\"2D3E*5 \\\".2\\\"\\\"2233*) \\\".>\\\"\\\"2>3?\"),\n	          peg$decode(\"!7\\u0100+h$.8\\\"\\\"2839+X%7\\xFA+N%!.\\u01A4\\\"\\\"2\\u01A43\\u01A5+-$7\\xEB+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u01A6\\\"\\\"1%3\\u01A7*) \\\"/\\u01A8\\\"\\\"1$3\\u01A9+' 4!6\\u01A2!! %\"),\n	          peg$decode(\"!7\\xEB+Q$/\\xB4\\\"\\\"1#3\\xB5*7 \\\"/\\xB6\\\"\\\"1#3\\xB7*+ \\\" \\\\7+,#&7+\\\"+'%4\\\"6\\u01AA\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\u0104+\\x8F$.F\\\"\\\"2F3G+%7\\u0103+u%.F\\\"\\\"2F3G+e%7\\u0103+[%.F\\\"\\\"2F3G+K%7\\u0103+A%.F\\\"\\\"2F3G+1%7\\u0105+'%4)6\\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\u0103+-$7\\u0103+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\u0103+7$7\\u0103+-%7\\u0103+#%'#%$## X$\\\"# X\\\"# X\")\n	        ],\n	\n	        peg$currPos          = 0,\n	        peg$reportedPos      = 0,\n	        peg$cachedPos        = 0,\n	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n	        peg$maxFailPos       = 0,\n	        peg$maxFailExpected  = [],\n	        peg$silentFails      = 0,\n	\n	        peg$result;\n	\n	    if (\"startRule\" in options) {\n	      if (!(options.startRule in peg$startRuleIndices)) {\n	        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n	      }\n	\n	      peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n	    }\n	\n	    function text() {\n	      return input.substring(peg$reportedPos, peg$currPos);\n	    }\n	\n	    function offset() {\n	      return peg$reportedPos;\n	    }\n	\n	    function line() {\n	      return peg$computePosDetails(peg$reportedPos).line;\n	    }\n	\n	    function column() {\n	      return peg$computePosDetails(peg$reportedPos).column;\n	    }\n	\n	    function expected(description) {\n	      throw peg$buildException(\n	        null,\n	        [{ type: \"other\", description: description }],\n	        peg$reportedPos\n	      );\n	    }\n	\n	    function error(message) {\n	      throw peg$buildException(message, null, peg$reportedPos);\n	    }\n	\n	    function peg$computePosDetails(pos) {\n	      function advance(details, startPos, endPos) {\n	        var p, ch;\n	\n	        for (p = startPos; p < endPos; p++) {\n	          ch = input.charAt(p);\n	          if (ch === \"\\n\") {\n	            if (!details.seenCR) { details.line++; }\n	            details.column = 1;\n	            details.seenCR = false;\n	          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n	            details.line++;\n	            details.column = 1;\n	            details.seenCR = true;\n	          } else {\n	            details.column++;\n	            details.seenCR = false;\n	          }\n	        }\n	      }\n	\n	      if (peg$cachedPos !== pos) {\n	        if (peg$cachedPos > pos) {\n	          peg$cachedPos = 0;\n	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n	        }\n	        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n	        peg$cachedPos = pos;\n	      }\n	\n	      return peg$cachedPosDetails;\n	    }\n	\n	    function peg$fail(expected) {\n	      if (peg$currPos < peg$maxFailPos) { return; }\n	\n	      if (peg$currPos > peg$maxFailPos) {\n	        peg$maxFailPos = peg$currPos;\n	        peg$maxFailExpected = [];\n	      }\n	\n	      peg$maxFailExpected.push(expected);\n	    }\n	\n	    function peg$buildException(message, expected, pos) {\n	      function cleanupExpected(expected) {\n	        var i = 1;\n	\n	        expected.sort(function(a, b) {\n	          if (a.description < b.description) {\n	            return -1;\n	          } else if (a.description > b.description) {\n	            return 1;\n	          } else {\n	            return 0;\n	          }\n	        });\n	\n	        while (i < expected.length) {\n	          if (expected[i - 1] === expected[i]) {\n	            expected.splice(i, 1);\n	          } else {\n	            i++;\n	          }\n	        }\n	      }\n	\n	      function buildMessage(expected, found) {\n	        function stringEscape(s) {\n	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n	\n	          return s\n	            .replace(/\\\\/g,   '\\\\\\\\')\n	            .replace(/\"/g,    '\\\\\"')\n	            .replace(/\\x08/g, '\\\\b')\n	            .replace(/\\t/g,   '\\\\t')\n	            .replace(/\\n/g,   '\\\\n')\n	            .replace(/\\f/g,   '\\\\f')\n	            .replace(/\\r/g,   '\\\\r')\n	            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n	            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n	            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n	            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n	        }\n	\n	        var expectedDescs = new Array(expected.length),\n	            expectedDesc, foundDesc, i;\n	\n	        for (i = 0; i < expected.length; i++) {\n	          expectedDescs[i] = expected[i].description;\n	        }\n	\n	        expectedDesc = expected.length > 1\n	          ? expectedDescs.slice(0, -1).join(\", \")\n	              + \" or \"\n	              + expectedDescs[expected.length - 1]\n	          : expectedDescs[0];\n	\n	        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n	\n	        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n	      }\n	\n	      var posDetails = peg$computePosDetails(pos),\n	          found      = pos < input.length ? input.charAt(pos) : null;\n	\n	      if (expected !== null) {\n	        cleanupExpected(expected);\n	      }\n	\n	      return new SyntaxError(\n	        message !== null ? message : buildMessage(expected, found),\n	        expected,\n	        found,\n	        pos,\n	        posDetails.line,\n	        posDetails.column\n	      );\n	    }\n	\n	    function peg$decode(s) {\n	      var bc = new Array(s.length), i;\n	\n	      for (i = 0; i < s.length; i++) {\n	        bc[i] = s.charCodeAt(i) - 32;\n	      }\n	\n	      return bc;\n	    }\n	\n	    function peg$parseRule(index) {\n	      var bc    = peg$bytecode[index],\n	          ip    = 0,\n	          ips   = [],\n	          end   = bc.length,\n	          ends  = [],\n	          stack = [],\n	          params, i;\n	\n	      function protect(object) {\n	        return Object.prototype.toString.apply(object) === \"[object Array]\" ? [] : object;\n	      }\n	\n	      while (true) {\n	        while (ip < end) {\n	          switch (bc[ip]) {\n	            case 0:\n	              stack.push(protect(peg$consts[bc[ip + 1]]));\n	              ip += 2;\n	              break;\n	\n	            case 1:\n	              stack.push(peg$currPos);\n	              ip++;\n	              break;\n	\n	            case 2:\n	              stack.pop();\n	              ip++;\n	              break;\n	\n	            case 3:\n	              peg$currPos = stack.pop();\n	              ip++;\n	              break;\n	\n	            case 4:\n	              stack.length -= bc[ip + 1];\n	              ip += 2;\n	              break;\n	\n	            case 5:\n	              stack.splice(-2, 1);\n	              ip++;\n	              break;\n	\n	            case 6:\n	              stack[stack.length - 2].push(stack.pop());\n	              ip++;\n	              break;\n	\n	            case 7:\n	              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n	              ip += 2;\n	              break;\n	\n	            case 8:\n	              stack.pop();\n	              stack.push(input.substring(stack[stack.length - 1], peg$currPos));\n	              ip++;\n	              break;\n	\n	            case 9:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (stack[stack.length - 1]) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 10:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (stack[stack.length - 1] === peg$FAILED) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 11:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (stack[stack.length - 1] !== peg$FAILED) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 12:\n	              if (stack[stack.length - 1] !== peg$FAILED) {\n	                ends.push(end);\n	                ips.push(ip);\n	\n	                end = ip + 2 + bc[ip + 1];\n	                ip += 2;\n	              } else {\n	                ip += 2 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 13:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (input.length > peg$currPos) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 14:\n	              ends.push(end);\n	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n	\n	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n	                end = ip + 4 + bc[ip + 2];\n	                ip += 4;\n	              } else {\n	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n	                ip += 4 + bc[ip + 2];\n	              }\n	\n	              break;\n	\n	            case 15:\n	              ends.push(end);\n	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n	\n	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n	                end = ip + 4 + bc[ip + 2];\n	                ip += 4;\n	              } else {\n	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n	                ip += 4 + bc[ip + 2];\n	              }\n	\n	              break;\n	\n	            case 16:\n	              ends.push(end);\n	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n	\n	              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n	                end = ip + 4 + bc[ip + 2];\n	                ip += 4;\n	              } else {\n	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n	                ip += 4 + bc[ip + 2];\n	              }\n	\n	              break;\n	\n	            case 17:\n	              stack.push(input.substr(peg$currPos, bc[ip + 1]));\n	              peg$currPos += bc[ip + 1];\n	              ip += 2;\n	              break;\n	\n	            case 18:\n	              stack.push(peg$consts[bc[ip + 1]]);\n	              peg$currPos += peg$consts[bc[ip + 1]].length;\n	              ip += 2;\n	              break;\n	\n	            case 19:\n	              stack.push(peg$FAILED);\n	              if (peg$silentFails === 0) {\n	                peg$fail(peg$consts[bc[ip + 1]]);\n	              }\n	              ip += 2;\n	              break;\n	\n	            case 20:\n	              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];\n	              ip += 2;\n	              break;\n	\n	            case 21:\n	              peg$reportedPos = peg$currPos;\n	              ip++;\n	              break;\n	\n	            case 22:\n	              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n	              for (i = 0; i < bc[ip + 3]; i++) {\n	                params[i] = stack[stack.length - 1 - params[i]];\n	              }\n	\n	              stack.splice(\n	                stack.length - bc[ip + 2],\n	                bc[ip + 2],\n	                peg$consts[bc[ip + 1]].apply(null, params)\n	              );\n	\n	              ip += 4 + bc[ip + 3];\n	              break;\n	\n	            case 23:\n	              stack.push(peg$parseRule(bc[ip + 1]));\n	              ip += 2;\n	              break;\n	\n	            case 24:\n	              peg$silentFails++;\n	              ip++;\n	              break;\n	\n	            case 25:\n	              peg$silentFails--;\n	              ip++;\n	              break;\n	\n	            default:\n	              throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n	          }\n	        }\n	\n	        if (ends.length > 0) {\n	          end = ends.pop();\n	          ip = ips.pop();\n	        } else {\n	          break;\n	        }\n	      }\n	\n	      return stack[0];\n	    }\n	\n	\n	      options.data = {}; // Object to which header attributes will be assigned during parsing\n	\n	      function list (first, rest) {\n	        return [first].concat(rest);\n	      }\n	\n	\n	    peg$result = peg$parseRule(peg$startRuleIndex);\n	\n	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n	      return peg$result;\n	    } else {\n	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n	        peg$fail({ type: \"end\", description: \"end of input\" });\n	      }\n	\n	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n	    }\n	  }\n	\n	  return {\n	    SyntaxError: SyntaxError,\n	    parse:       parse\n	  };\n	})();\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n	\n	var toplevel = global.window || global;\n	\n	function getPrefixedProperty (object, name) {\n	  if (object == null) {\n	    return;\n	  }\n	  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n	  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n	  for (var i in prefixedNames) {\n	    var property = object[prefixedNames[i]];\n	    if (property) {\n	      return property.bind(object);\n	    }\n	  }\n	}\n	\n	module.exports = {\n	  WebSocket: toplevel.WebSocket,\n	  Transport: __webpack_require__(50),\n	  open: toplevel.open,\n	  Promise: toplevel.Promise,\n	  timers: toplevel,\n	\n	  // Console is not defined in ECMAScript, so just in case...\n	  console: toplevel.console || {\n	    debug: function () {},\n	    log: function () {},\n	    warn: function () {},\n	    error: function () {}\n	  },\n	\n	  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),\n	  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),\n	  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),\n	  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),\n	\n	  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),\n	  HTMLMediaElement: toplevel.HTMLMediaElement,\n	\n	  attachMediaStream: toplevel.attachMediaStream,\n	  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,\n	  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL\n	};\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Transport\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Transport\n	 * @param {SIP.UA} ua\n	 * @param {Object} server ws_server Object\n	 */\n	module.exports = function (SIP, WebSocket) {\n	var Transport,\n	  C = {\n	    // Transport status codes\n	    STATUS_READY:        0,\n	    STATUS_DISCONNECTED: 1,\n	    STATUS_ERROR:        2\n	  };\n	\n	/**\n	 * Compute an amount of time in seconds to wait before sending another\n	 * keep-alive.\n	 * @returns {Number}\n	 */\n	function computeKeepAliveTimeout(upperBound) {\n	  var lowerBound = upperBound * 0.8;\n	  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n	}\n	\n	Transport = function(ua, server) {\n	\n	  this.logger = ua.getLogger('sip.transport');\n	  this.ua = ua;\n	  this.ws = null;\n	  this.server = server;\n	  this.reconnection_attempts = 0;\n	  this.closed = false;\n	  this.connected = false;\n	  this.reconnectTimer = null;\n	  this.lastTransportError = {};\n	\n	  this.keepAliveInterval = ua.configuration.keepAliveInterval;\n	  this.keepAliveTimeout = null;\n	  this.keepAliveTimer = null;\n	\n	  this.ua.transport = this;\n	\n	  // Connect\n	  this.connect();\n	};\n	\n	Transport.prototype = {\n	  /**\n	   * Send a message.\n	   * @param {SIP.OutgoingRequest|String} msg\n	   * @returns {Boolean}\n	   */\n	  send: function(msg) {\n	    var message = msg.toString();\n	\n	    if(this.ws && this.ws.readyState === WebSocket.OPEN) {\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n	      }\n	      this.ws.send(message);\n	      return true;\n	    } else {\n	      this.logger.warn('unable to send message, WebSocket is not open');\n	      return false;\n	    }\n	  },\n	\n	  /**\n	   * Send a keep-alive (a double-CRLF sequence).\n	   * @private\n	   * @returns {Boolean}\n	   */\n	  sendKeepAlive: function() {\n	    if(this.keepAliveTimeout) { return; }\n	\n	    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {\n	      this.ua.emit('keepAliveTimeout');\n	    }.bind(this), 10000);\n	\n	    return this.send('\\r\\n\\r\\n');\n	  },\n	\n	  /**\n	   * Start sending keep-alives.\n	   * @private\n	   */\n	  startSendingKeepAlives: function() {\n	    if (this.keepAliveInterval && !this.keepAliveTimer) {\n	      this.keepAliveTimer = SIP.Timers.setTimeout(function() {\n	        this.sendKeepAlive();\n	        this.keepAliveTimer = null;\n	        this.startSendingKeepAlives();\n	      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));\n	    }\n	  },\n	\n	  /**\n	   * Stop sending keep-alives.\n	   * @private\n	   */\n	  stopSendingKeepAlives: function() {\n	    SIP.Timers.clearTimeout(this.keepAliveTimer);\n	    SIP.Timers.clearTimeout(this.keepAliveTimeout);\n	    this.keepAliveTimer = null;\n	    this.keepAliveTimeout = null;\n	  },\n	\n	  /**\n	  * Disconnect socket.\n	  */\n	  disconnect: function() {\n	    if(this.ws) {\n	      // Clear reconnectTimer\n	      SIP.Timers.clearTimeout(this.reconnectTimer);\n	\n	      this.stopSendingKeepAlives();\n	\n	      this.closed = true;\n	      this.logger.log('closing WebSocket ' + this.server.ws_uri);\n	      this.ws.close();\n	    }\n	\n	    if (this.reconnectTimer !== null) {\n	      SIP.Timers.clearTimeout(this.reconnectTimer);\n	      this.reconnectTimer = null;\n	      this.ua.emit('disconnected', {\n	        transport: this,\n	        code: this.lastTransportError.code,\n	        reason: this.lastTransportError.reason\n	      });\n	    }\n	  },\n	\n	  /**\n	  * Connect socket.\n	  */\n	  connect: function() {\n	    var transport = this;\n	\n	    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n	      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');\n	      return false;\n	    }\n	\n	    if(this.ws) {\n	      this.ws.close();\n	    }\n	\n	    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n	    this.ua.onTransportConnecting(this,\n	      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);\n	\n	    try {\n	      this.ws = new WebSocket(this.server.ws_uri, 'sip');\n	    } catch(e) {\n	      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);\n	    }\n	\n	    this.ws.binaryType = 'arraybuffer';\n	\n	    this.ws.onopen = function() {\n	      transport.onOpen();\n	    };\n	\n	    this.ws.onclose = function(e) {\n	      transport.onClose(e);\n	    };\n	\n	    this.ws.onmessage = function(e) {\n	      transport.onMessage(e);\n	    };\n	\n	    this.ws.onerror = function(e) {\n	      transport.onError(e);\n	    };\n	  },\n	\n	  // Transport Event Handlers\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onOpen: function() {\n	    this.connected = true;\n	\n	    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');\n	    // Clear reconnectTimer since we are not disconnected\n	    if (this.reconnectTimer !== null) {\n	      SIP.Timers.clearTimeout(this.reconnectTimer);\n	      this.reconnectTimer = null;\n	    }\n	    // Reset reconnection_attempts\n	    this.reconnection_attempts = 0;\n	    // Disable closed\n	    this.closed = false;\n	    // Trigger onTransportConnected callback\n	    this.ua.onTransportConnected(this);\n	    // Start sending keep-alives\n	    this.startSendingKeepAlives();\n	  },\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onClose: function(e) {\n	    var connected_before = this.connected;\n	\n	    this.lastTransportError.code = e.code;\n	    this.lastTransportError.reason = e.reason;\n	\n	    this.stopSendingKeepAlives();\n	\n	    if (this.reconnection_attempts > 0) {\n	      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n	      this.reconnect();\n	    } else {\n	      this.connected = false;\n	      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n	\n	      if(e.wasClean === false) {\n	        this.logger.warn('WebSocket abrupt disconnection');\n	      }\n	      // Transport was connected\n	      if(connected_before === true) {\n	        this.ua.onTransportClosed(this);\n	        // Check whether the user requested to close.\n	        if(!this.closed) {\n	          this.reconnect();\n	        } else {\n	          this.ua.emit('disconnected', {\n	            transport: this,\n	            code: this.lastTransportError.code,\n	            reason: this.lastTransportError.reason\n	          });\n	\n	        }\n	      } else {\n	        // This is the first connection attempt\n	        //Network error\n	        this.ua.onTransportError(this);\n	      }\n	    }\n	  },\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onMessage: function(e) {\n	    var message, transaction,\n	      data = e.data;\n	\n	    // CRLF Keep Alive response from server. Ignore it.\n	    if(data === '\\r\\n') {\n	      SIP.Timers.clearTimeout(this.keepAliveTimeout);\n	      this.keepAliveTimeout = null;\n	\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('received WebSocket message with CRLF Keep Alive response');\n	      }\n	\n	      return;\n	    }\n	\n	    // WebSocket binary message.\n	    else if (typeof data !== 'string') {\n	      try {\n	        data = String.fromCharCode.apply(null, new Uint8Array(data));\n	      } catch(evt) {\n	        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n	        return;\n	      }\n	\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n	      }\n	    }\n	\n	    // WebSocket text message.\n	    else {\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n	      }\n	    }\n	\n	    message = SIP.Parser.parseMessage(data, this.ua);\n	\n	    if (!message) {\n	      return;\n	    }\n	\n	    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n	      return;\n	    }\n	\n	    // Do some sanity check\n	    if(SIP.sanityCheck(message, this.ua, this)) {\n	      if(message instanceof SIP.IncomingRequest) {\n	        message.transport = this;\n	        this.ua.receiveRequest(message);\n	      } else if(message instanceof SIP.IncomingResponse) {\n	        /* Unike stated in 18.1.2, if a response does not match\n	        * any transaction, it is discarded here and no passed to the core\n	        * in order to be discarded there.\n	        */\n	        switch(message.method) {\n	          case SIP.C.INVITE:\n	            transaction = this.ua.transactions.ict[message.via_branch];\n	            if(transaction) {\n	              transaction.receiveResponse(message);\n	            }\n	            break;\n	          case SIP.C.ACK:\n	            // Just in case ;-)\n	            break;\n	          default:\n	            transaction = this.ua.transactions.nict[message.via_branch];\n	            if(transaction) {\n	              transaction.receiveResponse(message);\n	            }\n	            break;\n	        }\n	      }\n	    }\n	  },\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onError: function(e) {\n	    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));\n	  },\n	\n	  /**\n	  * Reconnection attempt logic.\n	  * @private\n	  */\n	  reconnect: function() {\n	    var transport = this;\n	\n	    this.reconnection_attempts += 1;\n	\n	    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {\n	      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n	      this.ua.onTransportError(this);\n	    } else if (this.reconnection_attempts === 1) {\n	      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');\n	      transport.connect();\n	    } else {\n	      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');\n	\n	      this.reconnectTimer = SIP.Timers.setTimeout(function() {\n	        transport.connect();\n	        transport.reconnectTimer = null;\n	      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);\n	    }\n	  }\n	};\n	\n	Transport.C = C;\n	return Transport;\n	};\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var LoginService = function (sdk) {\n	    var onLoginHandler = [];\n	    return {\n	        login: function login(username, extension, password) {\n	            return _rcSdk.RC.sdk.platform().login({\n	                'username': username,\n	                'extension': extension,\n	                'password': password\n	            });\n	        },\n	        logout: function logout() {\n	            return _rcSdk.RC.sdk.platform().logout();\n	        },\n	        checkLoginStatus: function checkLoginStatus() {\n	            return _rcSdk.RC.sdk.platform().loggedIn().then(function (isLoggedIn) {\n	                if (isLoggedIn) {\n	                    onLoginHandler.forEach(function (handler) {\n	                        return handler();\n	                    });\n	                }\n	                return isLoggedIn;\n	            });\n	        },\n	        oauth: function oauth() {\n	            return new Promise(function (resolve, reject) {\n	                var redirectUri = 'https://ringcentral.github.io/ringcentral-js-widget/page/redirect.html';\n	                var url = _rcSdk.RC.sdk.platform().authUrl({\n	                    redirectUri: redirectUri\n	                });\n	                var oauthWindow = window.open(url, 'rc-iframe-2', 'width=400, height=600');\n	                var interval = setInterval(check, 500);\n	                function check() {\n	                    if (!oauthWindow) {\n	                        return;\n	                    }\n	                    if (oauthWindow.closed) {\n	                        reject(new Error('RingCentral Oauth window is closed abnormally.'));\n	                        clearInterval(interval);\n	                    }\n	                }\n	                window.addEventListener('message', function oauthChannel(e) {\n	                    if (e.data.type === 'oauth') {\n	                        var qs = _rcSdk.RC.sdk.platform().parseAuthRedirectUrl(e.data.value);\n	                        qs.redirectUri = redirectUri;\n	                        window.removeEventListener('message', oauthChannel);\n	                        clearInterval(interval);\n	                        resolve(_rcSdk.RC.sdk.platform().login(qs));\n	                    } else if (e.data.type === 'oauth-fail') {\n	                        window.removeEventListener('message', oauthChannel);\n	                        clearInterval(interval);\n	                        reject(new Error('RingCentral Oauth window is closed abnormally.'));\n	                    }\n	                });\n	            });\n	        }\n	    };\n	}();\n	exports.default = LoginService;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _rcSubscriptionService = __webpack_require__(53);\n	\n	var _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var CallLogService = function (sdk) {\n	    var period = 7 * 24 * 3600 * 1000;\n	    var dateFrom = new Date(Date.now() - period);\n	    return {\n	        getCallLogs: function getCallLogs() {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', { dateFrom: dateFrom.toISOString() }).then(function (response) {\n	                return response.json().records;\n	            });\n	        },\n	        getCallLogsByNumber: function getCallLogsByNumber(phoneNumber, hourFrom, hourTo) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', {\n	                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n	                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n	                phoneNumber: phoneNumber\n	            }).then(function (response) {\n	                return response.json();\n	            }).then(function (data) {\n	                return data.records;\n	            }).then(function (records) {\n	                return records.reverse();\n	            });\n	        }\n	    };\n	}();\n	\n	exports.default = CallLogService;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var rcSubscription = function () {\n	    var _init = false;\n	    var cacheKey = 'ringcentral-subscription';\n	    var subscription;\n	    var handlers = {};\n	    function init() {\n	        _init = true;\n	        subscription = _rcSdk.RC.sdk.createCachedSubscription(cacheKey).restore();\n	        subscription.on(subscription.events.notification, function (msg) {\n	            for (var key in handlers) {\n	                if (handlers.hasOwnProperty(key)) {\n	                    if (msg.event.indexOf(key) > -1) {\n	                        handlers[key].forEach(function (h) {\n	                            try {\n	                                h(msg);\n	                            } catch (e) {\n	                                console.error('Error occurs when invoking subscription notification handler for \"' + msg.event + '\": ' + e);\n	                            }\n	                        });\n	                    }\n	                }\n	            }\n	        });\n	    }\n	\n	    return {\n	        subscribe: function subscribe(suffix, event, handler) {\n	            if (!_init) init();\n	            if (event && suffix) {\n	                if (!handlers[suffix]) {\n	                    handlers[suffix] = [];\n	                }\n	                handlers[suffix].push(handler);\n	                subscription.addEventFilters(event).register();\n	            }\n	        }\n	    };\n	}();\n	\n	exports.default = rcSubscription;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var accountService = function (RC) {\n	    var info;\n	    var numbers;\n	    var fetchNumbers = null;\n	\n	    function getNumbersByType(numbers, type) {\n	        if (!numbers) return Error('Need to fetch numbers first using accountService.getPhoneNumber');\n	        return numbers.filter(function (number) {\n	            return number.type === type;\n	        });\n	    }\n	\n	    function getNumbersByFeatures(numbers, features) {\n	        if (!Array.isArray(features)) features = [features];\n	        // if has duplicate features\n	        return numbers.filter(function (number) {\n	            return features.filter(function (f) {\n	                return number.features.indexOf(f) > -1;\n	            }).length > 0;\n	        });\n	    }\n	\n	    return {\n	        getAccountInfo: function getAccountInfo() {\n	            return RC.sdk.platform().get('/account/~/extension/~').then(function (response) {\n	                info = response.json();\n	                return info;\n	            }).catch(function (e) {\n	                return console.error('Recent Calls Error: ' + e.message);\n	            });\n	        },\n	\n	        getPhoneNumber: function getPhoneNumber() {\n	            fetchNumbers = RC.sdk.platform().get('/account/~/extension/~/phone-number').then(function (response) {\n	                var data = response.json();\n	                numbers = data.records;\n	                fetchNumbers = null;\n	                return data.records;\n	            }).catch(function (e) {\n	                return console.error('Recent Calls Error: ' + e.message);\n	            });\n	            return fetchNumbers;\n	        },\n	\n	        hasServiceFeature: function hasServiceFeature(name) {\n	            if (!info) return Error('Need to fetch account info by accountService.getAccountInfo');\n	            return info.serviceFeatures.filter(function (feature) {\n	                return feature.featureName.toLowerCase() === name.toLowerCase();\n	            }).length > 0;\n	        },\n	\n	        listNumber: function listNumber(type) {\n	            var features = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n	\n	            if (fetchNumbers) {\n	                return fetchNumbers.then(function () {\n	                    return getNumbersByFeatures(getNumbersByType(numbers, type), features).map(function (number) {\n	                        return number.phoneNumber;\n	                    });\n	                });\n	            } else {\n	                return getNumbersByFeatures(getNumbersByType(numbers, type), features).sort(function (number1, number2) {\n	                    if (number2.usageType === 'DirectNumber') return 1;\n	                    return -1;\n	                }).map(function (number) {\n	                    return number.phoneNumber;\n	                });\n	            }\n	        }\n	    };\n	}(_rcSdk.RC);\n	\n	exports.default = accountService;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _lzString = __webpack_require__(56);\n	\n	var _lzString2 = _interopRequireDefault(_lzString);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcContactService = function () {\n	    var companyContacts = [];\n	    var completeCompanyContacts = null;\n	\n	    var fetchingCompanyContacts = null;\n	    var fetchingCompleteCompanyContacts = null;\n	\n	    function Contact() {\n	        this.firstName = null;\n	        this.lastName = null;\n	        this.displayName = null;\n	        this.extension = null;\n	        this.email = null;\n	        this.type = null;\n	        this.id = null;\n	        this.phoneNumber = [];\n	    }\n	\n	    function createContact(extension) {\n	        var contact = new Contact();\n	        contact.extension = extension.extensionNumber;\n	        contact.firstName = extension.contact.firstName;\n	        contact.lastName = extension.contact.lastName;\n	        contact.displayName = contact.firstName + ' ' + contact.lastName;\n	        contact.email = extension.contact.email;\n	        contact.type = 'rc';\n	        contact.id = extension.id;\n	        contact.profileImage = extension.profileImage.uri;\n	        return contact;\n	    }\n	\n	    function addToCompanyContact(response) {\n	        var records = response.json().records.filter(function (extension) {\n	            return extension.status === 'Enabled' && ['DigitalUser', 'User'].indexOf(extension.type) >= 0;\n	        }).map(function (extension) {\n	            return createContact(extension);\n	        });\n	        companyContacts.push.apply(companyContacts, records);\n	    }\n	\n	    function fetchCompanyContactByPage(page) {\n	        return _rcSdk.RC.sdk.platform().get('/account/~/extension/', { perPage: 250, page: page });\n	    }\n	\n	    function fetchCompanyDirectNumbersByPage(page) {\n	        return _rcSdk.RC.sdk.platform().get('/account/~/phone-number', { perPage: 250, page: page });\n	    }\n	\n	    function fetchCompanyContacts() {\n	        var page = 1;\n	        fetchingCompanyContacts = fetchCompanyContactByPage(page).then(function (response) {\n	            var respObj = response.json();\n	            if (respObj.paging && respObj.paging.totalPages > page) {\n	                var promises = [];\n	                while (respObj.paging.totalPages > page) {\n	                    page++;\n	                    promises.push(fetchCompanyContactByPage(page));\n	                }\n	\n	                return Promise.all(promises).then(function (responses) {\n	                    responses.forEach(function (response) {\n	                        addToCompanyContact(response);\n	                    });\n	                    fetchingCompanyContacts = null;\n	                    return companyContacts;\n	                });\n	            } else {\n	                addToCompanyContact(response);\n	                return companyContacts;\n	            }\n	        }).catch(function (e) {\n	            console.error(e);\n	        });\n	        return fetchingCompanyContacts;\n	    }\n	\n	    function fetchCompanyDirectNumbers() {\n	        var page = 1;\n	        return fetchCompanyDirectNumbersByPage(page).then(function (response) {\n	            var respObj = response.json();\n	            if (respObj.paging && respObj.paging.totalPages > page) {\n	                var promises = [];\n	                while (respObj.paging.totalPages > page) {\n	                    page++;\n	                    promises.push(fetchCompanyDirectNumbersByPage(page));\n	                }\n	\n	                return Promise.all(promises).then(function (responses) {\n	                    var numbers = {};\n	                    responses.forEach(function (response) {\n	                        var resp = response.json();\n	                        resp.records.forEach(function (el) {\n	                            if (el.extension && el.extension.extensionNumber) {\n	                                if (!numbers[el.extension.extensionNumber]) {\n	                                    numbers[el.extension.extensionNumber] = [];\n	                                }\n	\n	                                numbers[el.extension.extensionNumber].push(el);\n	                            }\n	                        });\n	                    });\n	                    companyContacts.forEach(function (contact) {\n	                        var phones = numbers[contact.extension];\n	                        if (phones) {\n	                            phones.forEach(function (phone) {\n	                                contact.phoneNumber.push(phone.phoneNumber);\n	                            });\n	                        }\n	                    });\n	                });\n	            }\n	        });\n	    }\n	\n	    return {\n	        get companyContacts() {\n	            return companyContacts;\n	        },\n	        accessToken: function accessToken() {\n	            return _rcSdk.RC.sdk.platform().auth().accessToken();\n	        },\n	        asyncGetCompanyContact: function asyncGetCompanyContact() {\n	            if (fetchingCompanyContacts) {\n	                return fetchingCompanyContacts;\n	            } else {\n	                return Promise.resolve(companyContacts);\n	            }\n	        },\n	        syncCompanyContact: function syncCompanyContact() {\n	            companyContacts.length = 0;\n	            fetchCompanyContacts();\n	            fetchCompanyDirectNumbers();\n	        },\n	        completeCompanyContact: function completeCompanyContact() {\n	            if (completeCompanyContacts) return Promise.resolve(completeCompanyContacts);\n	            if (fetchingCompleteCompanyContacts) return fetchingCompleteCompanyContacts;\n	            fetchingCompleteCompanyContacts = fetchCompanyContacts().then(fetchCompanyDirectNumbers);\n	            return fetchingCompleteCompanyContacts.then(function () {\n	                completeCompanyContacts = companyContacts;\n	                fetchingCompleteCompanyContacts = null;\n	                return companyContacts;\n	            });\n	        },\n	        cacheContacts: function () {\n	            var contact = null;\n	            var data = localStorage.getItem('rc-contacts');\n	            return function () {\n	                if (contact) {\n	                    contact.then(function (value) {\n	                        completeCompanyContacts = companyContacts = value;\n	                    });\n	                    return contact;\n	                }\n	                // For test\n	                if (window.location.href.indexOf('127.0.0.11') === -1) {\n	                    var fetch = new Promise(function (resolve, reject) {\n	                        // Hack for delay the refreshing request\n	                        setTimeout(function () {\n	                            rcContactService.completeCompanyContact().then(function (data) {\n	                                if (data) {\n	                                    completeCompanyContacts = companyContacts = data;\n	                                    localStorage.setItem('rc-contacts', _lzString2.default.compressToUTF16(JSON.stringify(data)));\n	                                }\n	                                return resolve(data);\n	                            });\n	                        }, 100);\n	                    });\n	                } else {\n	                    var fetch;\n	                }\n	                if (data) {\n	                    var fetchedContact = JSON.parse(_lzString2.default.decompressFromUTF16(data));\n	                    completeCompanyContacts = companyContacts = fetchedContact;\n	                    contact = Promise.resolve(fetchedContact);\n	                } else {\n	                    contact = fetch;\n	                }\n	                return contact;\n	            };\n	        }()\n	    };\n	}();\n	\n	exports.default = rcContactService;\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n	// This work is free. You can redistribute it and/or modify it\n	// under the terms of the WTFPL, Version 2\n	// For more information see LICENSE.txt or http://www.wtfpl.net/\n	//\n	// For more information, the home page:\n	// http://pieroxy.net/blog/pages/lz-string/testing.html\n	//\n	// LZ-based compression algorithm, version 1.4.4\n	var LZString = (function() {\n	\n	// private property\n	var f = String.fromCharCode;\n	var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n	var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n	var baseReverseDic = {};\n	\n	function getBaseValue(alphabet, character) {\n	  if (!baseReverseDic[alphabet]) {\n	    baseReverseDic[alphabet] = {};\n	    for (var i=0 ; i<alphabet.length ; i++) {\n	      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n	    }\n	  }\n	  return baseReverseDic[alphabet][character];\n	}\n	\n	var LZString = {\n	  compressToBase64 : function (input) {\n	    if (input == null) return \"\";\n	    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n	    switch (res.length % 4) { // To produce valid Base64\n	    default: // When could this happen ?\n	    case 0 : return res;\n	    case 1 : return res+\"===\";\n	    case 2 : return res+\"==\";\n	    case 3 : return res+\"=\";\n	    }\n	  },\n	\n	  decompressFromBase64 : function (input) {\n	    if (input == null) return \"\";\n	    if (input == \"\") return null;\n	    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n	  },\n	\n	  compressToUTF16 : function (input) {\n	    if (input == null) return \"\";\n	    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n	  },\n	\n	  decompressFromUTF16: function (compressed) {\n	    if (compressed == null) return \"\";\n	    if (compressed == \"\") return null;\n	    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n	  },\n	\n	  //compress into uint8array (UCS-2 big endian format)\n	  compressToUint8Array: function (uncompressed) {\n	    var compressed = LZString.compress(uncompressed);\n	    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n	\n	    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n	      var current_value = compressed.charCodeAt(i);\n	      buf[i*2] = current_value >>> 8;\n	      buf[i*2+1] = current_value % 256;\n	    }\n	    return buf;\n	  },\n	\n	  //decompress from uint8array (UCS-2 big endian format)\n	  decompressFromUint8Array:function (compressed) {\n	    if (compressed===null || compressed===undefined){\n	        return LZString.decompress(compressed);\n	    } else {\n	        var buf=new Array(compressed.length/2); // 2 bytes per character\n	        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n	          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n	        }\n	\n	        var result = [];\n	        buf.forEach(function (c) {\n	          result.push(f(c));\n	        });\n	        return LZString.decompress(result.join(''));\n	\n	    }\n	\n	  },\n	\n	\n	  //compress into a string that is already URI encoded\n	  compressToEncodedURIComponent: function (input) {\n	    if (input == null) return \"\";\n	    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n	  },\n	\n	  //decompress from an output of compressToEncodedURIComponent\n	  decompressFromEncodedURIComponent:function (input) {\n	    if (input == null) return \"\";\n	    if (input == \"\") return null;\n	    input = input.replace(/ /g, \"+\");\n	    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n	  },\n	\n	  compress: function (uncompressed) {\n	    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n	  },\n	  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n	    if (uncompressed == null) return \"\";\n	    var i, value,\n	        context_dictionary= {},\n	        context_dictionaryToCreate= {},\n	        context_c=\"\",\n	        context_wc=\"\",\n	        context_w=\"\",\n	        context_enlargeIn= 2, // Compensate for the first entry which should not count\n	        context_dictSize= 3,\n	        context_numBits= 2,\n	        context_data=[],\n	        context_data_val=0,\n	        context_data_position=0,\n	        ii;\n	\n	    for (ii = 0; ii < uncompressed.length; ii += 1) {\n	      context_c = uncompressed.charAt(ii);\n	      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n	        context_dictionary[context_c] = context_dictSize++;\n	        context_dictionaryToCreate[context_c] = true;\n	      }\n	\n	      context_wc = context_w + context_c;\n	      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n	        context_w = context_wc;\n	      } else {\n	        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n	          if (context_w.charCodeAt(0)<256) {\n	            for (i=0 ; i<context_numBits ; i++) {\n	              context_data_val = (context_data_val << 1);\n	              if (context_data_position == bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	            }\n	            value = context_w.charCodeAt(0);\n	            for (i=0 ; i<8 ; i++) {\n	              context_data_val = (context_data_val << 1) | (value&1);\n	              if (context_data_position == bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	              value = value >> 1;\n	            }\n	          } else {\n	            value = 1;\n	            for (i=0 ; i<context_numBits ; i++) {\n	              context_data_val = (context_data_val << 1) | value;\n	              if (context_data_position ==bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	              value = 0;\n	            }\n	            value = context_w.charCodeAt(0);\n	            for (i=0 ; i<16 ; i++) {\n	              context_data_val = (context_data_val << 1) | (value&1);\n	              if (context_data_position == bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	              value = value >> 1;\n	            }\n	          }\n	          context_enlargeIn--;\n	          if (context_enlargeIn == 0) {\n	            context_enlargeIn = Math.pow(2, context_numBits);\n	            context_numBits++;\n	          }\n	          delete context_dictionaryToCreate[context_w];\n	        } else {\n	          value = context_dictionary[context_w];\n	          for (i=0 ; i<context_numBits ; i++) {\n	            context_data_val = (context_data_val << 1) | (value&1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = value >> 1;\n	          }\n	\n	\n	        }\n	        context_enlargeIn--;\n	        if (context_enlargeIn == 0) {\n	          context_enlargeIn = Math.pow(2, context_numBits);\n	          context_numBits++;\n	        }\n	        // Add wc to the dictionary.\n	        context_dictionary[context_wc] = context_dictSize++;\n	        context_w = String(context_c);\n	      }\n	    }\n	\n	    // Output the code for w.\n	    if (context_w !== \"\") {\n	      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n	        if (context_w.charCodeAt(0)<256) {\n	          for (i=0 ; i<context_numBits ; i++) {\n	            context_data_val = (context_data_val << 1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	          }\n	          value = context_w.charCodeAt(0);\n	          for (i=0 ; i<8 ; i++) {\n	            context_data_val = (context_data_val << 1) | (value&1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = value >> 1;\n	          }\n	        } else {\n	          value = 1;\n	          for (i=0 ; i<context_numBits ; i++) {\n	            context_data_val = (context_data_val << 1) | value;\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = 0;\n	          }\n	          value = context_w.charCodeAt(0);\n	          for (i=0 ; i<16 ; i++) {\n	            context_data_val = (context_data_val << 1) | (value&1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = value >> 1;\n	          }\n	        }\n	        context_enlargeIn--;\n	        if (context_enlargeIn == 0) {\n	          context_enlargeIn = Math.pow(2, context_numBits);\n	          context_numBits++;\n	        }\n	        delete context_dictionaryToCreate[context_w];\n	      } else {\n	        value = context_dictionary[context_w];\n	        for (i=0 ; i<context_numBits ; i++) {\n	          context_data_val = (context_data_val << 1) | (value&1);\n	          if (context_data_position == bitsPerChar-1) {\n	            context_data_position = 0;\n	            context_data.push(getCharFromInt(context_data_val));\n	            context_data_val = 0;\n	          } else {\n	            context_data_position++;\n	          }\n	          value = value >> 1;\n	        }\n	\n	\n	      }\n	      context_enlargeIn--;\n	      if (context_enlargeIn == 0) {\n	        context_enlargeIn = Math.pow(2, context_numBits);\n	        context_numBits++;\n	      }\n	    }\n	\n	    // Mark the end of the stream\n	    value = 2;\n	    for (i=0 ; i<context_numBits ; i++) {\n	      context_data_val = (context_data_val << 1) | (value&1);\n	      if (context_data_position == bitsPerChar-1) {\n	        context_data_position = 0;\n	        context_data.push(getCharFromInt(context_data_val));\n	        context_data_val = 0;\n	      } else {\n	        context_data_position++;\n	      }\n	      value = value >> 1;\n	    }\n	\n	    // Flush the last char\n	    while (true) {\n	      context_data_val = (context_data_val << 1);\n	      if (context_data_position == bitsPerChar-1) {\n	        context_data.push(getCharFromInt(context_data_val));\n	        break;\n	      }\n	      else context_data_position++;\n	    }\n	    return context_data.join('');\n	  },\n	\n	  decompress: function (compressed) {\n	    if (compressed == null) return \"\";\n	    if (compressed == \"\") return null;\n	    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n	  },\n	\n	  _decompress: function (length, resetValue, getNextValue) {\n	    var dictionary = [],\n	        next,\n	        enlargeIn = 4,\n	        dictSize = 4,\n	        numBits = 3,\n	        entry = \"\",\n	        result = [],\n	        i,\n	        w,\n	        bits, resb, maxpower, power,\n	        c,\n	        data = {val:getNextValue(0), position:resetValue, index:1};\n	\n	    for (i = 0; i < 3; i += 1) {\n	      dictionary[i] = i;\n	    }\n	\n	    bits = 0;\n	    maxpower = Math.pow(2,2);\n	    power=1;\n	    while (power!=maxpower) {\n	      resb = data.val & data.position;\n	      data.position >>= 1;\n	      if (data.position == 0) {\n	        data.position = resetValue;\n	        data.val = getNextValue(data.index++);\n	      }\n	      bits |= (resb>0 ? 1 : 0) * power;\n	      power <<= 1;\n	    }\n	\n	    switch (next = bits) {\n	      case 0:\n	          bits = 0;\n	          maxpower = Math.pow(2,8);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	        c = f(bits);\n	        break;\n	      case 1:\n	          bits = 0;\n	          maxpower = Math.pow(2,16);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	        c = f(bits);\n	        break;\n	      case 2:\n	        return \"\";\n	    }\n	    dictionary[3] = c;\n	    w = c;\n	    result.push(c);\n	    while (true) {\n	      if (data.index > length) {\n	        return \"\";\n	      }\n	\n	      bits = 0;\n	      maxpower = Math.pow(2,numBits);\n	      power=1;\n	      while (power!=maxpower) {\n	        resb = data.val & data.position;\n	        data.position >>= 1;\n	        if (data.position == 0) {\n	          data.position = resetValue;\n	          data.val = getNextValue(data.index++);\n	        }\n	        bits |= (resb>0 ? 1 : 0) * power;\n	        power <<= 1;\n	      }\n	\n	      switch (c = bits) {\n	        case 0:\n	          bits = 0;\n	          maxpower = Math.pow(2,8);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	\n	          dictionary[dictSize++] = f(bits);\n	          c = dictSize-1;\n	          enlargeIn--;\n	          break;\n	        case 1:\n	          bits = 0;\n	          maxpower = Math.pow(2,16);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	          dictionary[dictSize++] = f(bits);\n	          c = dictSize-1;\n	          enlargeIn--;\n	          break;\n	        case 2:\n	          return result.join('');\n	      }\n	\n	      if (enlargeIn == 0) {\n	        enlargeIn = Math.pow(2, numBits);\n	        numBits++;\n	      }\n	\n	      if (dictionary[c]) {\n	        entry = dictionary[c];\n	      } else {\n	        if (c === dictSize) {\n	          entry = w + w.charAt(0);\n	        } else {\n	          return null;\n	        }\n	      }\n	      result.push(entry);\n	\n	      // Add w+entry[0] to the dictionary.\n	      dictionary[dictSize++] = w + entry.charAt(0);\n	      enlargeIn--;\n	\n	      w = entry;\n	\n	      if (enlargeIn == 0) {\n	        enlargeIn = Math.pow(2, numBits);\n	        numBits++;\n	      }\n	\n	    }\n	  }\n	};\n	  return LZString;\n	})();\n	\n	if (true) {\n	  !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return LZString; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	} else if( typeof module !== 'undefined' && module != null ) {\n	  module.exports = LZString\n	}\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	var contactSearchService = function () {\n	    var searchProviders = [];\n	    var queryCompletedHandlers = [];\n	\n	    function createResult(item) {\n	        return {\n	            name: item.name,\n	            value: item.value,\n	            type: item.type,\n	            id: item.id\n	        };\n	    }\n	    return {\n	        query: function query(searchFunctions, filter) {\n	            return Promise.all(searchFunctions).then(function (results) {\n	                var searchResultsKeys = {};\n	                var searchResults = [];\n	                results.forEach(function (result) {\n	                    result.forEach(function (item) {\n	                        if (filter) {\n	                            if (filter(item)) {\n	                                var key = item.name + item.value;\n	                                if (!searchResultsKeys[key]) {\n	                                    var toAddItem = createResult(item);\n	                                    searchResultsKeys[key] = toAddItem;\n	                                    searchResults.push(toAddItem);\n	                                }\n	                            }\n	                        } else {\n	                            var key = item.name + item.value;\n	                            if (!searchResultsKeys[key]) {\n	                                var toAddItem = createResult(item);\n	                                searchResultsKeys[key] = toAddItem;\n	                                searchResults.push(toAddItem);\n	                            }\n	                        }\n	                    });\n	                });\n	                return searchResults;\n	            });\n	        }\n	    };\n	}();\n	exports.default = contactSearchService;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcContactService = __webpack_require__(55);\n	\n	var _rcContactService2 = _interopRequireDefault(_rcContactService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcContactSearchProvider = function () {\n	    return {\n	        search: function search(text) {\n	            var results = [];\n	            if (text) {\n	                text = text.toLowerCase();\n	                _rcContactService2.default.companyContacts.map(function (contact) {\n	                    if (contact.displayName && contact.displayName.toLowerCase().indexOf(text) >= 0) {\n	                        results.push({\n	                            name: contact.displayName,\n	                            value: contact.extension,\n	                            type: 'rc',\n	                            id: contact.id\n	                        });\n	                        contact.phoneNumber.forEach(function (phone) {\n	                            results.push({\n	                                name: contact.displayName,\n	                                value: phone,\n	                                type: 'rc',\n	                                id: contact.id\n	                            });\n	                        });\n	                    } else {\n	                        if (contact.extension && contact.extension.indexOf(text) >= 0) {\n	                            results.push({\n	                                name: contact.displayName,\n	                                value: contact.extension,\n	                                type: 'rc',\n	                                id: contact.id\n	                            });\n	                        }\n	\n	                        contact.phoneNumber.forEach(function (phone) {\n	                            if (phone.indexOf(text) >= 0) {\n	                                results.push({\n	                                    name: contact.displayName,\n	                                    value: phone,\n	                                    type: 'rc',\n	                                    id: contact.id\n	                                });\n	                            }\n	                        });\n	                    }\n	                });\n	            }\n	\n	            return results;\n	        },\n	        searchAll: function searchAll() {\n	            return _rcContactService2.default.completeCompanyContact().then(function (companyContacts) {\n	                return companyContacts.map(function (contact) {\n	                    return {\n	                        name: contact.displayName,\n	                        type: 'rc',\n	                        id: contact.id\n	                    };\n	                });\n	            }).catch(function (e) {\n	                return console.error(e);\n	            });\n	        }\n	    };\n	}();\n	\n	exports.default = rcContactSearchProvider;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _rcSubscriptionService = __webpack_require__(53);\n	\n	var _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcMessageService = function () {\n	    var messages = {};\n	    var fetchingPromise = null;\n	    var syncToken = null;\n	    var messageUpdateHandlers = [];\n	\n	    function fullSyncMessages(hour) {\n	        return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n	            dateFrom: new Date(Date.now() - hour * 3600 * 1000).toISOString(),\n	            syncType: 'FSync'\n	        }).then(function (responses) {\n	            var jsonResponse = responses.json();\n	            syncToken = jsonResponse.syncInfo.syncToken;\n	            var results = jsonResponse.records;\n	            addMessageToList(results);\n	            fetchingPromise = null;\n	            return results;\n	        });\n	    }\n	\n	    function incrementalSyncMessages() {\n	        if (syncToken) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n	                syncType: 'ISync',\n	                syncToken: syncToken\n	            }).then(function (responses) {\n	                var jsonResponse = responses.json();\n	                var results = jsonResponse.records;\n	                syncToken = jsonResponse.syncInfo.syncToken;\n	                updateMessageList(results);\n	                messageUpdateHandlers.forEach(function (h) {\n	                    return h(results);\n	                });\n	            });\n	        }\n	    }\n	\n	    function concatMessages() {\n	        var results = [];\n	        for (var key in messages) {\n	            if (messages.hasOwnProperty(key)) {\n	                results = results.concat(messages[key]);\n	            }\n	        }\n	        return results;\n	    }\n	\n	    function addMessageToList(results) {\n	        results.forEach(function (message) {\n	            if (!messages[message.type]) {\n	                messages[message.type] = [];\n	            }\n	            messages[message.type].push(message);\n	        });\n	    }\n	\n	    function updateMessageList(results) {\n	        results.forEach(function (message) {\n	            var messageList = messages[message.type];\n	            if (!messageList) {\n	                if (message.availability === 'Alive') {\n	                    messages[message.type] = [];\n	                    messages[message.type].splice(0, 0, message);\n	                }\n	            } else {\n	                var index = 0;\n	                for (; index < messageList.length; index++) {\n	                    if (messageList[index].id === message.id) {\n	                        if (message.availability === 'Alive') {\n	                            messageList[index] = message;\n	                        } else {\n	                            messageList.splice(index, 1);\n	                        }\n	                        break;\n	                    }\n	                }\n	                if (index === messageList.length) {\n	                    if (message.availability === 'Alive') {\n	                        messageList.splice(0, 0, message);\n	                    }\n	                }\n	            }\n	        });\n	    }\n	\n	    return {\n	        syncMessages: function syncMessages(hour) {\n	            fetchingPromise = fullSyncMessages(hour);\n	            return fetchingPromise;\n	        },\n	        getMessagesByType: function getMessagesByType(type) {\n	            if (!fetchingPromise) {\n	                if (messages[type]) {\n	                    return messages[type];\n	                } else {\n	                    return [];\n	                }\n	            } else {\n	                return fetchingPromise.then(function () {\n	                    return messages[type];\n	                });\n	            }\n	        },\n	        getAllMessages: function getAllMessages() {\n	            return !fetchingPromise ? concatMessages() : fetchingPromise.then(concatMessages);\n	        },\n	        subscribeToMessageUpdate: function subscribeToMessageUpdate() {\n	            _rcSubscriptionService2.default.subscribe('message-store', '/restapi/v1.0/account/~/extension/~/message-store', incrementalSyncMessages);\n	        },\n	        onMessageUpdated: function onMessageUpdated(handler) {\n	            if (handler) {\n	                messageUpdateHandlers.push(handler);\n	            }\n	        },\n	        sendSMSMessage: function sendSMSMessage(text, fromNumber, toNumber) {\n	            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/sms/', {\n	                from: { phoneNumber: fromNumber },\n	                to: [{ phoneNumber: toNumber }],\n	                text: text\n	            }).then(function (response) {\n	                return response.json();\n	            });\n	        },\n	        sendPagerMessage: function sendPagerMessage(text, fromNumber, toNumber) {\n	            console.log(fromNumber);\n	            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/company-pager/', {\n	                from: { extensionNumber: fromNumber },\n	                to: [{ extensionNumber: toNumber }],\n	                text: text\n	            }).then(function (response) {\n	                return response.json();\n	            });\n	        },\n	        getConversation: function getConversation(conversationId, hourFrom, hourTo) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n	                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n	                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n	                conversationId: conversationId\n	            }).then(function (response) {\n	                return response.json();\n	            }).then(function (data) {\n	                return data.records;\n	            }).then(function (records) {\n	                return records.reverse();\n	            });\n	        },\n	        getMessagesByNumber: function getMessagesByNumber(phoneNumber, hourFrom, hourTo) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n	                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n	                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n	                phoneNumber: phoneNumber\n	            }).then(function (response) {\n	                return response.json();\n	            }).then(function (data) {\n	                return data.records;\n	            }).then(function (records) {\n	                return records.reverse();\n	            });\n	        }\n	    };\n	}();\n	\n	exports.default = rcMessageService;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcMessageService = __webpack_require__(59);\n	\n	var _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcMessageProvider = function () {\n	    var messageUpdatedHandlers = [];\n	    var conversations = {};\n	    var cachedHour = 0;\n	\n	    _rcMessageService2.default.onMessageUpdated(function (results) {\n	        messageUpdatedHandlers.forEach(function (h) {\n	            try {\n	                h(results.slice());\n	            } catch (e) {\n	                console.error(e);\n	            }\n	        });\n	    });\n	\n	    function createResult(message) {\n	        return {\n	            id: message.id,\n	            time: message.lastModifiedTime,\n	            readStatus: message.readStatus,\n	            type: getType(message),\n	            contact: getNumber(message.type, getDirection(message, 'Outbound')),\n	            subject: message.subject || null,\n	            convId: message.conversation ? message.conversation.id : null,\n	            author: getNumber(message, getDirection(message, 'Inbound'))\n	        };\n	\n	        function getDirection(message, dir) {\n	            return message.direction === dir ? message.to[0] : message.from;\n	        }\n	\n	        function getNumber(message, info) {\n	            return message.type === 'Pager' ? info.extensionNumber : info.phoneNumber;\n	        }\n	\n	        function getType(message) {\n	            return message.type === 'Fax' || message.type === 'VoiceMail' ? 'Text' : message.type;\n	        }\n	    }\n	\n	    return {\n	        getTextMessages: function getTextMessages() {\n	            return Promise.resolve(_rcMessageService2.default.getMessagesByType('SMS')).then(function (messages) {\n	                var results = [];\n	                messages.forEach(function (message) {\n	                    results.push(createResult(message));\n	                });\n	                return results;\n	            });\n	        },\n	\n	        getLastMessagesOfAllType: function getLastMessagesOfAllType() {\n	            var results = [];\n	            return this.getMessagesOfAllType().then(function (msgs) {\n	                for (var key in msgs) {\n	                    if (msgs.hasOwnProperty(key)) {\n	                        if (key === 'anonymous') results = results.concat(msgs.anonymous[0]);else results.push(msgs[key][0]);\n	                    }\n	                }\n	                return results;\n	            });\n	        },\n	        // Return all messages of type 'VoiceMail' and 'Fax'. For SMS and Pager, only last message in a conversation\n	        // will be returned.\n	        getMessagesOfAllType: function getMessagesOfAllType() {\n	            return Promise.resolve(_rcMessageService2.default.getAllMessages()).then(function (messages) {\n	                var results = [];\n	                var target = {};\n	                messages.forEach(function (message) {\n	                    var result = createResult(message);\n	                    //Combine SMS/Pager messages in conversation\n	                    if (message.conversation && message.conversation.id) {\n	                        target[message.conversation.id] = target[message.conversation.id] || [];\n	                        target[message.conversation.id].push(result);\n	                        conversations[message.conversation.id] = conversations[message.conversation.id] || [];\n	                        conversations[message.conversation.id].push(message);\n	                    } else {\n	                        target['anonymous'] = target['anonymous'] || [];\n	                        target['anonymous'].push(result);\n	                    }\n	                });\n	                return target;\n	            });\n	        },\n	\n	        getConversation: function getConversation(convId, hourFrom) {\n	            if (conversations[convId] && (!hourFrom || hourFrom < cachedHour)) {\n	                return Promise.resolve(conversations[convId].reverse());\n	            } else {\n	                return _rcMessageService2.default.getConversation(convId, hourFrom, cachedHour).then(function (result) {\n	                    cachedHour = hourFrom;\n	                    return result;\n	                });\n	            }\n	        },\n	\n	        onMessageUpdated: function onMessageUpdated(handler) {\n	            messageUpdatedHandlers.push(handler);\n	        }\n	    };\n	}();\n	exports.default = rcMessageProvider;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var rcConferenceSerivce = function () {\n	    var fetchingConferenceInfo = null;\n	\n	    function fetchConferenceInfo() {\n	        fetchingConferenceInfo = _rcSdk.RC.sdk.platform().get('/account/~/extension/~/conferencing').then(function (responses) {\n	            var jsonResponse = responses.json();\n	            var conferenceInfo = {};\n	            conferenceInfo.hostCode = jsonResponse.hostCode;\n	            conferenceInfo.phoneNumber = jsonResponse.phoneNumber;\n	            conferenceInfo.participantCode = jsonResponse.participantCode;\n	            fetchingConferenceInfo = null;\n	            return conferenceInfo;\n	        });\n	        return fetchingConferenceInfo;\n	    }\n	\n	    return {\n	        getConferenceInfo: function getConferenceInfo() {\n	            if (fetchingConferenceInfo) {\n	                return fetchingConferenceInfo;\n	            } else {\n	                return fetchConferenceInfo();\n	            }\n	        }\n	    };\n	}();\n	\n	exports.default = rcConferenceSerivce;\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _callLogService = __webpack_require__(52);\n	\n	var _callLogService2 = _interopRequireDefault(_callLogService);\n	\n	var _rcMessageService = __webpack_require__(59);\n	\n	var _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n	\n	var conversationService = function () {\n	    var cachedHour = 24 * 7;\n	    function groupMessageToContact(msgs, contacts) {\n	        var relatedContacts = contacts.filter(function (contact) {\n	            var knownContactsIndex = [];\n	            var contactNums = contact.phoneNumber.concat(contact.extension);\n	            var contactMsgs = msgs.filter(function (msg, index) {\n	                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	                var contain = contactNums.indexOf(msgNumber) > -1;\n	                contact.msg = contact.msg || [];\n	                var alreadyExist = contact.msg.find(function (contactMsg) {\n	                    return contactMsg.id == msg.id;\n	                });\n	                if (contain && !alreadyExist) {\n	\n	                    contact.msg.push(msg);\n	                    knownContactsIndex.push(index);\n	                }\n	                return contain;\n	            });\n	            knownContactsIndex.reverse().forEach(function (index) {\n	                return msgs.splice(index, 1);\n	            });\n	            return contactMsgs.length > 0;\n	        });\n	        msgs.forEach(function (msg) {\n	            var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	            var contact = relatedContacts.filter(function (contact) {\n	                return contact.id === msgNumber;\n	            })[0];\n	            if (contact) {\n	                contact.msg.push(msg);\n	            } else {\n	                relatedContacts.push(fakeContact(msg));\n	            }\n	        });\n	        return relatedContacts;\n	    }\n	\n	    function groupContactToMessage(msgs, contacts) {\n	        return msgs.map(function (msg) {\n	            var unknownContact = true;\n	            contacts.forEach(function (contact) {\n	                var contactNums = contact.phoneNumber.concat(contact.extension);\n	                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	                var contain = contactNums.indexOf(msgNumber) > -1;\n	                if (contain) {\n	                    msg.contact = contact;\n	                    unknownContact = false;\n	                }\n	            });\n	            // if (unknownContact) {\n	            //     console.log(msg);\n	            //     var fake = fakeContact(msg)\n	            //     msg.contact = fake\n	            //     contacts.push(fake)\n	            // }\n	            return msg;\n	        });\n	    }\n	\n	    function combineAdjacentMessage(contents) {\n	        // group related SMS message\n	        var savedContent;\n	        var result = [];\n	        for (var i = contents.length - 1; i > 0; --i) {\n	            var content = contents[i];\n	            // if (content.type !== 'SMS') {\n	            //     if (savedContent) {\n	            //         result.push(savedContent)\n	            //         savedContent = null\n	            //     }\n	            //     result.push(content)\n	            //     continue\n	            // }\n	            if (savedContent && savedContent.type === content.type && savedContent.contact.id === content.contact.id) {\n	                savedContent.others.push(content);\n	            } else {\n	                savedContent && result.push(savedContent);\n	                content.others = [];\n	                savedContent = content;\n	            }\n	        }\n	        savedContent && result.push(savedContent);\n	        return result;\n	    }\n	\n	    function combine() {\n	        for (var _len = arguments.length, targets = Array(_len), _key = 0; _key < _len; _key++) {\n	            targets[_key] = arguments[_key];\n	        }\n	\n	        return targets.reduce(function (result, target) {\n	            return result.concat(target);\n	        }, []);\n	    }\n	\n	    function sortTime(target) {\n	        return target.slice().sort(function (a, b) {\n	            return Date.parse(a.time) - Date.parse(b.time);\n	        });\n	    }\n	    function containSameVal(array1, array2) {\n	        return array1.filter(function (n) {\n	            return array2.indexOf(n) != -1;\n	        }).length > 0;\n	    }\n	    function uniqueArray(target) {\n	        var seen = {};\n	        return target.filter(function (item) {\n	            return seen.hasOwnProperty(item) ? false : seen[item] = true;\n	        });\n	    }\n	\n	    function fakeContact(msg) {\n	        var phoneNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	        return {\n	            displayName: phoneNumber,\n	            id: phoneNumber,\n	            phoneNumber: [phoneNumber],\n	            extension: null,\n	            msg: [msg]\n	        };\n	    }\n	\n	    function adaptMessage(msg) {\n	        return {\n	            id: msg.id,\n	            from: !msg.from && 'anonymous' || // For fax\n	            msg.from.extensionNumber || msg.from.phoneNumber,\n	            to: msg.to.phoneNumber || msg.to.extensionNumber || msg.to[0].extensionNumber || msg.to[0].phoneNumber,\n	            direction: msg.direction,\n	            type: msg.type,\n	            time: msg.creationTime || msg.startTime,\n	            lastModifiedTime: msg.lastModifiedTime || msg.startTime,\n	            subject: msg.recording || msg.subject || msg.action || msg.attachments[0],\n	            status: {\n	                sendConfirmed: false,\n	                receiveConfirmed: false\n	            }\n	        };\n	    }\n	    function getMessagesByNumber(contact, offset) {\n	        return Promise.all(contact.phoneNumber.map(function (number) {\n	            return _rcMessageService2.default.getMessagesByNumber(\n	            // FIXME\n	            number, cachedHour + offset, cachedHour);\n	        })).then(function (result) {\n	            return combine.apply(undefined, _toConsumableArray(result));\n	        });\n	    }\n	    function getCallLogsByNumber(contact, offset) {\n	        return Promise.all(contact.phoneNumber.map(function (number) {\n	            return _callLogService2.default.getCallLogsByNumber(number, cachedHour + offset, cachedHour);\n	        })).then(function (result) {\n	            return combine.apply(undefined, _toConsumableArray(result));\n	        });\n	    }\n	    function uniqId(target) {\n	        var seen = {};\n	        return target.filter(function (item) {\n	            return seen.hasOwnProperty(item.id) ? false : seen[item.id] = true;\n	        });\n	    }\n	    function combineContent() {\n	        for (var _len2 = arguments.length, sources = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n	            sources[_key2] = arguments[_key2];\n	        }\n	\n	        return sortTime(combine.apply(undefined, _toConsumableArray(sources.map(function (source) {\n	            return source.map(adaptMessage);\n	        }))));\n	    }\n	    return {\n	        get cachedHour() {\n	            return cachedHour;\n	        },\n	        syncContent: function syncContent(contacts) {\n	            for (var _len3 = arguments.length, sources = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n	                sources[_key3 - 1] = arguments[_key3];\n	            }\n	\n	            var contents = combineContent.apply(undefined, sources);\n	            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n	            contents = groupContactToMessage(contents, relatedContacts);\n	            return contents;\n	        },\n	        organizeContent: function organizeContent(contacts) {\n	            for (var _len4 = arguments.length, sources = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n	                sources[_key4 - 1] = arguments[_key4];\n	            }\n	\n	            var contents = combineContent.apply(undefined, sources);\n	            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n	            contents = groupContactToMessage(contents, relatedContacts);\n	            contents = combineAdjacentMessage(contents);\n	            return contents;\n	        },\n	        getConversations: function getConversations(contacts) {\n	            for (var _len5 = arguments.length, sources = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n	                sources[_key5 - 1] = arguments[_key5];\n	            }\n	\n	            var contents = combineContent.apply(undefined, sources);\n	            var relatedContacts = groupMessageToContact(contents, contacts).map(function (contact) {\n	                contact.syncHour = cachedHour;\n	                return contact;\n	            }).map(function (contact) {\n	                contact.phoneNumber = uniqueArray(contact.phoneNumber.concat(contact.extension));\n	                return contact;\n	            }).reduce(function (map, contact) {\n	                map[contact.id] = contact;\n	                return map;\n	            }, {});\n	            return relatedContacts;\n	        },\n	        loadContent: function loadContent(contact, offset) {\n	            return Promise.all([getCallLogsByNumber(contact, offset), getMessagesByNumber(contact, offset)]).then(function (result) {\n	                return combineContent.apply(undefined, _toConsumableArray(result));\n	            }).then(function (contents) {\n	                contact.msg = contents.concat(contact.msg);\n	                cachedHour += offset;\n	                return contents;\n	            });\n	        },\n	        onConversationUpdate: function onConversationUpdate(handler) {\n	            _rcMessageService2.default.onMessageUpdated(function (msgs) {\n	                try {\n	                    var msgs = sortTime(msgs.map(adaptMessage));\n	                    handler(msgs);\n	                } catch (e) {\n	                    console.error(e);\n	                    throw e;\n	                }\n	            });\n	        },\n	        adaptMessage: adaptMessage\n	    };\n	}();\n	\n	exports.default = conversationService;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var __WEBPACK_AMD_DEFINE_RESULT__;/*\n	 * JavaScript MD5\n	 * https://github.com/blueimp/JavaScript-MD5\n	 *\n	 * Copyright 2011, Sebastian Tschan\n	 * https://blueimp.net\n	 *\n	 * Licensed under the MIT license:\n	 * http://www.opensource.org/licenses/MIT\n	 *\n	 * Based on\n	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n	 * Digest Algorithm, as defined in RFC 1321.\n	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n	 * Distributed under the BSD License\n	 * See http://pajhome.org.uk/crypt/md5 for more info.\n	 */\n	\n	/*global unescape, define, module */\n	\n	;(function ($) {\n	  'use strict'\n	\n	  /*\n	  * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n	  * to work around bugs in some JS interpreters.\n	  */\n	  function safe_add (x, y) {\n	    var lsw = (x & 0xFFFF) + (y & 0xFFFF)\n	    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n	    return (msw << 16) | (lsw & 0xFFFF)\n	  }\n	\n	  /*\n	  * Bitwise rotate a 32-bit number to the left.\n	  */\n	  function bit_rol (num, cnt) {\n	    return (num << cnt) | (num >>> (32 - cnt))\n	  }\n	\n	  /*\n	  * These functions implement the four basic operations the algorithm uses.\n	  */\n	  function md5_cmn (q, a, b, x, s, t) {\n	    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)\n	  }\n	  function md5_ff (a, b, c, d, x, s, t) {\n	    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)\n	  }\n	  function md5_gg (a, b, c, d, x, s, t) {\n	    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)\n	  }\n	  function md5_hh (a, b, c, d, x, s, t) {\n	    return md5_cmn(b ^ c ^ d, a, b, x, s, t)\n	  }\n	  function md5_ii (a, b, c, d, x, s, t) {\n	    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)\n	  }\n	\n	  /*\n	  * Calculate the MD5 of an array of little-endian words, and a bit length.\n	  */\n	  function binl_md5 (x, len) {\n	    /* append padding */\n	    x[len >> 5] |= 0x80 << (len % 32)\n	    x[(((len + 64) >>> 9) << 4) + 14] = len\n	\n	    var i\n	    var olda\n	    var oldb\n	    var oldc\n	    var oldd\n	    var a = 1732584193\n	    var b = -271733879\n	    var c = -1732584194\n	    var d = 271733878\n	\n	    for (i = 0; i < x.length; i += 16) {\n	      olda = a\n	      oldb = b\n	      oldc = c\n	      oldd = d\n	\n	      a = md5_ff(a, b, c, d, x[i], 7, -680876936)\n	      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)\n	      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)\n	      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)\n	      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)\n	      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)\n	      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)\n	      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)\n	      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)\n	      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)\n	      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)\n	      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)\n	      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)\n	      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)\n	      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)\n	      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)\n	\n	      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)\n	      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)\n	      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)\n	      b = md5_gg(b, c, d, a, x[i], 20, -373897302)\n	      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)\n	      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)\n	      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)\n	      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)\n	      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)\n	      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)\n	      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)\n	      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)\n	      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)\n	      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)\n	      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)\n	      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)\n	\n	      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)\n	      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)\n	      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)\n	      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)\n	      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)\n	      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)\n	      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)\n	      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)\n	      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)\n	      d = md5_hh(d, a, b, c, x[i], 11, -358537222)\n	      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)\n	      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)\n	      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)\n	      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)\n	      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)\n	      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)\n	\n	      a = md5_ii(a, b, c, d, x[i], 6, -198630844)\n	      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)\n	      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)\n	      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)\n	      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)\n	      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)\n	      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)\n	      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)\n	      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)\n	      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)\n	      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)\n	      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)\n	      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)\n	      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)\n	      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)\n	      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)\n	\n	      a = safe_add(a, olda)\n	      b = safe_add(b, oldb)\n	      c = safe_add(c, oldc)\n	      d = safe_add(d, oldd)\n	    }\n	    return [a, b, c, d]\n	  }\n	\n	  /*\n	  * Convert an array of little-endian words to a string\n	  */\n	  function binl2rstr (input) {\n	    var i\n	    var output = ''\n	    for (i = 0; i < input.length * 32; i += 8) {\n	      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)\n	    }\n	    return output\n	  }\n	\n	  /*\n	  * Convert a raw string to an array of little-endian words\n	  * Characters >255 have their high-byte silently ignored.\n	  */\n	  function rstr2binl (input) {\n	    var i\n	    var output = []\n	    output[(input.length >> 2) - 1] = undefined\n	    for (i = 0; i < output.length; i += 1) {\n	      output[i] = 0\n	    }\n	    for (i = 0; i < input.length * 8; i += 8) {\n	      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)\n	    }\n	    return output\n	  }\n	\n	  /*\n	  * Calculate the MD5 of a raw string\n	  */\n	  function rstr_md5 (s) {\n	    return binl2rstr(binl_md5(rstr2binl(s), s.length * 8))\n	  }\n	\n	  /*\n	  * Calculate the HMAC-MD5, of a key and some data (raw strings)\n	  */\n	  function rstr_hmac_md5 (key, data) {\n	    var i\n	    var bkey = rstr2binl(key)\n	    var ipad = []\n	    var opad = []\n	    var hash\n	    ipad[15] = opad[15] = undefined\n	    if (bkey.length > 16) {\n	      bkey = binl_md5(bkey, key.length * 8)\n	    }\n	    for (i = 0; i < 16; i += 1) {\n	      ipad[i] = bkey[i] ^ 0x36363636\n	      opad[i] = bkey[i] ^ 0x5C5C5C5C\n	    }\n	    hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n	    return binl2rstr(binl_md5(opad.concat(hash), 512 + 128))\n	  }\n	\n	  /*\n	  * Convert a raw string to a hex string\n	  */\n	  function rstr2hex (input) {\n	    var hex_tab = '0123456789abcdef'\n	    var output = ''\n	    var x\n	    var i\n	    for (i = 0; i < input.length; i += 1) {\n	      x = input.charCodeAt(i)\n	      output += hex_tab.charAt((x >>> 4) & 0x0F) +\n	      hex_tab.charAt(x & 0x0F)\n	    }\n	    return output\n	  }\n	\n	  /*\n	  * Encode a string as utf-8\n	  */\n	  function str2rstr_utf8 (input) {\n	    return unescape(encodeURIComponent(input))\n	  }\n	\n	  /*\n	  * Take string arguments and return either raw or hex encoded strings\n	  */\n	  function raw_md5 (s) {\n	    return rstr_md5(str2rstr_utf8(s))\n	  }\n	  function hex_md5 (s) {\n	    return rstr2hex(raw_md5(s))\n	  }\n	  function raw_hmac_md5 (k, d) {\n	    return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))\n	  }\n	  function hex_hmac_md5 (k, d) {\n	    return rstr2hex(raw_hmac_md5(k, d))\n	  }\n	\n	  function md5 (string, key, raw) {\n	    if (!key) {\n	      if (!raw) {\n	        return hex_md5(string)\n	      }\n	      return raw_md5(string)\n	    }\n	    if (!raw) {\n	      return hex_hmac_md5(key, string)\n	    }\n	    return raw_hmac_md5(key, string)\n	  }\n	\n	  if (true) {\n	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n	      return md5\n	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n	  } else if (typeof module === 'object' && module.exports) {\n	    module.exports = md5\n	  } else {\n	    $.md5 = md5\n	  }\n	}(this))\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n	\n	/*!\n	 * EventEmitter v5.0.0 - git.io/ee\n	 * Unlicense - http://unlicense.org/\n	 * Oliver Caldwell - http://oli.me.uk/\n	 * @preserve\n	 */\n	\n	/**\n	 * Class for managing events.\n	 * Can be extended to provide event functionality in other classes.\n	 *\n	 * @class EventEmitter Manages event registering and emitting.\n	 */\n	function EventEmitter() {}\n	\n	// Shortcuts to improve speed and size\n	var proto = EventEmitter.prototype;\n	\n	/**\n	 * Finds the index of the listener for the event in its storage array.\n	 *\n	 * @param {Function[]} listeners Array of listeners to search through.\n	 * @param {Function} listener Method to look for.\n	 * @return {Number} Index of the specified listener, -1 if not found\n	 * @api private\n	 */\n	function indexOfListener(listeners, listener) {\n	    var i = listeners.length;\n	    while (i--) {\n	        if (listeners[i].listener === listener) {\n	            return i;\n	        }\n	    }\n	\n	    return -1;\n	}\n	\n	/**\n	 * Alias a method while keeping the context correct, to allow for overwriting of target method.\n	 *\n	 * @param {String} name The name of the target method.\n	 * @return {Function} The aliased method\n	 * @api private\n	 */\n	function alias(name) {\n	    return function aliasClosure() {\n	        return this[name].apply(this, arguments);\n	    };\n	}\n	\n	/**\n	 * Returns the listener array for the specified event.\n	 * Will initialise the event object and listener arrays if required.\n	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n	 * Each property in the object response is an array of listener functions.\n	 *\n	 * @param {String|RegExp} evt Name of the event to return the listeners from.\n	 * @return {Function[]|Object} All listener functions for the event.\n	 */\n	proto.getListeners = function getListeners(evt) {\n	    var events = this._getEvents();\n	    var response;\n	    var key;\n	\n	    // Return a concatenated array of all matching events if\n	    // the selector is a regular expression.\n	    if (evt instanceof RegExp) {\n	        response = {};\n	        for (key in events) {\n	            if (events.hasOwnProperty(key) && evt.test(key)) {\n	                response[key] = events[key];\n	            }\n	        }\n	    } else {\n	        response = events[evt] || (events[evt] = []);\n	    }\n	\n	    return response;\n	};\n	\n	/**\n	 * Takes a list of listener objects and flattens it into a list of listener functions.\n	 *\n	 * @param {Object[]} listeners Raw listener objects.\n	 * @return {Function[]} Just the listener functions.\n	 */\n	proto.flattenListeners = function flattenListeners(listeners) {\n	    var flatListeners = [];\n	    var i;\n	\n	    for (i = 0; i < listeners.length; i += 1) {\n	        flatListeners.push(listeners[i].listener);\n	    }\n	\n	    return flatListeners;\n	};\n	\n	/**\n	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n	 *\n	 * @param {String|RegExp} evt Name of the event to return the listeners from.\n	 * @return {Object} All listener functions for an event in an object.\n	 */\n	proto.getListenersAsObject = function getListenersAsObject(evt) {\n	    var listeners = this.getListeners(evt);\n	    var response;\n	\n	    if (listeners instanceof Array) {\n	        response = {};\n	        response[evt] = listeners;\n	    }\n	\n	    return response || listeners;\n	};\n	\n	/**\n	 * Adds a listener function to the specified event.\n	 * The listener will not be added if it is a duplicate.\n	 * If the listener returns true then it will be removed after it is called.\n	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to attach the listener to.\n	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.addListener = function addListener(evt, listener) {\n	    var listeners = this.getListenersAsObject(evt);\n	    var listenerIsWrapped = (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object';\n	    var key;\n	\n	    for (key in listeners) {\n	        if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n	            listeners[key].push(listenerIsWrapped ? listener : {\n	                listener: listener,\n	                once: false\n	            });\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of addListener\n	 */\n	proto.on = alias('addListener');\n	\n	/**\n	 * Semi-alias of addListener. It will add a listener that will be\n	 * automatically removed after its first execution.\n	 *\n	 * @param {String|RegExp} evt Name of the event to attach the listener to.\n	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.addOnceListener = function addOnceListener(evt, listener) {\n	    return this.addListener(evt, {\n	        listener: listener,\n	        once: true\n	    });\n	};\n	\n	/**\n	 * Alias of addOnceListener.\n	 */\n	proto.once = alias('addOnceListener');\n	\n	/**\n	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n	 * You need to tell it what event names should be matched by a regex.\n	 *\n	 * @param {String} evt Name of the event to create.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.defineEvent = function defineEvent(evt) {\n	    this.getListeners(evt);\n	    return this;\n	};\n	\n	/**\n	 * Uses defineEvent to define multiple events.\n	 *\n	 * @param {String[]} evts An array of event names to define.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.defineEvents = function defineEvents(evts) {\n	    for (var i = 0; i < evts.length; i += 1) {\n	        this.defineEvent(evts[i]);\n	    }\n	    return this;\n	};\n	\n	/**\n	 * Removes a listener function from the specified event.\n	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to remove the listener from.\n	 * @param {Function} listener Method to remove from the event.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.removeListener = function removeListener(evt, listener) {\n	    var listeners = this.getListenersAsObject(evt);\n	    var index;\n	    var key;\n	\n	    for (key in listeners) {\n	        if (listeners.hasOwnProperty(key)) {\n	            index = indexOfListener(listeners[key], listener);\n	\n	            if (index !== -1) {\n	                listeners[key].splice(index, 1);\n	            }\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of removeListener\n	 */\n	proto.off = alias('removeListener');\n	\n	/**\n	 * Adds listeners in bulk using the manipulateListeners method.\n	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n	 * You can also pass it a regular expression to add the array of listeners to all events that match it.\n	 * Yeah, this function does quite a bit. That's probably a bad thing.\n	 *\n	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n	 * @param {Function[]} [listeners] An optional array of listener functions to add.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.addListeners = function addListeners(evt, listeners) {\n	    // Pass through to manipulateListeners\n	    return this.manipulateListeners(false, evt, listeners);\n	};\n	\n	/**\n	 * Removes listeners in bulk using the manipulateListeners method.\n	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n	 * You can also pass it an event name and an array of listeners to be removed.\n	 * You can also pass it a regular expression to remove the listeners from all events that match it.\n	 *\n	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n	 * @param {Function[]} [listeners] An optional array of listener functions to remove.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.removeListeners = function removeListeners(evt, listeners) {\n	    // Pass through to manipulateListeners\n	    return this.manipulateListeners(true, evt, listeners);\n	};\n	\n	/**\n	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n	 * The first argument will determine if the listeners are removed (true) or added (false).\n	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n	 * You can also pass it an event name and an array of listeners to be added/removed.\n	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n	 *\n	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n	    var i;\n	    var value;\n	    var single = remove ? this.removeListener : this.addListener;\n	    var multiple = remove ? this.removeListeners : this.addListeners;\n	\n	    // If evt is an object then pass each of its properties to this method\n	    if ((typeof evt === 'undefined' ? 'undefined' : _typeof(evt)) === 'object' && !(evt instanceof RegExp)) {\n	        for (i in evt) {\n	            if (evt.hasOwnProperty(i) && (value = evt[i])) {\n	                // Pass the single listener straight through to the singular method\n	                if (typeof value === 'function') {\n	                    single.call(this, i, value);\n	                } else {\n	                    // Otherwise pass back to the multiple function\n	                    multiple.call(this, i, value);\n	                }\n	            }\n	        }\n	    } else {\n	        // So evt must be a string\n	        // And listeners must be an array of listeners\n	        // Loop over it and pass each one to the multiple method\n	        i = listeners.length;\n	        while (i--) {\n	            single.call(this, evt, listeners[i]);\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Removes all listeners from a specified event.\n	 * If you do not specify an event then all listeners will be removed.\n	 * That means every event will be emptied.\n	 * You can also pass a regex to remove all events that match it.\n	 *\n	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.removeEvent = function removeEvent(evt) {\n	    var type = typeof evt === 'undefined' ? 'undefined' : _typeof(evt);\n	    var events = this._getEvents();\n	    var key;\n	\n	    // Remove different things depending on the state of evt\n	    if (type === 'string') {\n	        // Remove all listeners for the specified event\n	        delete events[evt];\n	    } else if (evt instanceof RegExp) {\n	        // Remove all events matching the regex.\n	        for (key in events) {\n	            if (events.hasOwnProperty(key) && evt.test(key)) {\n	                delete events[key];\n	            }\n	        }\n	    } else {\n	        // Remove all listeners in all events\n	        delete this._events;\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of removeEvent.\n	 *\n	 * Added to mirror the node API.\n	 */\n	proto.removeAllListeners = alias('removeEvent');\n	\n	/**\n	 * Emits an event of your choice.\n	 * When emitted, every listener attached to that event will be executed.\n	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n	 * So they will not arrive within the array on the other side, they will be separate.\n	 * You can also pass a regular expression to emit to all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n	 * @param {Array} [args] Optional array of arguments to be passed to each listener.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.emitEvent = function emitEvent(evt, args) {\n	    var listenersMap = this.getListenersAsObject(evt);\n	    var listeners;\n	    var listener;\n	    var i;\n	    var key;\n	    var response;\n	\n	    for (key in listenersMap) {\n	        if (listenersMap.hasOwnProperty(key)) {\n	            listeners = listenersMap[key].slice(0);\n	\n	            for (i = 0; i < listeners.length; i++) {\n	                // If the listener returns true then it shall be removed from the event\n	                // The function is executed either with a basic call or an apply if there is an args array\n	                listener = listeners[i];\n	\n	                if (listener.once === true) {\n	                    this.removeListener(evt, listener.listener);\n	                }\n	\n	                response = listener.listener.apply(this, args || []);\n	\n	                if (response === this._getOnceReturnValue()) {\n	                    this.removeListener(evt, listener.listener);\n	                }\n	            }\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of emitEvent\n	 */\n	proto.trigger = alias('emitEvent');\n	\n	/**\n	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n	 * @param {...*} Optional additional arguments to be passed to each listener.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.emit = function emit(evt) {\n	    var args = Array.prototype.slice.call(arguments, 1);\n	    return this.emitEvent(evt, args);\n	};\n	\n	/**\n	 * Sets the current value to check against when executing listeners. If a\n	 * listeners return value matches the one set here then it will be removed\n	 * after execution. This value defaults to true.\n	 *\n	 * @param {*} value The new value to check for when executing listeners.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.setOnceReturnValue = function setOnceReturnValue(value) {\n	    this._onceReturnValue = value;\n	    return this;\n	};\n	\n	/**\n	 * Fetches the current value to check against when executing listeners. If\n	 * the listeners return value matches this one then it should be removed\n	 * automatically. It will return true by default.\n	 *\n	 * @return {*|Boolean} The current value to check for or the default, true.\n	 * @api private\n	 */\n	proto._getOnceReturnValue = function _getOnceReturnValue() {\n	    if (this.hasOwnProperty('_onceReturnValue')) {\n	        return this._onceReturnValue;\n	    } else {\n	        return true;\n	    }\n	};\n	\n	/**\n	 * Fetches the events object and creates one if required.\n	 *\n	 * @return {Object} The events storage object.\n	 * @api private\n	 */\n	proto._getEvents = function _getEvents() {\n	    return this._events || (this._events = {});\n	};\n	\n	exports.default = EventEmitter;\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map",
template:'<div>\n    <div data-info=auth-panel></div>\n    <div class="rc-panel main" data-info=main-panel hidden>\n        <div class=rc-panel__header>\n            <img class=logo src=./ringcentral_logo.png>\n            \n        </div>\n    </div>\n    <div class="rc-panel__content rc-panel__content--full">\n        <p data-info=waiting>\n            Waiting for incoming call.\n        </p>\n        <div id=call-panel></div>\n        <div id=call-panel-incoming></div>\n    </div>\n</div>',style:"\n    rc-phone-incontact .main {\n        text-align: center;\n    }\n    rc-phone-incontact .logo {\n        width: 80%;\n    }\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!0}},__w_widgets["rc-phone"]={script:"/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = \"\";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	function _interopRequireDefault(t) {\n	  return t && t.__esModule ? t : { \"default\": t };\n	}var _extends = Object.assign || function (t) {\n	  for (var e = 1; e < arguments.length; e++) {\n	    var o = arguments[e];for (var a in o) {\n	      Object.prototype.hasOwnProperty.call(o, a) && (t[a] = o[a]);\n	    }\n	  }return t;\n	},\n	    _factory = __webpack_require__(2),\n	    _factory2 = _interopRequireDefault(_factory),\n	    _eventemitter = __webpack_require__(64),\n	    _eventemitter2 = _interopRequireDefault(_eventemitter);w.register(function () {\n	  function t(t, o) {\n	    var a = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],\n	        i = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];return w(\"conversation-advanced\", { data: _extends({}, a, { \"new\": !0, contact: t }), actions: e.create(\"conversation-advanced\", _extends({}, i, { back: { after: function after() {\n	            this.unmount(), o && \"function\" == typeof o && o();\n	          } } })) });\n	  }var e = new _factory2[\"default\"]();this.data = { width: 250, originalHeight: 400 }, this.props = { panels: [], width: 250, originalHeight: 400, minimizedHeight: 100, height: 400, toolbarHeight: 40, key: null, secret: null, ee: new _eventemitter2[\"default\"]() }, this.actions = e.create(\"rcPhone\", { on: { method: function method(t, e, o) {\n	        this.props.ee.on(e, o);\n	      } }, resize: { before: function before() {}, after: function after(t) {\n	        var e;e = t ? t : this.props.height === this.props.minimizedHeight ? this.props.originalHeight : this.props.minimizedHeight, this.props.ee.trigger(\"resize\", [this.props.width, e]);\n	      } }, setSize: { method: function method(t, e, o) {\n	        this.props.width = e, this.props.height = o, this.dom.phone.style.width = this.props.width + \"px\", this.dom.phone.style.height = this.props.height + \"px\";\n	      } }, init: { before: function before() {\n	        this.props.cachedMessageHours = 168, this.props.originalHeight = this.data.originalHeight, this.props.width = this.data.width, this.props.key = this.data.key, this.props.secret = this.data.secret, this.props.sandbox = \"true\" === this.data.sandbox, this.setSize(this.props.width, this.props.originalHeight), this.dom.toolbar.style.height = this.props.toolbarHeight + \"px\", this.dom[\"auth-panel\"].style.width = this.props.width + \"px\", this.dom[\"auth-panel\"].style.height = this.props.height + \"px\", this.createWidgets();\n	      } }, createWidgets: { method: function method() {\n	        var o = this,\n	            a = this,\n	            i = this.props.height;if (this.props.conversation = void 0, this.props.contactDetail = void 0, this.props.notification = w(\"notification\", {}), this.data.firstLevel) {\n	          var n = this.data.firstLevel.split(\",\");if (this.props.authPanel = w(\"auth-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { oauth: !0 }), actions: e.create(\"auth-panel\", { login: { after: function after() {\n	                  this.unmount(), a.loadData(), n.length > 1 ? a.data.shadowRoot ? a.props.toolbar.mount(a.data.shadowRoot.querySelector(\"#toolbar\")) : a.props.toolbar.mount(\"#toolbar\") : (a.props.panels[0].mount(\"#first-level-0\"), a.dom.toolbar.parentNode.removeChild(a.dom.toolbar)), a.dom[\"auth-panel\"].style[\"z-index\"] = \"-1\";\n	                } } }) }), console.log(n.length), console.log(i), n.length > 1) {\n	            var s = this.props.toolbar = w(\"tool-bar\", { shadowRoot: a.data.shadowRoot, data: a.data, actions: { mount: { after: function after() {\n	                    a.props.panels[0].mount(\"#first-level-0\");\n	                  } } } });i = this.props.height - this.props.toolbarHeight;\n	          } else 1 === n.length && (this.props.minimizedHeight = this.props.minimizedHeight - this.props.toolbarHeight);n.forEach(function (r, p) {\n	            var l;if (\"call-log\" === r ? (l = o.props.callLog = w(\"call-log\", { shadowRoot: a.data.shadowRoot, actions: e.create(\"call-log\") }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uniC8\"></span><span class=\"icon-RC_shapes_2-30_pressed\"></span>'), a.switchWidgets(panel, \"#first-level\" + p, p))) : \"time-line\" === r ? (o.props.callPanel || (o.props.callPanel = w(\"call-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { target: \"#call-panel\", width: o.props.width, height: i }), actions: e.create(\"call-panel\") })), l = o.props.timeline = w(\"time-line\", { shadowRoot: a.data.shadowRoot, actions: e.create(\"time-line\", { search: { method: function method() {\n	                    contacts.dom.searchText.value = this.dom.searchText.value, contacts.search();\n	                  } }, enterItem: { after: function after() {\n	                    var e = this,\n	                        o = this.props.selectedContent.contact,\n	                        n = o.phoneNumber[0];this.props.currentConv = t(o, function () {\n	                      e.props.currentConv.unmount();\n	                    }, { width: a.props.width, height: i, toNumber: n, anchorContent: this.props.selectedContent, remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }, { callout: { after: function after() {\n	                          a.props.callPanel.setName(this.props.toNumber);\n	                        } } }), this.props.currentConv.mount(\"#conversation\");\n	                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uni2487\"></span></span><span class=\"icon-RC_shapes_1_30_pressed\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"contacts\" === r ? (l = o.props.contacts = w(\"contacts\", { shadowRoot: a.data.shadowRoot, data: {}, actions: e.create(\"contacts\", { selectContact: { method: function method() {\n	                    var e = this.props.relateContacts && this.props.relateContacts[this.props.selectedContact.id] || this.props.contacts[this.props.selectedContact.id],\n	                        o = a.props.timeline.props.currentConv = t(e, function () {\n	                      a.props.timeline.mount(\"#contact-detail\");\n	                    });o.mount(\"#contact-detail\");\n	                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uni7D\"></span><span class=\"icon-contact_info_pressed\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"dial-pad\" === r ? (o.props.callPanel || (o.props.callPanel = w(\"call-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { target: \"#call-panel\", width: o.props.width, height: i }), actions: e.create(\"call-panel\") })), l = o.props.dialPad = w(\"dial-pad\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }), actions: e.create(\"dial-pad\", { mount: { after: function after() {\n	                    var t = !1;[\"RTCPeerConnection\", \"webkitRTCPeerConnection\", \"mozRTCPeerConnection\", \"RTCIceGatherer\"].forEach(function (e) {\n	                      t || (t = e in window);\n	                    }), t || this.disable(\"This browser does not support WebRTC.\");\n	                  } }, callout: { after: function after() {\n	                    a.props.callPanel.setName(this.props.toNumber);\n	                  } }, numberChange: { after: function after() {\n	                    a.props.ee.trigger(\"dialing\", [this.props.toNumber]);\n	                  } } }) }), o.props.callPanelIncoming = w(\"call-panel-incoming\", { shadowRoot: a.data.shadowRoot, data: _extends({ target: \"#call-panel-incoming\" }, a.data, { width: o.props.width, height: i, remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }), actions: e.create(\"call-panel-incoming\", { mount: { after: function after() {\n	                    a.props.height === a.props.minimizedHeight ? this.simplify(!0) : this.simplify(!1), a.resize(Math.max(280, a.props.height));\n	                  } }, unmount: { after: function after() {\n	                    a.props.height !== a.props.originalHeight && a.resize(a.props.minimizedHeight);\n	                  } }, accept: { after: function after() {\n	                    this.unmount(), a.props.callPanel.setName(this.props.name), a.props.callPanel.mount(\"#call-panel\"), a.props.callPanel.start(), a.resize(a.props.originalHeight);\n	                  } }, ignore: { after: function after() {\n	                    a.resize(a.props.minimizedHeight);\n	                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uniA4\"></span><span class=\"icon-RC_shapes_1-40_pressed\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"conference\" === r ? (l = o.props.conference = w(\"conference\", { data: a.data, actions: e.create(\"conference\", { inviteWithText: { method: function method() {} }, joinAsHost: { method: function method() {\n	                    a.dom.container.style.transform = \"translateX(0px)\", a.props.dialPad.mount(\"#dial-pad\"), a.props.dialPad.number(a.props.conference.props.dialInNumber);\n	                  } } }) }), n.length > 1 && s.clickItem(s.addItem('<span class=\"icon-uniA3\"></span>'), a.switchWidgets(l, \"#first-level\" + p, p))) : \"call-panel-incoming\" === r && (o.props.callPanel = w(\"call-panel\", { shadowRoot: a.data.shadowRoot, data: _extends({}, a.data, { target: \"#call-panel\", width: o.props.width, height: i }), actions: e.create(\"call-panel\") }), o.props.callPanelIncoming = w(\"call-panel-incoming\", { shadowRoot: a.data.shadowRoot, data: _extends({ target: \"#call-panel-incoming\" }, a.data, { width: o.props.width, height: i, remoteVideo: a.props.callPanel.props.remoteVideo, localVideo: a.props.callPanel.props.localVideo }), actions: e.create(\"call-panel-incoming\", { mount: { after: function after() {\n	                    a.props.height === a.props.minimizedHeight ? this.simplify(!0) : this.simplify(!1), a.resize(Math.max(250, a.props.height));\n	                  } }, unmount: { after: function after() {\n	                    a.props.height != a.props.originalHeight && a.resize(a.props.minimizedHeight);\n	                  } }, accept: { after: function after() {\n	                    this.unmount(), a.props.callPanel.setName(this.props.name), a.props.callPanel.mount(\"#call-panel\"), a.props.callPanel.start(), a.resize(a.props.originalHeight);\n	                  } }, ignore: { after: function after() {\n	                    a.resize(a.props.minimizedHeight);\n	                  } } }) })), l) {\n	              o.props.panels.push(l);var h = document.createElement(\"div\");h.classList.add(\"panel\"), h.classList.add(\"float-left\"), h.style.width = o.props.width + \"px\", h.style.height = o.props.height + \"px\", n.length > 1 && (h.style.height = o.props.height - o.props.toolbarHeight + \"px\"), h.setAttribute(\"id\", \"first-level-\" + (o.props.panels.length - 1)), o.dom.container.appendChild(h);\n	            }\n	          });\n	        }\n	      } }, switchWidgets: { method: function method(t, e, o, a) {\n	        var i = this;return function () {\n	          if (i.props.conversation && (i.props.conversation.destroy(), i.props.conversation = null), i.props.contactDetail && (i.props.contactDetail.destroy(), i.props.contactDetail = null), i.props.callPanel && i.props.callPanel._mounted && i.props.callPanel.minimize(), i.props.currentIndex !== a && !i.props.isTranistioning) {\n	            var t = function o(t) {\n	              i.props.panels.filter(function (t, e) {\n	                return e !== a;\n	              }).forEach(function (t) {\n	                return t.unmount();\n	              }), i.dom.container.removeEventListener(\"transitionend\", o), i.props.isTranistioning = !1;\n	            };i.props.isTranistioning = !0, i.props.currentIndex = a, i.dom.container.style.transform = \"translateX(\" + (0 - a * i.props.width) + \"px)\", i.dom.container.addEventListener(\"transitionend\", t), e.mount(\"#first-level-\" + a);\n	          }\n	        };\n	      } }, mount: { after: function after() {\n	        var t = this;this.checkLogin().then(function (e) {\n	          e ? (t.loadData(), 1 === t.props.panels.length ? (t.props.panels[0].mount(\"#first-level-0\"), t.dom.toolbar.parentNode.removeChild(t.dom.toolbar)) : 0 === t.props.panels.length ? t.dom.toolbar.parentNode.removeChild(t.dom.toolbar) : t.data.shadowRoot ? t.props.toolbar.mount(phone.data.shadowRoot.querySelector(\"#toolbar\")) : t.props.toolbar.mount(\"#toolbar\"), t.dom[\"auth-panel\"].style[\"z-index\"] = \"-1\") : t.data.shadowRoot ? t.props.authPanel.mount(t.data.shadowRoot.querySelector(\"#auth-panel\")) : t.props.authPanel.mount(\"#auth-panel\");\n	        }), this.props.ee.trigger(\"ready\");\n	      } }, logout: { after: function after() {\n	        this.props.authPanel.mount(this.dom[\"auth-panel\"]), this.dom[\"auth-panel\"].style[\"z-index\"] = \"5\", this.props.toolbar.unmount(), this.props.panels.forEach(function (t) {\n	          return t.unmount();\n	        }), this.props.currentIndex = 0, this.dom.container.style.transform = \"translateX(0px)\";\n	      } } }), this.on(\"click\", function (t) {\n	    t.target === this.dom.resize && this.resize(), t.target === this.dom.remove ? (this.props.ee.trigger(\"unmount\"), this.unmount()) : t.target === this.dom.logout && this.logout();\n	  });\n	});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcServices = __webpack_require__(3);\n	\n	var _rcServices2 = _interopRequireDefault(_rcServices);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function extend(base, mixin) {\n	    // FIXME: avoid create function in for loop\n	    Object.keys(mixin).forEach(function (action) {\n	        if (base[action]) {\n	            Object.keys(mixin[action]).forEach(function (hook) {\n	                var origin = base[action][hook];\n	                var mix = mixin[action][hook];\n	                base[action][hook] = function () {\n	                    var result;\n	                    if (origin) {\n	                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n	                            args[_key] = arguments[_key];\n	                        }\n	\n	                        result = origin.call.apply(origin, [this].concat(args));\n	                    }\n	                    mix.call(this);\n	                    return result;\n	                };\n	            });\n	        } else {\n	            base[action] = mixin[action];\n	        }\n	    });\n	    return base;\n	} // TODO: use dependency injection\n	\n	\n	var Factory = function Factory() {};\n	\n	Factory.prototype.create = function (type) {\n	    var mixin = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n	\n	    return extend(_rcServices2.default[type], mixin);\n	};\n	\n	exports.default = Factory;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _phoneService = __webpack_require__(12);\n	\n	var _phoneService2 = _interopRequireDefault(_phoneService);\n	\n	var _loginService = __webpack_require__(51);\n	\n	var _loginService2 = _interopRequireDefault(_loginService);\n	\n	var _callLogService = __webpack_require__(52);\n	\n	var _callLogService2 = _interopRequireDefault(_callLogService);\n	\n	var _accountService = __webpack_require__(54);\n	\n	var _accountService2 = _interopRequireDefault(_accountService);\n	\n	var _rcContactService = __webpack_require__(55);\n	\n	var _rcContactService2 = _interopRequireDefault(_rcContactService);\n	\n	var _contactSearchService = __webpack_require__(57);\n	\n	var _contactSearchService2 = _interopRequireDefault(_contactSearchService);\n	\n	var _rcContactSearchProvider = __webpack_require__(58);\n	\n	var _rcContactSearchProvider2 = _interopRequireDefault(_rcContactSearchProvider);\n	\n	var _rcMessageService = __webpack_require__(59);\n	\n	var _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n	\n	var _rcMessageProvider = __webpack_require__(60);\n	\n	var _rcMessageProvider2 = _interopRequireDefault(_rcMessageProvider);\n	\n	var _rcConferenceService = __webpack_require__(61);\n	\n	var _rcConferenceService2 = _interopRequireDefault(_rcConferenceService);\n	\n	var _rcConversationService = __webpack_require__(62);\n	\n	var _rcConversationService2 = _interopRequireDefault(_rcConversationService);\n	\n	var _blueimpMd = __webpack_require__(63);\n	\n	var _blueimpMd2 = _interopRequireDefault(_blueimpMd);\n	\n	var _rcConfig = __webpack_require__(11);\n	\n	var _rcConfig2 = _interopRequireDefault(_rcConfig);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n	\n	var dialPadSearchProviders = [_rcContactSearchProvider2.default];\n	\n	var services = {};\n	services['incontact'] = {\n	    init: {\n	        after: function after() {\n	            /// critical, inject app key & secret into service\n	            (0, _rcSdk.injectSDK)({\n	                key: this.props.key,\n	                secret: this.props.secret,\n	                sandbox: this.props.sandbox\n	            });\n	            _phoneService2.default.init({\n	                incomingAudio: _rcConfig2.default.incomingAudio,\n	                outgoingAudio: _rcConfig2.default.outgoingAudio\n	            });\n	        }\n	    },\n	    checkLogin: {\n	        method: function method() {\n	            return _loginService2.default.checkLoginStatus();\n	        }\n	    }\n	};\n	services['rcPhone'] = {\n	    init: {\n	        after: function after() {\n	            /// critical, inject app key & secret into service\n	            (0, _rcSdk.injectSDK)({\n	                key: this.props.key,\n	                secret: this.props.secret,\n	                sandbox: this.props.sandbox\n	            });\n	        }\n	    },\n	    loadData: {\n	        method: function method() {\n	            _rcMessageService2.default.subscribeToMessageUpdate();\n	            // rcMessageService.syncMessages(this.props.cachedMessageHours);\n	            _accountService2.default.getAccountInfo();\n	            _accountService2.default.getPhoneNumber();\n	            _rcContactService2.default.cacheContacts();\n	            _phoneService2.default.init({\n	                incomingAudio: _rcConfig2.default.incomingAudio,\n	                outgoingAudio: _rcConfig2.default.outgoingAudio\n	            });\n	            _callLogService2.default.getCallLogs();\n	        }\n	    },\n	    checkLogin: {\n	        method: function method() {\n	            return _loginService2.default.checkLoginStatus();\n	        }\n	    },\n	    logout: {\n	        method: function method() {\n	            return _loginService2.default.logout();\n	        }\n	    }\n	};\n	services['auth-panel'] = {\n	    login: {\n	        method: function method() {\n	            // return loginService.login(\n	            //     this.props.username,\n	            //     this.props.extension,\n	            //     this.props.password\n	            // )\n	            return _loginService2.default.oauth();\n	        }\n	    }\n	};\n	services['dial-pad'] = {\n	    mount: {\n	        after: function after() {\n	            if (!_accountService2.default.hasServiceFeature('VoipCalling')) this.disable();\n	        }\n	    },\n	    callout: {\n	        method: function method() {\n	            console.log('real call');\n	            return _phoneService2.default.call(this.props.fromNumber, this.props.toNumber, {\n	                remoteVideo: this.props.remoteVideo,\n	                localVideo: this.props.localVideo\n	            });\n	        }\n	    },\n	    queryContacts: {\n	        method: function method() {\n	            var _this = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this.props.toNumber);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    },\n	    getOutboundCallerID: {\n	        method: function method() {\n	            return _accountService2.default.getPhoneNumber().then(function () {\n	                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n	            });\n	        }\n	    }\n	};\n	\n	services['conference'] = {\n	    getConferenceInfo: {\n	        method: function method() {\n	            return _rcConferenceService2.default.getConferenceInfo();\n	        }\n	    }\n	};\n	services['call-log'] = {\n	    init: {\n	        method: function method() {\n	            return _callLogService2.default.getCallLogs();\n	        }\n	    }\n	};\n	\n	services['time-line'] = {\n	    mount: {\n	        after: function after() {\n	            var _this2 = this;\n	\n	            _rcMessageService2.default.subscribeToMessageUpdate();\n	            _rcMessageProvider2.default.onMessageUpdated(function (msg) {\n	                _this2.updateTimeline(_rcConversationService2.default.syncContent(_this2.props.contacts, msg));\n	                if (_this2.props.currentConv) {\n	                    _this2.props.currentConv.confirmMessages();\n	                    _this2.props.currentConv.addIncomingMessages();\n	                }\n	            });\n	            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n	                return _this2.props.contacts = contacts;\n	            });\n	        }\n	    },\n	    fetchData: {\n	        method: function method() {\n	            return Promise.all([_rcContactService2.default.cacheContacts(), // first one must be the contacts\n	            _rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs()]).then(function (result) {\n	                return _rcConversationService2.default.organizeContent.apply(_rcConversationService2.default, _toConsumableArray(result));\n	            });\n	        }\n	    }\n	};\n	\n	services['contacts'] = {\n	    mount: {\n	        after: function after() {\n	            this.fetchContacts();\n	        }\n	    },\n	    fetchRelatedContact: {\n	        method: function method() {\n	            var _this3 = this;\n	\n	            return Promise.all([_rcMessageService2.default.syncMessages(_rcConversationService2.default.cachedHour), _callLogService2.default.getCallLogs(), _rcContactService2.default.cacheContacts()]).then(function (result) {\n	                var _result = _slicedToArray(result, 3);\n	\n	                var msgs = _result[0];\n	                var logs = _result[1];\n	                var contacts = _result[2];\n	\n	                _this3.props.contacts = contacts.reduce(function (result, contact) {\n	                    result[contact.id] = contact;\n	                    return result;\n	                }, {});\n	                return _rcConversationService2.default.getConversations(contacts, msgs, logs);\n	            }).then(function (relateContacts) {\n	                _this3.props.relateContacts = relateContacts;\n	                return relateContacts;\n	            }).then(function (relateContacts) {\n	                return Object.keys(relateContacts).map(function (index) {\n	                    // adapt to messages template format\n	                    relateContacts[index].msg[0].contact = relateContacts[index].displayName;\n	                    // for conversation-advance temaplate\n	                    relateContacts[index].msg[0].contactId = index;\n	                    return relateContacts[index].msg[0];\n	                });\n	            });\n	        }\n	    },\n	    fetchContacts: {\n	        method: function method() {\n	            var _this4 = this;\n	\n	            // var dialPadSearchFunctions = dialPadSearchProviders.map(provider => {\n	            //     return provider.searchAll();\n	            // });\n	            // return contactSearchService.query(dialPadSearchFunctions);\n	            return _rcContactService2.default.cacheContacts().then(function (contacts) {\n	                _this4.props.contacts = contacts.reduce(function (result, contact) {\n	                    result[contact.id] = contact;\n	                    return result;\n	                }, {});\n	                return contacts.map(function (contact) {\n	                    return {\n	                        name: contact.displayName,\n	                        type: 'rc',\n	                        id: contact.id\n	                    };\n	                });\n	            }).catch(function (e) {\n	                return console.error(e);\n	            });\n	        }\n	    }\n	};\n	\n	services['conversation-advanced'] = {\n	    init: {\n	        after: function after() {}\n	    },\n	    mount: {\n	        after: function after() {\n	            var _this5 = this;\n	\n	            console.log('get account info');\n	            return _accountService2.default.getAccountInfo().then(function (info) {\n	                return _this5.props.fromExtension = info.extensionNumber;\n	            }).then(function () {\n	                _this5.setOutboundCallerID();\n	            });\n	        }\n	    },\n	    send: {\n	        method: function method() {\n	            if (this.props.toNumber === this.props.toExtension) {\n	                return _rcMessageService2.default.sendPagerMessage(this.props.message, this.props.fromExtension, this.props.toExtension);\n	            } else {\n	                return _rcMessageService2.default.sendSMSMessage(this.props.message, this.props.fromNumber, this.props.toNumber);\n	            }\n	        }\n	    },\n	    callout: {\n	        method: function method() {\n	            return _phoneService2.default.call(this.props.fromNumber, this.props.toNumber, {\n	                remoteVideo: this.props.remoteVideo,\n	                localVideo: this.props.localVideo\n	            });\n	        }\n	    },\n	    reachTop: {\n	        method: function method() {\n	            console.log('load content');\n	            return _rcConversationService2.default.loadContent(this.props.contact, this.props.loadingPeriod);\n	        }\n	    },\n	    getAvatar: {\n	        method: function method() {\n	            var _this6 = this;\n	\n	            if (!this.props.profileImage) return Promise.resolve('https://www.gravatar.com/avatar/' + (0, _blueimpMd2.default)(this.props.contact.id) + '?d=retro');\n	            return _rcSdk.RC.sdk.platform().get(this.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken())).then(function (r) {\n	                return r.response();\n	            }).then(function (r) {\n	                // Real contact, no avatar\n	                if (r.status === 204 || r.status === 404) {\n	                    var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n	                    return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n	                } else {\n	                    // Real contact, has avatar\n	                    return;\n	                    _this6.props.profileImage + ('?access_token=' + _rcContactService2.default.accessToken());\n	                }\n	            }).catch(function (e) {\n	                // Real contact, no avatar\n	                var hash = (0, _blueimpMd2.default)(_this6.props.contact.id);\n	                return 'https://www.gravatar.com/avatar/' + hash + '?d=retro';\n	            });\n	        }\n	    },\n	    transformURL: {\n	        method: function method() {\n	            return this.props.transformee + ('?access_token=' + _rcContactService2.default.accessToken());\n	        }\n	    },\n	    getFileInfo: {\n	        method: function method() {\n	            console.log(this.props.fileURL);\n	            return _rcSdk.RC.sdk.platform().get(this.props.fileURL).then(function (r) {\n	                return r.json();\n	            });\n	        }\n	    },\n	    setOutboundCallerID: {\n	        method: function method() {\n	            return _accountService2.default.getPhoneNumber().then(function () {\n	                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n	            });\n	        }\n	    }\n	};\n	services['call-panel'] = {\n	    init: {\n	        after: function after() {\n	            var _this7 = this;\n	\n	            _phoneService2.default.on('progress', function () {\n	                if (!_this7._mounted) {\n	                    _this7.mount(_this7.props.target);\n	                }\n	            });\n	            _phoneService2.default.on('bye', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('terminated', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('rejected', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('failed', function () {\n	                _this7.unmount();\n	            });\n	            _phoneService2.default.on('accepted', function () {\n	                console.log('accept');\n	                _this7.start();\n	            });\n	        }\n	    },\n	    mount: {\n	        after: function after() {}\n	    },\n	    getContact: {\n	        method: function method() {\n	            var _this8 = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this8.props.name);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    },\n	    hangup: {\n	        method: function method() {\n	            return _phoneService2.default.hangup();\n	        }\n	    },\n	    hold: {\n	        method: function method() {\n	            return _phoneService2.default.hold(!this.props.isHold);\n	        }\n	    },\n	    mute: {\n	        method: function method() {\n	            return _phoneService2.default.mute(!this.props.isMute);\n	        }\n	    },\n	    flip: {\n	        method: function method() {\n	            return _phoneService2.default.flip(this.props.actionNumber);\n	        }\n	    },\n	    transfer: {\n	        method: function method() {\n	            return _phoneService2.default.transfer(this.props.actionNumber);\n	        }\n	    },\n	    record: {\n	        method: function method() {\n	            console.log(this.props.isRecord);\n	            return _phoneService2.default.record(!this.props.isRecord);\n	        }\n	    },\n	    park: {\n	        method: function method() {\n	            return _phoneService2.default.park();\n	        }\n	    },\n	    dtmf: {\n	        method: function method(number) {\n	            return _phoneService2.default.dtmf(this.props.dtmfNumber);\n	        }\n	    },\n	    queryContacts: {\n	        method: function method() {\n	            var _this9 = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this9.props.inputValue);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    },\n	    getOutboundCallerID: {\n	        method: function method() {\n	            return _accountService2.default.getPhoneNumber().then(function () {\n	                return _accountService2.default.listNumber('VoiceFax', 'CallerId');\n	            });\n	        }\n	    }\n	};\n	services['call-panel-incoming'] = {\n	    init: {\n	        method: function method() {\n	            var _this10 = this;\n	\n	            _phoneService2.default.on('invite', function (session) {\n	                _this10.props.session = session;\n	                var name = session.request.from.displayName || session.request.from.friendlyName.split(\"@\")[0];\n	                _this10.setName(name);\n	                _this10.mount(_this10.props.target);\n	                _phoneService2.default.on('terminated', function () {\n	                    _this10.unmount();\n	                });\n	                _phoneService2.default.on('failed', function () {\n	                    _this10.unmount();\n	                });\n	            });\n	        }\n	    },\n	    accept: {\n	        method: function method() {\n	            return _phoneService2.default.accept({\n	                remoteVideo: this.props.remoteVideo,\n	                localVideo: this.props.localVideo\n	            });\n	        }\n	    },\n	    reject: {\n	        method: function method() {\n	            return _phoneService2.default.reject();\n	        }\n	    },\n	    forward: {\n	        method: function method() {\n	            return _phoneService2.default.forward(this.props.actionNumber);\n	        }\n	    },\n	    queryContacts: {\n	        method: function method() {\n	            var _this11 = this;\n	\n	            var dialPadSearchFunctions = dialPadSearchProviders.map(function (provider) {\n	                return provider.search(_this11.props.inputValue);\n	            });\n	            return _contactSearchService2.default.query(dialPadSearchFunctions);\n	        }\n	    }\n	};\n	exports.default = services;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	exports.RC = exports.injectSDK = undefined;\n	\n	var _ringcentralBundle = __webpack_require__(5);\n	\n	var _ringcentralBundle2 = _interopRequireDefault(_ringcentralBundle);\n	\n	var _rcConfig = __webpack_require__(11);\n	\n	var _rcConfig2 = _interopRequireDefault(_rcConfig);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var holder = {};\n	\n	// for dependency injection\n	var sdk = function () {\n	    return holder.sdk;\n	}();\n	\n	var injectSDK = function injectSDK(_ref) {\n	    var key = _ref.key;\n	    var secret = _ref.secret;\n	    var sandbox = _ref.sandbox;\n	\n	    holder.sdk = new _ringcentralBundle2.default({\n	        appKey: key,\n	        appSecret: secret,\n	        server: sandbox ? _ringcentralBundle2.default.server.sandbox : _ringcentralBundle2.default.server.production\n	    });\n	};\n	exports.injectSDK = injectSDK;\n	exports.RC = holder;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {\n		if(true)\n			module.exports = factory();\n		else if(typeof define === 'function' && define.amd)\n			define([], factory);\n		else if(typeof exports === 'object')\n			exports[\"SDK\"] = factory();\n		else\n			root[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"SDK\"] = factory();\n	})(this, function() {\n	return /******/ (function(modules) { // webpackBootstrap\n	/******/ 	// The module cache\n	/******/ 	var installedModules = {};\n	/******/\n	/******/ 	// The require function\n	/******/ 	function __webpack_require__(moduleId) {\n	/******/\n	/******/ 		// Check if module is in cache\n	/******/ 		if(installedModules[moduleId])\n	/******/ 			return installedModules[moduleId].exports;\n	/******/\n	/******/ 		// Create a new module (and put it into the cache)\n	/******/ 		var module = installedModules[moduleId] = {\n	/******/ 			exports: {},\n	/******/ 			id: moduleId,\n	/******/ 			loaded: false\n	/******/ 		};\n	/******/\n	/******/ 		// Execute the module function\n	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n	/******/\n	/******/ 		// Flag the module as loaded\n	/******/ 		module.loaded = true;\n	/******/\n	/******/ 		// Return the exports of the module\n	/******/ 		return module.exports;\n	/******/ 	}\n	/******/\n	/******/\n	/******/ 	// expose the modules object (__webpack_modules__)\n	/******/ 	__webpack_require__.m = modules;\n	/******/\n	/******/ 	// expose the module cache\n	/******/ 	__webpack_require__.c = installedModules;\n	/******/\n	/******/ 	// __webpack_public_path__\n	/******/ 	__webpack_require__.p = \"/build/\";\n	/******/\n	/******/ 	// Load entry module and return exports\n	/******/ 	return __webpack_require__(0);\n	/******/ })\n	/************************************************************************/\n	/******/ ([\n	/* 0 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	__webpack_require__(1);\n	module.exports = __webpack_require__(2);\n	\n	\n	/***/ },\n	/* 1 */\n	/***/ function(module, exports) {\n	\n	/* WEBPACK VAR INJECTION */(function(global) {/**\n	 * Copyright (c) 2014, Facebook, Inc.\n	 * All rights reserved.\n	 *\n	 * This source code is licensed under the BSD-style license found in the\n	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n	 * additional grant of patent rights can be found in the PATENTS file in\n	 * the same directory.\n	 */\n	\n	!(function(global) {\n	  \"use strict\";\n	\n	  var hasOwn = Object.prototype.hasOwnProperty;\n	  var undefined; // More compressible than void 0.\n	  var iteratorSymbol =\n	    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n	\n	  var inModule = typeof module === \"object\";\n	  var runtime = global.regeneratorRuntime;\n	  if (runtime) {\n	    if (inModule) {\n	      // If regeneratorRuntime is defined globally and we're in a module,\n	      // make the exports object identical to regeneratorRuntime.\n	      module.exports = runtime;\n	    }\n	    // Don't bother evaluating the rest of this file if the runtime was\n	    // already defined globally.\n	    return;\n	  }\n	\n	  // Define the runtime globally (as expected by generated code) as either\n	  // module.exports (if we're in a module) or a new, empty object.\n	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n	\n	  function wrap(innerFn, outerFn, self, tryLocsList) {\n	    // If outerFn provided, then outerFn.prototype instanceof Generator.\n	    var generator = Object.create((outerFn || Generator).prototype);\n	    var context = new Context(tryLocsList || []);\n	\n	    // The ._invoke method unifies the implementations of the .next,\n	    // .throw, and .return methods.\n	    generator._invoke = makeInvokeMethod(innerFn, self, context);\n	\n	    return generator;\n	  }\n	  runtime.wrap = wrap;\n	\n	  // Try/catch helper to minimize deoptimizations. Returns a completion\n	  // record like context.tryEntries[i].completion. This interface could\n	  // have been (and was previously) designed to take a closure to be\n	  // invoked without arguments, but in all the cases we care about we\n	  // already have an existing method we want to call, so there's no need\n	  // to create a new function object. We can even get away with assuming\n	  // the method takes exactly one argument, since that happens to be true\n	  // in every case, so we don't have to touch the arguments object. The\n	  // only additional allocation required is the completion record, which\n	  // has a stable shape and so hopefully should be cheap to allocate.\n	  function tryCatch(fn, obj, arg) {\n	    try {\n	      return { type: \"normal\", arg: fn.call(obj, arg) };\n	    } catch (err) {\n	      return { type: \"throw\", arg: err };\n	    }\n	  }\n	\n	  var GenStateSuspendedStart = \"suspendedStart\";\n	  var GenStateSuspendedYield = \"suspendedYield\";\n	  var GenStateExecuting = \"executing\";\n	  var GenStateCompleted = \"completed\";\n	\n	  // Returning this object from the innerFn has the same effect as\n	  // breaking out of the dispatch switch statement.\n	  var ContinueSentinel = {};\n	\n	  // Dummy constructor functions that we use as the .constructor and\n	  // .constructor.prototype properties for functions that return Generator\n	  // objects. For full spec compliance, you may wish to configure your\n	  // minifier not to mangle the names of these two functions.\n	  function Generator() {}\n	  function GeneratorFunction() {}\n	  function GeneratorFunctionPrototype() {}\n	\n	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n	  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n	  GeneratorFunction.displayName = \"GeneratorFunction\";\n	\n	  // Helper for defining the .next, .throw, and .return methods of the\n	  // Iterator interface in terms of a single ._invoke method.\n	  function defineIteratorMethods(prototype) {\n	    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n	      prototype[method] = function(arg) {\n	        return this._invoke(method, arg);\n	      };\n	    });\n	  }\n	\n	  runtime.isGeneratorFunction = function(genFun) {\n	    var ctor = typeof genFun === \"function\" && genFun.constructor;\n	    return ctor\n	      ? ctor === GeneratorFunction ||\n	        // For the native GeneratorFunction constructor, the best we can\n	        // do is to check its .name property.\n	        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n	      : false;\n	  };\n	\n	  runtime.mark = function(genFun) {\n	    if (Object.setPrototypeOf) {\n	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n	    } else {\n	      genFun.__proto__ = GeneratorFunctionPrototype;\n	    }\n	    genFun.prototype = Object.create(Gp);\n	    return genFun;\n	  };\n	\n	  // Within the body of any async function, `await x` is transformed to\n	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n	  // `value instanceof AwaitArgument` to determine if the yielded value is\n	  // meant to be awaited. Some may consider the name of this method too\n	  // cutesy, but they are curmudgeons.\n	  runtime.awrap = function(arg) {\n	    return new AwaitArgument(arg);\n	  };\n	\n	  function AwaitArgument(arg) {\n	    this.arg = arg;\n	  }\n	\n	  function AsyncIterator(generator) {\n	    // This invoke function is written in a style that assumes some\n	    // calling function (or Promise) will handle exceptions.\n	    function invoke(method, arg) {\n	      var result = generator[method](arg);\n	      var value = result.value;\n	      return value instanceof AwaitArgument\n	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)\n	        : Promise.resolve(value).then(function(unwrapped) {\n	            // When a yielded Promise is resolved, its final value becomes\n	            // the .value of the Promise<{value,done}> result for the\n	            // current iteration. If the Promise is rejected, however, the\n	            // result for this iteration will be rejected with the same\n	            // reason. Note that rejections of yielded Promises are not\n	            // thrown back into the generator function, as is the case\n	            // when an awaited Promise is rejected. This difference in\n	            // behavior between yield and await is important, because it\n	            // allows the consumer to decide what to do with the yielded\n	            // rejection (swallow it and continue, manually .throw it back\n	            // into the generator, abandon iteration, whatever). With\n	            // await, by contrast, there is no opportunity to examine the\n	            // rejection reason outside the generator function, so the\n	            // only option is to throw it from the await expression, and\n	            // let the generator function handle the exception.\n	            result.value = unwrapped;\n	            return result;\n	          });\n	    }\n	\n	    if (typeof process === \"object\" && process.domain) {\n	      invoke = process.domain.bind(invoke);\n	    }\n	\n	    var invokeNext = invoke.bind(generator, \"next\");\n	    var invokeThrow = invoke.bind(generator, \"throw\");\n	    var invokeReturn = invoke.bind(generator, \"return\");\n	    var previousPromise;\n	\n	    function enqueue(method, arg) {\n	      function callInvokeWithMethodAndArg() {\n	        return invoke(method, arg);\n	      }\n	\n	      return previousPromise =\n	        // If enqueue has been called before, then we want to wait until\n	        // all previous Promises have been resolved before calling invoke,\n	        // so that results are always delivered in the correct order. If\n	        // enqueue has not been called before, then it is important to\n	        // call invoke immediately, without waiting on a callback to fire,\n	        // so that the async generator function has the opportunity to do\n	        // any necessary setup in a predictable way. This predictability\n	        // is why the Promise constructor synchronously invokes its\n	        // executor callback, and why async functions synchronously\n	        // execute code before the first await. Since we implement simple\n	        // async functions in terms of async generators, it is especially\n	        // important to get this right, even though it requires care.\n	        previousPromise ? previousPromise.then(\n	          callInvokeWithMethodAndArg,\n	          // Avoid propagating failures to Promises returned by later\n	          // invocations of the iterator.\n	          callInvokeWithMethodAndArg\n	        ) : new Promise(function (resolve) {\n	          resolve(callInvokeWithMethodAndArg());\n	        });\n	    }\n	\n	    // Define the unified helper method that is used to implement .next,\n	    // .throw, and .return (see defineIteratorMethods).\n	    this._invoke = enqueue;\n	  }\n	\n	  defineIteratorMethods(AsyncIterator.prototype);\n	\n	  // Note that simple async functions are implemented on top of\n	  // AsyncIterator objects; they just return a Promise for the value of\n	  // the final result produced by the iterator.\n	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n	    var iter = new AsyncIterator(\n	      wrap(innerFn, outerFn, self, tryLocsList)\n	    );\n	\n	    return runtime.isGeneratorFunction(outerFn)\n	      ? iter // If outerFn is a generator, return the full iterator.\n	      : iter.next().then(function(result) {\n	          return result.done ? result.value : iter.next();\n	        });\n	  };\n	\n	  function makeInvokeMethod(innerFn, self, context) {\n	    var state = GenStateSuspendedStart;\n	\n	    return function invoke(method, arg) {\n	      if (state === GenStateExecuting) {\n	        throw new Error(\"Generator is already running\");\n	      }\n	\n	      if (state === GenStateCompleted) {\n	        if (method === \"throw\") {\n	          throw arg;\n	        }\n	\n	        // Be forgiving, per 25.3.3.3.3 of the spec:\n	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n	        return doneResult();\n	      }\n	\n	      while (true) {\n	        var delegate = context.delegate;\n	        if (delegate) {\n	          if (method === \"return\" ||\n	              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n	            // A return or throw (when the delegate iterator has no throw\n	            // method) always terminates the yield* loop.\n	            context.delegate = null;\n	\n	            // If the delegate iterator has a return method, give it a\n	            // chance to clean up.\n	            var returnMethod = delegate.iterator[\"return\"];\n	            if (returnMethod) {\n	              var record = tryCatch(returnMethod, delegate.iterator, arg);\n	              if (record.type === \"throw\") {\n	                // If the return method threw an exception, let that\n	                // exception prevail over the original return or throw.\n	                method = \"throw\";\n	                arg = record.arg;\n	                continue;\n	              }\n	            }\n	\n	            if (method === \"return\") {\n	              // Continue with the outer return, now that the delegate\n	              // iterator has been terminated.\n	              continue;\n	            }\n	          }\n	\n	          var record = tryCatch(\n	            delegate.iterator[method],\n	            delegate.iterator,\n	            arg\n	          );\n	\n	          if (record.type === \"throw\") {\n	            context.delegate = null;\n	\n	            // Like returning generator.throw(uncaught), but without the\n	            // overhead of an extra function call.\n	            method = \"throw\";\n	            arg = record.arg;\n	            continue;\n	          }\n	\n	          // Delegate generator ran and handled its own exceptions so\n	          // regardless of what the method was, we continue as if it is\n	          // \"next\" with an undefined arg.\n	          method = \"next\";\n	          arg = undefined;\n	\n	          var info = record.arg;\n	          if (info.done) {\n	            context[delegate.resultName] = info.value;\n	            context.next = delegate.nextLoc;\n	          } else {\n	            state = GenStateSuspendedYield;\n	            return info;\n	          }\n	\n	          context.delegate = null;\n	        }\n	\n	        if (method === \"next\") {\n	          context._sent = arg;\n	\n	          if (state === GenStateSuspendedYield) {\n	            context.sent = arg;\n	          } else {\n	            context.sent = undefined;\n	          }\n	        } else if (method === \"throw\") {\n	          if (state === GenStateSuspendedStart) {\n	            state = GenStateCompleted;\n	            throw arg;\n	          }\n	\n	          if (context.dispatchException(arg)) {\n	            // If the dispatched exception was caught by a catch block,\n	            // then let that catch block handle the exception normally.\n	            method = \"next\";\n	            arg = undefined;\n	          }\n	\n	        } else if (method === \"return\") {\n	          context.abrupt(\"return\", arg);\n	        }\n	\n	        state = GenStateExecuting;\n	\n	        var record = tryCatch(innerFn, self, context);\n	        if (record.type === \"normal\") {\n	          // If an exception is thrown from innerFn, we leave state ===\n	          // GenStateExecuting and loop back for another invocation.\n	          state = context.done\n	            ? GenStateCompleted\n	            : GenStateSuspendedYield;\n	\n	          var info = {\n	            value: record.arg,\n	            done: context.done\n	          };\n	\n	          if (record.arg === ContinueSentinel) {\n	            if (context.delegate && method === \"next\") {\n	              // Deliberately forget the last sent value so that we don't\n	              // accidentally pass it on to the delegate.\n	              arg = undefined;\n	            }\n	          } else {\n	            return info;\n	          }\n	\n	        } else if (record.type === \"throw\") {\n	          state = GenStateCompleted;\n	          // Dispatch the exception by looping back around to the\n	          // context.dispatchException(arg) call above.\n	          method = \"throw\";\n	          arg = record.arg;\n	        }\n	      }\n	    };\n	  }\n	\n	  // Define Generator.prototype.{next,throw,return} in terms of the\n	  // unified ._invoke helper method.\n	  defineIteratorMethods(Gp);\n	\n	  Gp[iteratorSymbol] = function() {\n	    return this;\n	  };\n	\n	  Gp.toString = function() {\n	    return \"[object Generator]\";\n	  };\n	\n	  function pushTryEntry(locs) {\n	    var entry = { tryLoc: locs[0] };\n	\n	    if (1 in locs) {\n	      entry.catchLoc = locs[1];\n	    }\n	\n	    if (2 in locs) {\n	      entry.finallyLoc = locs[2];\n	      entry.afterLoc = locs[3];\n	    }\n	\n	    this.tryEntries.push(entry);\n	  }\n	\n	  function resetTryEntry(entry) {\n	    var record = entry.completion || {};\n	    record.type = \"normal\";\n	    delete record.arg;\n	    entry.completion = record;\n	  }\n	\n	  function Context(tryLocsList) {\n	    // The root entry object (effectively a try statement without a catch\n	    // or a finally block) gives us a place to store values thrown from\n	    // locations where there is no enclosing try statement.\n	    this.tryEntries = [{ tryLoc: \"root\" }];\n	    tryLocsList.forEach(pushTryEntry, this);\n	    this.reset(true);\n	  }\n	\n	  runtime.keys = function(object) {\n	    var keys = [];\n	    for (var key in object) {\n	      keys.push(key);\n	    }\n	    keys.reverse();\n	\n	    // Rather than returning an object with a next method, we keep\n	    // things simple and return the next function itself.\n	    return function next() {\n	      while (keys.length) {\n	        var key = keys.pop();\n	        if (key in object) {\n	          next.value = key;\n	          next.done = false;\n	          return next;\n	        }\n	      }\n	\n	      // To avoid creating an additional object, we just hang the .value\n	      // and .done properties off the next function object itself. This\n	      // also ensures that the minifier will not anonymize the function.\n	      next.done = true;\n	      return next;\n	    };\n	  };\n	\n	  function values(iterable) {\n	    if (iterable) {\n	      var iteratorMethod = iterable[iteratorSymbol];\n	      if (iteratorMethod) {\n	        return iteratorMethod.call(iterable);\n	      }\n	\n	      if (typeof iterable.next === \"function\") {\n	        return iterable;\n	      }\n	\n	      if (!isNaN(iterable.length)) {\n	        var i = -1, next = function next() {\n	          while (++i < iterable.length) {\n	            if (hasOwn.call(iterable, i)) {\n	              next.value = iterable[i];\n	              next.done = false;\n	              return next;\n	            }\n	          }\n	\n	          next.value = undefined;\n	          next.done = true;\n	\n	          return next;\n	        };\n	\n	        return next.next = next;\n	      }\n	    }\n	\n	    // Return an iterator with no values.\n	    return { next: doneResult };\n	  }\n	  runtime.values = values;\n	\n	  function doneResult() {\n	    return { value: undefined, done: true };\n	  }\n	\n	  Context.prototype = {\n	    constructor: Context,\n	\n	    reset: function(skipTempReset) {\n	      this.prev = 0;\n	      this.next = 0;\n	      this.sent = undefined;\n	      this.done = false;\n	      this.delegate = null;\n	\n	      this.tryEntries.forEach(resetTryEntry);\n	\n	      if (!skipTempReset) {\n	        for (var name in this) {\n	          // Not sure about the optimal order of these conditions:\n	          if (name.charAt(0) === \"t\" &&\n	              hasOwn.call(this, name) &&\n	              !isNaN(+name.slice(1))) {\n	            this[name] = undefined;\n	          }\n	        }\n	      }\n	    },\n	\n	    stop: function() {\n	      this.done = true;\n	\n	      var rootEntry = this.tryEntries[0];\n	      var rootRecord = rootEntry.completion;\n	      if (rootRecord.type === \"throw\") {\n	        throw rootRecord.arg;\n	      }\n	\n	      return this.rval;\n	    },\n	\n	    dispatchException: function(exception) {\n	      if (this.done) {\n	        throw exception;\n	      }\n	\n	      var context = this;\n	      function handle(loc, caught) {\n	        record.type = \"throw\";\n	        record.arg = exception;\n	        context.next = loc;\n	        return !!caught;\n	      }\n	\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        var record = entry.completion;\n	\n	        if (entry.tryLoc === \"root\") {\n	          // Exception thrown outside of any try block that could handle\n	          // it, so set the completion value of the entire function to\n	          // throw the exception.\n	          return handle(\"end\");\n	        }\n	\n	        if (entry.tryLoc <= this.prev) {\n	          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n	          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n	\n	          if (hasCatch && hasFinally) {\n	            if (this.prev < entry.catchLoc) {\n	              return handle(entry.catchLoc, true);\n	            } else if (this.prev < entry.finallyLoc) {\n	              return handle(entry.finallyLoc);\n	            }\n	\n	          } else if (hasCatch) {\n	            if (this.prev < entry.catchLoc) {\n	              return handle(entry.catchLoc, true);\n	            }\n	\n	          } else if (hasFinally) {\n	            if (this.prev < entry.finallyLoc) {\n	              return handle(entry.finallyLoc);\n	            }\n	\n	          } else {\n	            throw new Error(\"try statement without catch or finally\");\n	          }\n	        }\n	      }\n	    },\n	\n	    abrupt: function(type, arg) {\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        if (entry.tryLoc <= this.prev &&\n	            hasOwn.call(entry, \"finallyLoc\") &&\n	            this.prev < entry.finallyLoc) {\n	          var finallyEntry = entry;\n	          break;\n	        }\n	      }\n	\n	      if (finallyEntry &&\n	          (type === \"break\" ||\n	           type === \"continue\") &&\n	          finallyEntry.tryLoc <= arg &&\n	          arg <= finallyEntry.finallyLoc) {\n	        // Ignore the finally entry if control is not jumping to a\n	        // location outside the try/catch block.\n	        finallyEntry = null;\n	      }\n	\n	      var record = finallyEntry ? finallyEntry.completion : {};\n	      record.type = type;\n	      record.arg = arg;\n	\n	      if (finallyEntry) {\n	        this.next = finallyEntry.finallyLoc;\n	      } else {\n	        this.complete(record);\n	      }\n	\n	      return ContinueSentinel;\n	    },\n	\n	    complete: function(record, afterLoc) {\n	      if (record.type === \"throw\") {\n	        throw record.arg;\n	      }\n	\n	      if (record.type === \"break\" ||\n	          record.type === \"continue\") {\n	        this.next = record.arg;\n	      } else if (record.type === \"return\") {\n	        this.rval = record.arg;\n	        this.next = \"end\";\n	      } else if (record.type === \"normal\" && afterLoc) {\n	        this.next = afterLoc;\n	      }\n	    },\n	\n	    finish: function(finallyLoc) {\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        if (entry.finallyLoc === finallyLoc) {\n	          this.complete(entry.completion, entry.afterLoc);\n	          resetTryEntry(entry);\n	          return ContinueSentinel;\n	        }\n	      }\n	    },\n	\n	    \"catch\": function(tryLoc) {\n	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n	        var entry = this.tryEntries[i];\n	        if (entry.tryLoc === tryLoc) {\n	          var record = entry.completion;\n	          if (record.type === \"throw\") {\n	            var thrown = record.arg;\n	            resetTryEntry(entry);\n	          }\n	          return thrown;\n	        }\n	      }\n	\n	      // The context.catch method must only be called with a location\n	      // argument that corresponds to a known catch block.\n	      throw new Error(\"illegal catch attempt\");\n	    },\n	\n	    delegateYield: function(iterable, resultName, nextLoc) {\n	      this.delegate = {\n	        iterator: values(iterable),\n	        resultName: resultName,\n	        nextLoc: nextLoc\n	      };\n	\n	      return ContinueSentinel;\n	    }\n	  };\n	})(\n	  // Among the various tricks for obtaining a reference to the global\n	  // object, this seems to be the most reliable technique that does not\n	  // use indirect eval (which violates Content Security Policy).\n	  typeof global === \"object\" ? global :\n	  typeof window === \"object\" ? window :\n	  typeof self === \"object\" ? self : this\n	);\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n	\n	/***/ },\n	/* 2 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	var _Utils = __webpack_require__(3);\n	\n	var Utils = _interopRequireWildcard(_Utils);\n	\n	var _Cache = __webpack_require__(12);\n	\n	var _Cache2 = _interopRequireDefault(_Cache);\n	\n	var _Externals = __webpack_require__(4);\n	\n	var Externals = _interopRequireWildcard(_Externals);\n	\n	var _Observable = __webpack_require__(13);\n	\n	var _Observable2 = _interopRequireDefault(_Observable);\n	\n	var _Queue = __webpack_require__(14);\n	\n	var _Queue2 = _interopRequireDefault(_Queue);\n	\n	var _Client = __webpack_require__(15);\n	\n	var _Client2 = _interopRequireDefault(_Client);\n	\n	var _ApiResponse = __webpack_require__(16);\n	\n	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n	\n	var _ClientMock = __webpack_require__(17);\n	\n	var _ClientMock2 = _interopRequireDefault(_ClientMock);\n	\n	var _Mock = __webpack_require__(19);\n	\n	var _Mock2 = _interopRequireDefault(_Mock);\n	\n	var _Registry = __webpack_require__(18);\n	\n	var _Registry2 = _interopRequireDefault(_Registry);\n	\n	var _Platform = __webpack_require__(20);\n	\n	var _Platform2 = _interopRequireDefault(_Platform);\n	\n	var _Auth = __webpack_require__(21);\n	\n	var _Auth2 = _interopRequireDefault(_Auth);\n	\n	var _PubnubFactory = __webpack_require__(22);\n	\n	var _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);\n	\n	var _Subscription = __webpack_require__(24);\n	\n	var _Subscription2 = _interopRequireDefault(_Subscription);\n	\n	var _CachedSubscription = __webpack_require__(25);\n	\n	var _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var SDK = function () {\n	\n	    /**\n	     * @namespace RingCentral\n	     * @constructor\n	     * @param {object} [options]\n	     * @param {string} [options.server]\n	     * @param {string} [options.cachePrefix]\n	     * @param {string} [options.appSecret]\n	     * @param {string} [options.appKey]\n	     * @param {string} [options.appName]\n	     * @param {string} [options.appVersion]\n	     * @param {string} [options.pubnubFactory]\n	     * @param {string} [options.client]\n	     */\n	\n	    function SDK(options) {\n	        _classCallCheck(this, SDK);\n	\n	        options = options || {};\n	\n	        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);\n	\n	        this._client = options.client || new _Client2.default();\n	\n	        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);\n	\n	        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;\n	    }\n	\n	    /**\n	     * @return {Platform}\n	     */\n	\n	\n	    SDK.prototype.platform = function platform() {\n	        return this._platform;\n	    };\n	\n	    /**\n	     * @return {Subscription}\n	     */\n	\n	\n	    SDK.prototype.createSubscription = function createSubscription() {\n	        return new _Subscription2.default(this._pubnubFactory, this._platform);\n	    };\n	\n	    /**\n	     * @return {CachedSubscription}\n	     */\n	\n	\n	    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {\n	        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);\n	    };\n	\n	    /**\n	     * @return {Cache}\n	     */\n	\n	\n	    SDK.prototype.cache = function cache() {\n	        return this._cache;\n	    };\n	\n	    SDK.handleAuthRedirect = function handleAuthRedirect(origin) {\n	        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);\n	    };\n	\n	    return SDK;\n	}();\n	\n	SDK.version = '2.0.6';\n	SDK.server = {\n	    sandbox: 'https://platform.devtest.ringcentral.com',\n	    production: 'https://platform.ringcentral.com'\n	};\n	SDK.core = {\n	    Cache: _Cache2.default,\n	    Observable: _Observable2.default,\n	    Utils: Utils,\n	    Externals: Externals,\n	    Queue: _Queue2.default\n	};\n	SDK.http = {\n	    Client: _Client2.default,\n	    ApiResponse: _ApiResponse2.default\n	};\n	SDK.platform = {\n	    Auth: _Auth2.default,\n	    Platform: _Platform2.default\n	};\n	SDK.subscription = {\n	    Subscription: _Subscription2.default\n	};\n	SDK.mocks = {\n	    Client: _ClientMock2.default,\n	    Registry: _Registry2.default,\n	    Mock: _Mock2.default\n	};\n	SDK.pubnub = {\n	    PubnubMockFactory: _PubnubFactory2.default\n	};\n	\n	\n	module.exports = SDK;\n	\n	/***/ },\n	/* 3 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n	\n	exports.queryStringify = queryStringify;\n	exports.parseQueryString = parseQueryString;\n	exports.isFunction = isFunction;\n	exports.isArray = isArray;\n	exports.isObject = isObject;\n	exports.isObjectObject = isObjectObject;\n	exports.isPlainObject = isPlainObject;\n	exports.poll = poll;\n	exports.stopPolling = stopPolling;\n	exports.isNodeJS = isNodeJS;\n	exports.isBrowser = isBrowser;\n	exports.delay = delay;\n	\n	var _Externals = __webpack_require__(4);\n	\n	/**\n	 * TODO Replace with something better\n	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n	 * @param {object} parameters\n	 * @returns {string}\n	 */\n	function queryStringify(parameters) {\n	\n	    var array = [];\n	\n	    parameters = parameters || {};\n	\n	    Object.keys(parameters).forEach(function (k) {\n	\n	        var v = parameters[k];\n	\n	        if (isArray(v)) {\n	            v.forEach(function (vv) {\n	                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));\n	            });\n	        } else {\n	            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));\n	        }\n	    });\n	\n	    return array.join('&');\n	}\n	\n	/**\n	 * TODO Replace with something better\n	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js\n	 * @param {string} queryString\n	 * @returns {object}\n	 */\n	function parseQueryString(queryString) {\n	\n	    var argsParsed = {};\n	\n	    queryString.split('&').forEach(function (arg) {\n	\n	        arg = decodeURIComponent(arg);\n	\n	        if (arg.indexOf('=') == -1) {\n	\n	            argsParsed[arg.trim()] = true;\n	        } else {\n	\n	            var pair = arg.split('='),\n	                key = pair[0].trim(),\n	                value = pair[1].trim();\n	\n	            if (key in argsParsed) {\n	                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];\n	                argsParsed[key].push(value);\n	            } else {\n	                argsParsed[key] = value;\n	            }\n	        }\n	    });\n	\n	    return argsParsed;\n	}\n	\n	/**\n	 * @param obj\n	 * @return {boolean}\n	 */\n	function isFunction(obj) {\n	    return typeof obj === \"function\";\n	}\n	\n	/**\n	 * @param obj\n	 * @return {boolean}\n	 */\n	function isArray(obj) {\n	    return Array.isArray ? Array.isArray(obj) : typeof obj === \"array\";\n	}\n	\n	function isObject(o) {\n	    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);\n	}\n	\n	function isObjectObject(o) {\n	    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n	}\n	\n	function isPlainObject(o) {\n	    var ctor, prot;\n	\n	    if (isObjectObject(o) === false) return false;\n	\n	    // If has modified constructor\n	    ctor = o.constructor;\n	    if (typeof ctor !== 'function') return false;\n	\n	    // If has modified prototype\n	    prot = ctor.prototype;\n	    if (isObjectObject(prot) === false) return false;\n	\n	    // If constructor does not have an Object-specific method\n	    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n	        return false;\n	    }\n	\n	    // Most likely a plain Object\n	    return true;\n	}\n	\n	/**\n	 * @param fn\n	 * @param interval\n	 * @param timeout\n	 */\n	function poll(fn, interval, timeout) {\n	    //NodeJS.Timer|number\n	\n	    module.exports.stopPolling(timeout);\n	\n	    interval = interval || 1000;\n	\n	    var next = function next(delay) {\n	\n	        delay = delay || interval;\n	\n	        interval = delay;\n	\n	        return setTimeout(function () {\n	\n	            fn(next, delay);\n	        }, delay);\n	    };\n	\n	    return next();\n	}\n	\n	function stopPolling(timeout) {\n	    if (timeout) clearTimeout(timeout);\n	}\n	\n	function isNodeJS() {\n	    return typeof process !== 'undefined';\n	}\n	\n	function isBrowser() {\n	    return typeof window !== 'undefined';\n	}\n	\n	function delay(timeout) {\n	    return new _Externals.Promise(function (resolve, reject) {\n	        setTimeout(function () {\n	            resolve(null);\n	        }, timeout);\n	    });\n	}\n	\n	/***/ },\n	/* 4 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n	\n	exports.__esModule = true;\n	exports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;\n	\n	var _es6Promise = __webpack_require__(5);\n	\n	var _es6Promise2 = _interopRequireDefault(_es6Promise);\n	\n	var _nodeFetch = __webpack_require__(10);\n	\n	var _nodeFetch2 = _interopRequireDefault(_nodeFetch);\n	\n	var _pubnub = __webpack_require__(11);\n	\n	var _pubnub2 = _interopRequireDefault(_pubnub);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var root = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function(\"return this;\")();\n	\n	var Promise = exports.Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;\n	\n	var fetch = exports.fetch = root.fetch || _nodeFetch2.default;\n	var Request = exports.Request = root.Request || fetch.Request;\n	var Response = exports.Response = root.Response || fetch.Response;\n	var Headers = exports.Headers = root.Headers || fetch.Headers;\n	\n	var PUBNUB = exports.PUBNUB = root.PUBNUB || _pubnub2.default;\n	\n	var localStorage = exports.localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n	\n	/***/ },\n	/* 5 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate, global, module) {/*!\n	 * @overview es6-promise - a tiny implementation of Promises/A+.\n	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n	 * @license   Licensed under MIT license\n	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n	 * @version   2.2.0\n	 */\n	\n	(function() {\n	    \"use strict\";\n	    function lib$es6$promise$utils$$objectOrFunction(x) {\n	      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n	    }\n	\n	    function lib$es6$promise$utils$$isFunction(x) {\n	      return typeof x === 'function';\n	    }\n	\n	    function lib$es6$promise$utils$$isMaybeThenable(x) {\n	      return typeof x === 'object' && x !== null;\n	    }\n	\n	    var lib$es6$promise$utils$$_isArray;\n	    if (!Array.isArray) {\n	      lib$es6$promise$utils$$_isArray = function (x) {\n	        return Object.prototype.toString.call(x) === '[object Array]';\n	      };\n	    } else {\n	      lib$es6$promise$utils$$_isArray = Array.isArray;\n	    }\n	\n	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n	    var lib$es6$promise$asap$$len = 0;\n	    var lib$es6$promise$asap$$toString = {}.toString;\n	    var lib$es6$promise$asap$$vertxNext;\n	    var lib$es6$promise$asap$$customSchedulerFn;\n	\n	    function lib$es6$promise$asap$$asap(callback, arg) {\n	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n	      lib$es6$promise$asap$$len += 2;\n	      if (lib$es6$promise$asap$$len === 2) {\n	        // If len is 2, that means that we need to schedule an async flush.\n	        // If additional callbacks are queued before the queue is flushed, they\n	        // will be processed by this flush that we are scheduling.\n	        if (lib$es6$promise$asap$$customSchedulerFn) {\n	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n	        } else {\n	          lib$es6$promise$asap$$scheduleFlush();\n	        }\n	      }\n	    }\n	\n	    var lib$es6$promise$asap$$default = lib$es6$promise$asap$$asap;\n	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n	    }\n	\n	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n	\n	    // test for web worker but not in IE10\n	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n	      typeof importScripts !== 'undefined' &&\n	      typeof MessageChannel !== 'undefined';\n	\n	    // node\n	    function lib$es6$promise$asap$$useNextTick() {\n	      var nextTick = process.nextTick;\n	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n	      // setImmediate should be used instead instead\n	      var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n	      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n	        nextTick = setImmediate;\n	      }\n	      return function() {\n	        nextTick(lib$es6$promise$asap$$flush);\n	      };\n	    }\n	\n	    // vertx\n	    function lib$es6$promise$asap$$useVertxTimer() {\n	      return function() {\n	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n	      };\n	    }\n	\n	    function lib$es6$promise$asap$$useMutationObserver() {\n	      var iterations = 0;\n	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n	      var node = document.createTextNode('');\n	      observer.observe(node, { characterData: true });\n	\n	      return function() {\n	        node.data = (iterations = ++iterations % 2);\n	      };\n	    }\n	\n	    // web worker\n	    function lib$es6$promise$asap$$useMessageChannel() {\n	      var channel = new MessageChannel();\n	      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n	      return function () {\n	        channel.port2.postMessage(0);\n	      };\n	    }\n	\n	    function lib$es6$promise$asap$$useSetTimeout() {\n	      return function() {\n	        setTimeout(lib$es6$promise$asap$$flush, 1);\n	      };\n	    }\n	\n	    var lib$es6$promise$asap$$queue = new Array(1000);\n	    function lib$es6$promise$asap$$flush() {\n	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n	        var callback = lib$es6$promise$asap$$queue[i];\n	        var arg = lib$es6$promise$asap$$queue[i+1];\n	\n	        callback(arg);\n	\n	        lib$es6$promise$asap$$queue[i] = undefined;\n	        lib$es6$promise$asap$$queue[i+1] = undefined;\n	      }\n	\n	      lib$es6$promise$asap$$len = 0;\n	    }\n	\n	    function lib$es6$promise$asap$$attemptVertex() {\n	      try {\n	        var r = require;\n	        var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"vertx\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n	        return lib$es6$promise$asap$$useVertxTimer();\n	      } catch(e) {\n	        return lib$es6$promise$asap$$useSetTimeout();\n	      }\n	    }\n	\n	    var lib$es6$promise$asap$$scheduleFlush;\n	    // Decide what async method to use to triggering processing of queued callbacks:\n	    if (lib$es6$promise$asap$$isNode) {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n	    } else if (lib$es6$promise$asap$$isWorker) {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n	    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();\n	    } else {\n	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n	    }\n	\n	    function lib$es6$promise$$internal$$noop() {}\n	\n	    var lib$es6$promise$$internal$$PENDING   = void 0;\n	    var lib$es6$promise$$internal$$FULFILLED = 1;\n	    var lib$es6$promise$$internal$$REJECTED  = 2;\n	\n	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n	\n	    function lib$es6$promise$$internal$$selfFullfillment() {\n	      return new TypeError(\"You cannot resolve a promise with itself\");\n	    }\n	\n	    function lib$es6$promise$$internal$$cannotReturnOwn() {\n	      return new TypeError('A promises callback cannot return that same promise.');\n	    }\n	\n	    function lib$es6$promise$$internal$$getThen(promise) {\n	      try {\n	        return promise.then;\n	      } catch(error) {\n	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n	        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n	      try {\n	        then.call(value, fulfillmentHandler, rejectionHandler);\n	      } catch(e) {\n	        return e;\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n	       lib$es6$promise$asap$$default(function(promise) {\n	        var sealed = false;\n	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n	          if (sealed) { return; }\n	          sealed = true;\n	          if (thenable !== value) {\n	            lib$es6$promise$$internal$$resolve(promise, value);\n	          } else {\n	            lib$es6$promise$$internal$$fulfill(promise, value);\n	          }\n	        }, function(reason) {\n	          if (sealed) { return; }\n	          sealed = true;\n	\n	          lib$es6$promise$$internal$$reject(promise, reason);\n	        }, 'Settle: ' + (promise._label || ' unknown promise'));\n	\n	        if (!sealed && error) {\n	          sealed = true;\n	          lib$es6$promise$$internal$$reject(promise, error);\n	        }\n	      }, promise);\n	    }\n	\n	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n	        lib$es6$promise$$internal$$reject(promise, thenable._result);\n	      } else {\n	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n	          lib$es6$promise$$internal$$resolve(promise, value);\n	        }, function(reason) {\n	          lib$es6$promise$$internal$$reject(promise, reason);\n	        });\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n	      if (maybeThenable.constructor === promise.constructor) {\n	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n	      } else {\n	        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n	\n	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n	        } else if (then === undefined) {\n	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n	        } else if (lib$es6$promise$utils$$isFunction(then)) {\n	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n	        } else {\n	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n	        }\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$resolve(promise, value) {\n	      if (promise === value) {\n	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());\n	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n	      } else {\n	        lib$es6$promise$$internal$$fulfill(promise, value);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$publishRejection(promise) {\n	      if (promise._onerror) {\n	        promise._onerror(promise._result);\n	      }\n	\n	      lib$es6$promise$$internal$$publish(promise);\n	    }\n	\n	    function lib$es6$promise$$internal$$fulfill(promise, value) {\n	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n	\n	      promise._result = value;\n	      promise._state = lib$es6$promise$$internal$$FULFILLED;\n	\n	      if (promise._subscribers.length !== 0) {\n	        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, promise);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$reject(promise, reason) {\n	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n	      promise._state = lib$es6$promise$$internal$$REJECTED;\n	      promise._result = reason;\n	\n	      lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publishRejection, promise);\n	    }\n	\n	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n	      var subscribers = parent._subscribers;\n	      var length = subscribers.length;\n	\n	      parent._onerror = null;\n	\n	      subscribers[length] = child;\n	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n	\n	      if (length === 0 && parent._state) {\n	        lib$es6$promise$asap$$default(lib$es6$promise$$internal$$publish, parent);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$publish(promise) {\n	      var subscribers = promise._subscribers;\n	      var settled = promise._state;\n	\n	      if (subscribers.length === 0) { return; }\n	\n	      var child, callback, detail = promise._result;\n	\n	      for (var i = 0; i < subscribers.length; i += 3) {\n	        child = subscribers[i];\n	        callback = subscribers[i + settled];\n	\n	        if (child) {\n	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n	        } else {\n	          callback(detail);\n	        }\n	      }\n	\n	      promise._subscribers.length = 0;\n	    }\n	\n	    function lib$es6$promise$$internal$$ErrorObject() {\n	      this.error = null;\n	    }\n	\n	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n	\n	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n	      try {\n	        return callback(detail);\n	      } catch(e) {\n	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n	          value, error, succeeded, failed;\n	\n	      if (hasCallback) {\n	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n	\n	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n	          failed = true;\n	          error = value.error;\n	          value = null;\n	        } else {\n	          succeeded = true;\n	        }\n	\n	        if (promise === value) {\n	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n	          return;\n	        }\n	\n	      } else {\n	        value = detail;\n	        succeeded = true;\n	      }\n	\n	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n	        // noop\n	      } else if (hasCallback && succeeded) {\n	        lib$es6$promise$$internal$$resolve(promise, value);\n	      } else if (failed) {\n	        lib$es6$promise$$internal$$reject(promise, error);\n	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n	        lib$es6$promise$$internal$$fulfill(promise, value);\n	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n	        lib$es6$promise$$internal$$reject(promise, value);\n	      }\n	    }\n	\n	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n	      try {\n	        resolver(function resolvePromise(value){\n	          lib$es6$promise$$internal$$resolve(promise, value);\n	        }, function rejectPromise(reason) {\n	          lib$es6$promise$$internal$$reject(promise, reason);\n	        });\n	      } catch(e) {\n	        lib$es6$promise$$internal$$reject(promise, e);\n	      }\n	    }\n	\n	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n	      var enumerator = this;\n	\n	      enumerator._instanceConstructor = Constructor;\n	      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n	\n	      if (enumerator._validateInput(input)) {\n	        enumerator._input     = input;\n	        enumerator.length     = input.length;\n	        enumerator._remaining = input.length;\n	\n	        enumerator._init();\n	\n	        if (enumerator.length === 0) {\n	          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n	        } else {\n	          enumerator.length = enumerator.length || 0;\n	          enumerator._enumerate();\n	          if (enumerator._remaining === 0) {\n	            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n	          }\n	        }\n	      } else {\n	        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n	      }\n	    }\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n	      return lib$es6$promise$utils$$isArray(input);\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n	      return new Error('Array Methods must be provided an Array');\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n	      this._result = new Array(this.length);\n	    };\n	\n	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n	      var enumerator = this;\n	\n	      var length  = enumerator.length;\n	      var promise = enumerator.promise;\n	      var input   = enumerator._input;\n	\n	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n	        enumerator._eachEntry(input[i], i);\n	      }\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n	      var enumerator = this;\n	      var c = enumerator._instanceConstructor;\n	\n	      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n	        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n	          entry._onerror = null;\n	          enumerator._settledAt(entry._state, i, entry._result);\n	        } else {\n	          enumerator._willSettleAt(c.resolve(entry), i);\n	        }\n	      } else {\n	        enumerator._remaining--;\n	        enumerator._result[i] = entry;\n	      }\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n	      var enumerator = this;\n	      var promise = enumerator.promise;\n	\n	      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n	        enumerator._remaining--;\n	\n	        if (state === lib$es6$promise$$internal$$REJECTED) {\n	          lib$es6$promise$$internal$$reject(promise, value);\n	        } else {\n	          enumerator._result[i] = value;\n	        }\n	      }\n	\n	      if (enumerator._remaining === 0) {\n	        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n	      }\n	    };\n	\n	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n	      var enumerator = this;\n	\n	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n	      }, function(reason) {\n	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n	      });\n	    };\n	    function lib$es6$promise$promise$all$$all(entries) {\n	      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n	    }\n	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n	    function lib$es6$promise$promise$race$$race(entries) {\n	      /*jshint validthis:true */\n	      var Constructor = this;\n	\n	      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n	\n	      if (!lib$es6$promise$utils$$isArray(entries)) {\n	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n	        return promise;\n	      }\n	\n	      var length = entries.length;\n	\n	      function onFulfillment(value) {\n	        lib$es6$promise$$internal$$resolve(promise, value);\n	      }\n	\n	      function onRejection(reason) {\n	        lib$es6$promise$$internal$$reject(promise, reason);\n	      }\n	\n	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n	      }\n	\n	      return promise;\n	    }\n	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n	    function lib$es6$promise$promise$resolve$$resolve(object) {\n	      /*jshint validthis:true */\n	      var Constructor = this;\n	\n	      if (object && typeof object === 'object' && object.constructor === Constructor) {\n	        return object;\n	      }\n	\n	      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n	      lib$es6$promise$$internal$$resolve(promise, object);\n	      return promise;\n	    }\n	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n	    function lib$es6$promise$promise$reject$$reject(reason) {\n	      /*jshint validthis:true */\n	      var Constructor = this;\n	      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n	      lib$es6$promise$$internal$$reject(promise, reason);\n	      return promise;\n	    }\n	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n	\n	    var lib$es6$promise$promise$$counter = 0;\n	\n	    function lib$es6$promise$promise$$needsResolver() {\n	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n	    }\n	\n	    function lib$es6$promise$promise$$needsNew() {\n	      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n	    }\n	\n	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n	    /**\n	      Promise objects represent the eventual result of an asynchronous operation. The\n	      primary way of interacting with a promise is through its `then` method, which\n	      registers callbacks to receive either a promises eventual value or the reason\n	      why the promise cannot be fulfilled.\n	\n	      Terminology\n	      -----------\n	\n	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n	      - `thenable` is an object or function that defines a `then` method.\n	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n	      - `exception` is a value that is thrown using the throw statement.\n	      - `reason` is a value that indicates why a promise was rejected.\n	      - `settled` the final resting state of a promise, fulfilled or rejected.\n	\n	      A promise can be in one of three states: pending, fulfilled, or rejected.\n	\n	      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n	      state.  Promises that are rejected have a rejection reason and are in the\n	      rejected state.  A fulfillment value is never a thenable.\n	\n	      Promises can also be said to *resolve* a value.  If this value is also a\n	      promise, then the original promise's settled state will match the value's\n	      settled state.  So a promise that *resolves* a promise that rejects will\n	      itself reject, and a promise that *resolves* a promise that fulfills will\n	      itself fulfill.\n	\n	\n	      Basic Usage:\n	      ------------\n	\n	      ```js\n	      var promise = new Promise(function(resolve, reject) {\n	        // on success\n	        resolve(value);\n	\n	        // on failure\n	        reject(reason);\n	      });\n	\n	      promise.then(function(value) {\n	        // on fulfillment\n	      }, function(reason) {\n	        // on rejection\n	      });\n	      ```\n	\n	      Advanced Usage:\n	      ---------------\n	\n	      Promises shine when abstracting away asynchronous interactions such as\n	      `XMLHttpRequest`s.\n	\n	      ```js\n	      function getJSON(url) {\n	        return new Promise(function(resolve, reject){\n	          var xhr = new XMLHttpRequest();\n	\n	          xhr.open('GET', url);\n	          xhr.onreadystatechange = handler;\n	          xhr.responseType = 'json';\n	          xhr.setRequestHeader('Accept', 'application/json');\n	          xhr.send();\n	\n	          function handler() {\n	            if (this.readyState === this.DONE) {\n	              if (this.status === 200) {\n	                resolve(this.response);\n	              } else {\n	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n	              }\n	            }\n	          };\n	        });\n	      }\n	\n	      getJSON('/posts.json').then(function(json) {\n	        // on fulfillment\n	      }, function(reason) {\n	        // on rejection\n	      });\n	      ```\n	\n	      Unlike callbacks, promises are great composable primitives.\n	\n	      ```js\n	      Promise.all([\n	        getJSON('/posts'),\n	        getJSON('/comments')\n	      ]).then(function(values){\n	        values[0] // => postsJSON\n	        values[1] // => commentsJSON\n	\n	        return values;\n	      });\n	      ```\n	\n	      @class Promise\n	      @param {function} resolver\n	      Useful for tooling.\n	      @constructor\n	    */\n	    function lib$es6$promise$promise$$Promise(resolver) {\n	      this._id = lib$es6$promise$promise$$counter++;\n	      this._state = undefined;\n	      this._result = undefined;\n	      this._subscribers = [];\n	\n	      if (lib$es6$promise$$internal$$noop !== resolver) {\n	        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n	          lib$es6$promise$promise$$needsResolver();\n	        }\n	\n	        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n	          lib$es6$promise$promise$$needsNew();\n	        }\n	\n	        lib$es6$promise$$internal$$initializePromise(this, resolver);\n	      }\n	    }\n	\n	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$default;\n	\n	    lib$es6$promise$promise$$Promise.prototype = {\n	      constructor: lib$es6$promise$promise$$Promise,\n	\n	    /**\n	      The primary way of interacting with a promise is through its `then` method,\n	      which registers callbacks to receive either a promise's eventual value or the\n	      reason why the promise cannot be fulfilled.\n	\n	      ```js\n	      findUser().then(function(user){\n	        // user is available\n	      }, function(reason){\n	        // user is unavailable, and you are given the reason why\n	      });\n	      ```\n	\n	      Chaining\n	      --------\n	\n	      The return value of `then` is itself a promise.  This second, 'downstream'\n	      promise is resolved with the return value of the first promise's fulfillment\n	      or rejection handler, or rejected if the handler throws an exception.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        return user.name;\n	      }, function (reason) {\n	        return 'default name';\n	      }).then(function (userName) {\n	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n	        // will be `'default name'`\n	      });\n	\n	      findUser().then(function (user) {\n	        throw new Error('Found user, but still unhappy');\n	      }, function (reason) {\n	        throw new Error('`findUser` rejected and we're unhappy');\n	      }).then(function (value) {\n	        // never reached\n	      }, function (reason) {\n	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n	      });\n	      ```\n	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        throw new PedagogicalException('Upstream error');\n	      }).then(function (value) {\n	        // never reached\n	      }).then(function (value) {\n	        // never reached\n	      }, function (reason) {\n	        // The `PedgagocialException` is propagated all the way down to here\n	      });\n	      ```\n	\n	      Assimilation\n	      ------------\n	\n	      Sometimes the value you want to propagate to a downstream promise can only be\n	      retrieved asynchronously. This can be achieved by returning a promise in the\n	      fulfillment or rejection handler. The downstream promise will then be pending\n	      until the returned promise is settled. This is called *assimilation*.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        return findCommentsByAuthor(user);\n	      }).then(function (comments) {\n	        // The user's comments are now available\n	      });\n	      ```\n	\n	      If the assimliated promise rejects, then the downstream promise will also reject.\n	\n	      ```js\n	      findUser().then(function (user) {\n	        return findCommentsByAuthor(user);\n	      }).then(function (comments) {\n	        // If `findCommentsByAuthor` fulfills, we'll have the value here\n	      }, function (reason) {\n	        // If `findCommentsByAuthor` rejects, we'll have the reason here\n	      });\n	      ```\n	\n	      Simple Example\n	      --------------\n	\n	      Synchronous Example\n	\n	      ```javascript\n	      var result;\n	\n	      try {\n	        result = findResult();\n	        // success\n	      } catch(reason) {\n	        // failure\n	      }\n	      ```\n	\n	      Errback Example\n	\n	      ```js\n	      findResult(function(result, err){\n	        if (err) {\n	          // failure\n	        } else {\n	          // success\n	        }\n	      });\n	      ```\n	\n	      Promise Example;\n	\n	      ```javascript\n	      findResult().then(function(result){\n	        // success\n	      }, function(reason){\n	        // failure\n	      });\n	      ```\n	\n	      Advanced Example\n	      --------------\n	\n	      Synchronous Example\n	\n	      ```javascript\n	      var author, books;\n	\n	      try {\n	        author = findAuthor();\n	        books  = findBooksByAuthor(author);\n	        // success\n	      } catch(reason) {\n	        // failure\n	      }\n	      ```\n	\n	      Errback Example\n	\n	      ```js\n	\n	      function foundBooks(books) {\n	\n	      }\n	\n	      function failure(reason) {\n	\n	      }\n	\n	      findAuthor(function(author, err){\n	        if (err) {\n	          failure(err);\n	          // failure\n	        } else {\n	          try {\n	            findBoooksByAuthor(author, function(books, err) {\n	              if (err) {\n	                failure(err);\n	              } else {\n	                try {\n	                  foundBooks(books);\n	                } catch(reason) {\n	                  failure(reason);\n	                }\n	              }\n	            });\n	          } catch(error) {\n	            failure(err);\n	          }\n	          // success\n	        }\n	      });\n	      ```\n	\n	      Promise Example;\n	\n	      ```javascript\n	      findAuthor().\n	        then(findBooksByAuthor).\n	        then(function(books){\n	          // found books\n	      }).catch(function(reason){\n	        // something went wrong\n	      });\n	      ```\n	\n	      @method then\n	      @param {Function} onFulfilled\n	      @param {Function} onRejected\n	      Useful for tooling.\n	      @return {Promise}\n	    */\n	      then: function(onFulfillment, onRejection) {\n	        var parent = this;\n	        var state = parent._state;\n	\n	        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n	          return this;\n	        }\n	\n	        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n	        var result = parent._result;\n	\n	        if (state) {\n	          var callback = arguments[state - 1];\n	          lib$es6$promise$asap$$default(function(){\n	            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n	          });\n	        } else {\n	          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n	        }\n	\n	        return child;\n	      },\n	\n	    /**\n	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n	      as the catch block of a try/catch statement.\n	\n	      ```js\n	      function findAuthor(){\n	        throw new Error('couldn't find that author');\n	      }\n	\n	      // synchronous\n	      try {\n	        findAuthor();\n	      } catch(reason) {\n	        // something went wrong\n	      }\n	\n	      // async with promises\n	      findAuthor().catch(function(reason){\n	        // something went wrong\n	      });\n	      ```\n	\n	      @method catch\n	      @param {Function} onRejection\n	      Useful for tooling.\n	      @return {Promise}\n	    */\n	      'catch': function(onRejection) {\n	        return this.then(null, onRejection);\n	      }\n	    };\n	    function lib$es6$promise$polyfill$$polyfill() {\n	      var local;\n	\n	      if (typeof global !== 'undefined') {\n	          local = global;\n	      } else if (typeof self !== 'undefined') {\n	          local = self;\n	      } else {\n	          try {\n	              local = Function('return this')();\n	          } catch (e) {\n	              throw new Error('polyfill failed because global object is unavailable in this environment');\n	          }\n	      }\n	\n	      var P = local.Promise;\n	\n	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n	        return;\n	      }\n	\n	      local.Promise = lib$es6$promise$promise$$default;\n	    }\n	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n	\n	    var lib$es6$promise$umd$$ES6Promise = {\n	      'Promise': lib$es6$promise$promise$$default,\n	      'polyfill': lib$es6$promise$polyfill$$default\n	    };\n	\n	    /* global define:true module:true window: true */\n	    if (\"function\" === 'function' && __webpack_require__(9)['amd']) {\n	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	    } else if (typeof module !== 'undefined' && module['exports']) {\n	      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n	    } else if (typeof this !== 'undefined') {\n	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n	    }\n	\n	    lib$es6$promise$polyfill$$default();\n	}).call(this);\n	\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, (function() { return this; }()), __webpack_require__(8)(module)))\n	\n	/***/ },\n	/* 6 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(7).nextTick;\n	var apply = Function.prototype.apply;\n	var slice = Array.prototype.slice;\n	var immediateIds = {};\n	var nextImmediateId = 0;\n	\n	// DOM APIs, for completeness\n	\n	exports.setTimeout = function() {\n	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n	};\n	exports.setInterval = function() {\n	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n	};\n	exports.clearTimeout =\n	exports.clearInterval = function(timeout) { timeout.close(); };\n	\n	function Timeout(id, clearFn) {\n	  this._id = id;\n	  this._clearFn = clearFn;\n	}\n	Timeout.prototype.unref = Timeout.prototype.ref = function() {};\n	Timeout.prototype.close = function() {\n	  this._clearFn.call(window, this._id);\n	};\n	\n	// Does not start the time, just sets up the members needed.\n	exports.enroll = function(item, msecs) {\n	  clearTimeout(item._idleTimeoutId);\n	  item._idleTimeout = msecs;\n	};\n	\n	exports.unenroll = function(item) {\n	  clearTimeout(item._idleTimeoutId);\n	  item._idleTimeout = -1;\n	};\n	\n	exports._unrefActive = exports.active = function(item) {\n	  clearTimeout(item._idleTimeoutId);\n	\n	  var msecs = item._idleTimeout;\n	  if (msecs >= 0) {\n	    item._idleTimeoutId = setTimeout(function onTimeout() {\n	      if (item._onTimeout)\n	        item._onTimeout();\n	    }, msecs);\n	  }\n	};\n	\n	// That's not how node.js implements it but the exposed api is the same.\n	exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n	  var id = nextImmediateId++;\n	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n	\n	  immediateIds[id] = true;\n	\n	  nextTick(function onNextTick() {\n	    if (immediateIds[id]) {\n	      // fn.call() is faster so we optimize for the common use-case\n	      // @see http://jsperf.com/call-apply-segu\n	      if (args) {\n	        fn.apply(null, args);\n	      } else {\n	        fn.call(null);\n	      }\n	      // Prevent ids from leaking\n	      exports.clearImmediate(id);\n	    }\n	  });\n	\n	  return id;\n	};\n	\n	exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n	  delete immediateIds[id];\n	};\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, __webpack_require__(6).clearImmediate))\n	\n	/***/ },\n	/* 7 */\n	/***/ function(module, exports) {\n	\n	// shim for using process in browser\n	\n	var process = module.exports = {};\n	var queue = [];\n	var draining = false;\n	var currentQueue;\n	var queueIndex = -1;\n	\n	function cleanUpNextTick() {\n	    draining = false;\n	    if (currentQueue.length) {\n	        queue = currentQueue.concat(queue);\n	    } else {\n	        queueIndex = -1;\n	    }\n	    if (queue.length) {\n	        drainQueue();\n	    }\n	}\n	\n	function drainQueue() {\n	    if (draining) {\n	        return;\n	    }\n	    var timeout = setTimeout(cleanUpNextTick);\n	    draining = true;\n	\n	    var len = queue.length;\n	    while(len) {\n	        currentQueue = queue;\n	        queue = [];\n	        while (++queueIndex < len) {\n	            if (currentQueue) {\n	                currentQueue[queueIndex].run();\n	            }\n	        }\n	        queueIndex = -1;\n	        len = queue.length;\n	    }\n	    currentQueue = null;\n	    draining = false;\n	    clearTimeout(timeout);\n	}\n	\n	process.nextTick = function (fun) {\n	    var args = new Array(arguments.length - 1);\n	    if (arguments.length > 1) {\n	        for (var i = 1; i < arguments.length; i++) {\n	            args[i - 1] = arguments[i];\n	        }\n	    }\n	    queue.push(new Item(fun, args));\n	    if (queue.length === 1 && !draining) {\n	        setTimeout(drainQueue, 0);\n	    }\n	};\n	\n	// v8 likes predictible objects\n	function Item(fun, array) {\n	    this.fun = fun;\n	    this.array = array;\n	}\n	Item.prototype.run = function () {\n	    this.fun.apply(null, this.array);\n	};\n	process.title = 'browser';\n	process.browser = true;\n	process.env = {};\n	process.argv = [];\n	process.version = ''; // empty string to avoid regexp issues\n	process.versions = {};\n	\n	function noop() {}\n	\n	process.on = noop;\n	process.addListener = noop;\n	process.once = noop;\n	process.off = noop;\n	process.removeListener = noop;\n	process.removeAllListeners = noop;\n	process.emit = noop;\n	\n	process.binding = function (name) {\n	    throw new Error('process.binding is not supported');\n	};\n	\n	process.cwd = function () { return '/' };\n	process.chdir = function (dir) {\n	    throw new Error('process.chdir is not supported');\n	};\n	process.umask = function() { return 0; };\n	\n	\n	/***/ },\n	/* 8 */\n	/***/ function(module, exports) {\n	\n	module.exports = function(module) {\n		if(!module.webpackPolyfill) {\n			module.deprecate = function() {};\n			module.paths = [];\n			// module.parent = undefined by default\n			module.children = [];\n			module.webpackPolyfill = 1;\n		}\n		return module;\n	}\n	\n	\n	/***/ },\n	/* 9 */\n	/***/ function(module, exports) {\n	\n	module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\n	\n	\n	/***/ },\n	/* 10 */\n	/***/ function(module, exports) {\n	\n	(function() {\n	  'use strict';\n	\n	  if (self.fetch) {\n	    return\n	  }\n	\n	  function normalizeName(name) {\n	    if (typeof name !== 'string') {\n	      name = String(name)\n	    }\n	    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n	      throw new TypeError('Invalid character in header field name')\n	    }\n	    return name.toLowerCase()\n	  }\n	\n	  function normalizeValue(value) {\n	    if (typeof value !== 'string') {\n	      value = String(value)\n	    }\n	    return value\n	  }\n	\n	  function Headers(headers) {\n	    this.map = {}\n	\n	    if (headers instanceof Headers) {\n	      headers.forEach(function(value, name) {\n	        this.append(name, value)\n	      }, this)\n	\n	    } else if (headers) {\n	      Object.getOwnPropertyNames(headers).forEach(function(name) {\n	        this.append(name, headers[name])\n	      }, this)\n	    }\n	  }\n	\n	  Headers.prototype.append = function(name, value) {\n	    name = normalizeName(name)\n	    value = normalizeValue(value)\n	    var list = this.map[name]\n	    if (!list) {\n	      list = []\n	      this.map[name] = list\n	    }\n	    list.push(value)\n	  }\n	\n	  Headers.prototype['delete'] = function(name) {\n	    delete this.map[normalizeName(name)]\n	  }\n	\n	  Headers.prototype.get = function(name) {\n	    var values = this.map[normalizeName(name)]\n	    return values ? values[0] : null\n	  }\n	\n	  Headers.prototype.getAll = function(name) {\n	    return this.map[normalizeName(name)] || []\n	  }\n	\n	  Headers.prototype.has = function(name) {\n	    return this.map.hasOwnProperty(normalizeName(name))\n	  }\n	\n	  Headers.prototype.set = function(name, value) {\n	    this.map[normalizeName(name)] = [normalizeValue(value)]\n	  }\n	\n	  Headers.prototype.forEach = function(callback, thisArg) {\n	    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n	      this.map[name].forEach(function(value) {\n	        callback.call(thisArg, value, name, this)\n	      }, this)\n	    }, this)\n	  }\n	\n	  function consumed(body) {\n	    if (body.bodyUsed) {\n	      return Promise.reject(new TypeError('Already read'))\n	    }\n	    body.bodyUsed = true\n	  }\n	\n	  function fileReaderReady(reader) {\n	    return new Promise(function(resolve, reject) {\n	      reader.onload = function() {\n	        resolve(reader.result)\n	      }\n	      reader.onerror = function() {\n	        reject(reader.error)\n	      }\n	    })\n	  }\n	\n	  function readBlobAsArrayBuffer(blob) {\n	    var reader = new FileReader()\n	    reader.readAsArrayBuffer(blob)\n	    return fileReaderReady(reader)\n	  }\n	\n	  function readBlobAsText(blob) {\n	    var reader = new FileReader()\n	    reader.readAsText(blob)\n	    return fileReaderReady(reader)\n	  }\n	\n	  var support = {\n	    blob: 'FileReader' in self && 'Blob' in self && (function() {\n	      try {\n	        new Blob();\n	        return true\n	      } catch(e) {\n	        return false\n	      }\n	    })(),\n	    formData: 'FormData' in self\n	  }\n	\n	  function Body() {\n	    this.bodyUsed = false\n	\n	\n	    this._initBody = function(body) {\n	      this._bodyInit = body\n	      if (typeof body === 'string') {\n	        this._bodyText = body\n	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n	        this._bodyBlob = body\n	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n	        this._bodyFormData = body\n	      } else if (!body) {\n	        this._bodyText = ''\n	      } else {\n	        throw new Error('unsupported BodyInit type')\n	      }\n	    }\n	\n	    if (support.blob) {\n	      this.blob = function() {\n	        var rejected = consumed(this)\n	        if (rejected) {\n	          return rejected\n	        }\n	\n	        if (this._bodyBlob) {\n	          return Promise.resolve(this._bodyBlob)\n	        } else if (this._bodyFormData) {\n	          throw new Error('could not read FormData body as blob')\n	        } else {\n	          return Promise.resolve(new Blob([this._bodyText]))\n	        }\n	      }\n	\n	      this.arrayBuffer = function() {\n	        return this.blob().then(readBlobAsArrayBuffer)\n	      }\n	\n	      this.text = function() {\n	        var rejected = consumed(this)\n	        if (rejected) {\n	          return rejected\n	        }\n	\n	        if (this._bodyBlob) {\n	          return readBlobAsText(this._bodyBlob)\n	        } else if (this._bodyFormData) {\n	          throw new Error('could not read FormData body as text')\n	        } else {\n	          return Promise.resolve(this._bodyText)\n	        }\n	      }\n	    } else {\n	      this.text = function() {\n	        var rejected = consumed(this)\n	        return rejected ? rejected : Promise.resolve(this._bodyText)\n	      }\n	    }\n	\n	    if (support.formData) {\n	      this.formData = function() {\n	        return this.text().then(decode)\n	      }\n	    }\n	\n	    this.json = function() {\n	      return this.text().then(JSON.parse)\n	    }\n	\n	    return this\n	  }\n	\n	  // HTTP methods whose capitalization should be normalized\n	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n	\n	  function normalizeMethod(method) {\n	    var upcased = method.toUpperCase()\n	    return (methods.indexOf(upcased) > -1) ? upcased : method\n	  }\n	\n	  function Request(input, options) {\n	    options = options || {}\n	    var body = options.body\n	    if (Request.prototype.isPrototypeOf(input)) {\n	      if (input.bodyUsed) {\n	        throw new TypeError('Already read')\n	      }\n	      this.url = input.url\n	      this.credentials = input.credentials\n	      if (!options.headers) {\n	        this.headers = new Headers(input.headers)\n	      }\n	      this.method = input.method\n	      this.mode = input.mode\n	      if (!body) {\n	        body = input._bodyInit\n	        input.bodyUsed = true\n	      }\n	    } else {\n	      this.url = input\n	    }\n	\n	    this.credentials = options.credentials || this.credentials || 'omit'\n	    if (options.headers || !this.headers) {\n	      this.headers = new Headers(options.headers)\n	    }\n	    this.method = normalizeMethod(options.method || this.method || 'GET')\n	    this.mode = options.mode || this.mode || null\n	    this.referrer = null\n	\n	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n	      throw new TypeError('Body not allowed for GET or HEAD requests')\n	    }\n	    this._initBody(body)\n	  }\n	\n	  function decode(body) {\n	    var form = new FormData()\n	    body.trim().split('&').forEach(function(bytes) {\n	      if (bytes) {\n	        var split = bytes.split('=')\n	        var name = split.shift().replace(/\\+/g, ' ')\n	        var value = split.join('=').replace(/\\+/g, ' ')\n	        form.append(decodeURIComponent(name), decodeURIComponent(value))\n	      }\n	    })\n	    return form\n	  }\n	\n	  function headers(xhr) {\n	    var head = new Headers()\n	    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n	    pairs.forEach(function(header) {\n	      var split = header.trim().split(':')\n	      var key = split.shift().trim()\n	      var value = split.join(':').trim()\n	      head.append(key, value)\n	    })\n	    return head\n	  }\n	\n	  Body.call(Request.prototype)\n	\n	  function Response(bodyInit, options) {\n	    if (!options) {\n	      options = {}\n	    }\n	\n	    this._initBody(bodyInit)\n	    this.type = 'default'\n	    this.url = null\n	    this.status = options.status\n	    this.ok = this.status >= 200 && this.status < 300\n	    this.statusText = options.statusText\n	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n	    this.url = options.url || ''\n	  }\n	\n	  Body.call(Response.prototype)\n	\n	  self.Headers = Headers;\n	  self.Request = Request;\n	  self.Response = Response;\n	\n	  self.fetch = function(input, init) {\n	    var request\n	    if (Request.prototype.isPrototypeOf(input) && !init) {\n	      request = input\n	    } else {\n	      request = new Request(input, init)\n	    }\n	\n	    return new Promise(function(resolve, reject) {\n	      var xhr = new XMLHttpRequest()\n	\n	      function responseURL() {\n	        if ('responseURL' in xhr) {\n	          return xhr.responseURL\n	        }\n	\n	        // Avoid security warnings on getResponseHeader when not allowed by CORS\n	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n	          return xhr.getResponseHeader('X-Request-URL')\n	        }\n	\n	        return;\n	      }\n	\n	      xhr.onload = function() {\n	        var status = (xhr.status === 1223) ? 204 : xhr.status\n	        if (status < 100 || status > 599) {\n	          reject(new TypeError('Network request failed'))\n	          return\n	        }\n	        var options = {\n	          status: status,\n	          statusText: xhr.statusText,\n	          headers: headers(xhr),\n	          url: responseURL()\n	        }\n	        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n	        resolve(new Response(body, options))\n	      }\n	\n	      xhr.onerror = function() {\n	        reject(new TypeError('Network request failed'))\n	      }\n	\n	      xhr.open(request.method, request.url, true)\n	\n	      if (request.credentials === 'include') {\n	        xhr.withCredentials = true\n	      }\n	\n	      if ('responseType' in xhr && support.blob) {\n	        xhr.responseType = 'blob'\n	      }\n	\n	      request.headers.forEach(function(value, name) {\n	        xhr.setRequestHeader(name, value)\n	      })\n	\n	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n	    })\n	  }\n	  self.fetch.polyfill = true\n	})();\n	\n	\n	/***/ },\n	/* 11 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	/* WEBPACK VAR INJECTION */(function(module) {// Version: 3.7.16\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	/* =-=========================     JSON     =============================-= */\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	\n	(window['JSON'] && window['JSON']['stringify']) || (function () {\n	    window['JSON'] || (window['JSON'] = {});\n	\n	    function toJSON(key) {\n	        try      { return this.valueOf() }\n	        catch(e) { return null }\n	    }\n	\n	    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n	        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n	        gap,\n	        indent,\n	        meta = {    // table of character substitutions\n	            '\\b': '\\\\b',\n	            '\\t': '\\\\t',\n	            '\\n': '\\\\n',\n	            '\\f': '\\\\f',\n	            '\\r': '\\\\r',\n	            '\"' : '\\\\\"',\n	            '\\\\': '\\\\\\\\'\n	        },\n	        rep;\n	\n	    function quote(string) {\n	        escapable.lastIndex = 0;\n	        return escapable.test(string) ?\n	            '\"' + string.replace(escapable, function (a) {\n	                var c = meta[a];\n	                return typeof c === 'string' ? c :\n	                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n	            }) + '\"' :\n	            '\"' + string + '\"';\n	    }\n	\n	    function str(key, holder) {\n	        var i,          // The loop counter.\n	            k,          // The member key.\n	            v,          // The member value.\n	            length,\n	            partial,\n	            mind  = gap,\n	            value = holder[key];\n	\n	        if (value && typeof value === 'object') {\n	            value = toJSON.call( value, key );\n	        }\n	\n	        if (typeof rep === 'function') {\n	            value = rep.call(holder, key, value);\n	        }\n	\n	        switch (typeof value) {\n	        case 'string':\n	            return quote(value);\n	\n	        case 'number':\n	            return isFinite(value) ? String(value) : 'null';\n	\n	        case 'boolean':\n	        case 'null':\n	            return String(value);\n	\n	        case 'object':\n	\n	            if (!value) {\n	                return 'null';\n	            }\n	\n	            gap += indent;\n	            partial = [];\n	\n	            if (Object.prototype.toString.apply(value) === '[object Array]') {\n	\n	                length = value.length;\n	                for (i = 0; i < length; i += 1) {\n	                    partial[i] = str(i, value) || 'null';\n	                }\n	\n	                v = partial.length === 0 ? '[]' :\n	                    gap ? '[\\n' + gap +\n	                            partial.join(',\\n' + gap) + '\\n' +\n	                                mind + ']' :\n	                          '[' + partial.join(',') + ']';\n	                gap = mind;\n	                return v;\n	            }\n	            if (rep && typeof rep === 'object') {\n	                length = rep.length;\n	                for (i = 0; i < length; i += 1) {\n	                    k = rep[i];\n	                    if (typeof k === 'string') {\n	                        v = str(k, value);\n	                        if (v) {\n	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n	                        }\n	                    }\n	                }\n	            } else {\n	                for (k in value) {\n	                    if (Object.hasOwnProperty.call(value, k)) {\n	                        v = str(k, value);\n	                        if (v) {\n	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n	                        }\n	                    }\n	                }\n	            }\n	\n	            v = partial.length === 0 ? '{}' :\n	                gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n	                        mind + '}' : '{' + partial.join(',') + '}';\n	            gap = mind;\n	            return v;\n	        }\n	    }\n	\n	    if (typeof JSON['stringify'] !== 'function') {\n	        JSON['stringify'] = function (value, replacer, space) {\n	            var i;\n	            gap = '';\n	            indent = '';\n	\n	            if (typeof space === 'number') {\n	                for (i = 0; i < space; i += 1) {\n	                    indent += ' ';\n	                }\n	            } else if (typeof space === 'string') {\n	                indent = space;\n	            }\n	            rep = replacer;\n	            if (replacer && typeof replacer !== 'function' &&\n	                    (typeof replacer !== 'object' ||\n	                     typeof replacer.length !== 'number')) {\n	                throw new Error('JSON.stringify');\n	            }\n	            return str('', {'': value});\n	        };\n	    }\n	\n	    if (typeof JSON['parse'] !== 'function') {\n	        // JSON is parsed on the server for security.\n	        JSON['parse'] = function (text) {return eval('('+text+')')};\n	    }\n	}());\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	/* =-=========================     UTIL     =============================-= */\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	\n	window['PUBNUB'] || (function() {\n	var NOW             = 1\n	,   READY           = false\n	,   READY_BUFFER    = []\n	,   PRESENCE_SUFFIX = '-pnpres'\n	,   DEF_WINDOWING   = 10     // MILLISECONDS.\n	,   DEF_TIMEOUT     = 10000  // MILLISECONDS.\n	,   DEF_SUB_TIMEOUT = 310    // SECONDS.\n	,   DEF_KEEPALIVE   = 60     // SECONDS (FOR TIMESYNC).\n	,   SECOND          = 1000   // A THOUSAND MILLISECONDS.\n	,   URLBIT          = '/'\n	,   PARAMSBIT       = '&'\n	,   PRESENCE_HB_THRESHOLD = 5\n	,   PRESENCE_HB_DEFAULT  = 30\n	,   SDK_VER         = '3.7.16'\n	,   REPL            = /{([\\w\\-]+)}/g;\n	\n	/**\n	 * UTILITIES\n	 */\n	function unique() { return'x'+ ++NOW+''+(+new Date) }\n	function rnow()   { return+new Date }\n	\n	/**\n	 * NEXTORIGIN\n	 * ==========\n	 * var next_origin = nextorigin();\n	 */\n	var nextorigin = (function() {\n	    var max = 20\n	    ,   ori = Math.floor(Math.random() * max);\n	    return function( origin, failover ) {\n	        return origin.indexOf('pubsub.') > 0\n	            && origin.replace(\n	             'pubsub', 'ps' + (\n	                failover ? generate_uuid().split('-')[0] :\n	                (++ori < max? ori : ori=1)\n	            ) ) || origin;\n	    }\n	})();\n	\n	\n	/**\n	 * Build Url\n	 * =======\n	 *\n	 */\n	function build_url( url_components, url_params ) {\n	    var url    = url_components.join(URLBIT)\n	    ,   params = [];\n	\n	    if (!url_params) return url;\n	\n	    each( url_params, function( key, value ) {\n	        var value_str = (typeof value == 'object')?JSON['stringify'](value):value;\n	        (typeof value != 'undefined' &&\n	            value != null && encode(value_str).length > 0\n	        ) && params.push(key + \"=\" + encode(value_str));\n	    } );\n	\n	    url += \"?\" + params.join(PARAMSBIT);\n	    return url;\n	}\n	\n	/**\n	 * UPDATER\n	 * =======\n	 * var timestamp = unique();\n	 */\n	function updater( fun, rate ) {\n	    var timeout\n	    ,   last   = 0\n	    ,   runnit = function() {\n	        if (last + rate > rnow()) {\n	            clearTimeout(timeout);\n	            timeout = setTimeout( runnit, rate );\n	        }\n	        else {\n	            last = rnow();\n	            fun();\n	        }\n	    };\n	\n	    return runnit;\n	}\n	\n	/**\n	 * GREP\n	 * ====\n	 * var list = grep( [1,2,3], function(item) { return item % 2 } )\n	 */\n	function grep( list, fun ) {\n	    var fin = [];\n	    each( list || [], function(l) { fun(l) && fin.push(l) } );\n	    return fin\n	}\n	\n	/**\n	 * SUPPLANT\n	 * ========\n	 * var text = supplant( 'Hello {name}!', { name : 'John' } )\n	 */\n	function supplant( str, values ) {\n	    return str.replace( REPL, function( _, match ) {\n	        return values[match] || _\n	    } );\n	}\n	\n	/**\n	 * timeout\n	 * =======\n	 * timeout( function(){}, 100 );\n	 */\n	function timeout( fun, wait ) {\n	    return setTimeout( fun, wait );\n	}\n	\n	/**\n	 * uuid\n	 * ====\n	 * var my_uuid = generate_uuid();\n	 */\n	function generate_uuid(callback) {\n	    var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,\n	    function(c) {\n	        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n	        return v.toString(16);\n	    });\n	    if (callback) callback(u);\n	    return u;\n	}\n	\n	function isArray(arg) {\n	  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n	  //return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === \"number\")\n	}\n	\n	/**\n	 * EACH\n	 * ====\n	 * each( [1,2,3], function(item) { } )\n	 */\n	function each( o, f) {\n	    if ( !o || !f ) return;\n	\n	    if ( isArray(o) )\n	        for ( var i = 0, l = o.length; i < l; )\n	            f.call( o[i], o[i], i++ );\n	    else\n	        for ( var i in o )\n	            o.hasOwnProperty    &&\n	            o.hasOwnProperty(i) &&\n	            f.call( o[i], i, o[i] );\n	}\n	\n	/**\n	 * MAP\n	 * ===\n	 * var list = map( [1,2,3], function(item) { return item + 1 } )\n	 */\n	function map( list, fun ) {\n	    var fin = [];\n	    each( list || [], function( k, v ) { fin.push(fun( k, v )) } );\n	    return fin;\n	}\n	\n	\n	function pam_encode(str) {\n	  return encodeURIComponent(str).replace(/[!'()*~]/g, function(c) {\n	    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n	  });\n	}\n	\n	/**\n	 * ENCODE\n	 * ======\n	 * var encoded_data = encode('path');\n	 */\n	function encode(path) { return encodeURIComponent(path) }\n	\n	/**\n	 * Generate Subscription Channel List\n	 * ==================================\n	 * generate_channel_list(channels_object);\n	 */\n	function generate_channel_list(channels, nopresence) {\n	    var list = [];\n	    each( channels, function( channel, status ) {\n	        if (nopresence) {\n	            if(channel.search('-pnpres') < 0) {\n	                if (status.subscribed) list.push(channel);\n	            }\n	        } else {\n	            if (status.subscribed) list.push(channel);\n	        }\n	    });\n	    return list.sort();\n	}\n	\n	/**\n	 * Generate Subscription Channel Groups List\n	 * ==================================\n	 * generate_channel_group_list(channels_groups object);\n	 */\n	function generate_channel_group_list(channel_groups, nopresence) {\n	    var list = [];\n	    each(channel_groups, function( channel_group, status ) {\n	        if (nopresence) {\n	            if(channel_group.search('-pnpres') < 0) {\n	                if (status.subscribed) list.push(channel_group);\n	            }\n	        } else {\n	            if (status.subscribed) list.push(channel_group);\n	        }\n	    });\n	    return list.sort();\n	}\n	\n	// PUBNUB READY TO CONNECT\n	function ready() { timeout( function() {\n	    if (READY) return;\n	    READY = 1;\n	    each( READY_BUFFER, function(connect) { connect() } );\n	}, SECOND ); }\n	\n	function PNmessage(args) {\n	    msg = args || {'apns' : {}},\n	    msg['getPubnubMessage'] = function() {\n	        var m = {};\n	\n	        if (Object.keys(msg['apns']).length) {\n	            m['pn_apns'] = {\n	                    'aps' : {\n	                        'alert' : msg['apns']['alert'] ,\n	                        'badge' : msg['apns']['badge']\n	                    }\n	            }\n	            for (var k in msg['apns']) {\n	                m['pn_apns'][k] = msg['apns'][k];\n	            }\n	            var exclude1 = ['badge','alert'];\n	            for (var k in exclude1) {\n	                delete m['pn_apns'][exclude1[k]];\n	            }\n	        }\n	\n	\n	\n	        if (msg['gcm']) {\n	            m['pn_gcm'] = {\n	                'data' : msg['gcm']\n	            }\n	        }\n	\n	        for (var k in msg) {\n	            m[k] = msg[k];\n	        }\n	        var exclude = ['apns','gcm','publish', 'channel','callback','error'];\n	        for (var k in exclude) {\n	            delete m[exclude[k]];\n	        }\n	\n	        return m;\n	    };\n	    msg['publish'] = function() {\n	\n	        var m = msg.getPubnubMessage();\n	\n	        if (msg['pubnub'] && msg['channel']) {\n	            msg['pubnub'].publish({\n	                'message' : m,\n	                'channel' : msg['channel'],\n	                'callback' : msg['callback'],\n	                'error' : msg['error']\n	            })\n	        }\n	    };\n	    return msg;\n	}\n	\n	function PN_API(setup) {\n	    var SUB_WINDOWING =  +setup['windowing']   || DEF_WINDOWING\n	    ,   SUB_TIMEOUT   = (+setup['timeout']     || DEF_SUB_TIMEOUT) * SECOND\n	    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n	    ,   TIME_CHECK    = setup['timecheck']     || 0\n	    ,   NOLEAVE       = setup['noleave']       || 0\n	    ,   PUBLISH_KEY   = setup['publish_key']\n	    ,   SUBSCRIBE_KEY = setup['subscribe_key']\n	    ,   AUTH_KEY      = setup['auth_key']      || ''\n	    ,   SECRET_KEY    = setup['secret_key']    || ''\n	    ,   hmac_SHA256   = setup['hmac_SHA256']\n	    ,   SSL           = setup['ssl']            ? 's' : ''\n	    ,   ORIGIN        = 'http'+SSL+'://'+(setup['origin']||'pubsub.pubnub.com')\n	    ,   STD_ORIGIN    = nextorigin(ORIGIN)\n	    ,   SUB_ORIGIN    = nextorigin(ORIGIN)\n	    ,   CONNECT       = function(){}\n	    ,   PUB_QUEUE     = []\n	    ,   CLOAK         = true\n	    ,   TIME_DRIFT    = 0\n	    ,   SUB_CALLBACK  = 0\n	    ,   SUB_CHANNEL   = 0\n	    ,   SUB_RECEIVER  = 0\n	    ,   SUB_RESTORE   = setup['restore'] || 0\n	    ,   SUB_BUFF_WAIT = 0\n	    ,   TIMETOKEN     = 0\n	    ,   RESUMED       = false\n	    ,   CHANNELS      = {}\n	    ,   CHANNEL_GROUPS       = {}\n	    ,   SUB_ERROR     = function(){}\n	    ,   STATE         = {}\n	    ,   PRESENCE_HB_TIMEOUT  = null\n	    ,   PRESENCE_HB          = validate_presence_heartbeat(\n	        setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']\n	    )\n	    ,   PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) -1\n	    ,   PRESENCE_HB_RUNNING  = false\n	    ,   NO_WAIT_FOR_PENDING  = setup['no_wait_for_pending']\n	    ,   COMPATIBLE_35 = setup['compatible_3.5']  || false\n	    ,   xdr           = setup['xdr']\n	    ,   params        = setup['params'] || {}\n	    ,   error         = setup['error']      || function() {}\n	    ,   _is_online    = setup['_is_online'] || function() { return 1 }\n	    ,   jsonp_cb      = setup['jsonp_cb']   || function() { return 0 }\n	    ,   db            = setup['db']         || {'get': function(){}, 'set': function(){}}\n	    ,   CIPHER_KEY    = setup['cipher_key']\n	    ,   UUID          = setup['uuid'] || ( !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY+'uuid') || '')\n	    ,   USE_INSTANCEID = setup['instance_id'] || false\n	    ,   INSTANCEID    = ''\n	    ,   shutdown      = setup['shutdown']\n	    ,   use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined')?setup['use_send_beacon']:true\n	    ,   sendBeacon    = (use_send_beacon)?setup['sendBeacon']:null\n	    ,   _poll_timer\n	    ,   _poll_timer2;\n	\n	    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n	\n	    var crypto_obj    = setup['crypto_obj'] ||\n	        {\n	            'encrypt' : function(a,key){ return a},\n	            'decrypt' : function(b,key){return b}\n	        };\n	\n	    function _get_url_params(data) {\n	        if (!data) data = {};\n	        each( params , function( key, value ) {\n	            if (!(key in data)) data[key] = value;\n	        });\n	        return data;\n	    }\n	\n	    function _object_to_key_list(o) {\n	        var l = []\n	        each( o , function( key, value ) {\n	            l.push(key);\n	        });\n	        return l;\n	    }\n	    function _object_to_key_list_sorted(o) {\n	        return _object_to_key_list(o).sort();\n	    }\n	\n	    function _get_pam_sign_input_from_params(params) {\n	        var si = \"\";\n	        var l = _object_to_key_list_sorted(params);\n	\n	        for (var i in l) {\n	            var k = l[i]\n	            si += k + \"=\" + pam_encode(params[k]) ;\n	            if (i != l.length - 1) si += \"&\"\n	        }\n	        return si;\n	    }\n	\n	    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n	        var err = false;\n	\n	        if (typeof heartbeat === 'undefined') {\n	            return cur_heartbeat;\n	        }\n	\n	        if (typeof heartbeat === 'number') {\n	            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0)\n	                err = false;\n	            else\n	                err = true;\n	        } else if(typeof heartbeat === 'boolean'){\n	            if (!heartbeat) {\n	                return 0;\n	            } else {\n	                return PRESENCE_HB_DEFAULT;\n	            }\n	        } else {\n	            err = true;\n	        }\n	\n	        if (err) {\n	            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n	            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n	        } else return heartbeat;\n	    }\n	\n	    function encrypt(input, key) {\n	        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n	    }\n	    function decrypt(input, key) {\n	        return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||\n	               crypto_obj['decrypt'](input, CIPHER_KEY) ||\n	               input;\n	    }\n	\n	    function error_common(message, callback) {\n	        callback && callback({ 'error' : message || \"error occurred\"});\n	        error && error(message);\n	    }\n	    function _presence_heartbeat() {\n	\n	        clearTimeout(PRESENCE_HB_TIMEOUT);\n	\n	        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||\n	            PRESENCE_HB_INTERVAL < 1 ||\n	            (!generate_channel_list(CHANNELS,true).length  && !generate_channel_group_list(CHANNEL_GROUPS, true).length ) )\n	        {\n	            PRESENCE_HB_RUNNING = false;\n	            return;\n	        }\n	\n	        PRESENCE_HB_RUNNING = true;\n	        SELF['presence_heartbeat']({\n	            'callback' : function(r) {\n	                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n	            },\n	            'error' : function(e) {\n	                error && error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n	                PRESENCE_HB_TIMEOUT = timeout( _presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND );\n	            }\n	        });\n	    }\n	\n	    function start_presence_heartbeat() {\n	        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n	    }\n	\n	    function publish(next) {\n	\n	        if (NO_WAIT_FOR_PENDING) {\n	            if (!PUB_QUEUE.length) return;\n	        } else {\n	            if (next) PUB_QUEUE.sending = 0;\n	            if ( PUB_QUEUE.sending || !PUB_QUEUE.length ) return;\n	            PUB_QUEUE.sending = 1;\n	        }\n	\n	        xdr(PUB_QUEUE.shift());\n	    }\n	    function each_channel_group(callback) {\n	        var count = 0;\n	\n	        each( generate_channel_group_list(CHANNEL_GROUPS), function(channel_group) {\n	            var chang = CHANNEL_GROUPS[channel_group];\n	\n	            if (!chang) return;\n	\n	            count++;\n	            (callback||function(){})(chang);\n	        } );\n	\n	        return count;\n	    }\n	\n	    function each_channel(callback) {\n	        var count = 0;\n	\n	        each( generate_channel_list(CHANNELS), function(channel) {\n	            var chan = CHANNELS[channel];\n	\n	            if (!chan) return;\n	\n	            count++;\n	            (callback||function(){})(chan);\n	        } );\n	\n	        return count;\n	    }\n	    function _invoke_callback(response, callback, err) {\n	        if (typeof response == 'object') {\n	            if (response['error']) {\n	                var callback_data = {};\n	\n	                if (response['message']) {\n	                    callback_data['message'] = response['message'];\n	                }\n	\n	                if (response['payload']) {\n	                    callback_data['payload'] = response['payload'];\n	                }\n	\n	                err && err(callback_data);\n	                return;\n	\n	            }\n	            if (response['payload']) {\n	                if (response['next_page'])\n	                    callback && callback(response['payload'], response['next_page']);\n	                else\n	                    callback && callback(response['payload']);\n	                return;\n	            }\n	        }\n	        callback && callback(response);\n	    }\n	\n	    function _invoke_error(response,err) {\n	\n	        if (typeof response == 'object' && response['error']) {\n	                var callback_data = {};\n	\n	                if (response['message']) {\n	                    callback_data['message'] = response['message'];\n	                }\n	\n	                if (response['payload']) {\n	                    callback_data['payload'] = response['payload'];\n	                }\n	                \n	                err && err(callback_data);\n	                return;\n	        } else {\n	            err && err(response);\n	        }\n	    }\n	    function CR(args, callback, url1, data) {\n	            var callback        = args['callback']      || callback\n	            ,   err             = args['error']         || error\n	            ,   jsonp           = jsonp_cb();\n	\n	            data = data || {};\n	            \n	            if (!data['auth']) {\n	                data['auth'] = args['auth_key'] || AUTH_KEY;\n	            }\n	            \n	            var url = [\n	                    STD_ORIGIN, 'v1', 'channel-registration',\n	                    'sub-key', SUBSCRIBE_KEY\n	                ];\n	\n	            url.push.apply(url,url1);\n	            \n	            if (jsonp) data['callback']              = jsonp;\n	            \n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	\n	    }\n	\n	    // Announce Leave Event\n	    var SELF = {\n	        'LEAVE' : function( channel, blocking, auth_key, callback, error ) {\n	\n	            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n	            ,   origin = nextorigin(ORIGIN)\n	            ,   callback = callback || function(){}\n	            ,   err      = error    || function(){}\n	            ,   url\n	            ,   params\n	            ,   jsonp  = jsonp_cb();\n	\n	            // Prevent Leaving a Presence Channel\n	            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n	\n	\n	            if (COMPATIBLE_35) {\n	                if (!SSL)         return false;\n	                if (jsonp == '0') return false;\n	            }\n	\n	            if (NOLEAVE)  return false;\n	\n	            if (jsonp != '0') data['callback'] = jsonp;\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            url = [\n	                    origin, 'v2', 'presence', 'sub_key',\n	                    SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'\n	                ];\n	\n	            params = _get_url_params(data);\n	\n	\n	            if (sendBeacon) {\n	                url_string = build_url(url, params);\n	                if (sendBeacon(url_string)) {\n	                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n	                    return true;\n	                }\n	            }\n	\n	\n	            xdr({\n	                blocking : blocking || SSL,\n	                timeout  : 2000,\n	                callback : jsonp,\n	                data     : params,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	            return true;\n	        },\n	        'LEAVE_GROUP' : function( channel_group, blocking, auth_key, callback, error ) {\n	\n	            var data   = { 'uuid' : UUID, 'auth' : auth_key || AUTH_KEY }\n	            ,   origin = nextorigin(ORIGIN)\n	            ,   url\n	            ,   params\n	            ,   callback = callback || function(){}\n	            ,   err      = error    || function(){}\n	            ,   jsonp  = jsonp_cb();\n	\n	            // Prevent Leaving a Presence Channel Group\n	            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n	\n	            if (COMPATIBLE_35) {\n	                if (!SSL)         return false;\n	                if (jsonp == '0') return false;\n	            }\n	\n	            if (NOLEAVE)  return false;\n	\n	            if (jsonp != '0') data['callback'] = jsonp;\n	\n	            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            url = [\n	                    origin, 'v2', 'presence', 'sub_key',\n	                    SUBSCRIBE_KEY, 'channel', encode(','), 'leave'\n	            ];\n	\n	            params = _get_url_params(data);\n	\n	            if (sendBeacon) {\n	                url_string = build_url(url, params);\n	                if (sendBeacon(url_string)) {\n	                    callback && callback({\"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\"});\n	                    return true;\n	                }\n	            }\n	\n	            xdr({\n	                blocking : blocking || SSL,\n	                timeout  : 5000,\n	                callback : jsonp,\n	                data     : params,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	            return true;\n	        },\n	        'set_resumed' : function(resumed) {\n	                RESUMED = resumed;\n	        },\n	        'get_cipher_key' : function() {\n	            return CIPHER_KEY;\n	        },\n	        'set_cipher_key' : function(key) {\n	            CIPHER_KEY = key;\n	        },\n	        'raw_encrypt' : function(input, key) {\n	            return encrypt(input, key);\n	        },\n	        'raw_decrypt' : function(input, key) {\n	            return decrypt(input, key);\n	        },\n	        'get_heartbeat' : function() {\n	            return PRESENCE_HB;\n	        },\n	        \n	        'set_heartbeat' : function(heartbeat, heartbeat_interval) {\n	            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);\n	            PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;\n	            if (PRESENCE_HB == 2) {\n	                PRESENCE_HB_INTERVAL = 1;\n	            }\n	            CONNECT();\n	            _presence_heartbeat();\n	        },\n	        \n	        'get_heartbeat_interval' : function() {\n	            return PRESENCE_HB_INTERVAL;\n	        },\n	        \n	        'set_heartbeat_interval' : function(heartbeat_interval) {\n	            PRESENCE_HB_INTERVAL = heartbeat_interval;\n	            _presence_heartbeat();\n	        },\n	        \n	        'get_version' : function() {\n	            return SDK_VER;\n	        },\n	        'getGcmMessageObject' : function(obj) {\n	            return {\n	                'data' : obj\n	            }\n	        },\n	        'getApnsMessageObject' : function(obj) {\n	            var x =  {\n	                'aps' : { 'badge' : 1, 'alert' : ''}\n	            }\n	            for (k in obj) {\n	                k[x] = obj[k];\n	            }\n	            return x;\n	        },\n	        'newPnMessage' : function() {\n	            var x = {};\n	            if (gcm) x['pn_gcm'] = gcm;\n	            if (apns) x['pn_apns'] = apns;\n	            for ( k in n ) {\n	                x[k] = n[k];\n	            }\n	            return x;\n	        },\n	\n	        '_add_param' : function(key,val) {\n	            params[key] = val;\n	        },\n	\n	        'channel_group' : function(args, callback) {\n	            var ns_ch       = args['channel_group']\n	            ,   callback    = callback         || args['callback']\n	            ,   channels    = args['channels'] || args['channel']\n	            ,   cloak       = args['cloak']\n	            ,   namespace\n	            ,   channel_group\n	            ,   url = []\n	            ,   data = {}\n	            ,   mode = args['mode'] || 'add';\n	\n	\n	            if (ns_ch) {\n	                var ns_ch_a = ns_ch.split(':');\n	\n	                if (ns_ch_a.length > 1) {\n	                    namespace = (ns_ch_a[0] === '*')?null:ns_ch_a[0];\n	\n	                    channel_group = ns_ch_a[1];\n	                } else {\n	                    channel_group = ns_ch_a[0];\n	                }\n	            }\n	\n	            namespace && url.push('namespace') && url.push(encode(namespace));\n	\n	            url.push('channel-group');\n	\n	            if (channel_group && channel_group !== '*') {\n	                url.push(channel_group);\n	            }\n	\n	            if (channels ) {\n	                if (isArray(channels)) {\n	                    channels = channels.join(',');\n	                }\n	                data[mode] = channels;\n	                data['cloak'] = (CLOAK)?'true':'false';\n	            } else {\n	                if (mode === 'remove') url.push('remove');\n	            }\n	\n	            if (typeof cloak != 'undefined') data['cloak'] = (cloak)?'true':'false';\n	\n	            CR(args, callback, url, data);\n	        },\n	\n	        'channel_group_list_groups' : function(args, callback) {\n	            var namespace;\n	\n	            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n	            if (namespace) {\n	                args[\"channel_group\"] = namespace + \":*\";\n	            }\n	\n	            SELF['channel_group'](args, callback);\n	        },\n	\n	        'channel_group_list_channels' : function(args, callback) {\n	            if (!args['channel_group']) return error('Missing Channel Group');\n	            SELF['channel_group'](args, callback);\n	        },\n	\n	        'channel_group_remove_channel' : function(args, callback) {\n	            if (!args['channel_group']) return error('Missing Channel Group');\n	            if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n	\n	            args['mode'] = 'remove';\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_remove_group' : function(args, callback) {\n	            if (!args['channel_group']) return error('Missing Channel Group');\n	            if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n	\n	            args['mode'] = 'remove';\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_add_channel' : function(args, callback) {\n	           if (!args['channel_group']) return error('Missing Channel Group');\n	           if (!args['channel'] && !args['channels'] ) return error('Missing Channel');\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_cloak' : function(args, callback) {\n	            if (typeof args['cloak'] == 'undefined') {\n	                callback(CLOAK);\n	                return;\n	            }\n	            CLOAK = args['cloak'];\n	            SELF['channel_group'](args,callback);\n	        },\n	\n	        'channel_group_list_namespaces' : function(args, callback) {\n	            var url = ['namespace'];\n	            CR(args, callback, url);\n	        },\n	        'channel_group_remove_namespace' : function(args, callback) {\n	            var url = ['namespace',args['namespace'],'remove'];\n	            CR(args, callback, url);\n	        },\n	\n	        /*\n	            PUBNUB.history({\n	                channel  : 'my_chat_channel',\n	                limit    : 100,\n	                callback : function(history) { }\n	            });\n	        */\n	        'history' : function( args, callback ) {\n	            var callback         = args['callback'] || callback\n	            ,   count            = args['count']    || args['limit'] || 100\n	            ,   reverse          = args['reverse']  || \"false\"\n	            ,   err              = args['error']    || function(){}\n	            ,   auth_key         = args['auth_key'] || AUTH_KEY\n	            ,   cipher_key       = args['cipher_key']\n	            ,   channel          = args['channel']\n	            ,   channel_group    = args['channel_group']\n	            ,   start            = args['start']\n	            ,   end              = args['end']\n	            ,   include_token    = args['include_token']\n	            ,   string_msg_token = args['string_message_token'] || false\n	            ,   params           = {}\n	            ,   jsonp            = jsonp_cb();\n	\n	            // Make sure we have a Channel\n	            if (!channel && !channel_group) return error('Missing Channel');\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            params['stringtoken'] = 'true';\n	            params['count']       = count;\n	            params['reverse']     = reverse;\n	            params['auth']        = auth_key;\n	\n	            if (channel_group) {\n	                params['channel-group'] = channel_group;\n	                if (!channel) {\n	                    channel = ','; \n	                }\n	            }\n	            if (jsonp) params['callback']              = jsonp;\n	            if (start) params['start']                 = start;\n	            if (end)   params['end']                   = end;\n	            if (include_token) params['include_token'] = 'true';\n	            if (string_msg_token) params['string_message_token'] = 'true';\n	\n	            // Send Message\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(params),\n	                success  : function(response) {\n	                    if (typeof response == 'object' && response['error']) {\n	                        err({'message' : response['message'], 'payload' : response['payload']});\n	                        return;\n	                    }\n	                    var messages = response[0];\n	                    var decrypted_messages = [];\n	                    for (var a = 0; a < messages.length; a++) {\n	                        if (include_token) {\n	                            var new_message = decrypt(messages[a]['message'],cipher_key);\n	                            var timetoken = messages[a]['timetoken'];\n	                            try {\n	                                decrypted_messages['push']({\"message\" : JSON['parse'](new_message), \"timetoken\" : timetoken});\n	                            } catch (e) {\n	                                decrypted_messages['push'](({\"message\" : new_message, \"timetoken\" : timetoken}));\n	                            }\n	                        } else {\n	                            var new_message = decrypt(messages[a],cipher_key);\n	                            try {\n	                                decrypted_messages['push'](JSON['parse'](new_message));\n	                            } catch (e) {\n	                                decrypted_messages['push']((new_message));\n	                            }     \n	                        }\n	                    }\n	                    callback([decrypted_messages, response[1], response[2]]);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v2', 'history', 'sub-key',\n	                    SUBSCRIBE_KEY, 'channel', encode(channel)\n	                ]\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.replay({\n	                source      : 'my_channel',\n	                destination : 'new_channel'\n	            });\n	        */\n	        'replay' : function(args, callback) {\n	            var callback    = callback || args['callback'] || function(){}\n	            ,   auth_key    = args['auth_key'] || AUTH_KEY\n	            ,   source      = args['source']\n	            ,   destination = args['destination']\n	            ,   stop        = args['stop']\n	            ,   start       = args['start']\n	            ,   end         = args['end']\n	            ,   reverse     = args['reverse']\n	            ,   limit       = args['limit']\n	            ,   jsonp       = jsonp_cb()\n	            ,   data        = {}\n	            ,   url;\n	\n	            // Check User Input\n	            if (!source)        return error('Missing Source Channel');\n	            if (!destination)   return error('Missing Destination Channel');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            // Setup URL Params\n	            if (jsonp != '0') data['callback'] = jsonp;\n	            if (stop)         data['stop']     = 'all';\n	            if (reverse)      data['reverse']  = 'true';\n	            if (start)        data['start']    = start;\n	            if (end)          data['end']      = end;\n	            if (limit)        data['count']    = limit;\n	\n	            data['auth'] = auth_key;\n	\n	            // Compose URL Parts\n	            url = [\n	                STD_ORIGIN, 'v1', 'replay',\n	                PUBLISH_KEY, SUBSCRIBE_KEY,\n	                source, destination\n	            ];\n	\n	            // Start (or Stop) Replay!\n	            xdr({\n	                callback : jsonp,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function() { callback([ 0, 'Disconnected' ]) },\n	                url      : url,\n	                data     : _get_url_params(data)\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.auth('AJFLKAJSDKLA');\n	        */\n	        'auth' : function(auth) {\n	            AUTH_KEY = auth;\n	            CONNECT();\n	        },\n	\n	        /*\n	            PUBNUB.time(function(time){ });\n	        */\n	        'time' : function(callback) {\n	            var jsonp = jsonp_cb();\n	\n	            var data = { 'uuid' : UUID, 'auth' : AUTH_KEY }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                timeout  : SECOND * 5,\n	                url      : [STD_ORIGIN, 'time', jsonp],\n	                success  : function(response) { callback(response[0]) },\n	                fail     : function() { callback(0) }\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.publish({\n	                channel : 'my_chat_channel',\n	                message : 'hello!'\n	            });\n	        */\n	        'publish' : function( args, callback ) {\n	            var msg      = args['message'];\n	            if (!msg) return error('Missing Message');\n	\n	            var callback = callback || args['callback'] || msg['callback'] || function(){}\n	            ,   channel  = args['channel'] || msg['channel']\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   cipher_key = args['cipher_key']\n	            ,   err      = args['error'] || msg['error'] || function() {}\n	            ,   post     = args['post'] || false\n	            ,   store    = ('store_in_history' in args) ? args['store_in_history']: true\n	            ,   jsonp    = jsonp_cb()\n	            ,   add_msg  = 'push'\n	            ,   params\n	            ,   url;\n	\n	            if (args['prepend']) add_msg = 'unshift'\n	\n	            if (!channel)       return error('Missing Channel');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            if (msg['getPubnubMessage']) {\n	                msg = msg['getPubnubMessage']();\n	            }\n	\n	            // If trying to send Object\n	            msg = JSON['stringify'](encrypt(msg, cipher_key));\n	\n	            // Create URL\n	            url = [\n	                STD_ORIGIN, 'publish',\n	                PUBLISH_KEY, SUBSCRIBE_KEY,\n	                0, encode(channel),\n	                jsonp, encode(msg)\n	            ];\n	\n	            params = { 'uuid' : UUID, 'auth' : auth_key }\n	\n	            if (!store) params['store'] =\"0\"\n	\n	            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n	\n	            // Queue Message Send\n	            PUB_QUEUE[add_msg]({\n	                callback : jsonp,\n	                timeout  : SECOND * 5,\n	                url      : url,\n	                data     : _get_url_params(params),\n	                fail     : function(response){\n	                    _invoke_error(response, err);\n	                    publish(1);\n	                },\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                    publish(1);\n	                },\n	                mode     : (post)?'POST':'GET'\n	            });\n	\n	            // Send Message\n	            publish();\n	        },\n	\n	        /*\n	            PUBNUB.unsubscribe({ channel : 'my_chat' });\n	        */\n	        'unsubscribe' : function(args, callback) {\n	            var channel       = args['channel']\n	            ,   channel_group = args['channel_group']\n	            ,   auth_key      = args['auth_key']    || AUTH_KEY\n	            ,   callback      = callback            || args['callback'] || function(){}\n	            ,   err           = args['error']       || function(){};\n	\n	            TIMETOKEN   = 0;\n	            SUB_RESTORE = 1;   // REVISIT !!!!\n	\n	            if (channel) {\n	\n	                // Prepare LeaveChannel(s)\n	                var leave_c = map( (\n	                    channel.join ? channel.join(',') : ''+channel\n	                ).split(','), function(channel) {\n	                    if (!CHANNELS[channel]) return;\n	                    return channel;\n	                } ).join(',');\n	\n	                // Prepare Channel(s)\n	                channel = map( (\n	                    channel.join ? channel.join(',') : ''+channel\n	                ).split(','), function(channel) {\n	                    if (!CHANNELS[channel]) return;\n	                    return channel + ',' + channel + PRESENCE_SUFFIX;\n	                } ).join(',');\n	\n	                // Iterate over Channels\n	                each(channel.split(','), function(ch) {\n	                    if (!ch) return;\n	                    CHANNELS[ch] = 0;\n	                    if (ch in STATE) delete STATE[ch];\n	                } );\n	\n	                var CB_CALLED = true;\n	                if (READY) {\n	                    CB_CALLED = SELF['LEAVE'](leave_c, 0 , auth_key, callback, err);\n	                }\n	                if (!CB_CALLED) callback({action : \"leave\"});\n	            }\n	\n	            if (channel_group) {\n	\n	                // Prepare channel group(s)\n	                var leave_gc = map( (\n	                    channel_group.join ? channel_group.join(',') : ''+channel_group\n	                ).split(','), function(channel_group) {\n	                    if (!CHANNEL_GROUPS[channel_group]) return;\n	                    return channel_group;\n	                } ).join(',');\n	\n	                // Prepare channel group(s)\n	                channel_group = map( (\n	                    channel_group.join ? channel_group.join(',') : ''+channel_group\n	                ).split(','), function(channel_group) {\n	                    if (!CHANNEL_GROUPS[channel_group]) return;\n	                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n	                } ).join(',');\n	\n	                // Iterate over channel groups\n	                each( channel_group.split(','), function(chg) {\n	                    if (!chg) return;\n	                    CHANNEL_GROUPS[chg] = 0;\n	                    if (chg in STATE) delete STATE[chg];\n	                } );\n	\n	                var CB_CALLED = true;\n	                if (READY) {\n	                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0 , auth_key, callback, err);\n	                }\n	                if (!CB_CALLED) callback({action : \"leave\"});\n	            }\n	\n	            // Reset Connection if Count Less\n	            CONNECT();\n	        },\n	\n	        /*\n	            PUBNUB.subscribe({\n	                channel  : 'my_chat'\n	                callback : function(message) { }\n	            });\n	        */\n	        'subscribe' : function( args, callback ) {\n	            var channel         = args['channel']\n	            ,   channel_group   = args['channel_group']\n	            ,   callback        = callback            || args['callback']\n	            ,   callback        = callback            || args['message']\n	            ,   connect         = args['connect']     || function(){}\n	            ,   reconnect       = args['reconnect']   || function(){}\n	            ,   disconnect      = args['disconnect']  || function(){}\n	            ,   SUB_ERROR       = args['error']       || SUB_ERROR || function(){}\n	            ,   idlecb          = args['idle']        || function(){}\n	            ,   presence        = args['presence']    || 0\n	            ,   noheresync      = args['noheresync']  || 0\n	            ,   backfill        = args['backfill']    || 0\n	            ,   timetoken       = args['timetoken']   || 0\n	            ,   sub_timeout     = args['timeout']     || SUB_TIMEOUT\n	            ,   windowing       = args['windowing']   || SUB_WINDOWING\n	            ,   state           = args['state']\n	            ,   heartbeat       = args['heartbeat'] || args['pnexpires']\n	            ,   heartbeat_interval = args['heartbeat_interval']\n	            ,   restore         = args['restore'] || SUB_RESTORE;\n	\n	            AUTH_KEY            = args['auth_key']    || AUTH_KEY;\n	\n	            // Restore Enabled?\n	            SUB_RESTORE = restore;\n	\n	            // Always Reset the TT\n	            TIMETOKEN = timetoken;\n	\n	            // Make sure we have a Channel\n	            if (!channel && !channel_group) {\n	                return error('Missing Channel');\n	            }\n	\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n	                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n	            }\n	\n	            // Setup Channel(s)\n	            if (channel) {\n	                each( (channel.join ? channel.join(',') : ''+channel).split(','),\n	                function(channel) {\n	                    var settings = CHANNELS[channel] || {};\n	\n	                    // Store Channel State\n	                    CHANNELS[SUB_CHANNEL = channel] = {\n	                        name         : channel,\n	                        connected    : settings.connected,\n	                        disconnected : settings.disconnected,\n	                        subscribed   : 1,\n	                        callback     : SUB_CALLBACK = callback,\n	                        'cipher_key' : args['cipher_key'],\n	                        connect      : connect,\n	                        disconnect   : disconnect,\n	                        reconnect    : reconnect\n	                    };\n	\n	                    if (state) {\n	                        if (channel in state) {\n	                            STATE[channel] = state[channel];\n	                        } else {\n	                            STATE[channel] = state;\n	                        }\n	                    }\n	\n	                    // Presence Enabled?\n	                    if (!presence) return;\n	\n	                    // Subscribe Presence Channel\n	                    SELF['subscribe']({\n	                        'channel'  : channel + PRESENCE_SUFFIX,\n	                        'callback' : presence,\n	                        'restore'  : restore\n	                    });\n	\n	                    // Presence Subscribed?\n	                    if (settings.subscribed) return;\n	\n	                    // See Who's Here Now?\n	                    if (noheresync) return;\n	                    SELF['here_now']({\n	                        'channel'  : channel,\n	                        'data'     : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n	                        'callback' : function(here) {\n	                            each( 'uuids' in here ? here['uuids'] : [],\n	                            function(uid) { presence( {\n	                                'action'    : 'join',\n	                                'uuid'      : uid,\n	                                'timestamp' : Math.floor(rnow() / 1000),\n	                                'occupancy' : here['occupancy'] || 1\n	                            }, here, channel ); } );\n	                        }\n	                    });\n	                } );\n	            }\n	\n	            // Setup Channel Groups\n	            if (channel_group) {\n	                each( (channel_group.join ? channel_group.join(',') : ''+channel_group).split(','),\n	                function(channel_group) {\n	                    var settings = CHANNEL_GROUPS[channel_group] || {};\n	\n	                    CHANNEL_GROUPS[channel_group] = {\n	                        name         : channel_group,\n	                        connected    : settings.connected,\n	                        disconnected : settings.disconnected,\n	                        subscribed   : 1,\n	                        callback     : SUB_CALLBACK = callback,\n	                        'cipher_key' : args['cipher_key'],\n	                        connect      : connect,\n	                        disconnect   : disconnect,\n	                        reconnect    : reconnect\n	                    };\n	\n	                    // Presence Enabled?\n	                    if (!presence) return;\n	\n	                    // Subscribe Presence Channel\n	                    SELF['subscribe']({\n	                        'channel_group'  : channel_group + PRESENCE_SUFFIX,\n	                        'callback' : presence,\n	                        'restore'  : restore,\n	                        'auth_key' : AUTH_KEY\n	                    });\n	\n	                    // Presence Subscribed?\n	                    if (settings.subscribed) return;\n	\n	                    // See Who's Here Now?\n	                    if (noheresync) return;\n	                    SELF['here_now']({\n	                        'channel_group'  : channel_group,\n	                        'data'           : _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY }),\n	                        'callback' : function(here) {\n	                            each( 'uuids' in here ? here['uuids'] : [],\n	                            function(uid) { presence( {\n	                                'action'    : 'join',\n	                                'uuid'      : uid,\n	                                'timestamp' : Math.floor(rnow() / 1000),\n	                                'occupancy' : here['occupancy'] || 1\n	                            }, here, channel_group ); } );\n	                        }\n	                    });\n	                } );\n	            }\n	\n	\n	            // Test Network Connection\n	            function _test_connection(success) {\n	                if (success) {\n	                    // Begin Next Socket Connection\n	                    timeout( CONNECT, windowing);\n	                }\n	                else {\n	                    // New Origin on Failed Connection\n	                    STD_ORIGIN = nextorigin( ORIGIN, 1 );\n	                    SUB_ORIGIN = nextorigin( ORIGIN, 1 );\n	\n	                    // Re-test Connection\n	                    timeout( function() {\n	                        SELF['time'](_test_connection);\n	                    }, SECOND );\n	                }\n	\n	                // Disconnect & Reconnect\n	                each_channel(function(channel){\n	                    // Reconnect\n	                    if (success && channel.disconnected) {\n	                        channel.disconnected = 0;\n	                        return channel.reconnect(channel.name);\n	                    }\n	\n	                    // Disconnect\n	                    if (!success && !channel.disconnected) {\n	                        channel.disconnected = 1;\n	                        channel.disconnect(channel.name);\n	                    }\n	                });\n	                \n	                // Disconnect & Reconnect for channel groups\n	                each_channel_group(function(channel_group){\n	                    // Reconnect\n	                    if (success && channel_group.disconnected) {\n	                        channel_group.disconnected = 0;\n	                        return channel_group.reconnect(channel_group.name);\n	                    }\n	\n	                    // Disconnect\n	                    if (!success && !channel_group.disconnected) {\n	                        channel_group.disconnected = 1;\n	                        channel_group.disconnect(channel_group.name);\n	                    }\n	                });\n	            }\n	\n	            // Evented Subscribe\n	            function _connect() {\n	                var jsonp           = jsonp_cb()\n	                ,   channels        = generate_channel_list(CHANNELS).join(',')\n	                ,   channel_groups  = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n	\n	                // Stop Connection\n	                if (!channels && !channel_groups) return;\n	\n	                if (!channels) channels = ',';\n	\n	                // Connect to PubNub Subscribe Servers\n	                _reset_offline();\n	\n	                var data = _get_url_params({ 'uuid' : UUID, 'auth' : AUTH_KEY });\n	\n	                if (channel_groups) {\n	                    data['channel-group'] = channel_groups;\n	                }\n	\n	\n	                var st = JSON.stringify(STATE);\n	                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n	\n	                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n	\n	                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	                start_presence_heartbeat();\n	                SUB_RECEIVER = xdr({\n	                    timeout  : sub_timeout,\n	                    callback : jsonp,\n	                    fail     : function(response) {\n	                        if (response && response['error'] && response['service']) {\n	                            _invoke_error(response, SUB_ERROR);\n	                            _test_connection(1);\n	                        } else {\n	                            SELF['time'](function(success){\n	                                !success && ( _invoke_error(response, SUB_ERROR));\n	                                _test_connection(success);\n	                            });\n	                        }\n	                    },\n	                    data     : _get_url_params(data),\n	                    url      : [\n	                        SUB_ORIGIN, 'subscribe',\n	                        SUBSCRIBE_KEY, encode(channels),\n	                        jsonp, TIMETOKEN\n	                    ],\n	                    success : function(messages) {\n	\n	                        // Check for Errors\n	                        if (!messages || (\n	                            typeof messages == 'object' &&\n	                            'error' in messages         &&\n	                            messages['error']\n	                        )) {\n	                            SUB_ERROR(messages['error']);\n	                            return timeout( CONNECT, SECOND );\n	                        }\n	\n	                        // User Idle Callback\n	                        idlecb(messages[1]);\n	\n	                        // Restore Previous Connection Point if Needed\n	                        TIMETOKEN = !TIMETOKEN               &&\n	                                    SUB_RESTORE              &&\n	                                    db['get'](SUBSCRIBE_KEY) || messages[1];\n	\n	                        /*\n	                        // Connect\n	                        each_channel_registry(function(registry){\n	                            if (registry.connected) return;\n	                            registry.connected = 1;\n	                            registry.connect(channel.name);\n	                        });\n	                        */\n	\n	                        // Connect\n	                        each_channel(function(channel){\n	                            if (channel.connected) return;\n	                            channel.connected = 1;\n	                            channel.connect(channel.name);\n	                        });\n	\n	                        // Connect for channel groups\n	                        each_channel_group(function(channel_group){\n	                            if (channel_group.connected) return;\n	                            channel_group.connected = 1;\n	                            channel_group.connect(channel_group.name);\n	                        });\n	\n	                        if (RESUMED && !SUB_RESTORE) {\n	                                TIMETOKEN = 0;\n	                                RESUMED = false;\n	                                // Update Saved Timetoken\n	                                db['set']( SUBSCRIBE_KEY, 0 );\n	                                timeout( _connect, windowing );\n	                                return;\n	                        }\n	\n	                        // Invoke Memory Catchup and Receive Up to 100\n	                        // Previous Messages from the Queue.\n	                        if (backfill) {\n	                            TIMETOKEN = 10000;\n	                            backfill  = 0;\n	                        }\n	\n	                        // Update Saved Timetoken\n	                        db['set']( SUBSCRIBE_KEY, messages[1] );\n	\n	                        // Route Channel <---> Callback for Message\n	                        var next_callback = (function() {\n	                            var channels = '';\n	                            var channels2 = '';\n	\n	                            if (messages.length > 3) {\n	                                channels  = messages[3];\n	                                channels2 = messages[2];\n	                            } else if (messages.length > 2) {\n	                                channels = messages[2];\n	                            } else {\n	                                channels =  map(\n	                                    generate_channel_list(CHANNELS), function(chan) { return map(\n	                                        Array(messages[0].length)\n	                                        .join(',').split(','),\n	                                        function() { return chan; }\n	                                    ) }).join(',')\n	                            }\n	\n	                            var list  = channels.split(',');\n	                            var list2 = (channels2)?channels2.split(','):[];\n	\n	                            return function() {\n	                                var channel  = list.shift()||SUB_CHANNEL;\n	                                var channel2 = list2.shift();\n	\n	                                var chobj = {};\n	\n	                                if (channel2) {\n	                                    if (channel && channel.indexOf('-pnpres') >= 0 \n	                                        && channel2.indexOf('-pnpres') < 0) {\n	                                        channel2 += '-pnpres';\n	                                    }\n	                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || {'callback' : function(){}};\n	                                } else {\n	                                    chobj = CHANNELS[channel];\n	                                }\n	\n	                                var r = [\n	                                    chobj\n	                                    .callback||SUB_CALLBACK,\n	                                    channel.split(PRESENCE_SUFFIX)[0]\n	                                ];\n	                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n	                                return r;\n	                            };\n	                        })();\n	\n	                        var latency = detect_latency(+messages[1]);\n	                        each( messages[0], function(msg) {\n	                            var next = next_callback();\n	                            var decrypted_msg = decrypt(msg,\n	                                (CHANNELS[next[1]])?CHANNELS[next[1]]['cipher_key']:null);\n	                            next[0] && next[0]( decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n	                        });\n	\n	                        timeout( _connect, windowing );\n	                    }\n	                });\n	            }\n	\n	            CONNECT = function() {\n	                _reset_offline();\n	                timeout( _connect, windowing );\n	            };\n	\n	            // Reduce Status Flicker\n	            if (!READY) return READY_BUFFER.push(CONNECT);\n	\n	            // Connect Now\n	            CONNECT();\n	        },\n	\n	        /*\n	            PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n	        */\n	        'here_now' : function( args, callback ) {\n	            var callback = args['callback'] || callback\n	            ,   debug    = args['debug']\n	            ,   err      = args['error']    || function(){}\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   channel  = args['channel']\n	            ,   channel_group = args['channel_group']\n	            ,   jsonp    = jsonp_cb()\n	            ,   uuids    = ('uuids' in args) ? args['uuids'] : true\n	            ,   state    = args['state']\n	            ,   data     = { 'uuid' : UUID, 'auth' : auth_key };\n	\n	            if (!uuids) data['disable_uuids'] = 1;\n	            if (state) data['state'] = 1;\n	\n	            // Make sure we have a Channel\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            var url = [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub_key', SUBSCRIBE_KEY\n	                ];\n	\n	            channel && url.push('channel') && url.push(encode(channel));\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            if (channel_group) {\n	                data['channel-group'] = channel_group;\n	                !channel && url.push('channel') && url.push(','); \n	            }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                debug    : debug,\n	                url      : url\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n	        */\n	        'where_now' : function( args, callback ) {\n	            var callback = args['callback'] || callback\n	            ,   err      = args['error']    || function(){}\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   jsonp    = jsonp_cb()\n	            ,   uuid     = args['uuid']     || UUID\n	            ,   data     = { 'auth' : auth_key };\n	\n	            // Make sure we have a Channel\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub_key', SUBSCRIBE_KEY,\n	                    'uuid', encode(uuid)\n	                ]\n	            });\n	        },\n	\n	        'state' : function(args, callback) {\n	            var callback = args['callback'] || callback || function(r) {}\n	            ,   err      = args['error']    || function(){}\n	            ,   auth_key = args['auth_key'] || AUTH_KEY\n	            ,   jsonp    = jsonp_cb()\n	            ,   state    = args['state']\n	            ,   uuid     = args['uuid'] || UUID\n	            ,   channel  = args['channel']\n	            ,   channel_group = args['channel_group']\n	            ,   url\n	            ,   data     = _get_url_params({ 'auth' : auth_key });\n	\n	            // Make sure we have a Channel\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	            if (!uuid) return error('Missing UUID');\n	            if (!channel && !channel_group) return error('Missing Channel');\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            if (typeof channel != 'undefined'\n	                && CHANNELS[channel] && CHANNELS[channel].subscribed ) {\n	                if (state) STATE[channel] = state;\n	            }\n	\n	            if (typeof channel_group != 'undefined'\n	                && CHANNEL_GROUPS[channel_group]\n	                && CHANNEL_GROUPS[channel_group].subscribed\n	                ) {\n	                if (state) STATE[channel_group] = state;\n	                data['channel-group'] = channel_group;\n	\n	                if (!channel) {\n	                    channel = ',';\n	                }\n	            }\n	\n	            data['state'] = JSON.stringify(state);\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            if (state) {\n	                url      = [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub-key', SUBSCRIBE_KEY,\n	                    'channel', channel,\n	                    'uuid', uuid, 'data'\n	                ]\n	            } else {\n	                url      = [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub-key', SUBSCRIBE_KEY,\n	                    'channel', channel,\n	                    'uuid', encode(uuid)\n	                ]\n	            }\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	\n	            });\n	\n	        },\n	\n	        /*\n	            PUBNUB.grant({\n	                channel  : 'my_chat',\n	                callback : fun,\n	                error    : fun,\n	                ttl      : 24 * 60, // Minutes\n	                read     : true,\n	                write    : true,\n	                auth_key : '3y8uiajdklytowsj'\n	            });\n	        */\n	        'grant' : function( args, callback ) {\n	            var callback        = args['callback'] || callback\n	            ,   err             = args['error']    || function(){}\n	            ,   channel         = args['channel']  || args['channels']\n	            ,   channel_group   = args['channel_group']\n	            ,   jsonp           = jsonp_cb()\n	            ,   ttl             = args['ttl']\n	            ,   r               = (args['read'] )?\"1\":\"0\"\n	            ,   w               = (args['write'])?\"1\":\"0\"\n	            ,   m               = (args['manage'])?\"1\":\"0\"\n	            ,   auth_key        = args['auth_key'] || args['auth_keys'];\n	\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SECRET_KEY)    return error('Missing Secret Key');\n	\n	            var timestamp  = Math.floor(new Date().getTime() / 1000)\n	            ,   sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\"\n	                    + \"grant\" + \"\\n\";\n	\n	            var data = {\n	                'w'         : w,\n	                'r'         : r,\n	                'timestamp' : timestamp\n	            };\n	            if (args['manage']) {\n	                data['m'] = m;\n	            }\n	            if (isArray(channel)) {\n	                channel = channel['join'](',');\n	            }\n	            if (isArray(auth_key)) {\n	                auth_key = auth_key['join'](',');\n	            }\n	            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n	            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n	                data['channel-group'] = channel_group;\n	            }\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	            if (ttl || ttl === 0) data['ttl'] = ttl;\n	\n	            if (auth_key) data['auth'] = auth_key;\n	\n	            data = _get_url_params(data)\n	\n	            if (!auth_key) delete data['auth'];\n	\n	            sign_input += _get_pam_sign_input_from_params(data);\n	\n	            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n	\n	            signature = signature.replace( /\\+/g, \"-\" );\n	            signature = signature.replace( /\\//g, \"_\" );\n	\n	            data['signature'] = signature;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : data,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v1', 'auth', 'grant' ,\n	                    'sub-key', SUBSCRIBE_KEY\n	                ]\n	            });\n	        },\n	\n	        /*\n	         PUBNUB.mobile_gw_provision ({\n	         device_id: 'A655FBA9931AB',\n	         op       : 'add' | 'remove',\n	         gw_type  : 'apns' | 'gcm',\n	         channel  : 'my_chat',\n	         callback : fun,\n	         error    : fun,\n	         });\n	         */\n	\n	        'mobile_gw_provision' : function( args ) {\n	\n	            var callback = args['callback'] || function(){}\n	                ,   auth_key       = args['auth_key'] || AUTH_KEY\n	                ,   err            = args['error'] || function() {}\n	                ,   jsonp          = jsonp_cb()\n	                ,   channel        = args['channel']\n	                ,   op             = args['op']\n	                ,   gw_type        = args['gw_type']\n	                ,   device_id      = args['device_id']\n	                ,   params\n	                ,   url;\n	\n	            if (!device_id)     return error('Missing Device ID (device_id)');\n	            if (!gw_type)       return error('Missing GW Type (gw_type: gcm or apns)');\n	            if (!op)            return error('Missing GW Operation (op: add or remove)');\n	            if (!channel)       return error('Missing gw destination Channel (channel)');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	\n	            // Create URL\n	            url = [\n	                STD_ORIGIN, 'v1/push/sub-key',\n	                SUBSCRIBE_KEY, 'devices', device_id\n	            ];\n	\n	            params = { 'uuid' : UUID, 'auth' : auth_key, 'type': gw_type};\n	\n	            if (op == \"add\") {\n	                params['add'] = channel;\n	            } else if (op == \"remove\") {\n	                params['remove'] = channel;\n	            }\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : params,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : url\n	            });\n	\n	        },\n	\n	        /*\n	            PUBNUB.audit({\n	                channel  : 'my_chat',\n	                callback : fun,\n	                error    : fun,\n	                read     : true,\n	                write    : true,\n	                auth_key : '3y8uiajdklytowsj'\n	            });\n	        */\n	        'audit' : function( args, callback ) {\n	            var callback        = args['callback'] || callback\n	            ,   err             = args['error']    || function(){}\n	            ,   channel         = args['channel']\n	            ,   channel_group   = args['channel_group']\n	            ,   auth_key        = args['auth_key']\n	            ,   jsonp           = jsonp_cb();\n	\n	            // Make sure we have a Channel\n	            if (!callback)      return error('Missing Callback');\n	            if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');\n	            if (!PUBLISH_KEY)   return error('Missing Publish Key');\n	            if (!SECRET_KEY)    return error('Missing Secret Key');\n	\n	            var timestamp  = Math.floor(new Date().getTime() / 1000)\n	            ,   sign_input = SUBSCRIBE_KEY + \"\\n\"\n	                + PUBLISH_KEY + \"\\n\"\n	                + \"audit\" + \"\\n\";\n	\n	            var data = {'timestamp' : timestamp };\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n	            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n	                data['channel-group'] = channel_group;\n	            }\n	            if (auth_key) data['auth']    = auth_key;\n	\n	            data = _get_url_params(data);\n	\n	            if (!auth_key) delete data['auth'];\n	\n	            sign_input += _get_pam_sign_input_from_params(data);\n	\n	            var signature = hmac_SHA256( sign_input, SECRET_KEY );\n	\n	            signature = signature.replace( /\\+/g, \"-\" );\n	            signature = signature.replace( /\\//g, \"_\" );\n	\n	            data['signature'] = signature;\n	            xdr({\n	                callback : jsonp,\n	                data     : data,\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) {\n	                    _invoke_error(response, err);\n	                },\n	                url      : [\n	                    STD_ORIGIN, 'v1', 'auth', 'audit' ,\n	                    'sub-key', SUBSCRIBE_KEY\n	                ]\n	            });\n	        },\n	\n	        /*\n	            PUBNUB.revoke({\n	                channel  : 'my_chat',\n	                callback : fun,\n	                error    : fun,\n	                auth_key : '3y8uiajdklytowsj'\n	            });\n	        */\n	        'revoke' : function( args, callback ) {\n	            args['read']  = false;\n	            args['write'] = false;\n	            SELF['grant']( args, callback );\n	        },\n	        'set_uuid' : function(uuid) {\n	            UUID = uuid;\n	            CONNECT();\n	        },\n	        'get_uuid' : function() {\n	            return UUID;\n	        },\n	        'isArray'  : function(arg) {\n	            return isArray(arg);\n	        },\n	        'get_subscibed_channels' : function() {\n	            return generate_channel_list(CHANNELS, true);\n	        },\n	        'presence_heartbeat' : function(args) {\n	            var callback = args['callback'] || function() {}\n	            var err      = args['error']    || function() {}\n	            var jsonp    = jsonp_cb();\n	            var data     = { 'uuid' : UUID, 'auth' : AUTH_KEY };\n	\n	            var st = JSON['stringify'](STATE);\n	            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n	\n	            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n	\n	            if (jsonp != '0') { data['callback'] = jsonp; }\n	\n	            var channels        = encode(generate_channel_list(CHANNELS, true)['join'](','));\n	            var channel_groups  = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n	\n	            if (!channels) channels = ',';\n	            if (channel_groups) data['channel-group'] = channel_groups;\n	\n	            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n	\n	            xdr({\n	                callback : jsonp,\n	                data     : _get_url_params(data),\n	                timeout  : SECOND * 5,\n	                url      : [\n	                    STD_ORIGIN, 'v2', 'presence',\n	                    'sub-key', SUBSCRIBE_KEY,\n	                    'channel' , channels,\n	                    'heartbeat'\n	                ],\n	                success  : function(response) {\n	                    _invoke_callback(response, callback, err);\n	                },\n	                fail     : function(response) { _invoke_error(response, err); }\n	            });\n	        },\n	        'stop_timers': function () {\n	            clearTimeout(_poll_timer);\n	            clearTimeout(_poll_timer2);\n	            clearTimeout(PRESENCE_HB_TIMEOUT);\n	        },\n	        'shutdown': function () {\n	            SELF['stop_timers']();\n	            shutdown && shutdown();\n	        },\n	\n	        // Expose PUBNUB Functions\n	        'xdr'           : xdr,\n	        'ready'         : ready,\n	        'db'            : db,\n	        'uuid'          : generate_uuid,\n	        'map'           : map,\n	        'each'          : each,\n	        'each-channel'  : each_channel,\n	        'grep'          : grep,\n	        'offline'       : function(){ _reset_offline(\n	            1, { \"message\" : \"Offline. Please check your network settings.\" })\n	        },\n	        'supplant'      : supplant,\n	        'now'           : rnow,\n	        'unique'        : unique,\n	        'updater'       : updater\n	    };\n	\n	    function _poll_online() {\n	        _is_online() || _reset_offline( 1, {\n	            \"error\" : \"Offline. Please check your network settings. \"\n	        });\n	        _poll_timer && clearTimeout(_poll_timer);\n	        _poll_timer = timeout( _poll_online, SECOND );\n	    }\n	\n	    function _poll_online2() {\n	        if (!TIME_CHECK) return;\n	        SELF['time'](function(success){\n	            detect_time_detla( function(){}, success );\n	            success || _reset_offline( 1, {\n	                \"error\" : \"Heartbeat failed to connect to Pubnub Servers.\" +\n	                    \"Please check your network settings.\"\n	                });\n	            _poll_timer2 && clearTimeout(_poll_timer2);\n	            _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n	        });\n	    }\n	\n	    function _reset_offline(err, msg) {\n	        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n	        SUB_RECEIVER = null;\n	\n	        clearTimeout(_poll_timer);\n	        clearTimeout(_poll_timer2);\n	    }\n	    \n	    if (!UUID) UUID = SELF['uuid']();\n	    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n	    db['set']( SUBSCRIBE_KEY + 'uuid', UUID );\n	\n	    _poll_timer  = timeout( _poll_online,  SECOND    );\n	    _poll_timer2 = timeout( _poll_online2, KEEPALIVE );\n	    PRESENCE_HB_TIMEOUT = timeout(\n	        start_presence_heartbeat,\n	        ( PRESENCE_HB_INTERVAL - 3 ) * SECOND\n	    );\n	\n	    // Detect Age of Message\n	    function detect_latency(tt) {\n	        var adjusted_time = rnow() - TIME_DRIFT;\n	        return adjusted_time - tt / 10000;\n	    }\n	\n	    detect_time_detla();\n	    function detect_time_detla( cb, time ) {\n	        var stime = rnow();\n	\n	        time && calculate(time) || SELF['time'](calculate);\n	\n	        function calculate(time) {\n	            if (!time) return;\n	            var ptime   = time / 10000\n	            ,   latency = (rnow() - stime) / 2;\n	            TIME_DRIFT = rnow() - (ptime + latency);\n	            cb && cb(TIME_DRIFT);\n	        }\n	    }\n	\n	    return SELF;\n	}\n	function crypto_obj() {\n	\n	    function SHA256(s) {\n	        return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);\n	    }\n	\n	    var iv = \"0123456789012345\";\n	\n	    var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];\n	    var allowedKeyLengths = [128, 256];\n	    var allowedModes = ['ecb', 'cbc'];\n	\n	    var defaultOptions = {\n	        'encryptKey': true,\n	        'keyEncoding': 'utf8',\n	        'keyLength': 256,\n	        'mode': 'cbc'\n	    };\n	\n	    function parse_options(options) {\n	\n	        // Defaults\n	        options = options || {};\n	        if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];\n	        if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];\n	        if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];\n	        if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];\n	\n	        // Validation\n	        if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];\n	        if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];\n	        if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];\n	\n	        return options;\n	\n	    }\n	\n	    function decode_key(key, options) {\n	        if (options['keyEncoding'] == 'base64') {\n	            return CryptoJS['enc']['Base64']['parse'](key);\n	        } else if (options['keyEncoding'] == 'hex') {\n	            return CryptoJS['enc']['Hex']['parse'](key);\n	        } else {\n	            return key;\n	        }\n	    }\n	\n	    function get_padded_key(key, options) {\n	        key = decode_key(key, options);\n	        if (options['encryptKey']) {\n	            return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));\n	        } else {\n	            return key;\n	        }\n	    }\n	\n	    function get_mode(options) {\n	        if (options['mode'] == 'ecb') {\n	            return CryptoJS['mode']['ECB'];\n	        } else {\n	            return CryptoJS['mode']['CBC'];\n	        }\n	    }\n	\n	    function get_iv(options) {\n	        return (options['mode'] == 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;\n	    }\n	\n	    return {\n	\n	        'encrypt': function(data, key, options) {\n	            if (!key) return data;\n	            options = parse_options(options);\n	            var iv = get_iv(options);\n	            var mode = get_mode(options);\n	            var cipher_key = get_padded_key(key, options);\n	            var hex_message = JSON['stringify'](data);\n	            var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, {'iv': iv, 'mode': mode})['ciphertext'];\n	            var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);\n	            return base_64_encrypted || data;\n	        },\n	\n	        'decrypt': function(data, key, options) {\n	            if (!key) return data;\n	            options = parse_options(options);\n	            var iv = get_iv(options);\n	            var mode = get_mode(options);\n	            var cipher_key = get_padded_key(key, options);\n	            try {\n	                var binary_enc = CryptoJS['enc']['Base64']['parse'](data);\n	                var json_plain = CryptoJS['AES']['decrypt']({'ciphertext': binary_enc}, cipher_key, {'iv': iv, 'mode': mode})['toString'](CryptoJS['enc']['Utf8']);\n	                var plaintext = JSON['parse'](json_plain);\n	                return plaintext;\n	            }\n	            catch (e) {\n	                return undefined;\n	            }\n	        }\n	    };\n	}\n	/**\n	 * UTIL LOCALS\n	 */\n	\n	var SWF             = 'https://pubnub.a.ssl.fastly.net/pubnub.swf'\n	,   ASYNC           = 'async'\n	,   UA              = navigator.userAgent\n	,   PNSDK           = 'PubNub-JS-' + 'Web' + '/' + '3.7.16'\n	,   XORIGN          = UA.indexOf('MSIE 6') == -1;\n	\n	/**\n	 * CONSOLE COMPATIBILITY\n	 */\n	window.console || (window.console=window.console||{});\n	console.log    || (\n	    console.log   =\n	    console.error =\n	    ((window.opera||{}).postError||function(){})\n	);\n	\n	/**\n	 * LOCAL STORAGE OR COOKIE\n	 */\n	var db = (function(){\n	    var store = {};\n	    var ls = false;\n	    try {\n	        ls = window['localStorage'];\n	    } catch (e) { }\n	    var cookieGet = function(key) {\n	        if (document.cookie.indexOf(key) == -1) return null;\n	        return ((document.cookie||'').match(\n	            RegExp(key+'=([^;]+)')\n	        )||[])[1] || null;\n	    };\n	    var cookieSet = function( key, value ) {\n	        document.cookie = key + '=' + value +\n	            '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';\n	    };\n	    var cookieTest = (function() {\n	        try {\n	            cookieSet('pnctest', '1');\n	            return cookieGet('pnctest') === '1';\n	        } catch (e) {\n	            return false;\n	        }\n	    }());\n	    return {\n	        'get' : function(key) {\n	            try {\n	                if (ls) return ls.getItem(key);\n	                if (cookieTest) return cookieGet(key);\n	                return store[key];\n	            } catch(e) {\n	                return store[key];\n	            }\n	        },\n	        'set' : function( key, value ) {\n	            try {\n	                if (ls) return ls.setItem( key, value ) && 0;\n	                if (cookieTest) cookieSet( key, value );\n	                store[key] = value;\n	            } catch(e) {\n	                store[key] = value;\n	            }\n	        }\n	    };\n	})();\n	\n	function get_hmac_SHA256(data,key) {\n	    var hash = CryptoJS['HmacSHA256'](data, key);\n	    return hash.toString(CryptoJS['enc']['Base64']);\n	}\n	\n	/**\n	 * $\n	 * =\n	 * var div = $('divid');\n	 */\n	function $(id) { return document.getElementById(id) }\n	\n	/**\n	 * ERROR\n	 * =====\n	 * error('message');\n	 */\n	function error(message) { console['error'](message) }\n	\n	/**\n	 * SEARCH\n	 * ======\n	 * var elements = search('a div span');\n	 */\n	function search( elements, start) {\n	    var list = [];\n	    each( elements.split(/\\s+/), function(el) {\n	        each( (start || document).getElementsByTagName(el), function(node) {\n	            list.push(node);\n	        } );\n	    });\n	    return list;\n	}\n	\n	/**\n	 * BIND\n	 * ====\n	 * bind( 'keydown', search('a')[0], function(element) {\n	 *     ...\n	 * } );\n	 */\n	function bind( type, el, fun ) {\n	    each( type.split(','), function(etype) {\n	        var rapfun = function(e) {\n	            if (!e) e = window.event;\n	            if (!fun(e)) {\n	                e.cancelBubble = true;\n	                e.preventDefault  && e.preventDefault();\n	                e.stopPropagation && e.stopPropagation();\n	            }\n	        };\n	\n	        if ( el.addEventListener ) el.addEventListener( etype, rapfun, false );\n	        else if ( el.attachEvent ) el.attachEvent( 'on' + etype, rapfun );\n	        else  el[ 'on' + etype ] = rapfun;\n	    } );\n	}\n	\n	/**\n	 * UNBIND\n	 * ======\n	 * unbind( 'keydown', search('a')[0] );\n	 */\n	function unbind( type, el, fun ) {\n	    if ( el.removeEventListener ) el.removeEventListener( type, false );\n	    else if ( el.detachEvent ) el.detachEvent( 'on' + type, false );\n	    else  el[ 'on' + type ] = null;\n	}\n	\n	/**\n	 * HEAD\n	 * ====\n	 * head().appendChild(elm);\n	 */\n	function head() { return search('head')[0] }\n	\n	/**\n	 * ATTR\n	 * ====\n	 * var attribute = attr( node, 'attribute' );\n	 */\n	function attr( node, attribute, value ) {\n	    if (value) node.setAttribute( attribute, value );\n	    else return node && node.getAttribute && node.getAttribute(attribute);\n	}\n	\n	/**\n	 * CSS\n	 * ===\n	 * var obj = create('div');\n	 */\n	function css( element, styles ) {\n	    for (var style in styles) if (styles.hasOwnProperty(style))\n	        try {element.style[style] = styles[style] + (\n	            '|width|height|top|left|'.indexOf(style) > 0 &&\n	            typeof styles[style] == 'number'\n	            ? 'px' : ''\n	        )}catch(e){}\n	}\n	\n	/**\n	 * CREATE\n	 * ======\n	 * var obj = create('div');\n	 */\n	function create(element) { return document.createElement(element) }\n	\n	\n	/**\n	 * jsonp_cb\n	 * ========\n	 * var callback = jsonp_cb();\n	 */\n	function jsonp_cb() { return XORIGN || FDomainRequest() ? 0 : unique() }\n	\n	\n	\n	/**\n	 * EVENTS\n	 * ======\n	 * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {\n	 *     // Do Stuff with message\n	 * } );\n	 *\n	 * PUBNUB.events.fire( 'you-stepped-on-flower', \"message-data\" );\n	 * PUBNUB.events.fire( 'you-stepped-on-flower', {message:\"data\"} );\n	 * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );\n	 *\n	 */\n	var events = {\n	    'list'   : {},\n	    'unbind' : function( name ) { events.list[name] = [] },\n	    'bind'   : function( name, fun ) {\n	        (events.list[name] = events.list[name] || []).push(fun);\n	    },\n	    'fire' : function( name, data ) {\n	        each(\n	            events.list[name] || [],\n	            function(fun) { fun(data) }\n	        );\n	    }\n	};\n	\n	/**\n	 * XDR Cross Domain Request\n	 * ========================\n	 *  xdr({\n	 *     url     : ['http://www.blah.com/url'],\n	 *     success : function(response) {},\n	 *     fail    : function() {}\n	 *  });\n	 */\n	function xdr( setup ) {\n	    if (XORIGN || FDomainRequest()) return ajax(setup);\n	\n	    var script    = create('script')\n	    ,   callback  = setup.callback\n	    ,   id        = unique()\n	    ,   finished  = 0\n	    ,   xhrtme    = setup.timeout || DEF_TIMEOUT\n	    ,   timer     = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n	    ,   fail      = setup.fail    || function(){}\n	    ,   data      = setup.data    || {}\n	    ,   success   = setup.success || function(){}\n	    ,   append    = function() { head().appendChild(script) }\n	    ,   done      = function( failed, response ) {\n	            if (finished) return;\n	            finished = 1;\n	\n	            script.onerror = null;\n	            clearTimeout(timer);\n	\n	            (failed || !response) || success(response);\n	\n	            timeout( function() {\n	                failed && fail();\n	                var s = $(id)\n	                ,   p = s && s.parentNode;\n	                p && p.removeChild(s);\n	            }, SECOND );\n	        };\n	\n	    window[callback] = function(response) {\n	        done( 0, response );\n	    };\n	\n	    if (!setup.blocking) script[ASYNC] = ASYNC;\n	\n	    script.onerror = function() { done(1) };\n	    script.src     = build_url( setup.url, data );\n	\n	    attr( script, 'id', id );\n	\n	    append();\n	    return done;\n	}\n	\n	/**\n	 * CORS XHR Request\n	 * ================\n	 *  xdr({\n	 *     url     : ['http://www.blah.com/url'],\n	 *     success : function(response) {},\n	 *     fail    : function() {}\n	 *  });\n	 */\n	function ajax( setup ) {\n	    var xhr, response\n	    ,   finished = function() {\n	            if (loaded) return;\n	            loaded = 1;\n	\n	            clearTimeout(timer);\n	\n	            try       { response = JSON['parse'](xhr.responseText); }\n	            catch (r) { return done(1); }\n	\n	            complete = 1;\n	            success(response);\n	        }\n	    ,   complete = 0\n	    ,   loaded   = 0\n	    ,   xhrtme   = setup.timeout || DEF_TIMEOUT\n	    ,   timer    = timeout( function(){done(1, {\"message\" : \"timeout\"})}, xhrtme )\n	    ,   fail     = setup.fail    || function(){}\n	    ,   data     = setup.data    || {}\n	    ,   success  = setup.success || function(){}\n	    ,   async    = !(setup.blocking)\n	    ,   done     = function(failed,response) {\n	            if (complete) return;\n	            complete = 1;\n	\n	            clearTimeout(timer);\n	\n	            if (xhr) {\n	                xhr.onerror = xhr.onload = null;\n	                xhr.abort && xhr.abort();\n	                xhr = null;\n	            }\n	\n	            failed && fail(response);\n	        };\n	\n	    // Send\n	    try {\n	        xhr = FDomainRequest()      ||\n	              window.XDomainRequest &&\n	              new XDomainRequest()  ||\n	              new XMLHttpRequest();\n	\n	        xhr.onerror = xhr.onabort   = function(e){ done(\n	            1, e || (xhr && xhr.responseText) || { \"error\" : \"Network Connection Error\"}\n	        ) };\n	        xhr.onload  = xhr.onloadend = finished;\n	        xhr.onreadystatechange = function() {\n	            if (xhr && xhr.readyState == 4) {\n	                switch(xhr.status) {\n	                    case 200:\n	                        break;\n	                    default:\n	                        try {\n	                            response = JSON['parse'](xhr.responseText);\n	                            done(1,response);\n	                        }\n	                        catch (r) { return done(1, {status : xhr.status, payload : null, message : xhr.responseText}); }\n	                        return;\n	                }\n	            }\n	        }\n	\n	        var url = build_url(setup.url,data);\n	\n	        xhr.open( 'GET', url, async );\n	        if (async) xhr.timeout = xhrtme;\n	        xhr.send();\n	    }\n	    catch(eee) {\n	        done(0);\n	        XORIGN = 0;\n	        return xdr(setup);\n	    }\n	\n	    // Return 'done'\n	    return done;\n	}\n	\n	// Test Connection State\n	function _is_online() {\n	    if (!('onLine' in navigator)) return 1;\n	    try       { return navigator['onLine'] }\n	    catch (e) { return true }\n	}\n	\n	\n	function sendBeacon(url) {\n	    if (!('sendBeacon' in navigator)) return false;\n	\n	    return navigator['sendBeacon'](url);\n	}\n	\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	/* =-=========================     PUBNUB     ===========================-= */\n	/* =-====================================================================-= */\n	/* =-====================================================================-= */\n	\n	var PDIV          = $('pubnub') || 0\n	,   CREATE_PUBNUB = function(setup) {\n	\n	    // Force JSONP if requested from user.\n	    if (setup['jsonp'])  XORIGN = 0;\n	    else                 XORIGN = UA.indexOf('MSIE 6') == -1;\n	\n	    var SUBSCRIBE_KEY = setup['subscribe_key'] || ''\n	    ,   KEEPALIVE     = (+setup['keepalive']   || DEF_KEEPALIVE)   * SECOND\n	    ,   UUID          = setup['uuid'] || db['get'](SUBSCRIBE_KEY+'uuid')||'';\n	\n	    var leave_on_unload = setup['leave_on_unload'] || 0;\n	\n	    setup['xdr']        = xdr;\n	    setup['db']         = db;\n	    setup['error']      = setup['error'] || error;\n	    setup['_is_online'] = _is_online;\n	    setup['jsonp_cb']   = jsonp_cb;\n	    setup['hmac_SHA256']= get_hmac_SHA256;\n	    setup['crypto_obj'] = crypto_obj();\n	    setup['sendBeacon'] = sendBeacon;\n	    setup['params']     = { 'pnsdk' : PNSDK }\n	\n	    var SELF = function(setup) {\n	        return CREATE_PUBNUB(setup);\n	    };\n	\n	    var PN = PN_API(setup);\n	\n	    for (var prop in PN) {\n	        if (PN.hasOwnProperty(prop)) {\n	            SELF[prop] = PN[prop];\n	        }\n	    }\n	    SELF['css']         = css;\n	    SELF['$']           = $;\n	    SELF['create']      = create;\n	    SELF['bind']        = bind;\n	    SELF['head']        = head;\n	    SELF['search']      = search;\n	    SELF['attr']        = attr;\n	    SELF['events']      = events;\n	    SELF['init']        = SELF;\n	    SELF['secure']      = SELF;\n	    SELF['crypto_obj']  = crypto_obj(); // export to instance\n	\n	\n	    // Add Leave Functions\n	    bind( 'beforeunload', window, function() {\n	        if (leave_on_unload) SELF['each-channel'](function(ch){ SELF['LEAVE']( ch.name, 0 ) });\n	        return true;\n	    } );\n	\n	    // Return without Testing\n	    if (setup['notest']) return SELF;\n	\n	    bind( 'offline', window,   SELF['offline'] );\n	    bind( 'offline', document, SELF['offline'] );\n	\n	    // Return PUBNUB Socket Object\n	    return SELF;\n	};\n	CREATE_PUBNUB['init']   = CREATE_PUBNUB;\n	CREATE_PUBNUB['secure'] = CREATE_PUBNUB;\n	CREATE_PUBNUB['crypto_obj'] = crypto_obj(); // export to constructor\n	\n	// Bind for PUBNUB Readiness to Subscribe\n	if (document.readyState === 'complete') {\n	    timeout( ready, 0 );\n	}\n	else {\n	    bind( 'load', window, function(){ timeout( ready, 0 ) } );\n	}\n	\n	var pdiv = PDIV || {};\n	\n	// CREATE A PUBNUB GLOBAL OBJECT\n	PUBNUB = CREATE_PUBNUB({\n	    'notest'        : 1,\n	    'publish_key'   : attr( pdiv, 'pub-key' ),\n	    'subscribe_key' : attr( pdiv, 'sub-key' ),\n	    'ssl'           : !document.location.href.indexOf('https') ||\n	                      attr( pdiv, 'ssl' ) == 'on',\n	    'origin'        : attr( pdiv, 'origin' ),\n	    'uuid'          : attr( pdiv, 'uuid' )\n	});\n	\n	// jQuery Interface\n	window['jQuery'] && (window['jQuery']['PUBNUB'] = CREATE_PUBNUB);\n	\n	// For Modern JS + Testling.js - http://testling.com/\n	typeof(module) !== 'undefined' && (module['exports'] = PUBNUB) && ready();\n	\n	var pubnubs = $('pubnubs') || 0;\n	\n	// LEAVE NOW IF NO PDIV.\n	if (!PDIV) return;\n	\n	// PUBNUB Flash Socket\n	css( PDIV, { 'position' : 'absolute', 'top' : -SECOND } );\n	\n	if ('opera' in window || attr( PDIV, 'flash' )) PDIV['innerHTML'] =\n	    '<object id=pubnubs data='  + SWF +\n	    '><param name=movie value=' + SWF +\n	    '><param name=allowscriptaccess value=always></object>';\n	\n	// Create Interface for Opera Flash\n	PUBNUB['rdx'] = function( id, data ) {\n	    if (!data) return FDomainRequest[id]['onerror']();\n	    FDomainRequest[id]['responseText'] = unescape(data);\n	    FDomainRequest[id]['onload']();\n	};\n	\n	function FDomainRequest() {\n	    if (!pubnubs || !pubnubs['get']) return 0;\n	\n	    var fdomainrequest = {\n	        'id'    : FDomainRequest['id']++,\n	        'send'  : function() {},\n	        'abort' : function() { fdomainrequest['id'] = {} },\n	        'open'  : function( method, url ) {\n	            FDomainRequest[fdomainrequest['id']] = fdomainrequest;\n	            pubnubs['get']( fdomainrequest['id'], url );\n	        }\n	    };\n	\n	    return fdomainrequest;\n	}\n	FDomainRequest['id'] = SECOND;\n	\n	})();\n	(function(){\n	\n	// ---------------------------------------------------------------------------\n	// WEBSOCKET INTERFACE\n	// ---------------------------------------------------------------------------\n	var WS = PUBNUB['ws'] = function( url, protocols ) {\n	    if (!(this instanceof WS)) return new WS( url, protocols );\n	\n	    var self     = this\n	    ,   url      = self.url      = url || ''\n	    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'\n	    ,   bits     = url.split('/')\n	    ,   setup    = {\n	         'ssl'           : bits[0] === 'wss:'\n	        ,'origin'        : bits[2]\n	        ,'publish_key'   : bits[3]\n	        ,'subscribe_key' : bits[4]\n	        ,'channel'       : bits[5]\n	    };\n	\n	    // READY STATES\n	    self['CONNECTING'] = 0; // The connection is not yet open.\n	    self['OPEN']       = 1; // The connection is open and ready to communicate.\n	    self['CLOSING']    = 2; // The connection is in the process of closing.\n	    self['CLOSED']     = 3; // The connection is closed or couldn't be opened.\n	\n	    // CLOSE STATES\n	    self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.\n	    self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.\n	    self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.\n	    self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.\n	    self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.\n	    self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.\n	    self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.\n	\n	    // Events Default\n	    self['onclose']   = self['onerror'] =\n	    self['onmessage'] = self['onopen']  =\n	    self['onsend']    =  function(){};\n	\n	    // Attributes\n	    self['binaryType']     = '';\n	    self['extensions']     = '';\n	    self['bufferedAmount'] = 0;\n	    self['trasnmitting']   = false;\n	    self['buffer']         = [];\n	    self['readyState']     = self['CONNECTING'];\n	\n	    // Close if no setup.\n	    if (!url) {\n	        self['readyState'] = self['CLOSED'];\n	        self['onclose']({\n	            'code'     : self['CLOSE_ABNORMAL'],\n	            'reason'   : 'Missing URL',\n	            'wasClean' : true\n	        });\n	        return self;\n	    }\n	\n	    // PubNub WebSocket Emulation\n	    self.pubnub       = PUBNUB['init'](setup);\n	    self.pubnub.setup = setup;\n	    self.setup        = setup;\n	\n	    self.pubnub['subscribe']({\n	        'restore'    : false,\n	        'channel'    : setup['channel'],\n	        'disconnect' : self['onerror'],\n	        'reconnect'  : self['onopen'],\n	        'error'      : function() {\n	            self['onclose']({\n	                'code'     : self['CLOSE_ABNORMAL'],\n	                'reason'   : 'Missing URL',\n	                'wasClean' : false\n	            });\n	        },\n	        'callback'   : function(message) {\n	            self['onmessage']({ 'data' : message });\n	        },\n	        'connect'    : function() {\n	            self['readyState'] = self['OPEN'];\n	            self['onopen']();\n	        }\n	    });\n	};\n	\n	// ---------------------------------------------------------------------------\n	// WEBSOCKET SEND\n	// ---------------------------------------------------------------------------\n	WS.prototype.send = function(data) {\n	    var self = this;\n	    self.pubnub['publish']({\n	        'channel'  : self.pubnub.setup['channel'],\n	        'message'  : data,\n	        'callback' : function(response) {\n	            self['onsend']({ 'data' : response });\n	        }\n	    });\n	};\n	\n	// ---------------------------------------------------------------------------\n	// WEBSOCKET CLOSE\n	// ---------------------------------------------------------------------------\n	WS.prototype.close = function() {\n	    var self = this;\n	    self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });\n	    self['readyState'] = self['CLOSED'];\n	    self['onclose']({});\n	};\n	\n	})();\n	/*\n	CryptoJS v3.1.2\n	code.google.com/p/crypto-js\n	(c) 2009-2013 by Jeff Mott. All rights reserved.\n	code.google.com/p/crypto-js/wiki/License\n	*/\n	var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\n	r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n	32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n	2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\n	u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);\n	a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,\n	d)).finalize(c)}}});var t=f.algo={};return f}(Math);\n	\n	// SHA256\n	(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=\n	c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\n	d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);\n	\n	// HMAC SHA256\n	(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;\"string\"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=\n	this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();\n	\n	// Base64\n	(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join(\"\")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<\n	l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"}})();\n	\n	// BlockCipher\n	(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},\n	_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),\n	f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,\n	m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,\n	E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/\n	4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);\n	(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,\n	l)}})();\n	\n	// Cipher\n	CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},\n	finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return(\"string\"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return(\"string\"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=\n	c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,\n	e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,\n	this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,\n	1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},\n	decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return\"string\"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,\n	b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();\n	\n	// AES\n	(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,\n	16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>\n	8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=\n	d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();\n	\n	// Mode ECB\n	CryptoJS.mode.ECB = (function () {\n	    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n	\n	    ECB.Encryptor = ECB.extend({\n	        processBlock: function (words, offset) {\n	            this._cipher.encryptBlock(words, offset);\n	        }\n	    });\n	\n	    ECB.Decryptor = ECB.extend({\n	        processBlock: function (words, offset) {\n	            this._cipher.decryptBlock(words, offset);\n	        }\n	    });\n	\n	    return ECB;\n	}());// Moved to hmac-sha-256.js\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module)))\n	\n	/***/ },\n	/* 12 */\n	/***/ function(module, exports) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Cache = function () {\n	    function Cache(storage, prefix) {\n	        _classCallCheck(this, Cache);\n	\n	        this.setPrefix(prefix);\n	        this._storage = storage;\n	    }\n	\n	    Cache.prototype.setPrefix = function setPrefix(prefix) {\n	        this._prefix = prefix || Cache.defaultPrefix;\n	        return this;\n	    };\n	\n	    Cache.prototype.setItem = function setItem(key, data) {\n	        this._storage[this._prefixKey(key)] = JSON.stringify(data);\n	        return this;\n	    };\n	\n	    Cache.prototype.removeItem = function removeItem(key) {\n	        delete this._storage[this._prefixKey(key)];\n	        return this;\n	    };\n	\n	    Cache.prototype.getItem = function getItem(key) {\n	        var item = this._storage[this._prefixKey(key)];\n	        if (!item) return null;\n	        return JSON.parse(item);\n	    };\n	\n	    Cache.prototype.clean = function clean() {\n	\n	        for (var key in this._storage) {\n	\n	            if (!this._storage.hasOwnProperty(key)) continue;\n	\n	            if (key.indexOf(this._prefix) === 0) {\n	                delete this._storage[key];\n	            }\n	        }\n	\n	        return this;\n	    };\n	\n	    Cache.prototype._prefixKey = function _prefixKey(key) {\n	        return this._prefix + key;\n	    };\n	\n	    return Cache;\n	}();\n	\n	Cache.defaultPrefix = 'rc-';\n	exports.default = Cache;\n	\n	/***/ },\n	/* 13 */\n	/***/ function(module, exports) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Observable = function () {\n	    function Observable() {\n	        _classCallCheck(this, Observable);\n	\n	        this.off();\n	    }\n	\n	    Observable.prototype.hasListeners = function hasListeners(event) {\n	        return event in this._listeners;\n	    };\n	\n	    Observable.prototype.on = function on(events, callback) {\n	        var _this = this;\n	\n	        if (typeof events == 'string') events = [events];\n	        if (!events) throw new Error('No events to subscribe to');\n	        if (typeof callback !== 'function') throw new Error('Callback must be a function');\n	\n	        events.forEach(function (event) {\n	\n	            if (!_this.hasListeners(event)) _this._listeners[event] = [];\n	\n	            _this._listeners[event].push(callback);\n	        });\n	\n	        return this;\n	    };\n	\n	    Observable.prototype.emit = function emit(event) {\n	        var _this2 = this;\n	\n	        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n	            args[_key - 1] = arguments[_key];\n	        }\n	\n	        var result = null;\n	\n	        if (!this.hasListeners(event)) return null;\n	\n	        this._listeners[event].some(function (callback) {\n	\n	            result = callback.apply(_this2, args);\n	            return result === false;\n	        });\n	\n	        return result;\n	    };\n	\n	    Observable.prototype.off = function off(event, callback) {\n	        var _this3 = this;\n	\n	        if (!event) {\n	\n	            this._listeners = {};\n	        } else {\n	\n	            if (!callback) {\n	\n	                delete this._listeners[event];\n	            } else {\n	\n	                if (!this.hasListeners(event)) return this;\n	\n	                this._listeners[event].forEach(function (cb, i) {\n	\n	                    if (cb === callback) delete _this3._listeners[event][i];\n	                });\n	            }\n	        }\n	\n	        return this;\n	    };\n	\n	    return Observable;\n	}();\n	\n	exports.default = Observable;\n	\n	/***/ },\n	/* 14 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Queue = function () {\n	    function Queue(cache, cacheId) {\n	        _classCallCheck(this, Queue);\n	\n	        this._cache = cache;\n	        this._cacheId = cacheId;\n	        this._promise = null;\n	    }\n	\n	    Queue.prototype.isPaused = function isPaused() {\n	\n	        var time = this._cache.getItem(this._cacheId);\n	\n	        return !!time && Date.now() - parseInt(time) < Queue._releaseTimeout;\n	    };\n	\n	    Queue.prototype.pause = function pause() {\n	        this._cache.setItem(this._cacheId, Date.now());\n	        return this;\n	    };\n	\n	    Queue.prototype.resume = function resume() {\n	        this._cache.removeItem(this._cacheId);\n	        return this;\n	    };\n	\n	    Queue.prototype.poll = function poll() {\n	        var _this = this;\n	\n	        if (this._promise) return this._promise;\n	\n	        this._promise = new _Externals.Promise(function (resolve, reject) {\n	\n	            (0, _Utils.poll)(function (next) {\n	\n	                if (_this.isPaused()) return next();\n	\n	                _this._promise = null;\n	\n	                _this.resume(); // this is actually not needed but why not\n	\n	                resolve(null);\n	            }, Queue._pollInterval);\n	        });\n	\n	        return this._promise;\n	    };\n	\n	    return Queue;\n	}();\n	\n	Queue._pollInterval = 250;\n	Queue._releaseTimeout = 5000;\n	exports.default = Queue;\n	\n	/***/ },\n	/* 15 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	\"use strict\";\n	\n	exports.__esModule = true;\n	exports.findHeaderName = findHeaderName;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _Utils = __webpack_require__(3);\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _ApiResponse = __webpack_require__(16);\n	\n	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Client = function (_Observable) {\n	    _inherits(Client, _Observable);\n	\n	    function Client() {\n	        var _temp, _this, _ret;\n	\n	        _classCallCheck(this, Client);\n	\n	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n	            args[_key] = arguments[_key];\n	        }\n	\n	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Observable.call.apply(_Observable, [this].concat(args))), _this), _this.events = {\n	            beforeRequest: 'beforeRequest',\n	            requestSuccess: 'requestSuccess',\n	            requestError: 'requestError'\n	        }, _temp), _possibleConstructorReturn(_this, _ret);\n	    }\n	\n	    /**\n	     * @param {Request} request\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	    Client.prototype.sendRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n	            var apiResponse;\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            apiResponse = new _ApiResponse2.default(request);\n	                            _context.prev = 1;\n	\n	\n	                            //TODO Stop request if listeners return false\n	                            this.emit(this.events.beforeRequest, apiResponse);\n	\n	                            _context.next = 5;\n	                            return this._loadResponse(request);\n	\n	                        case 5:\n	                            apiResponse._response = _context.sent;\n	                            _context.next = 8;\n	                            return apiResponse._init();\n	\n	                        case 8:\n	                            if (apiResponse.ok()) {\n	                                _context.next = 10;\n	                                break;\n	                            }\n	\n	                            throw new Error('Response has unsuccessful status');\n	\n	                        case 10:\n	\n	                            this.emit(this.events.requestSuccess, apiResponse);\n	\n	                            return _context.abrupt(\"return\", apiResponse);\n	\n	                        case 14:\n	                            _context.prev = 14;\n	                            _context.t0 = _context[\"catch\"](1);\n	\n	\n	                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);\n	\n	                            this.emit(this.events.requestError, _context.t0);\n	\n	                            throw _context.t0;\n	\n	                        case 19:\n	                        case \"end\":\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this, [[1, 14]]);\n	        }));\n	\n	        function sendRequest(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return sendRequest;\n	    }();\n	\n	    /**\n	     * @param {Request} request\n	     * @return {Promise<Response>}\n	     * @private\n	     */\n	\n	\n	    Client.prototype._loadResponse = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {\n	            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n	                while (1) {\n	                    switch (_context2.prev = _context2.next) {\n	                        case 0:\n	                            _context2.next = 2;\n	                            return _Externals.fetch.call(null, request);\n	\n	                        case 2:\n	                            return _context2.abrupt(\"return\", _context2.sent);\n	\n	                        case 3:\n	                        case \"end\":\n	                            return _context2.stop();\n	                    }\n	                }\n	            }, _callee2, this);\n	        }));\n	\n	        function _loadResponse(_x2) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _loadResponse;\n	    }();\n	\n	    /**\n	     * Wraps the JS Error object with transaction information\n	     * @param {Error|IApiError} e\n	     * @param {ApiResponse} apiResponse\n	     * @return {IApiError}\n	     */\n	\n	\n	    Client.prototype.makeError = function makeError(e, apiResponse) {\n	\n	        // Wrap only if regular error\n	        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {\n	\n	            e.apiResponse = apiResponse;\n	            e.originalMessage = e.message;\n	            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;\n	        }\n	\n	        return e;\n	    };\n	\n	    /**\n	     *\n	     * @param {object} init\n	     * @param {object} [init.url]\n	     * @param {object} [init.body]\n	     * @param {string} [init.method]\n	     * @param {object} [init.query]\n	     * @param {object} [init.headers]\n	     * @return {Request}\n	     */\n	\n	\n	    Client.prototype.createRequest = function createRequest(init) {\n	\n	        init = init || {};\n	        init.headers = init.headers || {};\n	\n	        // Sanity checks\n	        if (!init.url) throw new Error('Url is not defined');\n	        if (!init.method) init.method = 'GET';\n	        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {\n	            throw new Error('Method has wrong value: ' + init.method);\n	        }\n	\n	        // Defaults\n	        init.credentials = init.credentials || 'include';\n	        init.mode = init.mode || 'cors';\n	\n	        // Append Query String\n	        if (init.query) {\n	            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);\n	        }\n	\n	        if (!findHeaderName('Accept', init.headers)) {\n	            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;\n	        }\n	\n	        // Serialize body\n	        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {\n	\n	            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);\n	\n	            if (!contentTypeHeaderName) {\n	                contentTypeHeaderName = _ApiResponse2.default._contentType;\n	                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;\n	            }\n	\n	            var contentType = init.headers[contentTypeHeaderName];\n	\n	            // Assign a new encoded body\n	            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {\n	                init.body = JSON.stringify(init.body);\n	            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {\n	                init.body = (0, _Utils.queryStringify)(init.body);\n	            }\n	        }\n	\n	        // Create a request with encoded body\n	        var req = new _Externals.Request(init.url, init);\n	\n	        // Keep the original body accessible directly (for mocks)\n	        req.originalBody = init.body;\n	\n	        return req;\n	    };\n	\n	    return Client;\n	}(_Observable3.default);\n	\n	Client._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];\n	exports.default = Client;\n	function findHeaderName(name, headers) {\n	    name = name.toLowerCase();\n	    return Object.keys(headers).reduce(function (res, key) {\n	        if (res) return res;\n	        if (name == key.toLowerCase()) return key;\n	        return res;\n	    }, null);\n	}\n	\n	/**\n	 * @name IApiError\n	 * @property {string} stack\n	 * @property {string} originalMessage\n	 * @property {ApiResponse} apiResponse\n	 */\n	\n	/***/ },\n	/* 16 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var ApiResponse = function () {\n	\n	    /**\n	     * @param {Request} request\n	     * @param {Response} response\n	     * @param {string} responseText\n	     */\n	\n	    function ApiResponse(request, response, responseText) {\n	        _classCallCheck(this, ApiResponse);\n	\n	        /** @type {Request} */\n	        this._request = request;\n	\n	        /** @type {Response} */\n	        this._response = response;\n	\n	        this._text = responseText;\n	        this._json = null;\n	        this._multipart = [];\n	    }\n	\n	    ApiResponse.prototype._init = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            if (!(this._isMultipart() || this._isJson())) {\n	                                _context.next = 4;\n	                                break;\n	                            }\n	\n	                            _context.next = 3;\n	                            return this.response().text();\n	\n	                        case 3:\n	                            this._text = _context.sent;\n	\n	                        case 4:\n	                            return _context.abrupt('return', this);\n	\n	                        case 5:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function _init() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _init;\n	    }();\n	\n	    /**\n	     * @return {Response}\n	     */\n	\n	\n	    ApiResponse.prototype.response = function response() {\n	        return this._response;\n	    };\n	\n	    /**\n	     * @return {Request}\n	     */\n	\n	\n	    ApiResponse.prototype.request = function request() {\n	        return this._request;\n	    };\n	\n	    /**\n	     * @return {boolean}\n	     */\n	\n	\n	    ApiResponse.prototype.ok = function ok() {\n	        return this._response && this._response.ok;\n	    };\n	\n	    /**\n	     * @return {string}\n	     */\n	\n	\n	    ApiResponse.prototype.text = function text() {\n	        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');\n	        return this._text;\n	    };\n	\n	    /**\n	     * @return {object}\n	     */\n	\n	\n	    ApiResponse.prototype.json = function json() {\n	        if (!this._isJson()) throw new Error('Response is not JSON');\n	        if (!this._json) {\n	            this._json = this._text ? JSON.parse(this._text) : null;\n	        }\n	        return this._json;\n	    };\n	\n	    /**\n	     * @param [skipOKCheck]\n	     * @return {string}\n	     */\n	\n	\n	    ApiResponse.prototype.error = function error(skipOKCheck) {\n	\n	        if (this.ok() && !skipOKCheck) return null;\n	\n	        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');\n	\n	        try {\n	\n	            if (this.json().message) message = this.json().message;\n	            if (this.json().error_description) message = this.json().error_description;\n	            if (this.json().description) message = this.json().description;\n	        } catch (e) {}\n	\n	        return message;\n	    };\n	\n	    /**\n	     * @return {ApiResponse[]}\n	     */\n	\n	\n	    ApiResponse.prototype.multipart = function multipart() {\n	\n	        if (!this._isMultipart()) throw new Error('Response is not multipart');\n	\n	        if (!this._multipart.length) {\n	\n	            // Step 1. Split multipart response\n	\n	            var text = this.text();\n	\n	            if (!text) throw new Error('No response body');\n	\n	            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];\n	\n	            if (!boundary) throw new Error('Cannot find boundary');\n	\n	            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);\n	\n	            if (parts[0].trim() === '') parts.shift();\n	            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();\n	\n	            if (parts.length < 1) throw new Error('No parts in body');\n	\n	            // Step 2. Parse status info\n	\n	            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();\n	\n	            // Step 3. Parse all other parts\n	\n	            this._multipart = parts.map(function (part, i) {\n	\n	                var status = statusInfo.response[i].status;\n	\n	                return ApiResponse.create(part, status);\n	            });\n	        }\n	\n	        return this._multipart;\n	    };\n	\n	    ApiResponse.prototype._isContentType = function _isContentType(contentType) {\n	        return this._getContentType().indexOf(contentType) > -1;\n	    };\n	\n	    ApiResponse.prototype._getContentType = function _getContentType() {\n	        return this._response.headers.get(ApiResponse._contentType) || '';\n	    };\n	\n	    ApiResponse.prototype._isMultipart = function _isMultipart() {\n	        return this._isContentType(ApiResponse._multipartContentType);\n	    };\n	\n	    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {\n	        return this._isContentType(ApiResponse._urlencodedContentType);\n	    };\n	\n	    ApiResponse.prototype._isJson = function _isJson() {\n	        return this._isContentType(ApiResponse._jsonContentType);\n	    };\n	\n	    /**\n	     * Method is used to create ApiResponse object from string parts of multipart/mixed response\n	     * @param {string} [text]\n	     * @param {number} [status]\n	     * @param {string} [statusText]\n	     * @return {ApiResponse}\n	     */\n	\n	\n	    ApiResponse.create = function create(text, status, statusText) {\n	\n	        text = text || '';\n	        status = status || 200;\n	        statusText = statusText || 'OK';\n	\n	        text = text.replace(/\\r/g, '');\n	\n	        var headers = new _Externals.Headers(),\n	            headersAndBody = text.split(ApiResponse._bodySeparator),\n	            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';\n	\n	        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;\n	\n	        (headersText || '').split('\\n').forEach(function (header) {\n	\n	            var split = header.trim().split(ApiResponse._headerSeparator),\n	                key = split.shift().trim(),\n	                value = split.join(ApiResponse._headerSeparator).trim();\n	\n	            if (key) headers.append(key, value);\n	        });\n	\n	        return new ApiResponse(null, new _Externals.Response(text ? text : null, {\n	            headers: headers,\n	            status: status,\n	            statusText: statusText\n	        }), text);\n	    };\n	\n	    return ApiResponse;\n	}();\n	\n	ApiResponse._contentType = 'Content-Type';\n	ApiResponse._jsonContentType = 'application/json';\n	ApiResponse._multipartContentType = 'multipart/mixed';\n	ApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';\n	ApiResponse._headerSeparator = ':';\n	ApiResponse._bodySeparator = '\\n\\n';\n	ApiResponse._boundarySeparator = '--';\n	exports.default = ApiResponse;\n	\n	/***/ },\n	/* 17 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Registry = __webpack_require__(18);\n	\n	var _Registry2 = _interopRequireDefault(_Registry);\n	\n	var _Client = __webpack_require__(15);\n	\n	var _Client2 = _interopRequireDefault(_Client);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Client = function (_HttpClient) {\n	    _inherits(Client, _HttpClient);\n	\n	    function Client() {\n	        _classCallCheck(this, Client);\n	\n	        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));\n	\n	        _this._registry = new _Registry2.default();\n	        return _this;\n	    }\n	\n	    Client.prototype.registry = function registry() {\n	        return this._registry;\n	    };\n	\n	    Client.prototype._loadResponse = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n	            var mock;\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            mock = this._registry.find(request);\n	                            _context.next = 3;\n	                            return mock.getResponse(request);\n	\n	                        case 3:\n	                            return _context.abrupt('return', _context.sent);\n	\n	                        case 4:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function _loadResponse(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _loadResponse;\n	    }();\n	\n	    return Client;\n	}(_Client2.default);\n	\n	exports.default = Client;\n	\n	/***/ },\n	/* 18 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Mock = __webpack_require__(19);\n	\n	var _Mock2 = _interopRequireDefault(_Mock);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Registry = function () {\n	    function Registry() {\n	        _classCallCheck(this, Registry);\n	\n	        this._mocks = [];\n	    }\n	\n	    Registry.prototype.add = function add(mock) {\n	        this._mocks.push(mock);\n	        return this;\n	    };\n	\n	    Registry.prototype.clear = function clear() {\n	        this._mocks = [];\n	        return this;\n	    };\n	\n	    Registry.prototype.find = function find(request) {\n	\n	        //console.log('Registry is looking for', request);\n	\n	        var mock = this._mocks.shift();\n	\n	        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);\n	\n	        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());\n	\n	        return mock;\n	    };\n	\n	    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText) {\n	\n	        this.add(new _Mock2.default(method, path, response, status, statusText));\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.authentication = function authentication() {\n	\n	        this.apiCall('POST', '/restapi/oauth/token', {\n	            'access_token': 'ACCESS_TOKEN',\n	            'token_type': 'bearer',\n	            'expires_in': 3600,\n	            'refresh_token': 'REFRESH_TOKEN',\n	            'refresh_token_expires_in': 60480,\n	            'scope': 'SMS RCM Foo Boo',\n	            'expireTime': new Date().getTime() + 3600000\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.logout = function logout() {\n	\n	        this.apiCall('POST', '/restapi/oauth/revoke', {});\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.presenceLoad = function presenceLoad(id) {\n	\n	        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {\n	            \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id + \"/presence\",\n	            \"extension\": {\n	                \"uri\": \"https://platform.ringcentral.com/restapi/v1.0/account/123/extension/\" + id,\n	                \"id\": id,\n	                \"extensionNumber\": \"101\"\n	            },\n	            \"activeCalls\": [],\n	            \"presenceStatus\": \"Available\",\n	            \"telephonyStatus\": \"Ringing\",\n	            \"userStatus\": \"Available\",\n	            \"dndStatus\": \"TakeAllCalls\",\n	            \"extensionId\": id\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {\n	\n	        expiresIn = expiresIn || 15 * 60 * 60;\n	\n	        var date = new Date();\n	\n	        this.apiCall('POST', '/restapi/v1.0/subscription', {\n	            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],\n	            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),\n	            'expiresIn': expiresIn,\n	            'deliveryMode': {\n	                'transportType': 'PubNub',\n	                'encryption': false,\n	                'address': '123_foo',\n	                'subscriberKey': 'sub-c-foo',\n	                'secretKey': 'sec-c-bar'\n	            },\n	            'id': 'foo-bar-baz',\n	            'creationTime': date.toISOString(),\n	            'status': 'Active',\n	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {\n	\n	        id = id || '1';\n	\n	        var date = new Date();\n	\n	        this.apiCall('POST', '/restapi/v1.0/subscription', {\n	            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],\n	            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),\n	            'deliveryMode': {\n	                'transportType': 'PubNub',\n	                'encryption': true,\n	                'address': '123_foo',\n	                'subscriberKey': 'sub-c-foo',\n	                'secretKey': 'sec-c-bar',\n	                'encryptionAlgorithm': 'AES',\n	                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='\n	            },\n	            'creationTime': date.toISOString(),\n	            'id': 'foo-bar-baz',\n	            'status': 'Active',\n	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'\n	        });\n	\n	        return this;\n	    };\n	\n	    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {\n	\n	        if (!failure) {\n	\n	            this.apiCall('POST', '/restapi/oauth/token', {\n	                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',\n	                'token_type': 'bearer',\n	                'expires_in': 3600,\n	                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',\n	                'refresh_token_expires_in': 60480,\n	                'scope': 'SMS RCM Foo Boo'\n	            });\n	        } else {\n	\n	            this.apiCall('POST', '/restapi/oauth/token', {\n	                'message': 'Wrong token',\n	                'error_description': 'Wrong token',\n	                'description': 'Wrong token'\n	            }, 400);\n	        }\n	\n	        return this;\n	    };\n	\n	    return Registry;\n	}();\n	\n	exports.default = Registry;\n	\n	/***/ },\n	/* 19 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _ApiResponse = __webpack_require__(16);\n	\n	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Mock = function () {\n	    function Mock(method, path, json, status, statusText, delay) {\n	        _classCallCheck(this, Mock);\n	\n	        this._method = method.toUpperCase();\n	        this._path = path;\n	        this._json = json || {};\n	        this._delay = delay || 10;\n	        this._status = status || 200;\n	        this._statusText = statusText || 'OK';\n	    }\n	\n	    Mock.prototype.path = function path() {\n	        return this._path;\n	    };\n	\n	    Mock.prototype.method = function method() {\n	        return this._method;\n	    };\n	\n	    Mock.prototype.test = function test(request) {\n	\n	        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;\n	    };\n	\n	    Mock.prototype.getResponse = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            _context.next = 2;\n	                            return (0, _Utils.delay)(this._delay);\n	\n	                        case 2:\n	                            return _context.abrupt('return', this.createResponse(this._json));\n	\n	                        case 3:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function getResponse(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return getResponse;\n	    }();\n	\n	    Mock.prototype.createResponse = function createResponse(json, init) {\n	\n	        init = init || {};\n	\n	        init.status = init.status || this._status;\n	        init.statusText = init.statusText || this._statusText;\n	\n	        var str = JSON.stringify(json),\n	            res = new _Externals.Response(str, init);\n	\n	        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);\n	\n	        return res;\n	    };\n	\n	    return Mock;\n	}();\n	\n	exports.default = Mock;\n	\n	/***/ },\n	/* 20 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	\"use strict\";\n	\n	exports.__esModule = true;\n	\n	var _Externals = __webpack_require__(4);\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _Queue = __webpack_require__(14);\n	\n	var _Queue2 = _interopRequireDefault(_Queue);\n	\n	var _Auth = __webpack_require__(21);\n	\n	var _Auth2 = _interopRequireDefault(_Auth);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Platform = function (_Observable) {\n	    _inherits(Platform, _Observable);\n	\n	    // 10 hours\n	\n	    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {\n	        _classCallCheck(this, Platform);\n	\n	        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n	\n	        _this.events = {\n	            beforeLogin: 'beforeLogin',\n	            loginSuccess: 'loginSuccess',\n	            loginError: 'loginError',\n	            beforeRefresh: 'beforeRefresh',\n	            refreshSuccess: 'refreshSuccess',\n	            refreshError: 'refreshError',\n	            beforeLogout: 'beforeLogout',\n	            logoutSuccess: 'logoutSuccess',\n	            logoutError: 'logoutError'\n	        };\n	\n	\n	        _this._server = server;\n	        _this._appKey = appKey;\n	        _this._appSecret = appSecret;\n	\n	        /** @type {Cache} */\n	        _this._cache = cache;\n	\n	        /** @type {Client} */\n	        _this._client = client;\n	\n	        _this._queue = new _Queue2.default(_this._cache, Platform._cacheId + '-refresh');\n	\n	        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);\n	\n	        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;\n	\n	        return _this;\n	    }\n	\n	    /**\n	     * @return {Auth}\n	     */\n	    // 1 week\n	\n	\n	    Platform.prototype.auth = function auth() {\n	        return this._auth;\n	    };\n	\n	    /**\n	     * @return {Client}\n	     */\n	\n	\n	    Platform.prototype.client = function client() {\n	        return this._client;\n	    };\n	\n	    /**\n	     * @param {string} path\n	     * @param {object} [options]\n	     * @param {boolean} [options.addServer]\n	     * @param {string} [options.addMethod]\n	     * @param {boolean} [options.addToken]\n	     * @return {string}\n	     */\n	\n	\n	    Platform.prototype.createUrl = function createUrl(path, options) {\n	\n	        path = path || '';\n	        options = options || {};\n	\n	        var builtUrl = '',\n	            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;\n	\n	        if (options.addServer && !hasHttp) builtUrl += this._server;\n	\n	        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;\n	\n	        builtUrl += path;\n	\n	        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';\n	\n	        if (options.addMethod) builtUrl += '_method=' + options.addMethod;\n	        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();\n	\n	        return builtUrl;\n	    };\n	\n	    /**\n	     * @param {string} options.redirectUri\n	     * @param {string} options.state\n	     * @param {string} options.brandId\n	     * @param {string} options.display\n	     * @param {string} options.prompt\n	     * @param {object} [options]\n	     * @return {string}\n	     */\n	\n	\n	    Platform.prototype.authUrl = function authUrl(options) {\n	\n	        options = options || {};\n	\n	        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({\n	            'response_type': 'code',\n	            'redirect_uri': options.redirectUri || '',\n	            'client_id': this._appKey,\n	            'state': options.state || '',\n	            'brand_id': options.brandId || '',\n	            'display': options.display || '',\n	            'prompt': options.prompt || ''\n	        }), { addServer: true });\n	    };\n	\n	    /**\n	     * @param {string} url\n	     * @return {Object}\n	     */\n	\n	\n	    Platform.prototype.parseAuthRedirectUrl = function parseAuthRedirectUrl(url) {\n	\n	        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),\n	            error = qs.error_description || qs.error;\n	\n	        if (error) {\n	            var e = new Error(error);\n	            e.error = qs.error;\n	            throw e;\n	        }\n	\n	        return qs;\n	    };\n	\n	    /**\n	     * Convenience method to handle 3-legged OAuth\n	     *\n	     * Attention! This is an experimental method and it's signature and behavior may change without notice.\n	     *\n	     * @experimental\n	     * @param {number} [options.width]\n	     * @param {number} [options.height]\n	     * @param {object} [options.login] additional options for login()\n	     * @param {string} [options.origin]\n	     * @param {string} [options.property] name of window.postMessage's event data property\n	     * @param {string} [options.target] target for window.open()\n	     * @param {string} options.url\n	     * @return {Promise}\n	     */\n	\n	\n	    Platform.prototype.authWindow = function authWindow(options) {\n	        var _this2 = this;\n	\n	        return new _Externals.Promise(function (resolve, reject) {\n	\n	            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');\n	\n	            if (!options.url) throw new Error('Missing mandatory URL parameter');\n	\n	            options = options || {};\n	            options.url = options.url || 400;\n	            options.width = options.width || 400;\n	            options.height = options.height || 600;\n	            options.origin = options.origin || window.location.origin;\n	            options.property = options.property || 'RCAuthorizationCode';\n	            options.target = options.target || '_blank';\n	\n	            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;\n	            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;\n	\n	            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;\n	            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n	\n	            var left = width / 2 - options.width / 2 + dualScreenLeft;\n	            var top = height / 2 - options.height / 2 + dualScreenTop;\n	            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');\n	\n	            if (window.focus) win.focus();\n	\n	            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';\n	            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';\n	            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';\n	\n	            var eventListener = function eventListener(e) {\n	\n	                if (e.origin != options.origin) return;\n	                if (!e.data || !e.data[options.property]) return; // keep waiting\n	\n	                win.close();\n	                window[eventRemoveMethod](messageEvent, eventListener);\n	\n	                try {\n	\n	                    var loginOptions = _this2.parseAuthRedirectUrl(e.data[options.property]);\n	\n	                    if (!loginOptions.code) throw new Error('No authorization code');\n	\n	                    resolve(loginOptions);\n	                } catch (e) {\n	                    reject(e);\n	                }\n	            };\n	\n	            window[eventMethod](messageEvent, eventListener, false);\n	        });\n	    };\n	\n	    /**\n	     * @return {Promise<boolean>}\n	     */\n	\n	\n	    Platform.prototype.loggedIn = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            _context.prev = 0;\n	                            _context.next = 3;\n	                            return this._ensureAuthentication();\n	\n	                        case 3:\n	                            return _context.abrupt(\"return\", true);\n	\n	                        case 6:\n	                            _context.prev = 6;\n	                            _context.t0 = _context[\"catch\"](0);\n	                            return _context.abrupt(\"return\", false);\n	\n	                        case 9:\n	                        case \"end\":\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this, [[0, 6]]);\n	        }));\n	\n	        function loggedIn() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return loggedIn;\n	    }();\n	\n	    /**\n	     * @param {string} options.username\n	     * @param {string} options.password\n	     * @param {string} options.extension\n	     * @param {string} options.code\n	     * @param {string} options.redirectUri\n	     * @param {string} options.endpointId\n	     * @param {string} options.remember\n	     * @param {string} options.accessTokenTtl\n	     * @param {string} options.refreshTokenTtl\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.login = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {\n	            var body, apiResponse, json;\n	            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n	                while (1) {\n	                    switch (_context2.prev = _context2.next) {\n	                        case 0:\n	                            _context2.prev = 0;\n	\n	\n	                            options = options || {};\n	\n	                            this.emit(this.events.beforeLogin);\n	\n	                            body = {};\n	\n	\n	                            if (!options.code) {\n	\n	                                body.grant_type = 'password';\n	                                body.username = options.username;\n	                                body.password = options.password;\n	                                body.extension = options.extension || '';\n	                            } else if (options.code) {\n	\n	                                body.grant_type = 'authorization_code';\n	                                body.code = options.code;\n	                                body.redirect_uri = options.redirectUri;\n	                                //body.client_id = this.getCredentials().key; // not needed\n	                            }\n	\n	                            if (options.endpointId) body.endpoint_id = options.endpointId;\n	                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;\n	                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;\n	                            if (options.remember && !options.refreshTokenTtl) body.refreshTokenTtl = options.remember ? Platform._refreshTokenTtlRemember : Platform._refreshTokenTtl;\n	\n	                            _context2.next = 11;\n	                            return this._tokenRequest(Platform._tokenEndpoint, body);\n	\n	                        case 11:\n	                            apiResponse = _context2.sent;\n	                            json = apiResponse.json();\n	\n	\n	                            this._auth.setData(json);\n	\n	                            this.emit(this.events.loginSuccess, apiResponse);\n	\n	                            return _context2.abrupt(\"return\", apiResponse);\n	\n	                        case 18:\n	                            _context2.prev = 18;\n	                            _context2.t0 = _context2[\"catch\"](0);\n	\n	\n	                            this._cache.clean();\n	\n	                            this.emit(this.events.loginError, _context2.t0);\n	\n	                            throw _context2.t0;\n	\n	                        case 23:\n	                        case \"end\":\n	                            return _context2.stop();\n	                    }\n	                }\n	            }, _callee2, this, [[0, 18]]);\n	        }));\n	\n	        function login(_x) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return login;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.refresh = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n	            var res, json;\n	            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n	                while (1) {\n	                    switch (_context3.prev = _context3.next) {\n	                        case 0:\n	                            _context3.prev = 0;\n	\n	\n	                            this.emit(this.events.beforeRefresh);\n	\n	                            if (!this._queue.isPaused()) {\n	                                _context3.next = 9;\n	                                break;\n	                            }\n	\n	                            _context3.next = 5;\n	                            return this._queue.poll();\n	\n	                        case 5:\n	                            if (this._isAccessTokenValid()) {\n	                                _context3.next = 7;\n	                                break;\n	                            }\n	\n	                            throw new Error('Automatic authentification timeout');\n	\n	                        case 7:\n	\n	                            this.emit(this.events.refreshSuccess, null);\n	\n	                            return _context3.abrupt(\"return\", null);\n	\n	                        case 9:\n	\n	                            this._queue.pause();\n	\n	                            // Make sure all existing AJAX calls had a chance to reach the server\n	                            _context3.next = 12;\n	                            return (0, _Utils.delay)(Platform._refreshDelayMs);\n	\n	                        case 12:\n	                            if (this._auth.refreshToken()) {\n	                                _context3.next = 14;\n	                                break;\n	                            }\n	\n	                            throw new Error('Refresh token is missing');\n	\n	                        case 14:\n	                            if (this._auth.refreshTokenValid()) {\n	                                _context3.next = 16;\n	                                break;\n	                            }\n	\n	                            throw new Error('Refresh token has expired');\n	\n	                        case 16:\n	                            if (this._queue.isPaused()) {\n	                                _context3.next = 18;\n	                                break;\n	                            }\n	\n	                            throw new Error('Queue was resumed before refresh call');\n	\n	                        case 18:\n	                            _context3.next = 20;\n	                            return this._tokenRequest(Platform._tokenEndpoint, {\n	                                \"grant_type\": \"refresh_token\",\n	                                \"refresh_token\": this._auth.refreshToken(),\n	                                \"access_token_ttl\": this._auth.data().expires_in + 1,\n	                                \"refresh_token_ttl\": this._auth.data().refresh_token_expires_in + 1\n	                            });\n	\n	                        case 20:\n	                            res = _context3.sent;\n	                            json = res.json();\n	\n	                            if (json.access_token) {\n	                                _context3.next = 24;\n	                                break;\n	                            }\n	\n	                            throw this._client.makeError(new Error('Malformed OAuth response'), res);\n	\n	                        case 24:\n	\n	                            this._auth.setData(json);\n	                            this._queue.resume();\n	\n	                            this.emit(this.events.refreshSuccess, res);\n	\n	                            return _context3.abrupt(\"return\", res);\n	\n	                        case 30:\n	                            _context3.prev = 30;\n	                            _context3.t0 = _context3[\"catch\"](0);\n	\n	\n	                            _context3.t0 = this._client.makeError(_context3.t0);\n	\n	                            if (Platform._clearCacheOnRefreshError) {\n	                                this._cache.clean();\n	                            }\n	\n	                            this.emit(this.events.refreshError, _context3.t0);\n	\n	                            throw _context3.t0;\n	\n	                        case 36:\n	                        case \"end\":\n	                            return _context3.stop();\n	                    }\n	                }\n	            }, _callee3, this, [[0, 30]]);\n	        }));\n	\n	        function refresh() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return refresh;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.logout = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n	            var res;\n	            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n	                while (1) {\n	                    switch (_context4.prev = _context4.next) {\n	                        case 0:\n	                            _context4.prev = 0;\n	\n	\n	                            this.emit(this.events.beforeLogout);\n	\n	                            this._queue.pause();\n	\n	                            _context4.next = 5;\n	                            return this._tokenRequest(Platform._revokeEndpoint, {\n	                                token: this._auth.accessToken()\n	                            });\n	\n	                        case 5:\n	                            res = _context4.sent;\n	\n	\n	                            this._queue.resume();\n	                            this._cache.clean();\n	\n	                            this.emit(this.events.logoutSuccess, res);\n	\n	                            return _context4.abrupt(\"return\", res);\n	\n	                        case 12:\n	                            _context4.prev = 12;\n	                            _context4.t0 = _context4[\"catch\"](0);\n	\n	\n	                            this._queue.resume();\n	\n	                            this.emit(this.events.logoutError, _context4.t0);\n	\n	                            throw _context4.t0;\n	\n	                        case 17:\n	                        case \"end\":\n	                            return _context4.stop();\n	                    }\n	                }\n	            }, _callee4, this, [[0, 12]]);\n	        }));\n	\n	        function logout() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return logout;\n	    }();\n	\n	    /**\n	     * @param {Request} request\n	     * @param {object} [options]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<Request>}\n	     */\n	\n	\n	    Platform.prototype.inflateRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(request, options) {\n	            return regeneratorRuntime.wrap(function _callee5$(_context5) {\n	                while (1) {\n	                    switch (_context5.prev = _context5.next) {\n	                        case 0:\n	\n	                            options = options || {};\n	\n	                            if (!options.skipAuthCheck) {\n	                                _context5.next = 3;\n	                                break;\n	                            }\n	\n	                            return _context5.abrupt(\"return\", request);\n	\n	                        case 3:\n	                            _context5.next = 5;\n	                            return this._ensureAuthentication();\n	\n	                        case 5:\n	\n	                            request.headers.set('X-User-Agent', this._userAgent);\n	                            request.headers.set('Client-Id', this._appKey);\n	                            request.headers.set('Authorization', this._authHeader());\n	                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...\n	\n	                            return _context5.abrupt(\"return\", request);\n	\n	                        case 9:\n	                        case \"end\":\n	                            return _context5.stop();\n	                    }\n	                }\n	            }, _callee5, this);\n	        }));\n	\n	        function inflateRequest(_x2, _x3) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return inflateRequest;\n	    }();\n	\n	    /**\n	     * @param {Request} request\n	     * @param {object} [options]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.sendRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {\n	            return regeneratorRuntime.wrap(function _callee6$(_context6) {\n	                while (1) {\n	                    switch (_context6.prev = _context6.next) {\n	                        case 0:\n	                            _context6.prev = 0;\n	                            _context6.next = 3;\n	                            return this.inflateRequest(request, options);\n	\n	                        case 3:\n	                            request = _context6.sent;\n	                            _context6.next = 6;\n	                            return this._client.sendRequest(request);\n	\n	                        case 6:\n	                            return _context6.abrupt(\"return\", _context6.sent);\n	\n	                        case 9:\n	                            _context6.prev = 9;\n	                            _context6.t0 = _context6[\"catch\"](0);\n	\n	                            if (!(!_context6.t0.apiResponse || !_context6.t0.apiResponse.response() || _context6.t0.apiResponse.response().status != 401)) {\n	                                _context6.next = 13;\n	                                break;\n	                            }\n	\n	                            throw _context6.t0;\n	\n	                        case 13:\n	\n	                            this._auth.cancelAccessToken();\n	\n	                            _context6.next = 16;\n	                            return this.sendRequest(request, options);\n	\n	                        case 16:\n	                            return _context6.abrupt(\"return\", _context6.sent);\n	\n	                        case 17:\n	                        case \"end\":\n	                            return _context6.stop();\n	                    }\n	                }\n	            }, _callee6, this, [[0, 9]]);\n	        }));\n	\n	        function sendRequest(_x4, _x5) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return sendRequest;\n	    }();\n	\n	    /**\n	     * General purpose function to send anything to server\n	     * @param {string} options.url\n	     * @param {object} [options.body]\n	     * @param {string} [options.method]\n	     * @param {object} [options.query]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.send = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {\n	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n	            return regeneratorRuntime.wrap(function _callee7$(_context7) {\n	                while (1) {\n	                    switch (_context7.prev = _context7.next) {\n	                        case 0:\n	\n	                            //FIXME https://github.com/bitinn/node-fetch/issues/43\n	                            options.url = this.createUrl(options.url, { addServer: true });\n	\n	                            _context7.next = 3;\n	                            return this.sendRequest(this._client.createRequest(options), options);\n	\n	                        case 3:\n	                            return _context7.abrupt(\"return\", _context7.sent);\n	\n	                        case 4:\n	                        case \"end\":\n	                            return _context7.stop();\n	                    }\n	                }\n	            }, _callee7, this);\n	        }));\n	\n	        function send(_x6) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return send;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {object} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.get = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(url, query, options) {\n	            return regeneratorRuntime.wrap(function _callee8$(_context8) {\n	                while (1) {\n	                    switch (_context8.prev = _context8.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'GET';\n	                            options.url = url;\n	                            options.query = query;\n	                            _context8.next = 6;\n	                            return this.send(options);\n	\n	                        case 6:\n	                            return _context8.abrupt(\"return\", _context8.sent);\n	\n	                        case 7:\n	                        case \"end\":\n	                            return _context8.stop();\n	                    }\n	                }\n	            }, _callee8, this);\n	        }));\n	\n	        function get(_x8, _x9, _x10) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return get;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {object} body\n	     * @param {object} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.post = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, body, query, options) {\n	            return regeneratorRuntime.wrap(function _callee9$(_context9) {\n	                while (1) {\n	                    switch (_context9.prev = _context9.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'POST';\n	                            options.url = url;\n	                            options.query = query;\n	                            options.body = body;\n	                            _context9.next = 7;\n	                            return this.send(options);\n	\n	                        case 7:\n	                            return _context9.abrupt(\"return\", _context9.sent);\n	\n	                        case 8:\n	                        case \"end\":\n	                            return _context9.stop();\n	                    }\n	                }\n	            }, _callee9, this);\n	        }));\n	\n	        function post(_x11, _x12, _x13, _x14) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return post;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {object} [body]\n	     * @param {object} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype.put = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {\n	            return regeneratorRuntime.wrap(function _callee10$(_context10) {\n	                while (1) {\n	                    switch (_context10.prev = _context10.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'PUT';\n	                            options.url = url;\n	                            options.query = query;\n	                            options.body = body;\n	                            _context10.next = 7;\n	                            return this.send(options);\n	\n	                        case 7:\n	                            return _context10.abrupt(\"return\", _context10.sent);\n	\n	                        case 8:\n	                        case \"end\":\n	                            return _context10.stop();\n	                    }\n	                }\n	            }, _callee10, this);\n	        }));\n	\n	        function put(_x15, _x16, _x17, _x18) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return put;\n	    }();\n	\n	    /**\n	     * @param {string} url\n	     * @param {string} [query]\n	     * @param {object} [options]\n	     * @param {object} [options.headers]\n	     * @param {boolean} [options.skipAuthCheck]\n	     * @return {Promise<ApiResponse>}\n	     */\n	\n	\n	    Platform.prototype['delete'] = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, query, options) {\n	            return regeneratorRuntime.wrap(function _callee11$(_context11) {\n	                while (1) {\n	                    switch (_context11.prev = _context11.next) {\n	                        case 0:\n	                            options = options || {};\n	                            options.method = 'DELETE';\n	                            options.url = url;\n	                            options.query = query;\n	                            _context11.next = 6;\n	                            return this.send(options);\n	\n	                        case 6:\n	                            return _context11.abrupt(\"return\", _context11.sent);\n	\n	                        case 7:\n	                        case \"end\":\n	                            return _context11.stop();\n	                    }\n	                }\n	            }, _callee11, this);\n	        }));\n	\n	        function _delete(_x19, _x20, _x21) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _delete;\n	    }();\n	\n	    Platform.prototype._tokenRequest = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(path, body) {\n	            return regeneratorRuntime.wrap(function _callee12$(_context12) {\n	                while (1) {\n	                    switch (_context12.prev = _context12.next) {\n	                        case 0:\n	                            _context12.next = 2;\n	                            return this.send({\n	                                url: path,\n	                                skipAuthCheck: true,\n	                                body: body,\n	                                method: 'POST',\n	                                headers: {\n	                                    'Authorization': 'Basic ' + this._apiKey(),\n	                                    'Content-Type': 'application/x-www-form-urlencoded'\n	                                }\n	                            });\n	\n	                        case 2:\n	                            return _context12.abrupt(\"return\", _context12.sent);\n	\n	                        case 3:\n	                        case \"end\":\n	                            return _context12.stop();\n	                    }\n	                }\n	            }, _callee12, this);\n	        }));\n	\n	        function _tokenRequest(_x22, _x23) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _tokenRequest;\n	    }();\n	\n	    Platform.prototype._ensureAuthentication = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {\n	            return regeneratorRuntime.wrap(function _callee13$(_context13) {\n	                while (1) {\n	                    switch (_context13.prev = _context13.next) {\n	                        case 0:\n	                            if (!this._isAccessTokenValid()) {\n	                                _context13.next = 2;\n	                                break;\n	                            }\n	\n	                            return _context13.abrupt(\"return\", null);\n	\n	                        case 2:\n	                            _context13.next = 4;\n	                            return this.refresh();\n	\n	                        case 4:\n	                            return _context13.abrupt(\"return\", _context13.sent);\n	\n	                        case 5:\n	                        case \"end\":\n	                            return _context13.stop();\n	                    }\n	                }\n	            }, _callee13, this);\n	        }));\n	\n	        function _ensureAuthentication() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _ensureAuthentication;\n	    }();\n	\n	    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {\n	\n	        return this._auth.accessTokenValid() && !this._queue.isPaused();\n	    };\n	\n	    Platform.prototype._apiKey = function _apiKey() {\n	        var apiKey = this._appKey + ':' + this._appSecret;\n	        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');\n	    };\n	\n	    Platform.prototype._authHeader = function _authHeader() {\n	        var token = this._auth.accessToken();\n	        return this._auth.tokenType() + (token ? ' ' + token : '');\n	    };\n	\n	    return Platform;\n	}(_Observable3.default);\n	\n	Platform._urlPrefix = '/restapi';\n	Platform._apiVersion = 'v1.0';\n	Platform._refreshTokenTtl = 10 * 60 * 60;\n	Platform._refreshTokenTtlRemember = 7 * 24 * 60 * 60;\n	Platform._tokenEndpoint = '/restapi/oauth/token';\n	Platform._revokeEndpoint = '/restapi/oauth/revoke';\n	Platform._authorizeEndpoint = '/restapi/oauth/authorize';\n	Platform._refreshDelayMs = 100;\n	Platform._cacheId = 'platform';\n	Platform._clearCacheOnRefreshError = false;\n	exports.default = Platform;\n	\n	/***/ },\n	/* 21 */\n	/***/ function(module, exports) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var Auth = function () {\n	    function Auth(cache, cacheId) {\n	        _classCallCheck(this, Auth);\n	\n	        /** @type {Cache} */\n	        this._cache = cache;\n	        this._cacheId = cacheId;\n	    } // 1 minute\n	\n	\n	    Auth.prototype.accessToken = function accessToken() {\n	        return this.data().access_token;\n	    };\n	\n	    Auth.prototype.refreshToken = function refreshToken() {\n	        return this.data().refresh_token;\n	    };\n	\n	    Auth.prototype.tokenType = function tokenType() {\n	        return this.data().token_type;\n	    };\n	\n	    /**\n	     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}\n	     */\n	\n	\n	    Auth.prototype.data = function data() {\n	\n	        return this._cache.getItem(this._cacheId) || {\n	            token_type: '',\n	            access_token: '',\n	            expires_in: 0,\n	            refresh_token: '',\n	            refresh_token_expires_in: 0\n	        };\n	    };\n	\n	    /**\n	     * @param {object} newData\n	     * @return {Auth}\n	     */\n	\n	\n	    Auth.prototype.setData = function setData(newData) {\n	\n	        newData = newData || {};\n	\n	        var data = this.data();\n	\n	        Object.keys(newData).forEach(function (key) {\n	            data[key] = newData[key];\n	        });\n	\n	        data.expire_time = Date.now() + data.expires_in * 1000;\n	        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;\n	\n	        this._cache.setItem(this._cacheId, data);\n	\n	        return this;\n	    };\n	\n	    /**\n	     * Check if there is a valid (not expired) access token\n	     * @return {boolean}\n	     */\n	\n	\n	    Auth.prototype.accessTokenValid = function accessTokenValid() {\n	\n	        var authData = this.data();\n	        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();\n	    };\n	\n	    /**\n	     * Check if there is a valid (not expired) access token\n	     * @return {boolean}\n	     */\n	\n	\n	    Auth.prototype.refreshTokenValid = function refreshTokenValid() {\n	\n	        return this.data().refresh_token_expire_time > Date.now();\n	    };\n	\n	    /**\n	     * @return {Auth}\n	     */\n	\n	\n	    Auth.prototype.cancelAccessToken = function cancelAccessToken() {\n	\n	        return this.setData({\n	            access_token: '',\n	            expires_in: 0\n	        });\n	    };\n	\n	    /**\n	     * This method sets a special authentication mode used in Service Web\n	     * @return {Auth}\n	     */\n	\n	\n	    Auth.prototype.forceAuthentication = function forceAuthentication() {\n	\n	        this.setData({\n	            token_type: Auth.forcedTokenType,\n	            access_token: '',\n	            expires_in: 0,\n	            refresh_token: '',\n	            refresh_token_expires_in: 0\n	        });\n	\n	        return this;\n	    };\n	\n	    return Auth;\n	}();\n	\n	//export interface IAuthData {\n	//    remember?:boolean;\n	//    token_type?:string;\n	//    access_token?:string;\n	//    expires_in?:number; // actually it's string\n	//    expire_time?:number;\n	//    refresh_token?:string;\n	//    refresh_token_expires_in?:number; // actually it's string\n	//    refresh_token_expire_time?:number;\n	//    scope?:string;\n	//}\n	\n	\n	Auth.refreshHandicapMs = 60 * 1000;\n	Auth.forcedTokenType = 'forced';\n	exports.default = Auth;\n	\n	/***/ },\n	/* 22 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _PubnubMock = __webpack_require__(23);\n	\n	var _PubnubMock2 = _interopRequireDefault(_PubnubMock);\n	\n	var _Externals = __webpack_require__(4);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	var PubnubMockFactory = function () {\n	    function PubnubMockFactory() {\n	        _classCallCheck(this, PubnubMockFactory);\n	\n	        this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n	    }\n	\n	    PubnubMockFactory.prototype.init = function init(options) {\n	        return new _PubnubMock2.default(options);\n	    };\n	\n	    return PubnubMockFactory;\n	}();\n	\n	exports.default = PubnubMockFactory;\n	\n	/***/ },\n	/* 23 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _Externals = __webpack_require__(4);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var PubnubMock = function (_Observable) {\n	    _inherits(PubnubMock, _Observable);\n	\n	    function PubnubMock(options) {\n	        _classCallCheck(this, PubnubMock);\n	\n	        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n	\n	        _this.options = options;\n	        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;\n	        return _this;\n	    }\n	\n	    PubnubMock.prototype.ready = function ready() {};\n	\n	    PubnubMock.prototype.subscribe = function subscribe(options) {\n	        this.on('message-' + options.channel, options.message);\n	    };\n	\n	    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {\n	        this.off('message-' + options.channel);\n	    };\n	\n	    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {\n	        this.emit('message-' + channel, msg, 'env', channel);\n	    };\n	\n	    return PubnubMock;\n	}(_Observable3.default);\n	\n	exports.default = PubnubMock;\n	\n	/***/ },\n	/* 24 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _Observable2 = __webpack_require__(13);\n	\n	var _Observable3 = _interopRequireDefault(_Observable2);\n	\n	var _Client = __webpack_require__(15);\n	\n	var _Client2 = _interopRequireDefault(_Client);\n	\n	var _Utils = __webpack_require__(3);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var Subscription = function (_Observable) {\n	    _inherits(Subscription, _Observable);\n	\n	    function Subscription(pubnubFactory, platform) {\n	        _classCallCheck(this, Subscription);\n	\n	        var _this = _possibleConstructorReturn(this, _Observable.call(this));\n	\n	        _this.events = {\n	            notification: 'notification',\n	            removeSuccess: 'removeSuccess',\n	            removeError: 'removeError',\n	            renewSuccess: 'renewSuccess',\n	            renewError: 'renewError',\n	            subscribeSuccess: 'subscribeSuccess',\n	            subscribeError: 'subscribeError'\n	        };\n	\n	\n	        _this._pubnubFactory = pubnubFactory;\n	        _this._platform = platform;\n	        _this._pubnub = null;\n	        _this._timeout = null;\n	        _this._subscription = {};\n	\n	        return _this;\n	    }\n	\n	    Subscription.prototype.subscribed = function subscribed() {\n	\n	        return !!(this._subscription.id && this._subscription.deliveryMode && this._subscription.deliveryMode.subscriberKey && this._subscription.deliveryMode.address);\n	    };\n	\n	    /**\n	     * @return {boolean}\n	     */\n	\n	\n	    Subscription.prototype.alive = function alive() {\n	        return this.subscribed() && Date.now() < this.expirationTime();\n	    };\n	\n	    Subscription.prototype.expirationTime = function expirationTime() {\n	        return new Date(this._subscription.expirationTime || 0).getTime() - Subscription._renewHandicapMs;\n	    };\n	\n	    Subscription.prototype.setSubscription = function setSubscription(subscription) {\n	\n	        subscription = subscription || {};\n	\n	        this._clearTimeout();\n	\n	        this._subscription = subscription;\n	\n	        if (!this._pubnub) this._subscribeAtPubnub();\n	\n	        this._setTimeout();\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype.subscription = function subscription() {\n	        return this._subscription;\n	    };\n	\n	    /**\n	     * Creates or updates subscription if there is an active one\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.register = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            if (!this.alive()) {\n	                                _context.next = 6;\n	                                break;\n	                            }\n	\n	                            _context.next = 3;\n	                            return this.renew();\n	\n	                        case 3:\n	                            return _context.abrupt('return', _context.sent);\n	\n	                        case 6:\n	                            _context.next = 8;\n	                            return this.subscribe();\n	\n	                        case 8:\n	                            return _context.abrupt('return', _context.sent);\n	\n	                        case 9:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this);\n	        }));\n	\n	        function register() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return register;\n	    }();\n	\n	    Subscription.prototype.eventFilters = function eventFilters() {\n	        return this._subscription.eventFilters || [];\n	    };\n	\n	    /**\n	     * @param {string[]} events\n	     * @return {Subscription}\n	     */\n	\n	\n	    Subscription.prototype.addEventFilters = function addEventFilters(events) {\n	        this.setEventFilters(this.eventFilters().concat(events));\n	        return this;\n	    };\n	\n	    /**\n	     * @param {string[]} events\n	     * @return {Subscription}\n	     */\n	\n	\n	    Subscription.prototype.setEventFilters = function setEventFilters(events) {\n	        this._subscription.eventFilters = events;\n	        return this;\n	    };\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.subscribe = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n	            var response, json;\n	            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n	                while (1) {\n	                    switch (_context2.prev = _context2.next) {\n	                        case 0:\n	                            _context2.prev = 0;\n	\n	\n	                            this._clearTimeout();\n	\n	                            if (this.eventFilters().length) {\n	                                _context2.next = 4;\n	                                break;\n	                            }\n	\n	                            throw new Error('Events are undefined');\n	\n	                        case 4:\n	                            _context2.next = 6;\n	                            return this._platform.post('/restapi/v1.0/subscription', {\n	                                eventFilters: this._getFullEventFilters(),\n	                                deliveryMode: {\n	                                    transportType: 'PubNub'\n	                                }\n	                            });\n	\n	                        case 6:\n	                            response = _context2.sent;\n	                            json = response.json();\n	\n	\n	                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);\n	\n	                            return _context2.abrupt('return', response);\n	\n	                        case 12:\n	                            _context2.prev = 12;\n	                            _context2.t0 = _context2['catch'](0);\n	\n	\n	                            _context2.t0 = this._platform.client().makeError(_context2.t0);\n	\n	                            this.reset().emit(this.events.subscribeError, _context2.t0);\n	\n	                            throw _context2.t0;\n	\n	                        case 17:\n	                        case 'end':\n	                            return _context2.stop();\n	                    }\n	                }\n	            }, _callee2, this, [[0, 12]]);\n	        }));\n	\n	        function subscribe() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return subscribe;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.renew = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n	            var response, json;\n	            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n	                while (1) {\n	                    switch (_context3.prev = _context3.next) {\n	                        case 0:\n	                            _context3.prev = 0;\n	\n	\n	                            this._clearTimeout();\n	\n	                            if (this.subscribed()) {\n	                                _context3.next = 4;\n	                                break;\n	                            }\n	\n	                            throw new Error('No subscription');\n	\n	                        case 4:\n	                            if (this.eventFilters().length) {\n	                                _context3.next = 6;\n	                                break;\n	                            }\n	\n	                            throw new Error('Events are undefined');\n	\n	                        case 6:\n	                            _context3.next = 8;\n	                            return this._platform.put('/restapi/v1.0/subscription/' + this._subscription.id, {\n	                                eventFilters: this._getFullEventFilters()\n	                            });\n	\n	                        case 8:\n	                            response = _context3.sent;\n	                            json = response.json();\n	\n	\n	                            this.setSubscription(json).emit(this.events.renewSuccess, response);\n	\n	                            return _context3.abrupt('return', response);\n	\n	                        case 14:\n	                            _context3.prev = 14;\n	                            _context3.t0 = _context3['catch'](0);\n	\n	\n	                            _context3.t0 = this._platform.client().makeError(_context3.t0);\n	\n	                            this.reset().emit(this.events.renewError, _context3.t0);\n	\n	                            throw _context3.t0;\n	\n	                        case 19:\n	                        case 'end':\n	                            return _context3.stop();\n	                    }\n	                }\n	            }, _callee3, this, [[0, 14]]);\n	        }));\n	\n	        function renew() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return renew;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.remove = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n	            var response;\n	            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n	                while (1) {\n	                    switch (_context4.prev = _context4.next) {\n	                        case 0:\n	                            _context4.prev = 0;\n	\n	                            if (this.subscribed()) {\n	                                _context4.next = 3;\n	                                break;\n	                            }\n	\n	                            throw new Error('No subscription');\n	\n	                        case 3:\n	                            _context4.next = 5;\n	                            return this._platform.delete('/restapi/v1.0/subscription/' + this._subscription.id);\n	\n	                        case 5:\n	                            response = _context4.sent;\n	\n	\n	                            this.reset().emit(this.events.removeSuccess, response);\n	\n	                            return _context4.abrupt('return', response);\n	\n	                        case 10:\n	                            _context4.prev = 10;\n	                            _context4.t0 = _context4['catch'](0);\n	\n	\n	                            _context4.t0 = this._platform.client().makeError(_context4.t0);\n	\n	                            this.emit(this.events.removeError, _context4.t0);\n	\n	                            throw _context4.t0;\n	\n	                        case 15:\n	                        case 'end':\n	                            return _context4.stop();\n	                    }\n	                }\n	            }, _callee4, this, [[0, 10]]);\n	        }));\n	\n	        function remove() {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return remove;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    Subscription.prototype.resubscribe = function resubscribe() {\n	\n	        return this.reset().setEventFilters(this.eventFilters()).subscribe();\n	    };\n	\n	    /**\n	     * Remove subscription and disconnect from PUBNUB\n	     * This method resets subscription at client side but backend is not notified\n	     */\n	\n	\n	    Subscription.prototype.reset = function reset() {\n	        this._clearTimeout();\n	        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this._subscription.deliveryMode.address });\n	        this._subscription = {};\n	        return this;\n	    };\n	\n	    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {\n	        var _this2 = this;\n	\n	        return this.eventFilters().map(function (event) {\n	            return _this2._platform.createUrl(event);\n	        });\n	    };\n	\n	    Subscription.prototype._setTimeout = function _setTimeout() {\n	        var _this3 = this;\n	\n	        this._clearTimeout();\n	\n	        if (!this.alive()) throw new Error('Subscription is not alive');\n	\n	        (0, _Utils.poll)(function (next) {\n	\n	            if (_this3.alive()) return next();\n	\n	            _this3.renew();\n	        }, Subscription._pollInterval, this._timeout);\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype._clearTimeout = function _clearTimeout() {\n	\n	        (0, _Utils.stopPolling)(this._timeout);\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype._decrypt = function _decrypt(message) {\n	\n	        if (!this.subscribed()) throw new Error('No subscription');\n	\n	        if (this._subscription.deliveryMode.encryptionKey) {\n	\n	            var PUBNUB = this._pubnubFactory;\n	\n	            message = PUBNUB.crypto_obj.decrypt(message, this._subscription.deliveryMode.encryptionKey, {\n	                encryptKey: false,\n	                keyEncoding: 'base64',\n	                keyLength: 128,\n	                mode: 'ecb'\n	            });\n	        }\n	\n	        return message;\n	    };\n	\n	    Subscription.prototype._notify = function _notify(message) {\n	\n	        this.emit(this.events.notification, this._decrypt(message));\n	\n	        return this;\n	    };\n	\n	    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {\n	\n	        if (!this.alive()) throw new Error('Subscription is not alive');\n	\n	        var PUBNUB = this._pubnubFactory;\n	\n	        this._pubnub = PUBNUB.init({\n	            ssl: true,\n	            subscribe_key: this._subscription.deliveryMode.subscriberKey\n	        });\n	\n	        this._pubnub.ready();\n	\n	        this._pubnub.subscribe({\n	            channel: this._subscription.deliveryMode.address,\n	            message: this._notify.bind(this),\n	            connect: function connect() {}\n	        });\n	\n	        return this;\n	    };\n	\n	    return Subscription;\n	}(_Observable3.default);\n	\n	//export interface ISubscription {\n	//    id?:string;\n	//    uri?: string;\n	//    eventFilters?:string[];\n	//    expirationTime?:string; // 2014-03-12T19:54:35.613Z\n	//    expiresIn?:number;\n	//    deliveryMode?: {\n	//        transportType?:string;\n	//        encryption?:boolean;\n	//        address?:string;\n	//        subscriberKey?:string;\n	//        encryptionKey?:string;\n	//        secretKey?:string;\n	//    };\n	//    creationTime?:string; // 2014-03-12T19:54:35.613Z\n	//    status?:string; // Active\n	//}\n	\n	\n	Subscription._renewHandicapMs = 2 * 60 * 1000;\n	Subscription._pollInterval = 10 * 1000;\n	exports.default = Subscription;\n	\n	/***/ },\n	/* 25 */\n	/***/ function(module, exports, __webpack_require__) {\n	\n	'use strict';\n	\n	exports.__esModule = true;\n	\n	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n	\n	var _Subscription2 = __webpack_require__(24);\n	\n	var _Subscription3 = _interopRequireDefault(_Subscription2);\n	\n	var _Queue = __webpack_require__(14);\n	\n	var _Queue2 = _interopRequireDefault(_Queue);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(\"next\", value); }, function (err) { return step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n	\n	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n	\n	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n	\n	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n	\n	var CachedSubscription = function (_Subscription) {\n	    _inherits(CachedSubscription, _Subscription);\n	\n	    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {\n	        _classCallCheck(this, CachedSubscription);\n	\n	        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));\n	\n	        _this._cache = cache;\n	        _this._cacheKey = cacheKey;\n	        _this._renewQueue = new _Queue2.default(_this._cache, cacheKey + '-renew');\n	        _this._resubscribeQueue = new _Queue2.default(_this._cache, cacheKey + '-resubscribe');\n	\n	        _this.events = _extends({}, _this.events, {\n	            queuedRenewSuccess: 'queuedRenewSuccess',\n	            queuedRenewError: 'queuedRenewError',\n	            queuedResubscribeSuccess: 'queuedResubscribeSuccess',\n	            queuedResubscribeError: 'queuedResubscribeError'\n	        });\n	\n	        _this.on(_this.events.renewError, function () {\n	            _this.resubscribe();\n	        });\n	\n	        _this.on([_this.events.subscribeSuccess, _this.events.renewSuccess], function () {\n	            _this._cache.setItem(_this._cacheKey, _this.subscription());\n	        });\n	\n	        _this.on(_this.events.removeSuccess, function () {\n	            _this._cache.removeItem(_this._cacheKey);\n	        });\n	\n	        return _this;\n	    }\n	\n	    /**\n	     * TODO Combine with Platform.refresh and move elsewhere\n	     * @param actionCb\n	     * @param queue\n	     * @param successEvent\n	     * @param errorEvent\n	     * @param errorMessage\n	     * @return {*}\n	     * @private\n	     */\n	\n	\n	    CachedSubscription.prototype._queue = function () {\n	        var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(actionCb, queue, successEvent, errorEvent, errorMessage) {\n	            var res;\n	            return regeneratorRuntime.wrap(function _callee$(_context) {\n	                while (1) {\n	                    switch (_context.prev = _context.next) {\n	                        case 0:\n	                            _context.prev = 0;\n	\n	                            if (!queue.isPaused()) {\n	                                _context.next = 8;\n	                                break;\n	                            }\n	\n	                            _context.next = 4;\n	                            return queue.poll();\n	\n	                        case 4:\n	                            if (this.alive()) {\n	                                _context.next = 6;\n	                                break;\n	                            }\n	\n	                            throw new Error(errorMessage);\n	\n	                        case 6:\n	\n	                            this.emit(successEvent, null);\n	\n	                            return _context.abrupt('return', null);\n	\n	                        case 8:\n	\n	                            queue.pause();\n	\n	                            _context.next = 11;\n	                            return actionCb.call(this);\n	\n	                        case 11:\n	                            res = _context.sent;\n	\n	\n	                            queue.resume();\n	\n	                            this.emit(successEvent, res);\n	\n	                            return _context.abrupt('return', res);\n	\n	                        case 17:\n	                            _context.prev = 17;\n	                            _context.t0 = _context['catch'](0);\n	\n	\n	                            this.emit(errorEvent, _context.t0);\n	\n	                            throw _context.t0;\n	\n	                        case 21:\n	                        case 'end':\n	                            return _context.stop();\n	                    }\n	                }\n	            }, _callee, this, [[0, 17]]);\n	        }));\n	\n	        function _queue(_x, _x2, _x3, _x4, _x5) {\n	            return ref.apply(this, arguments);\n	        }\n	\n	        return _queue;\n	    }();\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    CachedSubscription.prototype.renew = function renew() {\n	\n	        return this._queue(_Subscription.prototype.renew, this._renewQueue, this.events.queuedRenewSuccess, this.events.queuedRenewError, 'Subscription is not alive after renew timeout');\n	    };\n	\n	    /**\n	     * @returns {Promise<ApiResponse>}\n	     */\n	\n	\n	    CachedSubscription.prototype.resubscribe = function resubscribe() {\n	\n	        return this._queue(_Subscription.prototype.resubscribe, this._resubscribeQueue, this.events.queuedResubscribeSuccess, this.events.queuedResubscribeError, 'Subscription is not alive after resubscribe timeout');\n	    };\n	\n	    /**\n	     * @param {string[]} events\n	     * @return {CachedSubscription}\n	     */\n	\n	\n	    CachedSubscription.prototype.restore = function restore(events) {\n	\n	        var cachedSubscriptionData = this._cache.getItem(this._cacheKey);\n	\n	        if (cachedSubscriptionData) {\n	            try {\n	                this.setSubscription(cachedSubscriptionData);\n	            } catch (e) {}\n	        } else {\n	            this.setEventFilters(events);\n	        }\n	\n	        return this;\n	    };\n	\n	    return CachedSubscription;\n	}(_Subscription3.default);\n	\n	exports.default = CachedSubscription;\n	\n	/***/ }\n	/******/ ])\n	});\n	;\n	//# sourceMappingURL=ringcentral-bundle.js.map\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(7).Buffer))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n	// shim for using process in browser\n	\n	var process = module.exports = {};\n	var queue = [];\n	var draining = false;\n	var currentQueue;\n	var queueIndex = -1;\n	\n	function cleanUpNextTick() {\n	    draining = false;\n	    if (currentQueue.length) {\n	        queue = currentQueue.concat(queue);\n	    } else {\n	        queueIndex = -1;\n	    }\n	    if (queue.length) {\n	        drainQueue();\n	    }\n	}\n	\n	function drainQueue() {\n	    if (draining) {\n	        return;\n	    }\n	    var timeout = setTimeout(cleanUpNextTick);\n	    draining = true;\n	\n	    var len = queue.length;\n	    while(len) {\n	        currentQueue = queue;\n	        queue = [];\n	        while (++queueIndex < len) {\n	            if (currentQueue) {\n	                currentQueue[queueIndex].run();\n	            }\n	        }\n	        queueIndex = -1;\n	        len = queue.length;\n	    }\n	    currentQueue = null;\n	    draining = false;\n	    clearTimeout(timeout);\n	}\n	\n	process.nextTick = function (fun) {\n	    var args = new Array(arguments.length - 1);\n	    if (arguments.length > 1) {\n	        for (var i = 1; i < arguments.length; i++) {\n	            args[i - 1] = arguments[i];\n	        }\n	    }\n	    queue.push(new Item(fun, args));\n	    if (queue.length === 1 && !draining) {\n	        setTimeout(drainQueue, 0);\n	    }\n	};\n	\n	// v8 likes predictible objects\n	function Item(fun, array) {\n	    this.fun = fun;\n	    this.array = array;\n	}\n	Item.prototype.run = function () {\n	    this.fun.apply(null, this.array);\n	};\n	process.title = 'browser';\n	process.browser = true;\n	process.env = {};\n	process.argv = [];\n	process.version = ''; // empty string to avoid regexp issues\n	process.versions = {};\n	\n	function noop() {}\n	\n	process.on = noop;\n	process.addListener = noop;\n	process.once = noop;\n	process.off = noop;\n	process.removeListener = noop;\n	process.removeAllListeners = noop;\n	process.emit = noop;\n	\n	process.binding = function (name) {\n	    throw new Error('process.binding is not supported');\n	};\n	\n	process.cwd = function () { return '/' };\n	process.chdir = function (dir) {\n	    throw new Error('process.chdir is not supported');\n	};\n	process.umask = function() { return 0; };\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n	 * The buffer module from node.js, for the browser.\n	 *\n	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n	 * @license  MIT\n	 */\n	/* eslint-disable no-proto */\n	\n	'use strict'\n	\n	var base64 = __webpack_require__(8)\n	var ieee754 = __webpack_require__(9)\n	var isArray = __webpack_require__(10)\n	\n	exports.Buffer = Buffer\n	exports.SlowBuffer = SlowBuffer\n	exports.INSPECT_MAX_BYTES = 50\n	Buffer.poolSize = 8192 // not used by this implementation\n	\n	var rootParent = {}\n	\n	/**\n	 * If `Buffer.TYPED_ARRAY_SUPPORT`:\n	 *   === true    Use Uint8Array implementation (fastest)\n	 *   === false   Use Object implementation (most compatible, even IE6)\n	 *\n	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n	 * Opera 11.6+, iOS 4.2+.\n	 *\n	 * Due to various browser bugs, sometimes the Object implementation will be used even\n	 * when the browser supports typed arrays.\n	 *\n	 * Note:\n	 *\n	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n	 *\n	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n	 *     on objects.\n	 *\n	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n	 *\n	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n	 *     incorrect length in some situations.\n	\n	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n	 * get the Object implementation, which is slower but behaves correctly.\n	 */\n	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n	  ? global.TYPED_ARRAY_SUPPORT\n	  : typedArraySupport()\n	\n	function typedArraySupport () {\n	  function Bar () {}\n	  try {\n	    var arr = new Uint8Array(1)\n	    arr.foo = function () { return 42 }\n	    arr.constructor = Bar\n	    return arr.foo() === 42 && // typed array instances can be augmented\n	        arr.constructor === Bar && // constructor can be set\n	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n	  } catch (e) {\n	    return false\n	  }\n	}\n	\n	function kMaxLength () {\n	  return Buffer.TYPED_ARRAY_SUPPORT\n	    ? 0x7fffffff\n	    : 0x3fffffff\n	}\n	\n	/**\n	 * Class: Buffer\n	 * =============\n	 *\n	 * The Buffer constructor returns instances of `Uint8Array` that are augmented\n	 * with function properties for all the node `Buffer` API functions. We use\n	 * `Uint8Array` so that square bracket notation works as expected -- it returns\n	 * a single octet.\n	 *\n	 * By augmenting the instances, we can avoid modifying the `Uint8Array`\n	 * prototype.\n	 */\n	function Buffer (arg) {\n	  if (!(this instanceof Buffer)) {\n	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n	    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n	    return new Buffer(arg)\n	  }\n	\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n	    this.length = 0\n	    this.parent = undefined\n	  }\n	\n	  // Common case.\n	  if (typeof arg === 'number') {\n	    return fromNumber(this, arg)\n	  }\n	\n	  // Slightly less common case.\n	  if (typeof arg === 'string') {\n	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n	  }\n	\n	  // Unusual.\n	  return fromObject(this, arg)\n	}\n	\n	function fromNumber (that, length) {\n	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n	    for (var i = 0; i < length; i++) {\n	      that[i] = 0\n	    }\n	  }\n	  return that\n	}\n	\n	function fromString (that, string, encoding) {\n	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n	\n	  // Assumption: byteLength() return value is always < kMaxLength.\n	  var length = byteLength(string, encoding) | 0\n	  that = allocate(that, length)\n	\n	  that.write(string, encoding)\n	  return that\n	}\n	\n	function fromObject (that, object) {\n	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n	\n	  if (isArray(object)) return fromArray(that, object)\n	\n	  if (object == null) {\n	    throw new TypeError('must start with number, buffer, array or string')\n	  }\n	\n	  if (typeof ArrayBuffer !== 'undefined') {\n	    if (object.buffer instanceof ArrayBuffer) {\n	      return fromTypedArray(that, object)\n	    }\n	    if (object instanceof ArrayBuffer) {\n	      return fromArrayBuffer(that, object)\n	    }\n	  }\n	\n	  if (object.length) return fromArrayLike(that, object)\n	\n	  return fromJsonObject(that, object)\n	}\n	\n	function fromBuffer (that, buffer) {\n	  var length = checked(buffer.length) | 0\n	  that = allocate(that, length)\n	  buffer.copy(that, 0, 0, length)\n	  return that\n	}\n	\n	function fromArray (that, array) {\n	  var length = checked(array.length) | 0\n	  that = allocate(that, length)\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	// Duplicate of fromArray() to keep fromArray() monomorphic.\n	function fromTypedArray (that, array) {\n	  var length = checked(array.length) | 0\n	  that = allocate(that, length)\n	  // Truncating the elements is probably not what people expect from typed\n	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n	  // of the old Buffer constructor.\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	function fromArrayBuffer (that, array) {\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    // Return an augmented `Uint8Array` instance, for best performance\n	    array.byteLength\n	    that = Buffer._augment(new Uint8Array(array))\n	  } else {\n	    // Fallback: Return an object instance of the Buffer class\n	    that = fromTypedArray(that, new Uint8Array(array))\n	  }\n	  return that\n	}\n	\n	function fromArrayLike (that, array) {\n	  var length = checked(array.length) | 0\n	  that = allocate(that, length)\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n	// Returns a zero-length buffer for inputs that don't conform to the spec.\n	function fromJsonObject (that, object) {\n	  var array\n	  var length = 0\n	\n	  if (object.type === 'Buffer' && isArray(object.data)) {\n	    array = object.data\n	    length = checked(array.length) | 0\n	  }\n	  that = allocate(that, length)\n	\n	  for (var i = 0; i < length; i += 1) {\n	    that[i] = array[i] & 255\n	  }\n	  return that\n	}\n	\n	if (Buffer.TYPED_ARRAY_SUPPORT) {\n	  Buffer.prototype.__proto__ = Uint8Array.prototype\n	  Buffer.__proto__ = Uint8Array\n	} else {\n	  // pre-set for values that may exist in the future\n	  Buffer.prototype.length = undefined\n	  Buffer.prototype.parent = undefined\n	}\n	\n	function allocate (that, length) {\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    // Return an augmented `Uint8Array` instance, for best performance\n	    that = Buffer._augment(new Uint8Array(length))\n	    that.__proto__ = Buffer.prototype\n	  } else {\n	    // Fallback: Return an object instance of the Buffer class\n	    that.length = length\n	    that._isBuffer = true\n	  }\n	\n	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n	  if (fromPool) that.parent = rootParent\n	\n	  return that\n	}\n	\n	function checked (length) {\n	  // Note: cannot use `length < kMaxLength` here because that fails when\n	  // length is NaN (which is otherwise coerced to zero.)\n	  if (length >= kMaxLength()) {\n	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n	  }\n	  return length | 0\n	}\n	\n	function SlowBuffer (subject, encoding) {\n	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n	\n	  var buf = new Buffer(subject, encoding)\n	  delete buf.parent\n	  return buf\n	}\n	\n	Buffer.isBuffer = function isBuffer (b) {\n	  return !!(b != null && b._isBuffer)\n	}\n	\n	Buffer.compare = function compare (a, b) {\n	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n	    throw new TypeError('Arguments must be Buffers')\n	  }\n	\n	  if (a === b) return 0\n	\n	  var x = a.length\n	  var y = b.length\n	\n	  var i = 0\n	  var len = Math.min(x, y)\n	  while (i < len) {\n	    if (a[i] !== b[i]) break\n	\n	    ++i\n	  }\n	\n	  if (i !== len) {\n	    x = a[i]\n	    y = b[i]\n	  }\n	\n	  if (x < y) return -1\n	  if (y < x) return 1\n	  return 0\n	}\n	\n	Buffer.isEncoding = function isEncoding (encoding) {\n	  switch (String(encoding).toLowerCase()) {\n	    case 'hex':\n	    case 'utf8':\n	    case 'utf-8':\n	    case 'ascii':\n	    case 'binary':\n	    case 'base64':\n	    case 'raw':\n	    case 'ucs2':\n	    case 'ucs-2':\n	    case 'utf16le':\n	    case 'utf-16le':\n	      return true\n	    default:\n	      return false\n	  }\n	}\n	\n	Buffer.concat = function concat (list, length) {\n	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n	\n	  if (list.length === 0) {\n	    return new Buffer(0)\n	  }\n	\n	  var i\n	  if (length === undefined) {\n	    length = 0\n	    for (i = 0; i < list.length; i++) {\n	      length += list[i].length\n	    }\n	  }\n	\n	  var buf = new Buffer(length)\n	  var pos = 0\n	  for (i = 0; i < list.length; i++) {\n	    var item = list[i]\n	    item.copy(buf, pos)\n	    pos += item.length\n	  }\n	  return buf\n	}\n	\n	function byteLength (string, encoding) {\n	  if (typeof string !== 'string') string = '' + string\n	\n	  var len = string.length\n	  if (len === 0) return 0\n	\n	  // Use a for loop to avoid recursion\n	  var loweredCase = false\n	  for (;;) {\n	    switch (encoding) {\n	      case 'ascii':\n	      case 'binary':\n	      // Deprecated\n	      case 'raw':\n	      case 'raws':\n	        return len\n	      case 'utf8':\n	      case 'utf-8':\n	        return utf8ToBytes(string).length\n	      case 'ucs2':\n	      case 'ucs-2':\n	      case 'utf16le':\n	      case 'utf-16le':\n	        return len * 2\n	      case 'hex':\n	        return len >>> 1\n	      case 'base64':\n	        return base64ToBytes(string).length\n	      default:\n	        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n	        encoding = ('' + encoding).toLowerCase()\n	        loweredCase = true\n	    }\n	  }\n	}\n	Buffer.byteLength = byteLength\n	\n	function slowToString (encoding, start, end) {\n	  var loweredCase = false\n	\n	  start = start | 0\n	  end = end === undefined || end === Infinity ? this.length : end | 0\n	\n	  if (!encoding) encoding = 'utf8'\n	  if (start < 0) start = 0\n	  if (end > this.length) end = this.length\n	  if (end <= start) return ''\n	\n	  while (true) {\n	    switch (encoding) {\n	      case 'hex':\n	        return hexSlice(this, start, end)\n	\n	      case 'utf8':\n	      case 'utf-8':\n	        return utf8Slice(this, start, end)\n	\n	      case 'ascii':\n	        return asciiSlice(this, start, end)\n	\n	      case 'binary':\n	        return binarySlice(this, start, end)\n	\n	      case 'base64':\n	        return base64Slice(this, start, end)\n	\n	      case 'ucs2':\n	      case 'ucs-2':\n	      case 'utf16le':\n	      case 'utf-16le':\n	        return utf16leSlice(this, start, end)\n	\n	      default:\n	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n	        encoding = (encoding + '').toLowerCase()\n	        loweredCase = true\n	    }\n	  }\n	}\n	\n	Buffer.prototype.toString = function toString () {\n	  var length = this.length | 0\n	  if (length === 0) return ''\n	  if (arguments.length === 0) return utf8Slice(this, 0, length)\n	  return slowToString.apply(this, arguments)\n	}\n	\n	Buffer.prototype.equals = function equals (b) {\n	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n	  if (this === b) return true\n	  return Buffer.compare(this, b) === 0\n	}\n	\n	Buffer.prototype.inspect = function inspect () {\n	  var str = ''\n	  var max = exports.INSPECT_MAX_BYTES\n	  if (this.length > 0) {\n	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n	    if (this.length > max) str += ' ... '\n	  }\n	  return '<Buffer ' + str + '>'\n	}\n	\n	Buffer.prototype.compare = function compare (b) {\n	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n	  if (this === b) return 0\n	  return Buffer.compare(this, b)\n	}\n	\n	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {\n	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n	  byteOffset >>= 0\n	\n	  if (this.length === 0) return -1\n	  if (byteOffset >= this.length) return -1\n	\n	  // Negative offsets start from the end of the buffer\n	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n	\n	  if (typeof val === 'string') {\n	    if (val.length === 0) return -1 // special case: looking for empty string always fails\n	    return String.prototype.indexOf.call(this, val, byteOffset)\n	  }\n	  if (Buffer.isBuffer(val)) {\n	    return arrayIndexOf(this, val, byteOffset)\n	  }\n	  if (typeof val === 'number') {\n	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n	    }\n	    return arrayIndexOf(this, [ val ], byteOffset)\n	  }\n	\n	  function arrayIndexOf (arr, val, byteOffset) {\n	    var foundIndex = -1\n	    for (var i = 0; byteOffset + i < arr.length; i++) {\n	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n	        if (foundIndex === -1) foundIndex = i\n	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n	      } else {\n	        foundIndex = -1\n	      }\n	    }\n	    return -1\n	  }\n	\n	  throw new TypeError('val must be string, number or Buffer')\n	}\n	\n	// `get` is deprecated\n	Buffer.prototype.get = function get (offset) {\n	  console.log('.get() is deprecated. Access using array indexes instead.')\n	  return this.readUInt8(offset)\n	}\n	\n	// `set` is deprecated\n	Buffer.prototype.set = function set (v, offset) {\n	  console.log('.set() is deprecated. Access using array indexes instead.')\n	  return this.writeUInt8(v, offset)\n	}\n	\n	function hexWrite (buf, string, offset, length) {\n	  offset = Number(offset) || 0\n	  var remaining = buf.length - offset\n	  if (!length) {\n	    length = remaining\n	  } else {\n	    length = Number(length)\n	    if (length > remaining) {\n	      length = remaining\n	    }\n	  }\n	\n	  // must be an even number of digits\n	  var strLen = string.length\n	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n	\n	  if (length > strLen / 2) {\n	    length = strLen / 2\n	  }\n	  for (var i = 0; i < length; i++) {\n	    var parsed = parseInt(string.substr(i * 2, 2), 16)\n	    if (isNaN(parsed)) throw new Error('Invalid hex string')\n	    buf[offset + i] = parsed\n	  }\n	  return i\n	}\n	\n	function utf8Write (buf, string, offset, length) {\n	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n	}\n	\n	function asciiWrite (buf, string, offset, length) {\n	  return blitBuffer(asciiToBytes(string), buf, offset, length)\n	}\n	\n	function binaryWrite (buf, string, offset, length) {\n	  return asciiWrite(buf, string, offset, length)\n	}\n	\n	function base64Write (buf, string, offset, length) {\n	  return blitBuffer(base64ToBytes(string), buf, offset, length)\n	}\n	\n	function ucs2Write (buf, string, offset, length) {\n	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n	}\n	\n	Buffer.prototype.write = function write (string, offset, length, encoding) {\n	  // Buffer#write(string)\n	  if (offset === undefined) {\n	    encoding = 'utf8'\n	    length = this.length\n	    offset = 0\n	  // Buffer#write(string, encoding)\n	  } else if (length === undefined && typeof offset === 'string') {\n	    encoding = offset\n	    length = this.length\n	    offset = 0\n	  // Buffer#write(string, offset[, length][, encoding])\n	  } else if (isFinite(offset)) {\n	    offset = offset | 0\n	    if (isFinite(length)) {\n	      length = length | 0\n	      if (encoding === undefined) encoding = 'utf8'\n	    } else {\n	      encoding = length\n	      length = undefined\n	    }\n	  // legacy write(string, encoding, offset, length) - remove in v0.13\n	  } else {\n	    var swap = encoding\n	    encoding = offset\n	    offset = length | 0\n	    length = swap\n	  }\n	\n	  var remaining = this.length - offset\n	  if (length === undefined || length > remaining) length = remaining\n	\n	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n	    throw new RangeError('attempt to write outside buffer bounds')\n	  }\n	\n	  if (!encoding) encoding = 'utf8'\n	\n	  var loweredCase = false\n	  for (;;) {\n	    switch (encoding) {\n	      case 'hex':\n	        return hexWrite(this, string, offset, length)\n	\n	      case 'utf8':\n	      case 'utf-8':\n	        return utf8Write(this, string, offset, length)\n	\n	      case 'ascii':\n	        return asciiWrite(this, string, offset, length)\n	\n	      case 'binary':\n	        return binaryWrite(this, string, offset, length)\n	\n	      case 'base64':\n	        // Warning: maxLength not taken into account in base64Write\n	        return base64Write(this, string, offset, length)\n	\n	      case 'ucs2':\n	      case 'ucs-2':\n	      case 'utf16le':\n	      case 'utf-16le':\n	        return ucs2Write(this, string, offset, length)\n	\n	      default:\n	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n	        encoding = ('' + encoding).toLowerCase()\n	        loweredCase = true\n	    }\n	  }\n	}\n	\n	Buffer.prototype.toJSON = function toJSON () {\n	  return {\n	    type: 'Buffer',\n	    data: Array.prototype.slice.call(this._arr || this, 0)\n	  }\n	}\n	\n	function base64Slice (buf, start, end) {\n	  if (start === 0 && end === buf.length) {\n	    return base64.fromByteArray(buf)\n	  } else {\n	    return base64.fromByteArray(buf.slice(start, end))\n	  }\n	}\n	\n	function utf8Slice (buf, start, end) {\n	  end = Math.min(buf.length, end)\n	  var res = []\n	\n	  var i = start\n	  while (i < end) {\n	    var firstByte = buf[i]\n	    var codePoint = null\n	    var bytesPerSequence = (firstByte > 0xEF) ? 4\n	      : (firstByte > 0xDF) ? 3\n	      : (firstByte > 0xBF) ? 2\n	      : 1\n	\n	    if (i + bytesPerSequence <= end) {\n	      var secondByte, thirdByte, fourthByte, tempCodePoint\n	\n	      switch (bytesPerSequence) {\n	        case 1:\n	          if (firstByte < 0x80) {\n	            codePoint = firstByte\n	          }\n	          break\n	        case 2:\n	          secondByte = buf[i + 1]\n	          if ((secondByte & 0xC0) === 0x80) {\n	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n	            if (tempCodePoint > 0x7F) {\n	              codePoint = tempCodePoint\n	            }\n	          }\n	          break\n	        case 3:\n	          secondByte = buf[i + 1]\n	          thirdByte = buf[i + 2]\n	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n	              codePoint = tempCodePoint\n	            }\n	          }\n	          break\n	        case 4:\n	          secondByte = buf[i + 1]\n	          thirdByte = buf[i + 2]\n	          fourthByte = buf[i + 3]\n	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n	              codePoint = tempCodePoint\n	            }\n	          }\n	      }\n	    }\n	\n	    if (codePoint === null) {\n	      // we did not generate a valid codePoint so insert a\n	      // replacement char (U+FFFD) and advance only 1 byte\n	      codePoint = 0xFFFD\n	      bytesPerSequence = 1\n	    } else if (codePoint > 0xFFFF) {\n	      // encode to utf16 (surrogate pair dance)\n	      codePoint -= 0x10000\n	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n	      codePoint = 0xDC00 | codePoint & 0x3FF\n	    }\n	\n	    res.push(codePoint)\n	    i += bytesPerSequence\n	  }\n	\n	  return decodeCodePointsArray(res)\n	}\n	\n	// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n	// the lowest limit is Chrome, with 0x10000 args.\n	// We go 1 magnitude less, for safety\n	var MAX_ARGUMENTS_LENGTH = 0x1000\n	\n	function decodeCodePointsArray (codePoints) {\n	  var len = codePoints.length\n	  if (len <= MAX_ARGUMENTS_LENGTH) {\n	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n	  }\n	\n	  // Decode in chunks to avoid \"call stack size exceeded\".\n	  var res = ''\n	  var i = 0\n	  while (i < len) {\n	    res += String.fromCharCode.apply(\n	      String,\n	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n	    )\n	  }\n	  return res\n	}\n	\n	function asciiSlice (buf, start, end) {\n	  var ret = ''\n	  end = Math.min(buf.length, end)\n	\n	  for (var i = start; i < end; i++) {\n	    ret += String.fromCharCode(buf[i] & 0x7F)\n	  }\n	  return ret\n	}\n	\n	function binarySlice (buf, start, end) {\n	  var ret = ''\n	  end = Math.min(buf.length, end)\n	\n	  for (var i = start; i < end; i++) {\n	    ret += String.fromCharCode(buf[i])\n	  }\n	  return ret\n	}\n	\n	function hexSlice (buf, start, end) {\n	  var len = buf.length\n	\n	  if (!start || start < 0) start = 0\n	  if (!end || end < 0 || end > len) end = len\n	\n	  var out = ''\n	  for (var i = start; i < end; i++) {\n	    out += toHex(buf[i])\n	  }\n	  return out\n	}\n	\n	function utf16leSlice (buf, start, end) {\n	  var bytes = buf.slice(start, end)\n	  var res = ''\n	  for (var i = 0; i < bytes.length; i += 2) {\n	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n	  }\n	  return res\n	}\n	\n	Buffer.prototype.slice = function slice (start, end) {\n	  var len = this.length\n	  start = ~~start\n	  end = end === undefined ? len : ~~end\n	\n	  if (start < 0) {\n	    start += len\n	    if (start < 0) start = 0\n	  } else if (start > len) {\n	    start = len\n	  }\n	\n	  if (end < 0) {\n	    end += len\n	    if (end < 0) end = 0\n	  } else if (end > len) {\n	    end = len\n	  }\n	\n	  if (end < start) end = start\n	\n	  var newBuf\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    newBuf = Buffer._augment(this.subarray(start, end))\n	  } else {\n	    var sliceLen = end - start\n	    newBuf = new Buffer(sliceLen, undefined)\n	    for (var i = 0; i < sliceLen; i++) {\n	      newBuf[i] = this[i + start]\n	    }\n	  }\n	\n	  if (newBuf.length) newBuf.parent = this.parent || this\n	\n	  return newBuf\n	}\n	\n	/*\n	 * Need to make sure that buffer isn't trying to write out of bounds.\n	 */\n	function checkOffset (offset, ext, length) {\n	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n	}\n	\n	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkOffset(offset, byteLength, this.length)\n	\n	  var val = this[offset]\n	  var mul = 1\n	  var i = 0\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    val += this[offset + i] * mul\n	  }\n	\n	  return val\n	}\n	\n	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) {\n	    checkOffset(offset, byteLength, this.length)\n	  }\n	\n	  var val = this[offset + --byteLength]\n	  var mul = 1\n	  while (byteLength > 0 && (mul *= 0x100)) {\n	    val += this[offset + --byteLength] * mul\n	  }\n	\n	  return val\n	}\n	\n	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 1, this.length)\n	  return this[offset]\n	}\n	\n	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  return this[offset] | (this[offset + 1] << 8)\n	}\n	\n	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  return (this[offset] << 8) | this[offset + 1]\n	}\n	\n	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return ((this[offset]) |\n	      (this[offset + 1] << 8) |\n	      (this[offset + 2] << 16)) +\n	      (this[offset + 3] * 0x1000000)\n	}\n	\n	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return (this[offset] * 0x1000000) +\n	    ((this[offset + 1] << 16) |\n	    (this[offset + 2] << 8) |\n	    this[offset + 3])\n	}\n	\n	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkOffset(offset, byteLength, this.length)\n	\n	  var val = this[offset]\n	  var mul = 1\n	  var i = 0\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    val += this[offset + i] * mul\n	  }\n	  mul *= 0x80\n	\n	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n	\n	  return val\n	}\n	\n	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkOffset(offset, byteLength, this.length)\n	\n	  var i = byteLength\n	  var mul = 1\n	  var val = this[offset + --i]\n	  while (i > 0 && (mul *= 0x100)) {\n	    val += this[offset + --i] * mul\n	  }\n	  mul *= 0x80\n	\n	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n	\n	  return val\n	}\n	\n	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 1, this.length)\n	  if (!(this[offset] & 0x80)) return (this[offset])\n	  return ((0xff - this[offset] + 1) * -1)\n	}\n	\n	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  var val = this[offset] | (this[offset + 1] << 8)\n	  return (val & 0x8000) ? val | 0xFFFF0000 : val\n	}\n	\n	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 2, this.length)\n	  var val = this[offset + 1] | (this[offset] << 8)\n	  return (val & 0x8000) ? val | 0xFFFF0000 : val\n	}\n	\n	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return (this[offset]) |\n	    (this[offset + 1] << 8) |\n	    (this[offset + 2] << 16) |\n	    (this[offset + 3] << 24)\n	}\n	\n	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	\n	  return (this[offset] << 24) |\n	    (this[offset + 1] << 16) |\n	    (this[offset + 2] << 8) |\n	    (this[offset + 3])\n	}\n	\n	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	  return ieee754.read(this, offset, true, 23, 4)\n	}\n	\n	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 4, this.length)\n	  return ieee754.read(this, offset, false, 23, 4)\n	}\n	\n	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 8, this.length)\n	  return ieee754.read(this, offset, true, 52, 8)\n	}\n	\n	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n	  if (!noAssert) checkOffset(offset, 8, this.length)\n	  return ieee754.read(this, offset, false, 52, 8)\n	}\n	\n	function checkInt (buf, value, offset, ext, max, min) {\n	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n	  if (value > max || value < min) throw new RangeError('value is out of bounds')\n	  if (offset + ext > buf.length) throw new RangeError('index out of range')\n	}\n	\n	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n	\n	  var mul = 1\n	  var i = 0\n	  this[offset] = value & 0xFF\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    this[offset + i] = (value / mul) & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  byteLength = byteLength | 0\n	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n	\n	  var i = byteLength - 1\n	  var mul = 1\n	  this[offset + i] = value & 0xFF\n	  while (--i >= 0 && (mul *= 0x100)) {\n	    this[offset + i] = (value / mul) & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n	  this[offset] = (value & 0xff)\n	  return offset + 1\n	}\n	\n	function objectWriteUInt16 (buf, value, offset, littleEndian) {\n	  if (value < 0) value = 0xffff + value + 1\n	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n	      (littleEndian ? i : 1 - i) * 8\n	  }\n	}\n	\n	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value & 0xff)\n	    this[offset + 1] = (value >>> 8)\n	  } else {\n	    objectWriteUInt16(this, value, offset, true)\n	  }\n	  return offset + 2\n	}\n	\n	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 8)\n	    this[offset + 1] = (value & 0xff)\n	  } else {\n	    objectWriteUInt16(this, value, offset, false)\n	  }\n	  return offset + 2\n	}\n	\n	function objectWriteUInt32 (buf, value, offset, littleEndian) {\n	  if (value < 0) value = 0xffffffff + value + 1\n	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n	  }\n	}\n	\n	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset + 3] = (value >>> 24)\n	    this[offset + 2] = (value >>> 16)\n	    this[offset + 1] = (value >>> 8)\n	    this[offset] = (value & 0xff)\n	  } else {\n	    objectWriteUInt32(this, value, offset, true)\n	  }\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 24)\n	    this[offset + 1] = (value >>> 16)\n	    this[offset + 2] = (value >>> 8)\n	    this[offset + 3] = (value & 0xff)\n	  } else {\n	    objectWriteUInt32(this, value, offset, false)\n	  }\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) {\n	    var limit = Math.pow(2, 8 * byteLength - 1)\n	\n	    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n	  }\n	\n	  var i = 0\n	  var mul = 1\n	  var sub = value < 0 ? 1 : 0\n	  this[offset] = value & 0xFF\n	  while (++i < byteLength && (mul *= 0x100)) {\n	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) {\n	    var limit = Math.pow(2, 8 * byteLength - 1)\n	\n	    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n	  }\n	\n	  var i = byteLength - 1\n	  var mul = 1\n	  var sub = value < 0 ? 1 : 0\n	  this[offset + i] = value & 0xFF\n	  while (--i >= 0 && (mul *= 0x100)) {\n	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n	  }\n	\n	  return offset + byteLength\n	}\n	\n	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n	  if (value < 0) value = 0xff + value + 1\n	  this[offset] = (value & 0xff)\n	  return offset + 1\n	}\n	\n	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value & 0xff)\n	    this[offset + 1] = (value >>> 8)\n	  } else {\n	    objectWriteUInt16(this, value, offset, true)\n	  }\n	  return offset + 2\n	}\n	\n	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 8)\n	    this[offset + 1] = (value & 0xff)\n	  } else {\n	    objectWriteUInt16(this, value, offset, false)\n	  }\n	  return offset + 2\n	}\n	\n	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value & 0xff)\n	    this[offset + 1] = (value >>> 8)\n	    this[offset + 2] = (value >>> 16)\n	    this[offset + 3] = (value >>> 24)\n	  } else {\n	    objectWriteUInt32(this, value, offset, true)\n	  }\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n	  value = +value\n	  offset = offset | 0\n	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n	  if (value < 0) value = 0xffffffff + value + 1\n	  if (Buffer.TYPED_ARRAY_SUPPORT) {\n	    this[offset] = (value >>> 24)\n	    this[offset + 1] = (value >>> 16)\n	    this[offset + 2] = (value >>> 8)\n	    this[offset + 3] = (value & 0xff)\n	  } else {\n	    objectWriteUInt32(this, value, offset, false)\n	  }\n	  return offset + 4\n	}\n	\n	function checkIEEE754 (buf, value, offset, ext, max, min) {\n	  if (value > max || value < min) throw new RangeError('value is out of bounds')\n	  if (offset + ext > buf.length) throw new RangeError('index out of range')\n	  if (offset < 0) throw new RangeError('index out of range')\n	}\n	\n	function writeFloat (buf, value, offset, littleEndian, noAssert) {\n	  if (!noAssert) {\n	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n	  }\n	  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n	  return offset + 4\n	}\n	\n	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n	  return writeFloat(this, value, offset, true, noAssert)\n	}\n	\n	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n	  return writeFloat(this, value, offset, false, noAssert)\n	}\n	\n	function writeDouble (buf, value, offset, littleEndian, noAssert) {\n	  if (!noAssert) {\n	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n	  }\n	  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n	  return offset + 8\n	}\n	\n	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n	  return writeDouble(this, value, offset, true, noAssert)\n	}\n	\n	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n	  return writeDouble(this, value, offset, false, noAssert)\n	}\n	\n	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n	Buffer.prototype.copy = function copy (target, targetStart, start, end) {\n	  if (!start) start = 0\n	  if (!end && end !== 0) end = this.length\n	  if (targetStart >= target.length) targetStart = target.length\n	  if (!targetStart) targetStart = 0\n	  if (end > 0 && end < start) end = start\n	\n	  // Copy 0 bytes; we're done\n	  if (end === start) return 0\n	  if (target.length === 0 || this.length === 0) return 0\n	\n	  // Fatal error conditions\n	  if (targetStart < 0) {\n	    throw new RangeError('targetStart out of bounds')\n	  }\n	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n	  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n	\n	  // Are we oob?\n	  if (end > this.length) end = this.length\n	  if (target.length - targetStart < end - start) {\n	    end = target.length - targetStart + start\n	  }\n	\n	  var len = end - start\n	  var i\n	\n	  if (this === target && start < targetStart && targetStart < end) {\n	    // descending copy from end\n	    for (i = len - 1; i >= 0; i--) {\n	      target[i + targetStart] = this[i + start]\n	    }\n	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n	    // ascending copy from start\n	    for (i = 0; i < len; i++) {\n	      target[i + targetStart] = this[i + start]\n	    }\n	  } else {\n	    target._set(this.subarray(start, start + len), targetStart)\n	  }\n	\n	  return len\n	}\n	\n	// fill(value, start=0, end=buffer.length)\n	Buffer.prototype.fill = function fill (value, start, end) {\n	  if (!value) value = 0\n	  if (!start) start = 0\n	  if (!end) end = this.length\n	\n	  if (end < start) throw new RangeError('end < start')\n	\n	  // Fill 0 bytes; we're done\n	  if (end === start) return\n	  if (this.length === 0) return\n	\n	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n	\n	  var i\n	  if (typeof value === 'number') {\n	    for (i = start; i < end; i++) {\n	      this[i] = value\n	    }\n	  } else {\n	    var bytes = utf8ToBytes(value.toString())\n	    var len = bytes.length\n	    for (i = start; i < end; i++) {\n	      this[i] = bytes[i % len]\n	    }\n	  }\n	\n	  return this\n	}\n	\n	/**\n	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n	 */\n	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {\n	  if (typeof Uint8Array !== 'undefined') {\n	    if (Buffer.TYPED_ARRAY_SUPPORT) {\n	      return (new Buffer(this)).buffer\n	    } else {\n	      var buf = new Uint8Array(this.length)\n	      for (var i = 0, len = buf.length; i < len; i += 1) {\n	        buf[i] = this[i]\n	      }\n	      return buf.buffer\n	    }\n	  } else {\n	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n	  }\n	}\n	\n	// HELPER FUNCTIONS\n	// ================\n	\n	var BP = Buffer.prototype\n	\n	/**\n	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n	 */\n	Buffer._augment = function _augment (arr) {\n	  arr.constructor = Buffer\n	  arr._isBuffer = true\n	\n	  // save reference to original Uint8Array set method before overwriting\n	  arr._set = arr.set\n	\n	  // deprecated\n	  arr.get = BP.get\n	  arr.set = BP.set\n	\n	  arr.write = BP.write\n	  arr.toString = BP.toString\n	  arr.toLocaleString = BP.toString\n	  arr.toJSON = BP.toJSON\n	  arr.equals = BP.equals\n	  arr.compare = BP.compare\n	  arr.indexOf = BP.indexOf\n	  arr.copy = BP.copy\n	  arr.slice = BP.slice\n	  arr.readUIntLE = BP.readUIntLE\n	  arr.readUIntBE = BP.readUIntBE\n	  arr.readUInt8 = BP.readUInt8\n	  arr.readUInt16LE = BP.readUInt16LE\n	  arr.readUInt16BE = BP.readUInt16BE\n	  arr.readUInt32LE = BP.readUInt32LE\n	  arr.readUInt32BE = BP.readUInt32BE\n	  arr.readIntLE = BP.readIntLE\n	  arr.readIntBE = BP.readIntBE\n	  arr.readInt8 = BP.readInt8\n	  arr.readInt16LE = BP.readInt16LE\n	  arr.readInt16BE = BP.readInt16BE\n	  arr.readInt32LE = BP.readInt32LE\n	  arr.readInt32BE = BP.readInt32BE\n	  arr.readFloatLE = BP.readFloatLE\n	  arr.readFloatBE = BP.readFloatBE\n	  arr.readDoubleLE = BP.readDoubleLE\n	  arr.readDoubleBE = BP.readDoubleBE\n	  arr.writeUInt8 = BP.writeUInt8\n	  arr.writeUIntLE = BP.writeUIntLE\n	  arr.writeUIntBE = BP.writeUIntBE\n	  arr.writeUInt16LE = BP.writeUInt16LE\n	  arr.writeUInt16BE = BP.writeUInt16BE\n	  arr.writeUInt32LE = BP.writeUInt32LE\n	  arr.writeUInt32BE = BP.writeUInt32BE\n	  arr.writeIntLE = BP.writeIntLE\n	  arr.writeIntBE = BP.writeIntBE\n	  arr.writeInt8 = BP.writeInt8\n	  arr.writeInt16LE = BP.writeInt16LE\n	  arr.writeInt16BE = BP.writeInt16BE\n	  arr.writeInt32LE = BP.writeInt32LE\n	  arr.writeInt32BE = BP.writeInt32BE\n	  arr.writeFloatLE = BP.writeFloatLE\n	  arr.writeFloatBE = BP.writeFloatBE\n	  arr.writeDoubleLE = BP.writeDoubleLE\n	  arr.writeDoubleBE = BP.writeDoubleBE\n	  arr.fill = BP.fill\n	  arr.inspect = BP.inspect\n	  arr.toArrayBuffer = BP.toArrayBuffer\n	\n	  return arr\n	}\n	\n	var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n	\n	function base64clean (str) {\n	  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n	  // Node converts strings with length < 2 to ''\n	  if (str.length < 2) return ''\n	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n	  while (str.length % 4 !== 0) {\n	    str = str + '='\n	  }\n	  return str\n	}\n	\n	function stringtrim (str) {\n	  if (str.trim) return str.trim()\n	  return str.replace(/^\\s+|\\s+$/g, '')\n	}\n	\n	function toHex (n) {\n	  if (n < 16) return '0' + n.toString(16)\n	  return n.toString(16)\n	}\n	\n	function utf8ToBytes (string, units) {\n	  units = units || Infinity\n	  var codePoint\n	  var length = string.length\n	  var leadSurrogate = null\n	  var bytes = []\n	\n	  for (var i = 0; i < length; i++) {\n	    codePoint = string.charCodeAt(i)\n	\n	    // is surrogate component\n	    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n	      // last char was a lead\n	      if (!leadSurrogate) {\n	        // no lead yet\n	        if (codePoint > 0xDBFF) {\n	          // unexpected trail\n	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	          continue\n	        } else if (i + 1 === length) {\n	          // unpaired lead\n	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	          continue\n	        }\n	\n	        // valid lead\n	        leadSurrogate = codePoint\n	\n	        continue\n	      }\n	\n	      // 2 leads in a row\n	      if (codePoint < 0xDC00) {\n	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	        leadSurrogate = codePoint\n	        continue\n	      }\n	\n	      // valid surrogate pair\n	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n	    } else if (leadSurrogate) {\n	      // valid bmp char, but last char was a lead\n	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n	    }\n	\n	    leadSurrogate = null\n	\n	    // encode utf8\n	    if (codePoint < 0x80) {\n	      if ((units -= 1) < 0) break\n	      bytes.push(codePoint)\n	    } else if (codePoint < 0x800) {\n	      if ((units -= 2) < 0) break\n	      bytes.push(\n	        codePoint >> 0x6 | 0xC0,\n	        codePoint & 0x3F | 0x80\n	      )\n	    } else if (codePoint < 0x10000) {\n	      if ((units -= 3) < 0) break\n	      bytes.push(\n	        codePoint >> 0xC | 0xE0,\n	        codePoint >> 0x6 & 0x3F | 0x80,\n	        codePoint & 0x3F | 0x80\n	      )\n	    } else if (codePoint < 0x110000) {\n	      if ((units -= 4) < 0) break\n	      bytes.push(\n	        codePoint >> 0x12 | 0xF0,\n	        codePoint >> 0xC & 0x3F | 0x80,\n	        codePoint >> 0x6 & 0x3F | 0x80,\n	        codePoint & 0x3F | 0x80\n	      )\n	    } else {\n	      throw new Error('Invalid code point')\n	    }\n	  }\n	\n	  return bytes\n	}\n	\n	function asciiToBytes (str) {\n	  var byteArray = []\n	  for (var i = 0; i < str.length; i++) {\n	    // Node's code seems to be doing this and not & 0x7F..\n	    byteArray.push(str.charCodeAt(i) & 0xFF)\n	  }\n	  return byteArray\n	}\n	\n	function utf16leToBytes (str, units) {\n	  var c, hi, lo\n	  var byteArray = []\n	  for (var i = 0; i < str.length; i++) {\n	    if ((units -= 2) < 0) break\n	\n	    c = str.charCodeAt(i)\n	    hi = c >> 8\n	    lo = c % 256\n	    byteArray.push(lo)\n	    byteArray.push(hi)\n	  }\n	\n	  return byteArray\n	}\n	\n	function base64ToBytes (str) {\n	  return base64.toByteArray(base64clean(str))\n	}\n	\n	function blitBuffer (src, dst, offset, length) {\n	  for (var i = 0; i < length; i++) {\n	    if ((i + offset >= dst.length) || (i >= src.length)) break\n	    dst[i + offset] = src[i]\n	  }\n	  return i\n	}\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n	\n	;(function (exports) {\n		'use strict';\n	\n	  var Arr = (typeof Uint8Array !== 'undefined')\n	    ? Uint8Array\n	    : Array\n	\n		var PLUS   = '+'.charCodeAt(0)\n		var SLASH  = '/'.charCodeAt(0)\n		var NUMBER = '0'.charCodeAt(0)\n		var LOWER  = 'a'.charCodeAt(0)\n		var UPPER  = 'A'.charCodeAt(0)\n		var PLUS_URL_SAFE = '-'.charCodeAt(0)\n		var SLASH_URL_SAFE = '_'.charCodeAt(0)\n	\n		function decode (elt) {\n			var code = elt.charCodeAt(0)\n			if (code === PLUS ||\n			    code === PLUS_URL_SAFE)\n				return 62 // '+'\n			if (code === SLASH ||\n			    code === SLASH_URL_SAFE)\n				return 63 // '/'\n			if (code < NUMBER)\n				return -1 //no match\n			if (code < NUMBER + 10)\n				return code - NUMBER + 26 + 26\n			if (code < UPPER + 26)\n				return code - UPPER\n			if (code < LOWER + 26)\n				return code - LOWER + 26\n		}\n	\n		function b64ToByteArray (b64) {\n			var i, j, l, tmp, placeHolders, arr\n	\n			if (b64.length % 4 > 0) {\n				throw new Error('Invalid string. Length must be a multiple of 4')\n			}\n	\n			// the number of equal signs (place holders)\n			// if there are two placeholders, than the two characters before it\n			// represent one byte\n			// if there is only one, then the three characters before it represent 2 bytes\n			// this is just a cheap hack to not do indexOf twice\n			var len = b64.length\n			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n	\n			// base64 is 4/3 + up to two characters of the original data\n			arr = new Arr(b64.length * 3 / 4 - placeHolders)\n	\n			// if there are placeholders, only get up to the last complete 4 chars\n			l = placeHolders > 0 ? b64.length - 4 : b64.length\n	\n			var L = 0\n	\n			function push (v) {\n				arr[L++] = v\n			}\n	\n			for (i = 0, j = 0; i < l; i += 4, j += 3) {\n				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n				push((tmp & 0xFF0000) >> 16)\n				push((tmp & 0xFF00) >> 8)\n				push(tmp & 0xFF)\n			}\n	\n			if (placeHolders === 2) {\n				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n				push(tmp & 0xFF)\n			} else if (placeHolders === 1) {\n				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n				push((tmp >> 8) & 0xFF)\n				push(tmp & 0xFF)\n			}\n	\n			return arr\n		}\n	\n		function uint8ToBase64 (uint8) {\n			var i,\n				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n				output = \"\",\n				temp, length\n	\n			function encode (num) {\n				return lookup.charAt(num)\n			}\n	\n			function tripletToBase64 (num) {\n				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n			}\n	\n			// go through the array every three bytes, we'll deal with trailing stuff later\n			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n				output += tripletToBase64(temp)\n			}\n	\n			// pad the end with zeros, but make sure to not forget the extra bytes\n			switch (extraBytes) {\n				case 1:\n					temp = uint8[uint8.length - 1]\n					output += encode(temp >> 2)\n					output += encode((temp << 4) & 0x3F)\n					output += '=='\n					break\n				case 2:\n					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n					output += encode(temp >> 10)\n					output += encode((temp >> 4) & 0x3F)\n					output += encode((temp << 2) & 0x3F)\n					output += '='\n					break\n			}\n	\n			return output\n		}\n	\n		exports.toByteArray = b64ToByteArray\n		exports.fromByteArray = uint8ToBase64\n	}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n	exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n	  var e, m\n	  var eLen = nBytes * 8 - mLen - 1\n	  var eMax = (1 << eLen) - 1\n	  var eBias = eMax >> 1\n	  var nBits = -7\n	  var i = isLE ? (nBytes - 1) : 0\n	  var d = isLE ? -1 : 1\n	  var s = buffer[offset + i]\n	\n	  i += d\n	\n	  e = s & ((1 << (-nBits)) - 1)\n	  s >>= (-nBits)\n	  nBits += eLen\n	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n	\n	  m = e & ((1 << (-nBits)) - 1)\n	  e >>= (-nBits)\n	  nBits += mLen\n	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n	\n	  if (e === 0) {\n	    e = 1 - eBias\n	  } else if (e === eMax) {\n	    return m ? NaN : ((s ? -1 : 1) * Infinity)\n	  } else {\n	    m = m + Math.pow(2, mLen)\n	    e = e - eBias\n	  }\n	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n	}\n	\n	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n	  var e, m, c\n	  var eLen = nBytes * 8 - mLen - 1\n	  var eMax = (1 << eLen) - 1\n	  var eBias = eMax >> 1\n	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n	  var i = isLE ? 0 : (nBytes - 1)\n	  var d = isLE ? 1 : -1\n	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n	\n	  value = Math.abs(value)\n	\n	  if (isNaN(value) || value === Infinity) {\n	    m = isNaN(value) ? 1 : 0\n	    e = eMax\n	  } else {\n	    e = Math.floor(Math.log(value) / Math.LN2)\n	    if (value * (c = Math.pow(2, -e)) < 1) {\n	      e--\n	      c *= 2\n	    }\n	    if (e + eBias >= 1) {\n	      value += rt / c\n	    } else {\n	      value += rt * Math.pow(2, 1 - eBias)\n	    }\n	    if (value * c >= 2) {\n	      e++\n	      c /= 2\n	    }\n	\n	    if (e + eBias >= eMax) {\n	      m = 0\n	      e = eMax\n	    } else if (e + eBias >= 1) {\n	      m = (value * c - 1) * Math.pow(2, mLen)\n	      e = e + eBias\n	    } else {\n	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n	      e = 0\n	    }\n	  }\n	\n	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n	\n	  e = (e << mLen) | m\n	  eLen += mLen\n	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n	\n	  buffer[offset + i - d] |= s * 128\n	}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n	var toString = {}.toString;\n	\n	module.exports = Array.isArray || function (arr) {\n	  return toString.call(arr) == '[object Array]';\n	};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	var config = {\n	    key: '8mOtYiilT5OUPwwdeGgvpw',\n	    secret: 'cqNn89RmR2SR76Kpp8xJaAdNzNOqR8Qfmjb0B-gDOHTw',\n	\n	    incomingAudio: '../src/assets/audio/incoming.ogg',\n	    outgoingAudio: '../src/assets/audio/outgoing.ogg'\n	};\n	exports.default = config;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _rcWebphone = __webpack_require__(13);\n	\n	var _rcWebphone2 = _interopRequireDefault(_rcWebphone);\n	\n	var _rcConfig = __webpack_require__(11);\n	\n	var _rcConfig2 = _interopRequireDefault(_rcConfig);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var PhoneService = function () {\n	    var webPhone;\n	    var session;\n	    var handlers = {\n	        invite: [],\n	        accepted: [],\n	        progress: [],\n	        rejected: [],\n	        terminated: [],\n	        failed: [],\n	        bye: [],\n	        refer: []\n	    };\n	    function listen(session) {\n	        session.on('accepted', function () {\n	            handlers['accepted'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('progress', function () {\n	            handlers['progress'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('rejected', function () {\n	            handlers['rejected'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('terminated', function () {\n	            handlers['terminated'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('failed', function () {\n	            handlers['failed'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('bye', function () {\n	            handlers['bye'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	        session.on('refer', function () {\n	            handlers['refer'].forEach(function (handler) {\n	                return handler(session);\n	            });\n	        });\n	    }\n	    return {\n	        init: function init(options) {\n	            return _rcSdk.RC.sdk.platform().post('/client-info/sip-provision', {\n	                sipInfo: [{\n	                    transport: 'WSS'\n	                }]\n	            }).then(function (res) {\n	                return new _rcWebphone2.default(res.json(), { // optional\n	                    appKey: _rcConfig2.default.key,\n	                    logLevel: 1,\n	                    audioHelper: {\n	                        enabled: true, // enables audio feedback when web phone is ringing or making a call\n	                        incoming: options.incomingAudio, // path to audio file for incoming call\n	                        outgoing: options.outgoingAudio // path to aduotfile for outgoing call\n	                    }\n	                });\n	            }).then(function (p) {\n	                webPhone = p;\n	                webPhone.userAgent.on('invite', function (s) {\n	                    session = s;\n	                    handlers['invite'].forEach(function (handler) {\n	                        return handler(session);\n	                    });\n	                    listen(session);\n	                });\n	            }).catch(function (e) {\n	                return console.error(e);\n	            });\n	        },\n	        on: function on(name, callback) {\n	            handlers[name].push(callback);\n	        },\n	        call: function call(fromNumber, toNumber, options) {\n	            console.log(webPhone);\n	            session = webPhone.userAgent.invite(toNumber, {\n	                media: {\n	                    render: {\n	                        remote: options.remoteVideo,\n	                        local: options.localVideo\n	                    }\n	                },\n	                fromNumber: fromNumber\n	            });\n	            listen(session);\n	        },\n	        accept: function accept(options) {\n	            console.log(session);\n	            if (session.accept && !session.startTime) return session.accept({\n	                media: {\n	                    render: {\n	                        remote: options.remoteVideo,\n	                        local: options.localVideo\n	                    }\n	                }\n	            });\n	            return null;\n	        },\n	        reject: function reject() {\n	            return session.reject();\n	        },\n	        hangup: function hangup() {\n	            return session.bye();\n	        },\n	        hold: function hold(flag) {\n	            if (flag) {\n	                return session.hold().then(function () {\n	                    return session;\n	                });\n	            }\n	            return session.unhold().then(function () {\n	                return session;\n	            });\n	        },\n	        mute: function mute(flag) {\n	            if (flag) session.mute();else session.unmute();\n	            return session;\n	        },\n	        flip: function flip(number) {\n	            return session.flip(number).then(function () {\n	                return session;\n	            });\n	        },\n	        forward: function forward(number) {\n	            return session.forward(number).then(function () {\n	                return session;\n	            });\n	        },\n	        transfer: function transfer(number) {\n	            return session.transfer(number).then(function () {\n	                return session;\n	            });\n	        },\n	        park: function park() {\n	            return session.park().then(function () {\n	                return session;\n	            });\n	        },\n	        dtmf: function dtmf(number) {\n	            return session.dtmf(number);\n	        },\n	        record: function record(flag) {\n	            if (flag) {\n	                return session.startRecord().then(function () {\n	                    return session;\n	                });\n	            } else {\n	                return session.stopRecord().then(function () {\n	                    return session;\n	                });\n	            }\n	        }\n	    };\n	}();\n	exports.default = PhoneService;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	  value: true\n	});\n	\n	var _ringcentralWebPhone = __webpack_require__(14);\n	\n	var _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);\n\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n	exports.default = _ringcentralWebPhone2.default;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n	    if (true) {\n	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {\n	            return factory(SIP);\n	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	    } else if (typeof module === 'object') {\n	        module.exports = factory(require('sip.js'));\n	        module.exports.default = module.exports; //ES6\n	    } else {\n	        root.RingCentral = root.RingCentral || {};\n	        root.RingCentral.WebPhone = factory(root.SIP);\n	    }\n	}(this, function(SIP) {\n	\n	    var messages = {\n	        park: {reqid: 1, command: 'callpark'},\n	        startRecord: {reqid: 2, command: 'startcallrecord'},\n	        stopRecord: {reqid: 3, command: 'stopcallrecord'},\n	        flip: {reqid: 3, command: 'callflip', target: ''},\n	        monitor: {reqid: 4, command: 'monitor'},\n	        barge: {reqid: 5, command: 'barge'},\n	        whisper: {reqid: 6, command: 'whisper'},\n	        takeover: {reqid: 7, command: 'takeover'}\n	    };\n	\n	    var responseTimeout = 10000;\n	\n	    function uuid() {\n	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n	            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n	            return v.toString(16);\n	        });\n	    }\n	\n	    function delay(ms) {\n	        return new Promise(function(resolve, reject) {\n	            setTimeout(resolve, ms);\n	        });\n	    }\n	\n	    function extend(dst, src) {\n	        src = src || {};\n	        dst = dst || {};\n	        Object.keys(src).forEach(function(k) {\n	            dst[k] = src[k];\n	        });\n	        return dst;\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @param options\n	     * @constructor\n	     */\n	    function AudioHelper(options) {\n	\n	        options = options || {};\n	\n	        this._enabled = !!options.enabled;\n	        this._incoming = options.incoming || '../audio/incoming.ogg';\n	        this._outgoing = options.outgoing || '../audio/outgoing.ogg';\n	        this._audio = {};\n	\n	    }\n	\n	    AudioHelper.prototype._playSound = function(url, val, volume) {\n	\n	        if (!this._enabled) return this;\n	\n	        if (!this._audio[url]) {\n	            if (val) {\n	                this._audio[url] = new Audio();\n	                this._audio[url].src = url;\n	                this._audio[url].loop = true;\n	                this._audio[url].volume = volume;\n	                this._audio[url].play();\n	            }\n	        } else {\n	            if (val) {\n	                this._audio[url].currentTime = 0;\n	                this._audio[url].play();\n	            } else {\n	                this._audio[url].pause();\n	            }\n	        }\n	\n	        return this;\n	\n	    };\n	\n	    AudioHelper.prototype.playIncoming = function(val) {\n	        return this._playSound(this._incoming, val, 0.5);\n	    };\n	\n	    AudioHelper.prototype.playOutgoing = function(val) {\n	        return this._playSound(this._outgoing, val, 1);\n	    };\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @param {object} regData\n	     * @param {object} [options]\n	     * @param {string} [options.uuid]\n	     * @param {string} [options.appKey]\n	     * @param {string} [options.appName]\n	     * @param {string} [options.appVersion]\n	     * @param {string} [options.audioHelper]\n	     * @param {string} [options.onSession] fired each time UserAgent starts working with session\n	     * @constructor\n	     */\n	    function WebPhone(regData, options) {\n	\n	        regData = regData || {};\n	        options = options || {};\n	\n	        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;\n	        this.sipFlags = regData.sipFlags;\n	\n	        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable\n	        localStorage.setItem('rc-webPhone-uuid', id);\n	\n	        this.endpointHeader = 'P-rc-endpoint-id: ' + id;\n	\n	        var configuration = {\n	            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,\n	            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport\n	                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy\n	                : this.sipInfo.wsServers,\n	            authorizationUser: this.sipInfo.authorizationId,\n	            password: this.sipInfo.password,\n	            traceSip: true,\n	            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?\n	            turnServers: [],\n	            log: {\n	                level: options.logLevel || 1 //FIXME LOG LEVEL 3\n	            },\n	            domain: this.sipInfo.domain,\n	            autostart: true,\n	            register: true,\n	            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000\n	        };\n	\n	        this.appKey = options.appKey;\n	        this.appName = options.appName;\n	        this.appVersion = options.appVersion;\n	        this.userAgentHeader = 'RC-User-Agent: ' +\n	                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +\n	                               'RCWEBPHONE/' + WebPhone.version;\n	\n	        this.clientIdHeader = 'Client-id:' + options.appKey;\n	\n	        this.userAgent = new SIP.UA(configuration).register({\n	            extraHeaders: [\n	                this.endpointHeader,\n	                this.userAgentHeader,\n	                this.clientIdHeader\n	            ]\n	        });\n	\n	        this.userAgent.endpointHeader = this.endpointHeader;\n	        this.userAgent.userAgentHeader = this.userAgentHeader;\n	        this.userAgent.clientIdHeader = this.clientIdHeader;\n	        this.userAgent.sipInfo = this.sipInfo;\n	\n	        this.userAgent.__invite = this.userAgent.invite;\n	        this.userAgent.invite = invite;\n	\n	        this.userAgent.on('invite', function(session) {\n	            this.userAgent.audioHelper.playIncoming(true);\n	            patchSession(session);\n	        }.bind(this));\n	\n	        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);\n	\n	        this.userAgent.onSession = options.onSession || null;\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    WebPhone.version = '0.3.1';\n	    WebPhone.uuid = uuid;\n	    WebPhone.delay = delay;\n	    WebPhone.extend = extend;\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    function patchSession(session) {\n	\n	        if (session.__patched) return session;\n	\n	        session.__patched = true;\n	\n	        session.__sendRequest = session.sendRequest;\n	        session.__receiveRequest = session.receiveRequest;\n	        session.__receiveInviteResponse = session.receiveInviteResponse;\n	        session.__receiveResponse = session.receiveResponse;\n	        session.__sendReinvite = session.sendReinvite;\n	        session.__accept = session.accept;\n	        session.__hold = session.hold;\n	        session.__unhold = session.unhold;\n	        session.__dtmf = session.dtmf;\n	\n	        session.sendRequest = sendRequest;\n	        session.receiveRequest = receiveRequest;\n	        session.receiveInviteResponse = receiveInviteResponse;\n	        session.receiveResponse = receiveResponse;\n	        session.sendReinvite = sendReinvite;\n	        session.accept = accept;\n	        session.hold = hold;\n	        session.unhold = unhold;\n	        session.dtmf = dtmf;\n	\n	        session.blindTransfer = blindTransfer;\n	        session.transfer = transfer;\n	        session.park = park;\n	        session.forward = forward;\n	        session.startRecord = startRecord;\n	        session.stopRecord = stopRecord;\n	        session.flip = flip;\n	\n	        session.on('replaced', patchSession);\n	        // session.on('connecting', onConnecting);\n	\n	        // Audio\n	        session.on('accepted', stopPlaying);\n	        session.on('rejected', stopPlaying);\n	        session.on('bye', stopPlaying);\n	        session.on('terminated', stopPlaying);\n	        session.on('cancel', stopPlaying);\n	        session.on('failed', stopPlaying);\n	        session.on('replaced', stopPlaying);\n	        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);\n	        session.mediaHandler.on('iceConnectionFailed', stopPlaying);\n	\n	        function stopPlaying() {\n	            session.ua.audioHelper.playOutgoing(false);\n	            session.ua.audioHelper.playIncoming(false);\n	            session.removeListener('accepted', stopPlaying);\n	            session.removeListener('rejected', stopPlaying);\n	            session.removeListener('bye', stopPlaying);\n	            session.removeListener('terminated', stopPlaying);\n	            session.removeListener('cancel', stopPlaying);\n	            session.removeListener('failed', stopPlaying);\n	            session.removeListener('replaced', stopPlaying);\n	            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);\n	            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);\n	        }\n	\n	        if (session.ua.onSession) session.ua.onSession(session);\n	\n	        return session;\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @private\n	     * @param {SIP.Session} session\n	     * @param {object} command\n	     * @param {object} [options]\n	     * @return {Promise}\n	     */\n	    function sendReceive(session, command, options) {\n	\n	        options = options || {};\n	\n	        extend(command, options);\n	\n	        var cseq = null;\n	\n	        return new Promise(function(resolve, reject) {\n	\n	            session.sendRequest(SIP.C.INFO, {\n	                body: JSON.stringify({\n	                    request: command\n	                }),\n	                extraHeaders: [\n	                    \"Content-Type: application/json;charset=utf-8\",\n	                    session.ua.userAgentHeader,\n	                    session.ua.endpointHeader,\n	                    session.ua.clientIdHeader\n	                ],\n	                receiveResponse: function(response) {\n	                    var timeout = null;\n	                    if (response.status_code === 200) {\n	                        cseq = response.cseq;\n	                        var onInfo = function(request) {\n	                            if (response.cseq === cseq) {\n	\n	                                var body = request && request.body || '{}';\n	                                var obj;\n	\n	                                try {\n	                                    obj = JSON.parse(body);\n	                                } catch (e) {\n	                                    obj = {};\n	                                }\n	\n	                                if (obj.response && obj.response.command === command.command) {\n	                                    if (obj.response.result) {\n	                                        if (obj.response.result.code == 0) {\n	                                            return resolve(obj.response.result);\n	                                        } else {\n	                                            return reject(obj.response.result);\n	                                        }\n	                                    }\n	                                }\n	                                timeout && clearTimeout(timeout);\n	                                session.removeListener('RC_SIP_INFO', onInfo);\n	                                resolve(null); //FIXME What to resolve\n	                            }\n	                        };\n	\n	                        timeout = setTimeout(function() {\n	                            reject(new Error('Timeout: no reply'));\n	                            session.removeListener('RC_SIP_INFO', onInfo);\n	                        }, responseTimeout);\n	                        session.on('RC_SIP_INFO', onInfo);\n	                    }\n	                    else {\n	                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));\n	                    }\n	                }\n	            });\n	\n	        });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    function sendRequest(type, config) {\n	        if (type == SIP.C.PRACK) {\n	            type = SIP.C.ACK;\n	        }\n	        return this.__sendRequest(type, config);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * Fired each time a provisional (100-199) response is received.\n	     * Early media is supported by SIP.js library\n	     * But in case it is sent without 100rel support we play it manually\n	     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n	     *\n	     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n	     * @param {SIP.Session} session\n	     * @param response\n	     * @param {funciton} cb\n	     */\n	    function patch100rel(session, response, cb) {\n	\n	        //Early media is supported by SIP.js library\n	        //But in case it is sent without 100rel support we play it manually\n	        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n	        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\\n') !== -1) {\n	            if (!response.hasHeader('require')) response.setHeader('require', '100rel');\n	        }\n	\n	        return cb.call(session, response);\n	\n	    }\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param response\n	     * @return {*}\n	     */\n	    function receiveInviteResponse(response) {\n	        return patch100rel(this, response, this.__receiveInviteResponse);\n	    }\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param response\n	     * @return {*}\n	     */\n	    function receiveResponse(response) {\n	        return patch100rel(this, response, this.__receiveResponse);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @private\n	     * @param {SIP.Session} session\n	     * @param {boolean} flag\n	     * @return {Promise}\n	     */\n	    function setRecord(session, flag) {\n	\n	        var message = !!flag\n	            ? messages.startRecord\n	            : messages.stopRecord;\n	\n	        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {\n	            return sendReceive(session, message)\n	                .then(function(data) {\n	                    session.__onRecord = !!flag;\n	                    return data;\n	                });\n	        }\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @private\n	     * @param {SIP.Session} session\n	     * @param {boolean} flag\n	     * @return {Promise}\n	     */\n	    function setHold(session, flag) {\n	        return new Promise(function(resolve, reject) {\n	\n	            function onSucceeded() {\n	                resolve();\n	                session.removeListener('RC_CALL_REINVITE_FAILED', onFailed);\n	            }\n	\n	            function onFailed(e) {\n	                reject(e);\n	                session.removeListener('RC_CALL_REINVITE_SUCCEEDED', onSucceeded);\n	            }\n	\n	            session.once('RC_CALL_REINVITE_SUCCEEDED', onSucceeded);\n	            session.once('RC_CALL_REINVITE_FAILED', onFailed);\n	\n	            if (flag) {\n	                session.__hold();\n	            } else {\n	                session.__unhold();\n	            }\n	\n	        });\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.UA}\n	     * @param number\n	     * @param options\n	     * @return {SIP.Session}\n	     */\n	    function invite(number, options) {\n	\n	        var ua = this;\n	\n	        options = options || {};\n	        options.extraHeaders = options.extraHeaders || [];\n	\n	        options.extraHeaders.push(ua.userAgentHeader);\n	        options.extraHeaders.push(ua.endpointHeader);\n	        options.extraHeaders.push(ua.clientIdHeader);\n	\n	        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number\n	\n	        //FIXME Backend should know it already\n	        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }\n	\n	        options.media = options.media || {};\n	        options.media.constraints = options.media.constraints || {audio: true, video: false};\n	\n	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n	\n	        ua.audioHelper.playOutgoing(true);\n	\n	        return patchSession(ua.__invite(number, options));\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * Monkey patching sendReinvite for better Hold handling\n	     * @this {SIP.Session}\n	     * @return {*}\n	     */\n	    function sendReinvite() {\n	        var session = this;\n	        var res = session.__sendReinvite.apply(session, arguments);\n	        var __reinviteSucceeded = session.reinviteSucceeded,\n	            __reinviteFailed = session.reinviteFailed;\n	        session.reinviteSucceeded = function() {\n	            session.emit('RC_CALL_REINVITE_SUCCEEDED', session);\n	            return __reinviteSucceeded.apply(session, arguments);\n	        };\n	        session.reinviteFailed = function() {\n	            session.emit('RC_CALL_REINVITE_FAILED', session);\n	            return __reinviteFailed.apply(session, arguments);\n	        };\n	        return res;\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param request\n	     * @return {*}\n	     */\n	    function receiveRequest(request) {\n	        var session = this;\n	        switch (request.method) {\n	            case SIP.C.INFO:\n	                session.emit('RC_SIP_INFO', request);\n	                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case\n	                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n	                    var contentType = request.getHeader('content-type');\n	                    if (contentType.match(/^application\\/json/i)) {\n	                        request.reply(200);\n	                        return session;\n	                    }\n	                }\n	                break;\n	            //Refresh invite should not be rejected with 488\n	            case SIP.C.INVITE:\n	                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {\n	                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {\n	                        //TODO: check that SDP did not change\n	                        session.logger.log('re-INVITE received');\n	                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;\n	                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {\n	                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;\n	                            session.setInvite2xxTimer(request, localSDP);\n	                            session.setACKTimer();\n	                        });\n	                        return session;\n	                    }\n	                    //else will be rejected with 488 by SIP.js\n	                }\n	                break;\n	            //We need to analize NOTIFY messages sometimes, so we fire an event\n	            case SIP.C.NOTIFY:\n	                session.emit('RC_SIP_NOTIFY', request);\n	                break;\n	        }\n	        return session.__receiveRequest.apply(session, arguments);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param {object} options\n	     * @return {Promise}\n	     */\n	    function accept(options) {\n	\n	        var session = this;\n	\n	        options = options || {};\n	        options.extraHeaders = options.extraHeaders || [];\n	\n	        options.extraHeaders.push(session.ua.userAgentHeader);\n	        options.extraHeaders.push(session.ua.endpointHeader);\n	        options.extraHeaders.push(session.ua.clientIdHeader);\n	\n	        options.media = options.media || {};\n	        options.media.constraints = options.media.constraints || {audio: true, video: false};\n	\n	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};\n	\n	        return new Promise(function(resolve, reject) {\n	\n	            function onAnswered() {\n	                resolve(session);\n	                session.removeListener('failed', onFail);\n	            }\n	\n	            function onFail(e) {\n	                reject(e);\n	                session.removeListener('accepted', onAnswered);\n	            }\n	\n	            //TODO More events?\n	            session.once('accepted', onAnswered);\n	            session.once('failed', onFail);\n	\n	            session.__accept(options);\n	\n	        });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @param {string} dtmf\n	     * @param {number} duration\n	     * @return {Promise}\n	     */\n	    function dtmf(dtmf, duration) {\n	        var session = this;\n	        duration = parseInt(duration) || 1000;\n	        var peer = session.mediaHandler.peerConnection;\n	        var stream = session.getLocalStreams()[0];\n	        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);\n	        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {\n	            return dtmfSender.insertDTMF(dtmf, duration);\n	        }\n	        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\\'t insert DTMF' : 'Unknown')));\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @return {Promise}\n	     */\n	    function hold() {\n	        return setHold(this, true);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @return {Promise}\n	     */\n	    function unhold() {\n	        return setHold(this, false);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session} session\n	     * @param {string} target\n	     * @param {object} options\n	     * @return {Promise}\n	     */\n	    function blindTransfer(target, options) {\n	\n	        options = options || {};\n	\n	        var session = this;\n	        var extraHeaders = options.extraHeaders || [];\n	        var originalTarget = target;\n	\n	        return new Promise(function(resolve, reject) {\n	            //Blind Transfer is taken from SIP.js source\n	\n	            // Check Session Status\n	            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {\n	                throw new SIP.Exceptions.InvalidStateError(session.status);\n	            }\n	\n	            // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n	            // so try to make one ahead of time\n	            try {\n	                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n	            } catch (e) {\n	                session.logger.debug(\".refer() cannot parse Refer_To from\", target);\n	                session.logger.debug(\"...falling through to normalizeTarget()\");\n	            }\n	\n	            // Check target validity\n	            target = session.ua.normalizeTarget(target);\n	            if (!target) {\n	                throw new TypeError('Invalid target: ' + originalTarget);\n	            }\n	\n	            extraHeaders.push('Contact: ' + session.contact);\n	            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n	            extraHeaders.push('Refer-To: ' + target);\n	            extraHeaders.push(session.ua.userAgentHeader);\n	            extraHeaders.push(session.ua.endpointHeader);\n	            extraHeaders.push(session.ua.clientIdHeader);\n	\n	            // Send the request\n	            session.sendRequest(SIP.C.REFER, {\n	                extraHeaders: extraHeaders,\n	                body: options.body,\n	                receiveResponse: function(response) {\n	                    var timeout = null;\n	                    if (response.status_code === 202) {\n	                        var callId = response.call_id;\n	\n	                        var onNotify = function(request) {\n	                            if (request.call_id === callId) {\n	                                var body = request && request.body || '';\n	                                switch (true) {\n	                                    case /1[0-9]{2}/.test(body):\n	                                        request.reply(200);\n	                                        break;\n	                                    case /2[0-9]{2}/.test(body):\n	                                        session.terminate();\n	                                        clearTimeout(timeout);\n	                                        session.removeListener('RC_SIP_NOTIFY', onNotify);\n	                                        resolve();\n	                                        break;\n	                                    default:\n	                                        reject(body);\n	                                        break;\n	                                }\n	                            }\n	                        };\n	\n	                        timeout = setTimeout(function() {\n	                            reject(new Error('Timeout: no reply'));\n	                            session.removeListener('RC_SIP_NOTIFY', onNotify);\n	                        }, responseTimeout);\n	                        session.on('RC_SIP_NOTIFY', onNotify);\n	                    }\n	                    else {\n	                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));\n	                    }\n	                }\n	            });\n	\n	        });\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param {string} target\n	     * @param {object} options\n	     * @return {Promise}\n	     */\n	    function transfer(target, options) {\n	\n	        var session = this;\n	\n	        return (session.isOnHold() ? Promise.resolve(null) : session.hold())\n	            .then(function() { return delay(300); })\n	            .then(function() {\n	                return session.blindTransfer(target, options);\n	            });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param {string} target\n	     * @param {object} acceptOptions\n	     * @param {object} [transferOptions]\n	     * @return {Promise}\n	     */\n	    function forward(target, acceptOptions, transferOptions) {\n	\n	        var interval = null,\n	            session = this;\n	\n	        return session.accept(acceptOptions)\n	            .then(function() {\n	\n	                return new Promise(function(resolve, reject) {\n	                    interval = setInterval(function() {\n	                        if (session.status === 12) {\n	                            clearInterval(interval);\n	                            session.mute();\n	                            setTimeout(function() {\n	                                resolve(session.transfer(target, transferOptions));\n	                            }, 700);\n	                        }\n	                    }, 50);\n	                });\n	\n	            });\n	\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @return {Promise}\n	     */\n	    function startRecord() {\n	        return setRecord(this, true);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @return {Promise}\n	     */\n	    function stopRecord() {\n	        return setRecord(this, false);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @param target\n	     * @return {Promise}\n	     */\n	    function flip(target) {\n	        return sendReceive(this, messages.flip, {target: target});\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    /**\n	     * @this {SIP.Session}\n	     * @return {Promise}\n	     */\n	    function park() {\n	        return sendReceive(this, messages.park);\n	    }\n	\n	    /*--------------------------------------------------------------------------------------------------------------------*/\n	\n	    return WebPhone;\n	\n	}));\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	module.exports = __webpack_require__(16)(__webpack_require__(49));\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/**\n	 * @name SIP\n	 * @namespace\n	 */\n	\"use strict\";\n	\n	module.exports = function (environment) {\n	\n	var pkg = __webpack_require__(17);\n	\n	var SIP = Object.defineProperties({}, {\n	  version: {\n	    get: function(){ return pkg.version; }\n	  },\n	  name: {\n	    get: function(){ return pkg.title; }\n	  }\n	});\n	\n	__webpack_require__(18)(SIP, environment);\n	SIP.LoggerFactory = __webpack_require__(19)(environment.console);\n	SIP.EventEmitter = __webpack_require__(20)(environment.console);\n	SIP.C = __webpack_require__(22)(SIP.name, SIP.version);\n	SIP.Exceptions = __webpack_require__(23);\n	SIP.Timers = __webpack_require__(24)(environment.timers);\n	SIP.Transport = environment.Transport(SIP, environment.WebSocket);\n	__webpack_require__(25)(SIP);\n	__webpack_require__(26)(SIP);\n	__webpack_require__(27)(SIP);\n	__webpack_require__(28)(SIP);\n	__webpack_require__(29)(SIP);\n	__webpack_require__(30)(SIP);\n	__webpack_require__(32)(SIP);\n	__webpack_require__(33)(SIP);\n	SIP.MediaHandler = __webpack_require__(34)(SIP.EventEmitter);\n	__webpack_require__(35)(SIP);\n	__webpack_require__(36)(SIP);\n	__webpack_require__(37)(SIP, environment);\n	__webpack_require__(39)(SIP);\n	SIP.WebRTC = __webpack_require__(40)(SIP, environment);\n	__webpack_require__(43)(SIP, environment);\n	SIP.Hacks = __webpack_require__(44)(SIP);\n	__webpack_require__(45)(SIP);\n	SIP.DigestAuthentication = __webpack_require__(46)(SIP.Utils);\n	SIP.Grammar = __webpack_require__(47)(SIP);\n	\n	return SIP;\n	};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n	module.exports = {\n		\"_args\": [\n			[\n				\"sip.js@0.7.3\",\n				\"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\"\n			]\n		],\n		\"_from\": \"sip.js@0.7.3\",\n		\"_id\": \"sip.js@0.7.3\",\n		\"_inCache\": true,\n		\"_installable\": true,\n		\"_location\": \"/sip.js\",\n		\"_nodeVersion\": \"4.2.6\",\n		\"_npmUser\": {\n			\"email\": \"1212jtraceur@gmail.com\",\n			\"name\": \"josephfrazier\"\n		},\n		\"_npmVersion\": \"2.4.1\",\n		\"_phantomChildren\": {},\n		\"_requested\": {\n			\"name\": \"sip.js\",\n			\"raw\": \"sip.js@0.7.3\",\n			\"rawSpec\": \"0.7.3\",\n			\"scope\": null,\n			\"spec\": \"0.7.3\",\n			\"type\": \"version\"\n		},\n		\"_requiredBy\": [\n			\"/ringcentral-web-phone\"\n		],\n		\"_resolved\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.3.tgz\",\n		\"_shasum\": \"fc2ee6227d23a37a91976966f952d82c3da317b5\",\n		\"_shrinkwrap\": null,\n		\"_spec\": \"sip.js@0.7.3\",\n		\"_where\": \"/Users/howard.zhang/Sites/ringcentral-js-widget/node_modules/ringcentral-web-phone\",\n		\"author\": {\n			\"email\": \"will@onsip.com\",\n			\"name\": \"Will Mitchell\"\n		},\n		\"browser\": {\n			\"./src/environment.js\": \"./src/environment_browser.js\"\n		},\n		\"bugs\": {\n			\"url\": \"https://github.com/onsip/SIP.js/issues\"\n		},\n		\"contributors\": [\n			{\n				\"url\": \"http://sipjs.com/authors/\"\n			}\n		],\n		\"dependencies\": {\n			\"promiscuous\": \"^0.6.0\",\n			\"ws\": \"^0.6.4\"\n		},\n		\"description\": \"A simple, intuitive, and powerful JavaScript signaling library\",\n		\"devDependencies\": {\n			\"beefy\": \"^2.1.5\",\n			\"browserify\": \"^4.1.8\",\n			\"grunt\": \"~0.4.0\",\n			\"grunt-browserify\": \"^4.0.1\",\n			\"grunt-cli\": \"~0.1.6\",\n			\"grunt-contrib-copy\": \"^0.5.0\",\n			\"grunt-contrib-jasmine\": \"~0.8.0\",\n			\"grunt-contrib-jshint\": \">0.5.0\",\n			\"grunt-contrib-uglify\": \"~0.2.0\",\n			\"grunt-peg\": \"~1.3.1\",\n			\"grunt-trimtrailingspaces\": \"^0.4.0\",\n			\"pegjs\": \"^0.8.0\"\n		},\n		\"directories\": {},\n		\"dist\": {\n			\"shasum\": \"fc2ee6227d23a37a91976966f952d82c3da317b5\",\n			\"tarball\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.7.3.tgz\"\n		},\n		\"engines\": {\n			\"node\": \">=0.8\"\n		},\n		\"gitHead\": \"d9ae93c04d6aad5df37fc999cbdbc7d9060a2f06\",\n		\"homepage\": \"http://sipjs.com\",\n		\"keywords\": [\n			\"sip\",\n			\"websocket\",\n			\"webrtc\",\n			\"library\",\n			\"javascript\"\n		],\n		\"license\": \"MIT\",\n		\"main\": \"src/index.js\",\n		\"maintainers\": [\n			{\n				\"email\": \"eric.green@onsip.com\",\n				\"name\": \"egreen_onsip\"\n			},\n			{\n				\"email\": \"1212jtraceur@gmail.com\",\n				\"name\": \"josephfrazier\"\n			}\n		],\n		\"name\": \"sip.js\",\n		\"optionalDependencies\": {\n			\"promiscuous\": \"^0.6.0\"\n		},\n		\"readme\": \"ERROR: No README data found!\",\n		\"repository\": {\n			\"type\": \"git\",\n			\"url\": \"git+https://github.com/onsip/SIP.js.git\"\n		},\n		\"scripts\": {\n			\"build\": \"grunt build\",\n			\"prepublish\": \"cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js\",\n			\"repl\": \"beefy test/repl.js --open\",\n			\"test\": \"grunt travis --verbose\"\n		},\n		\"title\": \"SIP.js\",\n		\"version\": \"0.7.3\"\n	};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Utils\n	 */\n	\n	module.exports = function (SIP, environment) {\n	var Utils;\n	\n	Utils= {\n	\n	  Promise: environment.Promise,\n	\n	  defer: function defer () {\n	    var deferred = {};\n	    deferred.promise = new Utils.Promise(function (resolve, reject) {\n	      deferred.resolve = resolve;\n	      deferred.reject = reject;\n	    });\n	    return deferred;\n	  },\n	\n	  promisify: function promisify (object, methodName, callbacksFirst) {\n	    var oldMethod = object[methodName];\n	    return function promisifiedMethod (arg, onSuccess, onFailure) {\n	      return new Utils.Promise(function (resolve, reject) {\n	        var oldArgs = [arg, resolve, reject];\n	        if (callbacksFirst) {\n	          oldArgs = [resolve, reject, arg];\n	        }\n	        oldMethod.apply(object, oldArgs);\n	      }).then(onSuccess, onFailure);\n	    };\n	  },\n	\n	  augment: function (object, constructor, args, override) {\n	    var idx, proto;\n	\n	    // Add public properties from constructor's prototype onto object\n	    proto = constructor.prototype;\n	    for (idx in proto) {\n	      if (override || object[idx] === undefined) {\n	        object[idx] = proto[idx];\n	      }\n	    }\n	\n	    // Construct the object as though it were just created by constructor\n	    constructor.apply(object, args);\n	  },\n	\n	  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {\n	    if (isDeprecated && options[loser]) {\n	      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n	    }\n	\n	    if (options[winner] && options[loser]) {\n	      logger.warn(winner + ' overriding ' + loser);\n	    }\n	\n	    options[winner] = options[winner] || options[loser] || defaultValue;\n	  },\n	\n	  str_utf8_length: function(string) {\n	    return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n	  },\n	\n	  generateFakeSDP: function(body) {\n	    if (!body) {\n	      return;\n	    }\n	\n	    var start = body.indexOf('o=');\n	    var end = body.indexOf('\\r\\n', start);\n	\n	    return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n	  },\n	\n	  isFunction: function(fn) {\n	    if (fn !== undefined) {\n	      return Object.prototype.toString.call(fn) === '[object Function]';\n	    } else {\n	      return false;\n	    }\n	  },\n	\n	  isDecimal: function (num) {\n	    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));\n	  },\n	\n	  createRandomToken: function(size, base) {\n	    var i, r,\n	      token = '';\n	\n	    base = base || 32;\n	\n	    for( i=0; i < size; i++ ) {\n	      r = Math.random() * base|0;\n	      token += r.toString(base);\n	    }\n	\n	    return token;\n	  },\n	\n	  newTag: function() {\n	    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n	  },\n	\n	  // http://stackoverflow.com/users/109538/broofa\n	  newUUID: function() {\n	    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n	      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n	      return v.toString(16);\n	    });\n	\n	    return UUID;\n	  },\n	\n	  hostType: function(host) {\n	    if (!host) {\n	      return;\n	    } else {\n	      host = SIP.Grammar.parse(host,'host');\n	      if (host !== -1) {\n	        return host.host_type;\n	      }\n	    }\n	  },\n	\n	  /**\n	  * Normalize SIP URI.\n	  * NOTE: It does not allow a SIP URI without username.\n	  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n	  * Detects the domain part (if given) and properly hex-escapes the user portion.\n	  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n	  * @private\n	  * @param {String} target\n	  * @param {String} [domain]\n	  */\n	  normalizeTarget: function(target, domain) {\n	    var uri, target_array, target_user, target_domain;\n	\n	    // If no target is given then raise an error.\n	    if (!target) {\n	      return;\n	    // If a SIP.URI instance is given then return it.\n	    } else if (target instanceof SIP.URI) {\n	      return target;\n	\n	    // If a string is given split it by '@':\n	    // - Last fragment is the desired domain.\n	    // - Otherwise append the given domain argument.\n	    } else if (typeof target === 'string') {\n	      target_array = target.split('@');\n	\n	      switch(target_array.length) {\n	        case 1:\n	          if (!domain) {\n	            return;\n	          }\n	          target_user = target;\n	          target_domain = domain;\n	          break;\n	        case 2:\n	          target_user = target_array[0];\n	          target_domain = target_array[1];\n	          break;\n	        default:\n	          target_user = target_array.slice(0, target_array.length-1).join('@');\n	          target_domain = target_array[target_array.length-1];\n	      }\n	\n	      // Remove the URI scheme (if present).\n	      target_user = target_user.replace(/^(sips?|tel):/i, '');\n	\n	      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n	      if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n	        target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n	      }\n	\n	      // Build the complete SIP URI.\n	      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;\n	\n	      // Finally parse the resulting URI.\n	      if (uri = SIP.URI.parse(target)) {\n	        return uri;\n	      } else {\n	        return;\n	      }\n	    } else {\n	      return;\n	    }\n	  },\n	\n	  /**\n	  * Hex-escape a SIP URI user.\n	  * @private\n	  * @param {String} user\n	  */\n	  escapeUser: function(user) {\n	    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n	    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n	  },\n	\n	  headerize: function(string) {\n	    var exceptions = {\n	      'Call-Id': 'Call-ID',\n	      'Cseq': 'CSeq',\n	      'Min-Se': 'Min-SE',\n	      'Rack': 'RAck',\n	      'Rseq': 'RSeq',\n	      'Www-Authenticate': 'WWW-Authenticate'\n	      },\n	      name = string.toLowerCase().replace(/_/g,'-').split('-'),\n	      hname = '',\n	      parts = name.length, part;\n	\n	    for (part = 0; part < parts; part++) {\n	      if (part !== 0) {\n	        hname +='-';\n	      }\n	      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);\n	    }\n	    if (exceptions[hname]) {\n	      hname = exceptions[hname];\n	    }\n	    return hname;\n	  },\n	\n	  sipErrorCause: function(status_code) {\n	    var cause;\n	\n	    for (cause in SIP.C.SIP_ERROR_CAUSES) {\n	      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n	        return SIP.C.causes[cause];\n	      }\n	    }\n	\n	    return SIP.C.causes.SIP_FAILURE_CODE;\n	  },\n	\n	  getReasonPhrase: function getReasonPhrase (code, specific) {\n	    return specific || SIP.C.REASON_PHRASE[code] || '';\n	  },\n	\n	  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {\n	    reason = SIP.Utils.getReasonPhrase(code, reason);\n	    return 'SIP ;cause=' + code + ' ;text=\"' + reason + '\"';\n	  },\n	\n	  getCancelReason: function getCancelReason (code, reason) {\n	    if (code && code < 200 || code > 699) {\n	      throw new TypeError('Invalid status_code: ' + code);\n	    } else if (code) {\n	      return SIP.Utils.getReasonHeaderValue(code, reason);\n	    }\n	  },\n	\n	  buildStatusLine: function buildStatusLine (code, reason) {\n	    code = code || null;\n	    reason = reason || null;\n	\n	    // Validate code and reason values\n	    if (!code || (code < 100 || code > 699)) {\n	      throw new TypeError('Invalid status_code: '+ code);\n	    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n	      throw new TypeError('Invalid reason_phrase: '+ reason);\n	    }\n	\n	    reason = Utils.getReasonPhrase(code, reason);\n	\n	    return 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n	  },\n	\n	  /**\n	  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n	  * @private\n	  */\n	  getRandomTestNetIP: function() {\n	    function getOctet(from,to) {\n	      return Math.floor(Math.random()*(to-from+1)+from);\n	    }\n	    return '192.0.2.' + getOctet(1, 254);\n	  },\n	\n	  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info\n	  calculateMD5: function(string) {\n	    function RotateLeft(lValue, iShiftBits) {\n	      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n	    }\n	\n	    function AddUnsigned(lX,lY) {\n	      var lX4,lY4,lX8,lY8,lResult;\n	      lX8 = (lX & 0x80000000);\n	      lY8 = (lY & 0x80000000);\n	      lX4 = (lX & 0x40000000);\n	      lY4 = (lY & 0x40000000);\n	      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n	      if (lX4 & lY4) {\n	        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n	      }\n	      if (lX4 | lY4) {\n	        if (lResult & 0x40000000) {\n	          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n	        } else {\n	          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n	        }\n	      } else {\n	        return (lResult ^ lX8 ^ lY8);\n	      }\n	    }\n	\n	    function F(x,y,z) {\n	      return (x & y) | ((~x) & z);\n	    }\n	\n	    function G(x,y,z) {\n	      return (x & z) | (y & (~z));\n	    }\n	\n	    function H(x,y,z) {\n	      return (x ^ y ^ z);\n	    }\n	\n	    function I(x,y,z) {\n	      return (y ^ (x | (~z)));\n	    }\n	\n	    function FF(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function GG(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function HH(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function II(a,b,c,d,x,s,ac) {\n	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n	      return AddUnsigned(RotateLeft(a, s), b);\n	    }\n	\n	    function ConvertToWordArray(string) {\n	      var lWordCount;\n	      var lMessageLength = string.length;\n	      var lNumberOfWords_temp1=lMessageLength + 8;\n	      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n	      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n	      var lWordArray=Array(lNumberOfWords-1);\n	      var lBytePosition = 0;\n	      var lByteCount = 0;\n	      while ( lByteCount < lMessageLength ) {\n	        lWordCount = (lByteCount-(lByteCount % 4))/4;\n	        lBytePosition = (lByteCount % 4)*8;\n	        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n	        lByteCount++;\n	      }\n	      lWordCount = (lByteCount-(lByteCount % 4))/4;\n	      lBytePosition = (lByteCount % 4)*8;\n	      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n	      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n	      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n	      return lWordArray;\n	    }\n	\n	    function WordToHex(lValue) {\n	      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n	      for (lCount = 0;lCount<=3;lCount++) {\n	        lByte = (lValue>>>(lCount*8)) & 255;\n	        WordToHexValue_temp = \"0\" + lByte.toString(16);\n	        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n	      }\n	      return WordToHexValue;\n	    }\n	\n	    function Utf8Encode(string) {\n	      string = string.replace(/\\r\\n/g,\"\\n\");\n	      var utftext = \"\";\n	\n	      for (var n = 0; n < string.length; n++) {\n	        var c = string.charCodeAt(n);\n	\n	        if (c < 128) {\n	          utftext += String.fromCharCode(c);\n	        }\n	        else if((c > 127) && (c < 2048)) {\n	          utftext += String.fromCharCode((c >> 6) | 192);\n	          utftext += String.fromCharCode((c & 63) | 128);\n	        }\n	        else {\n	          utftext += String.fromCharCode((c >> 12) | 224);\n	          utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n	          utftext += String.fromCharCode((c & 63) | 128);\n	        }\n	      }\n	      return utftext;\n	    }\n	\n	    var x=[];\n	    var k,AA,BB,CC,DD,a,b,c,d;\n	    var S11=7, S12=12, S13=17, S14=22;\n	    var S21=5, S22=9 , S23=14, S24=20;\n	    var S31=4, S32=11, S33=16, S34=23;\n	    var S41=6, S42=10, S43=15, S44=21;\n	\n	    string = Utf8Encode(string);\n	\n	    x = ConvertToWordArray(string);\n	\n	    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n	\n	    for (k=0;k<x.length;k+=16) {\n	      AA=a; BB=b; CC=c; DD=d;\n	      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n	      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n	      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n	      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n	      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n	      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n	      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n	      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n	      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n	      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n	      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n	      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n	      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n	      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n	      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n	      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n	      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n	      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n	      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n	      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n	      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n	      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n	      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n	      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n	      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n	      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n	      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n	      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n	      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n	      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n	      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n	      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n	      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n	      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n	      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n	      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n	      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n	      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n	      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n	      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n	      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n	      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n	      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n	      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n	      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n	      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n	      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n	      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n	      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n	      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n	      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n	      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n	      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n	      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n	      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n	      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n	      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n	      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n	      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n	      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n	      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n	      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n	      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n	      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n	      a=AddUnsigned(a,AA);\n	      b=AddUnsigned(b,BB);\n	      c=AddUnsigned(c,CC);\n	      d=AddUnsigned(d,DD);\n	    }\n	\n	    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n	\n	    return temp.toLowerCase();\n	  }\n	};\n	\n	SIP.Utils = Utils;\n	};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	var levels = {\n	  'error': 0,\n	  'warn': 1,\n	  'log': 2,\n	  'debug': 3\n	};\n	\n	module.exports = function (console) {\n	\n	var LoggerFactory = function () {\n	  var logger,\n	    level = 2,\n	    builtinEnabled = true,\n	    connector = null;\n	\n	    this.loggers = {};\n	\n	    logger = this.getLogger('sip.loggerfactory');\n	\n	\n	  Object.defineProperties(this, {\n	    builtinEnabled: {\n	      get: function(){ return builtinEnabled; },\n	      set: function(value){\n	        if (typeof value === 'boolean') {\n	          builtinEnabled = value;\n	        } else {\n	          logger.error('invalid \"builtinEnabled\" parameter value: '+ JSON.stringify(value));\n	        }\n	      }\n	    },\n	\n	    level: {\n	      get: function() {return level; },\n	      set: function(value) {\n	        if (value >= 0 && value <=3) {\n	          level = value;\n	        } else if (value > 3) {\n	          level = 3;\n	        } else if (levels.hasOwnProperty(value)) {\n	          level = levels[value];\n	        } else {\n	          logger.error('invalid \"level\" parameter value: '+ JSON.stringify(value));\n	        }\n	      }\n	    },\n	\n	    connector: {\n	      get: function() {return connector; },\n	      set: function(value){\n	        if(value === null || value === \"\" || value === undefined) {\n	          connector = null;\n	        } else if (typeof value === 'function') {\n	          connector = value;\n	        } else {\n	          logger.error('invalid \"connector\" parameter value: '+ JSON.stringify(value));\n	        }\n	      }\n	    }\n	  });\n	};\n	\n	LoggerFactory.prototype.print = function(target, category, label, content) {\n	  if (typeof content === 'string') {\n	    var prefix = [new Date(), category];\n	    if (label) {\n	      prefix.push(label);\n	    }\n	    content = prefix.concat(content).join(' | ');\n	  }\n	  target.call(console, content);\n	};\n	\n	function Logger (logger, category, label) {\n	  this.logger = logger;\n	  this.category = category;\n	  this.label = label;\n	}\n	\n	Object.keys(levels).forEach(function (targetName) {\n	  Logger.prototype[targetName] = function (content) {\n	    this.logger[targetName](this.category, this.label, content);\n	  };\n	\n	  LoggerFactory.prototype[targetName] = function (category, label, content) {\n	    if (this.level >= levels[targetName]) {\n	      if (this.builtinEnabled) {\n	        this.print(console[targetName], category, label, content);\n	      }\n	\n	      if (this.connector) {\n	        this.connector(targetName, category, label, content);\n	      }\n	    }\n	  };\n	});\n	\n	LoggerFactory.prototype.getLogger = function(category, label) {\n	  var logger;\n	\n	  if (label && this.level === 3) {\n	    return new Logger(this, category, label);\n	  } else if (this.loggers[category]) {\n	    return this.loggers[category];\n	  } else {\n	    logger = new Logger(this, category);\n	    this.loggers[category] = logger;\n	    return logger;\n	  }\n	};\n	\n	return LoggerFactory;\n	};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	var NodeEventEmitter = __webpack_require__(21).EventEmitter;\n	\n	module.exports = function (console) {\n	\n	// Don't use `new SIP.EventEmitter()` for inheriting.\n	// Use Object.create(SIP.EventEmitter.prototoype);\n	function EventEmitter () {\n	  NodeEventEmitter.call(this);\n	}\n	\n	EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {\n	  constructor: {\n	    value: EventEmitter,\n	    enumerable: false,\n	    writable: true,\n	    configurable: true\n	  }\n	});\n	\n	EventEmitter.prototype.off = function off (eventName, listener) {\n	  var warning = '';\n	  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\\n';\n	  warning += 'Please use removeListener or removeAllListeners instead.\\n';\n	  warning += 'See here for more details:\\n';\n	  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';\n	  console.warn(warning);\n	\n	  if (arguments.length < 2) {\n	    return this.removeAllListeners.apply(this, arguments);\n	  } else {\n	    return this.removeListener(eventName, listener);\n	  }\n	};\n	\n	return EventEmitter;\n	\n	};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n	// Copyright Joyent, Inc. and other Node contributors.\n	//\n	// Permission is hereby granted, free of charge, to any person obtaining a\n	// copy of this software and associated documentation files (the\n	// \"Software\"), to deal in the Software without restriction, including\n	// without limitation the rights to use, copy, modify, merge, publish,\n	// distribute, sublicense, and/or sell copies of the Software, and to permit\n	// persons to whom the Software is furnished to do so, subject to the\n	// following conditions:\n	//\n	// The above copyright notice and this permission notice shall be included\n	// in all copies or substantial portions of the Software.\n	//\n	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n	// USE OR OTHER DEALINGS IN THE SOFTWARE.\n	\n	function EventEmitter() {\n	  this._events = this._events || {};\n	  this._maxListeners = this._maxListeners || undefined;\n	}\n	module.exports = EventEmitter;\n	\n	// Backwards-compat with node 0.10.x\n	EventEmitter.EventEmitter = EventEmitter;\n	\n	EventEmitter.prototype._events = undefined;\n	EventEmitter.prototype._maxListeners = undefined;\n	\n	// By default EventEmitters will print a warning if more than 10 listeners are\n	// added to it. This is a useful default which helps finding memory leaks.\n	EventEmitter.defaultMaxListeners = 10;\n	\n	// Obviously not all Emitters should be limited to 10. This function allows\n	// that to be increased. Set to zero for unlimited.\n	EventEmitter.prototype.setMaxListeners = function(n) {\n	  if (!isNumber(n) || n < 0 || isNaN(n))\n	    throw TypeError('n must be a positive number');\n	  this._maxListeners = n;\n	  return this;\n	};\n	\n	EventEmitter.prototype.emit = function(type) {\n	  var er, handler, len, args, i, listeners;\n	\n	  if (!this._events)\n	    this._events = {};\n	\n	  // If there is no 'error' event listener then throw.\n	  if (type === 'error') {\n	    if (!this._events.error ||\n	        (isObject(this._events.error) && !this._events.error.length)) {\n	      er = arguments[1];\n	      if (er instanceof Error) {\n	        throw er; // Unhandled 'error' event\n	      }\n	      throw TypeError('Uncaught, unspecified \"error\" event.');\n	    }\n	  }\n	\n	  handler = this._events[type];\n	\n	  if (isUndefined(handler))\n	    return false;\n	\n	  if (isFunction(handler)) {\n	    switch (arguments.length) {\n	      // fast cases\n	      case 1:\n	        handler.call(this);\n	        break;\n	      case 2:\n	        handler.call(this, arguments[1]);\n	        break;\n	      case 3:\n	        handler.call(this, arguments[1], arguments[2]);\n	        break;\n	      // slower\n	      default:\n	        args = Array.prototype.slice.call(arguments, 1);\n	        handler.apply(this, args);\n	    }\n	  } else if (isObject(handler)) {\n	    args = Array.prototype.slice.call(arguments, 1);\n	    listeners = handler.slice();\n	    len = listeners.length;\n	    for (i = 0; i < len; i++)\n	      listeners[i].apply(this, args);\n	  }\n	\n	  return true;\n	};\n	\n	EventEmitter.prototype.addListener = function(type, listener) {\n	  var m;\n	\n	  if (!isFunction(listener))\n	    throw TypeError('listener must be a function');\n	\n	  if (!this._events)\n	    this._events = {};\n	\n	  // To avoid recursion in the case that type === \"newListener\"! Before\n	  // adding it to the listeners, first emit \"newListener\".\n	  if (this._events.newListener)\n	    this.emit('newListener', type,\n	              isFunction(listener.listener) ?\n	              listener.listener : listener);\n	\n	  if (!this._events[type])\n	    // Optimize the case of one listener. Don't need the extra array object.\n	    this._events[type] = listener;\n	  else if (isObject(this._events[type]))\n	    // If we've already got an array, just append.\n	    this._events[type].push(listener);\n	  else\n	    // Adding the second element, need to change to array.\n	    this._events[type] = [this._events[type], listener];\n	\n	  // Check for listener leak\n	  if (isObject(this._events[type]) && !this._events[type].warned) {\n	    if (!isUndefined(this._maxListeners)) {\n	      m = this._maxListeners;\n	    } else {\n	      m = EventEmitter.defaultMaxListeners;\n	    }\n	\n	    if (m && m > 0 && this._events[type].length > m) {\n	      this._events[type].warned = true;\n	      console.error('(node) warning: possible EventEmitter memory ' +\n	                    'leak detected. %d listeners added. ' +\n	                    'Use emitter.setMaxListeners() to increase limit.',\n	                    this._events[type].length);\n	      if (typeof console.trace === 'function') {\n	        // not supported in IE 10\n	        console.trace();\n	      }\n	    }\n	  }\n	\n	  return this;\n	};\n	\n	EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n	\n	EventEmitter.prototype.once = function(type, listener) {\n	  if (!isFunction(listener))\n	    throw TypeError('listener must be a function');\n	\n	  var fired = false;\n	\n	  function g() {\n	    this.removeListener(type, g);\n	\n	    if (!fired) {\n	      fired = true;\n	      listener.apply(this, arguments);\n	    }\n	  }\n	\n	  g.listener = listener;\n	  this.on(type, g);\n	\n	  return this;\n	};\n	\n	// emits a 'removeListener' event iff the listener was removed\n	EventEmitter.prototype.removeListener = function(type, listener) {\n	  var list, position, length, i;\n	\n	  if (!isFunction(listener))\n	    throw TypeError('listener must be a function');\n	\n	  if (!this._events || !this._events[type])\n	    return this;\n	\n	  list = this._events[type];\n	  length = list.length;\n	  position = -1;\n	\n	  if (list === listener ||\n	      (isFunction(list.listener) && list.listener === listener)) {\n	    delete this._events[type];\n	    if (this._events.removeListener)\n	      this.emit('removeListener', type, listener);\n	\n	  } else if (isObject(list)) {\n	    for (i = length; i-- > 0;) {\n	      if (list[i] === listener ||\n	          (list[i].listener && list[i].listener === listener)) {\n	        position = i;\n	        break;\n	      }\n	    }\n	\n	    if (position < 0)\n	      return this;\n	\n	    if (list.length === 1) {\n	      list.length = 0;\n	      delete this._events[type];\n	    } else {\n	      list.splice(position, 1);\n	    }\n	\n	    if (this._events.removeListener)\n	      this.emit('removeListener', type, listener);\n	  }\n	\n	  return this;\n	};\n	\n	EventEmitter.prototype.removeAllListeners = function(type) {\n	  var key, listeners;\n	\n	  if (!this._events)\n	    return this;\n	\n	  // not listening for removeListener, no need to emit\n	  if (!this._events.removeListener) {\n	    if (arguments.length === 0)\n	      this._events = {};\n	    else if (this._events[type])\n	      delete this._events[type];\n	    return this;\n	  }\n	\n	  // emit removeListener for all listeners on all events\n	  if (arguments.length === 0) {\n	    for (key in this._events) {\n	      if (key === 'removeListener') continue;\n	      this.removeAllListeners(key);\n	    }\n	    this.removeAllListeners('removeListener');\n	    this._events = {};\n	    return this;\n	  }\n	\n	  listeners = this._events[type];\n	\n	  if (isFunction(listeners)) {\n	    this.removeListener(type, listeners);\n	  } else if (listeners) {\n	    // LIFO order\n	    while (listeners.length)\n	      this.removeListener(type, listeners[listeners.length - 1]);\n	  }\n	  delete this._events[type];\n	\n	  return this;\n	};\n	\n	EventEmitter.prototype.listeners = function(type) {\n	  var ret;\n	  if (!this._events || !this._events[type])\n	    ret = [];\n	  else if (isFunction(this._events[type]))\n	    ret = [this._events[type]];\n	  else\n	    ret = this._events[type].slice();\n	  return ret;\n	};\n	\n	EventEmitter.prototype.listenerCount = function(type) {\n	  if (this._events) {\n	    var evlistener = this._events[type];\n	\n	    if (isFunction(evlistener))\n	      return 1;\n	    else if (evlistener)\n	      return evlistener.length;\n	  }\n	  return 0;\n	};\n	\n	EventEmitter.listenerCount = function(emitter, type) {\n	  return emitter.listenerCount(type);\n	};\n	\n	function isFunction(arg) {\n	  return typeof arg === 'function';\n	}\n	\n	function isNumber(arg) {\n	  return typeof arg === 'number';\n	}\n	\n	function isObject(arg) {\n	  return typeof arg === 'object' && arg !== null;\n	}\n	\n	function isUndefined(arg) {\n	  return arg === void 0;\n	}\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Constants\n	 */\n	\n	/**\n	 * SIP Constants.\n	 * @augments SIP\n	 */\n	\n	module.exports = function (name, version) {\n	return {\n	  USER_AGENT: name +'/'+ version,\n	\n	  // SIP scheme\n	  SIP:  'sip',\n	  SIPS: 'sips',\n	\n	  // End and Failure causes\n	  causes: {\n	    // Generic error causes\n	    CONNECTION_ERROR:         'Connection Error',\n	    REQUEST_TIMEOUT:          'Request Timeout',\n	    SIP_FAILURE_CODE:         'SIP Failure Code',\n	    INTERNAL_ERROR:           'Internal Error',\n	\n	    // SIP error causes\n	    BUSY:                     'Busy',\n	    REJECTED:                 'Rejected',\n	    REDIRECTED:               'Redirected',\n	    UNAVAILABLE:              'Unavailable',\n	    NOT_FOUND:                'Not Found',\n	    ADDRESS_INCOMPLETE:       'Address Incomplete',\n	    INCOMPATIBLE_SDP:         'Incompatible SDP',\n	    AUTHENTICATION_ERROR:     'Authentication Error',\n	    DIALOG_ERROR:             'Dialog Error',\n	\n	    // Session error causes\n	    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',\n	    WEBRTC_ERROR:             'WebRTC Error',\n	    CANCELED:                 'Canceled',\n	    NO_ANSWER:                'No Answer',\n	    EXPIRES:                  'Expires',\n	    NO_ACK:                   'No ACK',\n	    NO_PRACK:                 'No PRACK',\n	    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n	    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',\n	    RTP_TIMEOUT:              'RTP Timeout'\n	  },\n	\n	  supported: {\n	    UNSUPPORTED:        'none',\n	    SUPPORTED:          'supported',\n	    REQUIRED:           'required'\n	  },\n	\n	  SIP_ERROR_CAUSES: {\n	    REDIRECTED: [300,301,302,305,380],\n	    BUSY: [486,600],\n	    REJECTED: [403,603],\n	    NOT_FOUND: [404,604],\n	    UNAVAILABLE: [480,410,408,430],\n	    ADDRESS_INCOMPLETE: [484],\n	    INCOMPATIBLE_SDP: [488,606],\n	    AUTHENTICATION_ERROR:[401,407]\n	  },\n	\n	  // SIP Methods\n	  ACK:        'ACK',\n	  BYE:        'BYE',\n	  CANCEL:     'CANCEL',\n	  INFO:       'INFO',\n	  INVITE:     'INVITE',\n	  MESSAGE:    'MESSAGE',\n	  NOTIFY:     'NOTIFY',\n	  OPTIONS:    'OPTIONS',\n	  REGISTER:   'REGISTER',\n	  UPDATE:     'UPDATE',\n	  SUBSCRIBE:  'SUBSCRIBE',\n	  REFER:      'REFER',\n	  PRACK:      'PRACK',\n	\n	  /* SIP Response Reasons\n	   * DOC: http://www.iana.org/assignments/sip-parameters\n	   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n	   */\n	  REASON_PHRASE: {\n	    100: 'Trying',\n	    180: 'Ringing',\n	    181: 'Call Is Being Forwarded',\n	    182: 'Queued',\n	    183: 'Session Progress',\n	    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199\n	    200: 'OK',\n	    202: 'Accepted',  // RFC 3265\n	    204: 'No Notification',  //RFC 5839\n	    300: 'Multiple Choices',\n	    301: 'Moved Permanently',\n	    302: 'Moved Temporarily',\n	    305: 'Use Proxy',\n	    380: 'Alternative Service',\n	    400: 'Bad Request',\n	    401: 'Unauthorized',\n	    402: 'Payment Required',\n	    403: 'Forbidden',\n	    404: 'Not Found',\n	    405: 'Method Not Allowed',\n	    406: 'Not Acceptable',\n	    407: 'Proxy Authentication Required',\n	    408: 'Request Timeout',\n	    410: 'Gone',\n	    412: 'Conditional Request Failed',  // RFC 3903\n	    413: 'Request Entity Too Large',\n	    414: 'Request-URI Too Long',\n	    415: 'Unsupported Media Type',\n	    416: 'Unsupported URI Scheme',\n	    417: 'Unknown Resource-Priority',  // RFC 4412\n	    420: 'Bad Extension',\n	    421: 'Extension Required',\n	    422: 'Session Interval Too Small',  // RFC 4028\n	    423: 'Interval Too Brief',\n	    428: 'Use Identity Header',  // RFC 4474\n	    429: 'Provide Referrer Identity',  // RFC 3892\n	    430: 'Flow Failed',  // RFC 5626\n	    433: 'Anonymity Disallowed',  // RFC 5079\n	    436: 'Bad Identity-Info',  // RFC 4474\n	    437: 'Unsupported Certificate',  // RFC 4744\n	    438: 'Invalid Identity Header',  // RFC 4744\n	    439: 'First Hop Lacks Outbound Support',  // RFC 5626\n	    440: 'Max-Breadth Exceeded',  // RFC 5393\n	    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events\n	    470: 'Consent Needed',  // RFC 5360\n	    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.\n	    480: 'Temporarily Unavailable',\n	    481: 'Call/Transaction Does Not Exist',\n	    482: 'Loop Detected',\n	    483: 'Too Many Hops',\n	    484: 'Address Incomplete',\n	    485: 'Ambiguous',\n	    486: 'Busy Here',\n	    487: 'Request Terminated',\n	    488: 'Not Acceptable Here',\n	    489: 'Bad Event',  // RFC 3265\n	    491: 'Request Pending',\n	    493: 'Undecipherable',\n	    494: 'Security Agreement Required',  // RFC 3329\n	    500: 'Internal Server Error',\n	    501: 'Not Implemented',\n	    502: 'Bad Gateway',\n	    503: 'Service Unavailable',\n	    504: 'Server Time-out',\n	    505: 'Version Not Supported',\n	    513: 'Message Too Large',\n	    580: 'Precondition Failure',  // RFC 3312\n	    600: 'Busy Everywhere',\n	    603: 'Decline',\n	    604: 'Does Not Exist Anywhere',\n	    606: 'Not Acceptable'\n	  },\n	\n	  /* SIP Option Tags\n	   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4\n	   */\n	  OPTION_TAGS: {\n	    '100rel':                   true,  // RFC 3262\n	    199:                        true,  // RFC 6228\n	    answermode:                 true,  // RFC 5373\n	    'early-session':            true,  // RFC 3959\n	    eventlist:                  true,  // RFC 4662\n	    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n	    'from-change':              true,  // RFC 4916\n	    'geolocation-http':         true,  // RFC 6442\n	    'geolocation-sip':          true,  // RFC 6442\n	    gin:                        true,  // RFC 6140\n	    gruu:                       true,  // RFC 5627\n	    histinfo:                   true,  // RFC 7044\n	    ice:                        true,  // RFC 5768\n	    join:                       true,  // RFC 3911\n	    'multiple-refer':           true,  // RFC 5368\n	    norefersub:                 true,  // RFC 4488\n	    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03\n	    outbound:                   true,  // RFC 5626\n	    path:                       true,  // RFC 3327\n	    policy:                     true,  // RFC 6794\n	    precondition:               true,  // RFC 3312\n	    pref:                       true,  // RFC 3840\n	    privacy:                    true,  // RFC 3323\n	    'recipient-list-invite':    true,  // RFC 5366\n	    'recipient-list-message':   true,  // RFC 5365\n	    'recipient-list-subscribe': true,  // RFC 5367\n	    replaces:                   true,  // RFC 3891\n	    'resource-priority':        true,  // RFC 4412\n	    'sdp-anat':                 true,  // RFC 4092\n	    'sec-agree':                true,  // RFC 3329\n	    tdialog:                    true,  // RFC 4538\n	    timer:                      true,  // RFC 4028\n	    uui:                        true   // RFC 7433\n	  }\n	};\n	};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Exceptions\n	 */\n	\n	/**\n	 * SIP Exceptions.\n	 * @augments SIP\n	 */\n	module.exports = {\n	  ConfigurationError: (function(){\n	    var exception = function(parameter, value) {\n	      this.code = 1;\n	      this.name = 'CONFIGURATION_ERROR';\n	      this.parameter = parameter;\n	      this.value = value;\n	      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter \"'+ this.parameter +'\"';\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }()),\n	\n	  InvalidStateError: (function(){\n	    var exception = function(status) {\n	      this.code = 2;\n	      this.name = 'INVALID_STATE_ERROR';\n	      this.status = status;\n	      this.message = 'Invalid status: ' + status;\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }()),\n	\n	  NotSupportedError: (function(){\n	    var exception = function(message) {\n	      this.code = 3;\n	      this.name = 'NOT_SUPPORTED_ERROR';\n	      this.message = message;\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }()),\n	\n	  GetDescriptionError: (function(){\n	    var exception = function(message) {\n	      this.code = 4;\n	      this.name = 'GET_DESCRIPTION_ERROR';\n	      this.message = message;\n	    };\n	    exception.prototype = new Error();\n	    return exception;\n	  }())\n	};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP TIMERS\n	 */\n	\n	/**\n	 * @augments SIP\n	 */\n	var\n	  T1 = 500,\n	  T2 = 4000,\n	  T4 = 5000;\n	module.exports = function (timers) {\n	  var Timers = {\n	    T1: T1,\n	    T2: T2,\n	    T4: T4,\n	    TIMER_B: 64 * T1,\n	    TIMER_D: 0  * T1,\n	    TIMER_F: 64 * T1,\n	    TIMER_H: 64 * T1,\n	    TIMER_I: 0  * T1,\n	    TIMER_J: 0  * T1,\n	    TIMER_K: 0  * T4,\n	    TIMER_L: 64 * T1,\n	    TIMER_M: 64 * T1,\n	    TIMER_N: 64 * T1,\n	    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1\n	  };\n	\n	  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']\n	  .forEach(function (name) {\n	    // can't just use timers[name].bind(timers) since it bypasses jasmine's\n	    // clock-mocking\n	    Timers[name] = function () {\n	      return timers[name].apply(timers, arguments);\n	    };\n	  });\n	\n	  return Timers;\n	};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Message Parser\n	 */\n	\n	/**\n	 * Extract and parse every header of a SIP message.\n	 * @augments SIP\n	 * @namespace\n	 */\n	module.exports = function (SIP) {\n	var Parser;\n	\n	function getHeader(data, headerStart) {\n	  var\n	    // 'start' position of the header.\n	    start = headerStart,\n	    // 'end' position of the header.\n	    end = 0,\n	    // 'partial end' position of the header.\n	    partialEnd = 0;\n	\n	  //End of message.\n	  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n	    return -2;\n	  }\n	\n	  while(end === 0) {\n	    // Partial End of Header.\n	    partialEnd = data.indexOf('\\r\\n', start);\n	\n	    // 'indexOf' returns -1 if the value to be found never occurs.\n	    if (partialEnd === -1) {\n	      return partialEnd;\n	    }\n	\n	    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n	      // Not the end of the message. Continue from the next position.\n	      start = partialEnd + 2;\n	    } else {\n	      end = partialEnd;\n	    }\n	  }\n	\n	  return end;\n	}\n	\n	function parseHeader(message, data, headerStart, headerEnd) {\n	  var header, idx, length, parsed,\n	    hcolonIndex = data.indexOf(':', headerStart),\n	    headerName = data.substring(headerStart, hcolonIndex).trim(),\n	    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n	\n	  // If header-field is well-known, parse it.\n	  switch(headerName.toLowerCase()) {\n	    case 'via':\n	    case 'v':\n	      message.addHeader('via', headerValue);\n	      if(message.getHeaders('via').length === 1) {\n	        parsed = message.parseHeader('Via');\n	        if(parsed) {\n	          message.via = parsed;\n	          message.via_branch = parsed.branch;\n	        }\n	      } else {\n	        parsed = 0;\n	      }\n	      break;\n	    case 'from':\n	    case 'f':\n	      message.setHeader('from', headerValue);\n	      parsed = message.parseHeader('from');\n	      if(parsed) {\n	        message.from = parsed;\n	        message.from_tag = parsed.getParam('tag');\n	      }\n	      break;\n	    case 'to':\n	    case 't':\n	      message.setHeader('to', headerValue);\n	      parsed = message.parseHeader('to');\n	      if(parsed) {\n	        message.to = parsed;\n	        message.to_tag = parsed.getParam('tag');\n	      }\n	      break;\n	    case 'record-route':\n	      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n	\n	      if (parsed === -1) {\n	        parsed = undefined;\n	        break;\n	      }\n	\n	      length = parsed.length;\n	      for (idx = 0; idx < length; idx++) {\n	        header = parsed[idx];\n	        message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n	        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n	      }\n	      break;\n	    case 'call-id':\n	    case 'i':\n	      message.setHeader('call-id', headerValue);\n	      parsed = message.parseHeader('call-id');\n	      if(parsed) {\n	        message.call_id = headerValue;\n	      }\n	      break;\n	    case 'contact':\n	    case 'm':\n	      parsed = SIP.Grammar.parse(headerValue, 'Contact');\n	\n	      if (parsed === -1) {\n	        parsed = undefined;\n	        break;\n	      }\n	\n	      length = parsed.length;\n	      for (idx = 0; idx < length; idx++) {\n	        header = parsed[idx];\n	        message.addHeader('contact', headerValue.substring(header.position, header.offset));\n	        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n	      }\n	      break;\n	    case 'content-length':\n	    case 'l':\n	      message.setHeader('content-length', headerValue);\n	      parsed = message.parseHeader('content-length');\n	      break;\n	    case 'content-type':\n	    case 'c':\n	      message.setHeader('content-type', headerValue);\n	      parsed = message.parseHeader('content-type');\n	      break;\n	    case 'cseq':\n	      message.setHeader('cseq', headerValue);\n	      parsed = message.parseHeader('cseq');\n	      if(parsed) {\n	        message.cseq = parsed.value;\n	      }\n	      if(message instanceof SIP.IncomingResponse) {\n	        message.method = parsed.method;\n	      }\n	      break;\n	    case 'max-forwards':\n	      message.setHeader('max-forwards', headerValue);\n	      parsed = message.parseHeader('max-forwards');\n	      break;\n	    case 'www-authenticate':\n	      message.setHeader('www-authenticate', headerValue);\n	      parsed = message.parseHeader('www-authenticate');\n	      break;\n	    case 'proxy-authenticate':\n	      message.setHeader('proxy-authenticate', headerValue);\n	      parsed = message.parseHeader('proxy-authenticate');\n	      break;\n	    case 'refer-to':\n	    case 'r':\n	      message.setHeader('refer-to', headerValue);\n	      parsed = message.parseHeader('refer-to');\n	      if (parsed) {\n	        message.refer_to = parsed;\n	      }\n	      break;\n	    default:\n	      // Do not parse this header.\n	      message.setHeader(headerName, headerValue);\n	      parsed = 0;\n	  }\n	\n	  if (parsed === undefined) {\n	    return {\n	      error: 'error parsing header \"'+ headerName +'\"'\n	    };\n	  } else {\n	    return true;\n	  }\n	}\n	\n	/** Parse SIP Message\n	 * @function\n	 * @param {String} message SIP message.\n	 * @param {Object} logger object.\n	 * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n	 */\n	Parser = {};\n	Parser.parseMessage = function(data, ua) {\n	  var message, firstLine, contentLength, bodyStart, parsed,\n	    headerStart = 0,\n	    headerEnd = data.indexOf('\\r\\n'),\n	    logger = ua.getLogger('sip.parser');\n	\n	  if(headerEnd === -1) {\n	    logger.warn('no CRLF found, not a SIP message, discarded');\n	    return;\n	  }\n	\n	  // Parse first line. Check if it is a Request or a Reply.\n	  firstLine = data.substring(0, headerEnd);\n	  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n	\n	  if(parsed === -1) {\n	    logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n	    return;\n	  } else if(!parsed.status_code) {\n	    message = new SIP.IncomingRequest(ua);\n	    message.method = parsed.method;\n	    message.ruri = parsed.uri;\n	  } else {\n	    message = new SIP.IncomingResponse(ua);\n	    message.status_code = parsed.status_code;\n	    message.reason_phrase = parsed.reason_phrase;\n	  }\n	\n	  message.data = data;\n	  headerStart = headerEnd + 2;\n	\n	  /* Loop over every line in data. Detect the end of each header and parse\n	  * it or simply add to the headers collection.\n	  */\n	  while(true) {\n	    headerEnd = getHeader(data, headerStart);\n	\n	    // The SIP message has normally finished.\n	    if(headerEnd === -2) {\n	      bodyStart = headerStart + 2;\n	      break;\n	    }\n	    // data.indexOf returned -1 due to a malformed message.\n	    else if(headerEnd === -1) {\n	      logger.error('malformed message');\n	      return;\n	    }\n	\n	    parsed = parseHeader(message, data, headerStart, headerEnd);\n	\n	    if(parsed !== true) {\n	      logger.error(parsed.error);\n	      return;\n	    }\n	\n	    headerStart = headerEnd + 2;\n	  }\n	\n	  /* RFC3261 18.3.\n	   * If there are additional bytes in the transport packet\n	   * beyond the end of the body, they MUST be discarded.\n	   */\n	  if(message.hasHeader('content-length')) {\n	    contentLength = message.getHeader('content-length');\n	    message.body = data.substr(bodyStart, contentLength);\n	  } else {\n	    message.body = data.substring(bodyStart);\n	  }\n	\n	  return message;\n	};\n	\n	SIP.Parser = Parser;\n	};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Message\n	 */\n	\n	module.exports = function (SIP) {\n	var\n	  OutgoingRequest,\n	  IncomingMessage,\n	  IncomingRequest,\n	  IncomingResponse;\n	\n	function getSupportedHeader (request) {\n	  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;\n	  var optionTags = [];\n	  var optionTagSet = {};\n	\n	  if (request.method === SIP.C.REGISTER) {\n	    optionTags.push('path', 'gruu');\n	  } else if (request.method === SIP.C.INVITE &&\n	             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {\n	    optionTags.push('gruu');\n	  }\n	\n	  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n	    optionTags.push('100rel');\n	  }\n	  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {\n	    optionTags.push('replaces');\n	  }\n	\n	  optionTags.push('outbound');\n	\n	  optionTags = optionTags.concat(request.ua.configuration.extraSupported);\n	\n	  optionTags = optionTags.filter(function(optionTag) {\n	    var registered = SIP.C.OPTION_TAGS[optionTag];\n	    var unique = !optionTagSet[optionTag];\n	    optionTagSet[optionTag] = true;\n	    return (registered || allowUnregistered) && unique;\n	  });\n	\n	  return 'Supported: ' + optionTags.join(', ') + '\\r\\n';\n	}\n	\n	/**\n	 * @augments SIP\n	 * @class Class for outgoing SIP request.\n	 * @param {String} method request method\n	 * @param {String} ruri request uri\n	 * @param {SIP.UA} ua\n	 * @param {Object} params parameters that will have priority over ua.configuration parameters:\n	 * <br>\n	 *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set\n	 * @param {Object} [headers] extra headers\n	 * @param {String} [body]\n	 */\n	OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {\n	  var\n	    to,\n	    from,\n	    call_id,\n	    cseq,\n	    to_uri,\n	    from_uri;\n	\n	  params = params || {};\n	\n	  // Mandatory parameters check\n	  if(!method || !ruri || !ua) {\n	    return null;\n	  }\n	\n	  this.logger = ua.getLogger('sip.sipmessage');\n	  this.ua = ua;\n	  this.headers = {};\n	  this.method = method;\n	  this.ruri = ruri;\n	  this.body = body;\n	  this.extraHeaders = (extraHeaders || []).slice();\n	  this.statusCode = params.status_code;\n	  this.reasonPhrase = params.reason_phrase;\n	\n	  // Fill the Common SIP Request Headers\n	\n	  // Route\n	  if (params.route_set) {\n	    this.setHeader('route', params.route_set);\n	  } else if (ua.configuration.usePreloadedRoute){\n	    this.setHeader('route', ua.transport.server.sip_uri);\n	  }\n	\n	  // Via\n	  // Empty Via header. Will be filled by the client transaction.\n	  this.setHeader('via', '');\n	\n	  // Max-Forwards\n	  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);\n	\n	  // To\n	  to_uri = params.to_uri || ruri;\n	  to = (params.to_displayName || params.to_displayName === 0) ? '\"' + params.to_displayName + '\" ' : '';\n	  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';\n	  to += params.to_tag ? ';tag=' + params.to_tag : '';\n	  this.to = new SIP.NameAddrHeader.parse(to);\n	  this.setHeader('to', to);\n	\n	  // From\n	  from_uri = params.from_uri || ua.configuration.uri;\n	  if (params.from_displayName || params.from_displayName === 0) {\n	    from = '\"' + params.from_displayName + '\" ';\n	  } else if (ua.configuration.displayName) {\n	    from = '\"' + ua.configuration.displayName + '\" ';\n	  } else {\n	    from = '';\n	  }\n	  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';\n	  from += params.from_tag || SIP.Utils.newTag();\n	  this.from = new SIP.NameAddrHeader.parse(from);\n	  this.setHeader('from', from);\n	\n	  // Call-ID\n	  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));\n	  this.call_id = call_id;\n	  this.setHeader('call-id', call_id);\n	\n	  // CSeq\n	  cseq = params.cseq || Math.floor(Math.random() * 10000);\n	  this.cseq = cseq;\n	  this.setHeader('cseq', cseq + ' ' + method);\n	};\n	\n	OutgoingRequest.prototype = {\n	  /**\n	   * Replace the the given header by the given value.\n	   * @param {String} name header name\n	   * @param {String | Array} value header value\n	   */\n	  setHeader: function(name, value) {\n	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n	  },\n	\n	  /**\n	   * Get the value of the given header name at the given position.\n	   * @param {String} name header name\n	   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.\n	   */\n	  getHeader: function(name) {\n	    var regexp, idx,\n	      length = this.extraHeaders.length,\n	      header = this.headers[SIP.Utils.headerize(name)];\n	\n	    if(header) {\n	      if(header[0]) {\n	        return header[0];\n	      }\n	    } else {\n	      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n	      for (idx = 0; idx < length; idx++) {\n	        header = this.extraHeaders[idx];\n	        if (regexp.test(header)) {\n	          return header.substring(header.indexOf(':')+1).trim();\n	        }\n	      }\n	    }\n	\n	    return;\n	  },\n	\n	  /**\n	   * Get the header/s of the given name.\n	   * @param {String} name header name\n	   * @returns {Array} Array with all the headers of the specified name.\n	   */\n	  getHeaders: function(name) {\n	    var idx, length, regexp,\n	      header = this.headers[SIP.Utils.headerize(name)],\n	      result = [];\n	\n	    if(header) {\n	      length = header.length;\n	      for (idx = 0; idx < length; idx++) {\n	        result.push(header[idx]);\n	      }\n	      return result;\n	    } else {\n	      length = this.extraHeaders.length;\n	      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n	      for (idx = 0; idx < length; idx++) {\n	        header = this.extraHeaders[idx];\n	        if (regexp.test(header)) {\n	          result.push(header.substring(header.indexOf(':')+1).trim());\n	        }\n	      }\n	      return result;\n	    }\n	  },\n	\n	  /**\n	   * Verify the existence of the given header.\n	   * @param {String} name header name\n	   * @returns {boolean} true if header with given name exists, false otherwise\n	   */\n	  hasHeader: function(name) {\n	    var regexp, idx,\n	      length = this.extraHeaders.length;\n	\n	    if (this.headers[SIP.Utils.headerize(name)]) {\n	      return true;\n	    } else {\n	      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n	      for (idx = 0; idx < length; idx++) {\n	        if (regexp.test(this.extraHeaders[idx])) {\n	          return true;\n	        }\n	      }\n	    }\n	\n	    return false;\n	  },\n	\n	  toString: function() {\n	    var msg = '', header, length, idx;\n	\n	    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\\r\\n';\n	\n	    for (header in this.headers) {\n	      length = this.headers[header].length;\n	      for (idx = 0; idx < length; idx++) {\n	        msg += header + ': ' + this.headers[header][idx] + '\\r\\n';\n	      }\n	    }\n	\n	    length = this.extraHeaders.length;\n	    for (idx = 0; idx < length; idx++) {\n	      msg += this.extraHeaders[idx].trim() +'\\r\\n';\n	    }\n	\n	    msg += getSupportedHeader(this);\n	    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n	\n	    if(this.body) {\n	      length = SIP.Utils.str_utf8_length(this.body);\n	      msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n	      msg += this.body;\n	    } else {\n	      msg += 'Content-Length: 0\\r\\n\\r\\n';\n	    }\n	\n	    return msg;\n	  }\n	};\n	\n	/**\n	 * @augments SIP\n	 * @class Class for incoming SIP message.\n	 */\n	IncomingMessage = function(){\n	  this.data = null;\n	  this.headers = null;\n	  this.method =  null;\n	  this.via = null;\n	  this.via_branch = null;\n	  this.call_id = null;\n	  this.cseq = null;\n	  this.from = null;\n	  this.from_tag = null;\n	  this.to = null;\n	  this.to_tag = null;\n	  this.body = null;\n	};\n	\n	IncomingMessage.prototype = {\n	  /**\n	  * Insert a header of the given name and value into the last position of the\n	  * header array.\n	  * @param {String} name header name\n	  * @param {String} value header value\n	  */\n	  addHeader: function(name, value) {\n	    var header = { raw: value };\n	\n	    name = SIP.Utils.headerize(name);\n	\n	    if(this.headers[name]) {\n	      this.headers[name].push(header);\n	    } else {\n	      this.headers[name] = [header];\n	    }\n	  },\n	\n	  /**\n	   * Get the value of the given header name at the given position.\n	   * @param {String} name header name\n	   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.\n	   */\n	  getHeader: function(name) {\n	    var header = this.headers[SIP.Utils.headerize(name)];\n	\n	    if(header) {\n	      if(header[0]) {\n	        return header[0].raw;\n	      }\n	    } else {\n	      return;\n	    }\n	  },\n	\n	  /**\n	   * Get the header/s of the given name.\n	   * @param {String} name header name\n	   * @returns {Array} Array with all the headers of the specified name.\n	   */\n	  getHeaders: function(name) {\n	    var idx, length,\n	      header = this.headers[SIP.Utils.headerize(name)],\n	      result = [];\n	\n	    if(!header) {\n	      return [];\n	    }\n	\n	    length = header.length;\n	    for (idx = 0; idx < length; idx++) {\n	      result.push(header[idx].raw);\n	    }\n	\n	    return result;\n	  },\n	\n	  /**\n	   * Verify the existence of the given header.\n	   * @param {String} name header name\n	   * @returns {boolean} true if header with given name exists, false otherwise\n	   */\n	  hasHeader: function(name) {\n	    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;\n	  },\n	\n	  /**\n	  * Parse the given header on the given index.\n	  * @param {String} name header name\n	  * @param {Number} [idx=0] header index\n	  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n	  */\n	  parseHeader: function(name, idx) {\n	    var header, value, parsed;\n	\n	    name = SIP.Utils.headerize(name);\n	\n	    idx = idx || 0;\n	\n	    if(!this.headers[name]) {\n	      this.logger.log('header \"' + name + '\" not present');\n	      return;\n	    } else if(idx >= this.headers[name].length) {\n	      this.logger.log('not so many \"' + name + '\" headers present');\n	      return;\n	    }\n	\n	    header = this.headers[name][idx];\n	    value = header.raw;\n	\n	    if(header.parsed) {\n	      return header.parsed;\n	    }\n	\n	    //substitute '-' by '_' for grammar rule matching.\n	    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));\n	\n	    if(parsed === -1) {\n	      this.headers[name].splice(idx, 1); //delete from headers\n	      this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n	      return;\n	    } else {\n	      header.parsed = parsed;\n	      return parsed;\n	    }\n	  },\n	\n	  /**\n	   * Message Header attribute selector. Alias of parseHeader.\n	   * @param {String} name header name\n	   * @param {Number} [idx=0] header index\n	   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n	   *\n	   * @example\n	   * message.s('via',3).port\n	   */\n	  s: function(name, idx) {\n	    return this.parseHeader(name, idx);\n	  },\n	\n	  /**\n	  * Replace the value of the given header by the value.\n	  * @param {String} name header name\n	  * @param {String} value header value\n	  */\n	  setHeader: function(name, value) {\n	    var header = { raw: value };\n	    this.headers[SIP.Utils.headerize(name)] = [header];\n	  },\n	\n	  toString: function() {\n	    return this.data;\n	  }\n	};\n	\n	/**\n	 * @augments IncomingMessage\n	 * @class Class for incoming SIP request.\n	 */\n	IncomingRequest = function(ua) {\n	  this.logger = ua.getLogger('sip.sipmessage');\n	  this.ua = ua;\n	  this.headers = {};\n	  this.ruri = null;\n	  this.transport = null;\n	  this.server_transaction = null;\n	};\n	IncomingRequest.prototype = new IncomingMessage();\n	\n	/**\n	* Stateful reply.\n	* @param {Number} code status code\n	* @param {String} reason reason phrase\n	* @param {Object} headers extra headers\n	* @param {String} body body\n	* @param {Function} [onSuccess] onSuccess callback\n	* @param {Function} [onFailure] onFailure callback\n	*/\n	IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {\n	  var rr, vias, length, idx, response,\n	    to = this.getHeader('To'),\n	    r = 0,\n	    v = 0;\n	\n	  response = SIP.Utils.buildStatusLine(code, reason);\n	  extraHeaders = (extraHeaders || []).slice();\n	\n	  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {\n	    rr = this.getHeaders('record-route');\n	    length = rr.length;\n	\n	    for(r; r < length; r++) {\n	      response += 'Record-Route: ' + rr[r] + '\\r\\n';\n	    }\n	  }\n	\n	  vias = this.getHeaders('via');\n	  length = vias.length;\n	\n	  for(v; v < length; v++) {\n	    response += 'Via: ' + vias[v] + '\\r\\n';\n	  }\n	\n	  if(!this.to_tag && code > 100) {\n	    to += ';tag=' + SIP.Utils.newTag();\n	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n	    to += ';tag=' + this.to_tag;\n	  }\n	\n	  response += 'To: ' + to + '\\r\\n';\n	  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n	  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n	\n	  length = extraHeaders.length;\n	  for (idx = 0; idx < length; idx++) {\n	    response += extraHeaders[idx].trim() +'\\r\\n';\n	  }\n	\n	  response += getSupportedHeader(this);\n	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n	\n	  if(body) {\n	    length = SIP.Utils.str_utf8_length(body);\n	    response += 'Content-Type: application/sdp\\r\\n';\n	    response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n	    response += body;\n	  } else {\n	    response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n	  }\n	\n	  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);\n	\n	  return response;\n	};\n	\n	/**\n	* Stateless reply.\n	* @param {Number} code status code\n	* @param {String} reason reason phrase\n	*/\n	IncomingRequest.prototype.reply_sl = function(code, reason) {\n	  var to, response,\n	    v = 0,\n	    vias = this.getHeaders('via'),\n	    length = vias.length;\n	\n	  response = SIP.Utils.buildStatusLine(code, reason);\n	\n	  for(v; v < length; v++) {\n	    response += 'Via: ' + vias[v] + '\\r\\n';\n	  }\n	\n	  to = this.getHeader('To');\n	\n	  if(!this.to_tag && code > 100) {\n	    to += ';tag=' + SIP.Utils.newTag();\n	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n	    to += ';tag=' + this.to_tag;\n	  }\n	\n	  response += 'To: ' + to + '\\r\\n';\n	  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n	  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n	  response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n	\n	  this.transport.send(response);\n	};\n	\n	\n	/**\n	 * @augments IncomingMessage\n	 * @class Class for incoming SIP response.\n	 */\n	IncomingResponse = function(ua) {\n	  this.logger = ua.getLogger('sip.sipmessage');\n	  this.headers = {};\n	  this.status_code = null;\n	  this.reason_phrase = null;\n	};\n	IncomingResponse.prototype = new IncomingMessage();\n	\n	SIP.OutgoingRequest = OutgoingRequest;\n	SIP.IncomingRequest = IncomingRequest;\n	SIP.IncomingResponse = IncomingResponse;\n	};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP URI\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP URI.\n	 *\n	 * @param {String} [scheme]\n	 * @param {String} [user]\n	 * @param {String} host\n	 * @param {String} [port]\n	 * @param {Object} [parameters]\n	 * @param {Object} [headers]\n	 *\n	 */\n	module.exports = function (SIP) {\n	var URI;\n	\n	URI = function(scheme, user, host, port, parameters, headers) {\n	  var param, header, raw, normal;\n	\n	  // Checks\n	  if(!host) {\n	    throw new TypeError('missing or invalid \"host\" parameter');\n	  }\n	\n	  // Initialize parameters\n	  scheme = scheme || SIP.C.SIP;\n	  this.parameters = {};\n	  this.headers = {};\n	\n	  for (param in parameters) {\n	    this.setParam(param, parameters[param]);\n	  }\n	\n	  for (header in headers) {\n	    this.setHeader(header, headers[header]);\n	  }\n	\n	  // Raw URI\n	  raw = {\n	    scheme: scheme,\n	    user: user,\n	    host: host,\n	    port: port\n	  };\n	\n	  // Normalized URI\n	  normal = {\n	    scheme: scheme.toLowerCase(),\n	    user: user,\n	    host: host.toLowerCase(),\n	    port: port\n	  };\n	\n	  Object.defineProperties(this, {\n	    _normal: {\n	      get: function() { return normal; }\n	    },\n	\n	    _raw: {\n	      get: function() { return raw; }\n	    },\n	\n	    scheme: {\n	      get: function() { return normal.scheme; },\n	      set: function(value) {\n	        raw.scheme = value;\n	        normal.scheme = value.toLowerCase();\n	      }\n	    },\n	\n	    user: {\n	      get: function() { return normal.user; },\n	      set: function(value) {\n	        normal.user = raw.user = value;\n	      }\n	    },\n	\n	    host: {\n	      get: function() { return normal.host; },\n	      set: function(value) {\n	        raw.host = value;\n	        normal.host = value.toLowerCase();\n	      }\n	    },\n	\n	    aor: {\n	      get: function() { return normal.user + '@' + normal.host; }\n	    },\n	\n	    port: {\n	      get: function() { return normal.port; },\n	      set: function(value) {\n	        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);\n	      }\n	    }\n	  });\n	};\n	\n	URI.prototype = {\n	  setParam: function(key, value) {\n	    if(key) {\n	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();\n	    }\n	  },\n	\n	  getParam: function(key) {\n	    if(key) {\n	      return this.parameters[key.toLowerCase()];\n	    }\n	  },\n	\n	  hasParam: function(key) {\n	    if(key) {\n	      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n	    }\n	  },\n	\n	  deleteParam: function(parameter) {\n	    var value;\n	    parameter = parameter.toLowerCase();\n	    if (this.parameters.hasOwnProperty(parameter)) {\n	      value = this.parameters[parameter];\n	      delete this.parameters[parameter];\n	      return value;\n	    }\n	  },\n	\n	  clearParams: function() {\n	    this.parameters = {};\n	  },\n	\n	  setHeader: function(name, value) {\n	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n	  },\n	\n	  getHeader: function(name) {\n	    if(name) {\n	      return this.headers[SIP.Utils.headerize(name)];\n	    }\n	  },\n	\n	  hasHeader: function(name) {\n	    if(name) {\n	      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;\n	    }\n	  },\n	\n	  deleteHeader: function(header) {\n	    var value;\n	    header = SIP.Utils.headerize(header);\n	    if(this.headers.hasOwnProperty(header)) {\n	      value = this.headers[header];\n	      delete this.headers[header];\n	      return value;\n	    }\n	  },\n	\n	  clearHeaders: function() {\n	    this.headers = {};\n	  },\n	\n	  clone: function() {\n	    return new URI(\n	      this._raw.scheme,\n	      this._raw.user,\n	      this._raw.host,\n	      this._raw.port,\n	      JSON.parse(JSON.stringify(this.parameters)),\n	      JSON.parse(JSON.stringify(this.headers)));\n	  },\n	\n	  toRaw: function() {\n	    return this._toString(this._raw);\n	  },\n	\n	  toString: function() {\n	    return this._toString(this._normal);\n	  },\n	\n	  _toString: function(uri) {\n	    var header, parameter, idx, uriString, headers = [];\n	\n	    uriString  = uri.scheme + ':';\n	    // add slashes if it's not a sip(s) URI\n	    if (!uri.scheme.toLowerCase().match(\"^sips?$\")) {\n	      uriString += \"//\";\n	    }\n	    if (uri.user) {\n	      uriString += SIP.Utils.escapeUser(uri.user) + '@';\n	    }\n	    uriString += uri.host;\n	    if (uri.port || uri.port === 0) {\n	      uriString += ':' + uri.port;\n	    }\n	\n	    for (parameter in this.parameters) {\n	      uriString += ';' + parameter;\n	\n	      if (this.parameters[parameter] !== null) {\n	        uriString += '='+ this.parameters[parameter];\n	      }\n	    }\n	\n	    for(header in this.headers) {\n	      for(idx in this.headers[header]) {\n	        headers.push(header + '=' + this.headers[header][idx]);\n	      }\n	    }\n	\n	    if (headers.length > 0) {\n	      uriString += '?' + headers.join('&');\n	    }\n	\n	    return uriString;\n	  }\n	};\n	\n	\n	/**\n	  * Parse the given string and returns a SIP.URI instance or undefined if\n	  * it is an invalid URI.\n	  * @public\n	  * @param {String} uri\n	  */\n	URI.parse = function(uri) {\n	  uri = SIP.Grammar.parse(uri,'SIP_URI');\n	\n	  if (uri !== -1) {\n	    return uri;\n	  } else {\n	    return undefined;\n	  }\n	};\n	\n	SIP.URI = URI;\n	};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP NameAddrHeader\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a Name Address SIP header.\n	 *\n	 * @param {SIP.URI} uri\n	 * @param {String} [displayName]\n	 * @param {Object} [parameters]\n	 *\n	 */\n	module.exports = function (SIP) {\n	var NameAddrHeader;\n	\n	NameAddrHeader = function(uri, displayName, parameters) {\n	  var param;\n	\n	  // Checks\n	  if(!uri || !(uri instanceof SIP.URI)) {\n	    throw new TypeError('missing or invalid \"uri\" parameter');\n	  }\n	\n	  // Initialize parameters\n	  this.uri = uri;\n	  this.parameters = {};\n	\n	  for (param in parameters) {\n	    this.setParam(param, parameters[param]);\n	  }\n	\n	  Object.defineProperties(this, {\n	    friendlyName: {\n	      get: function() { return this.displayName || uri.aor; }\n	    },\n	\n	    displayName: {\n	      get: function() { return displayName; },\n	      set: function(value) {\n	        displayName = (value === 0) ? '0' : value;\n	      }\n	    }\n	  });\n	};\n	NameAddrHeader.prototype = {\n	  setParam: function (key, value) {\n	    if(key) {\n	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n	    }\n	  },\n	  getParam: SIP.URI.prototype.getParam,\n	  hasParam: SIP.URI.prototype.hasParam,\n	  deleteParam: SIP.URI.prototype.deleteParam,\n	  clearParams: SIP.URI.prototype.clearParams,\n	\n	  clone: function() {\n	    return new NameAddrHeader(\n	      this.uri.clone(),\n	      this.displayName,\n	      JSON.parse(JSON.stringify(this.parameters)));\n	  },\n	\n	  toString: function() {\n	    var body, parameter;\n	\n	    body  = (this.displayName || this.displayName === 0) ? '\"' + this.displayName + '\" ' : '';\n	    body += '<' + this.uri.toString() + '>';\n	\n	    for (parameter in this.parameters) {\n	      body += ';' + parameter;\n	\n	      if (this.parameters[parameter] !== null) {\n	        body += '='+ this.parameters[parameter];\n	      }\n	    }\n	\n	    return body;\n	  }\n	};\n	\n	\n	/**\n	  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n	  * it is an invalid NameAddrHeader.\n	  * @public\n	  * @param {String} name_addr_header\n	  */\n	NameAddrHeader.parse = function(name_addr_header) {\n	  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');\n	\n	  if (name_addr_header !== -1) {\n	    return name_addr_header;\n	  } else {\n	    return undefined;\n	  }\n	};\n	\n	SIP.NameAddrHeader = NameAddrHeader;\n	};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Transactions\n	 */\n	\n	/**\n	 * SIP Transactions module.\n	 * @augments SIP\n	 */\n	module.exports = function (SIP) {\n	var\n	  C = {\n	    // Transaction states\n	    STATUS_TRYING:     1,\n	    STATUS_PROCEEDING: 2,\n	    STATUS_CALLING:    3,\n	    STATUS_ACCEPTED:   4,\n	    STATUS_COMPLETED:  5,\n	    STATUS_TERMINATED: 6,\n	    STATUS_CONFIRMED:  7,\n	\n	    // Transaction types\n	    NON_INVITE_CLIENT: 'nict',\n	    NON_INVITE_SERVER: 'nist',\n	    INVITE_CLIENT: 'ict',\n	    INVITE_SERVER: 'ist'\n	  };\n	\n	function buildViaHeader (request_sender, transport, id) {\n	  var via;\n	  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n	  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;\n	  if (request_sender.ua.configuration.forceRport) {\n	    via += ';rport';\n	  }\n	  return via;\n	}\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Non Invite Client Transaction\n	* @param {SIP.RequestSender} request_sender\n	* @param {SIP.OutgoingRequest} request\n	* @param {SIP.Transport} transport\n	*/\n	var NonInviteClientTransaction = function(request_sender, request, transport) {\n	  var via;\n	\n	  this.type = C.NON_INVITE_CLIENT;\n	  this.transport = transport;\n	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n	  this.request_sender = request_sender;\n	  this.request = request;\n	\n	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n	\n	  via = buildViaHeader(request_sender, transport, this.id);\n	  this.request.setHeader('via', via);\n	\n	  this.request_sender.ua.newTransaction(this);\n	};\n	NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	NonInviteClientTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	NonInviteClientTransaction.prototype.send = function() {\n	  var tr = this;\n	\n	  this.stateChanged(C.STATUS_TRYING);\n	  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n	\n	  if(!this.transport.send(this.request)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	NonInviteClientTransaction.prototype.onTransportError = function() {\n	  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n	  SIP.Timers.clearTimeout(this.F);\n	  SIP.Timers.clearTimeout(this.K);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	  this.request_sender.onTransportError();\n	};\n	\n	NonInviteClientTransaction.prototype.timer_F = function() {\n	  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	  this.request_sender.onRequestTimeout();\n	};\n	\n	NonInviteClientTransaction.prototype.timer_K = function() {\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	};\n	\n	NonInviteClientTransaction.prototype.receiveResponse = function(response) {\n	  var\n	    tr = this,\n	    status_code = response.status_code;\n	\n	  if(status_code < 200) {\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_PROCEEDING);\n	        this.request_sender.receiveResponse(response);\n	        break;\n	    }\n	  } else {\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_COMPLETED);\n	        SIP.Timers.clearTimeout(this.F);\n	\n	        if(status_code === 408) {\n	          this.request_sender.onRequestTimeout();\n	        } else {\n	          this.request_sender.receiveResponse(response);\n	        }\n	\n	        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n	        break;\n	      case C.STATUS_COMPLETED:\n	        break;\n	    }\n	  }\n	};\n	\n	\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Invite Client Transaction\n	* @param {SIP.RequestSender} request_sender\n	* @param {SIP.OutgoingRequest} request\n	* @param {SIP.Transport} transport\n	*/\n	var InviteClientTransaction = function(request_sender, request, transport) {\n	  var via,\n	    tr = this;\n	\n	  this.type = C.INVITE_CLIENT;\n	  this.transport = transport;\n	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n	  this.request_sender = request_sender;\n	  this.request = request;\n	\n	  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n	\n	  via = buildViaHeader(request_sender, transport, this.id);\n	  this.request.setHeader('via', via);\n	\n	  this.request_sender.ua.newTransaction(this);\n	\n	  // Add the cancel property to the request.\n	  //Will be called from the request instance, not the transaction itself.\n	  this.request.cancel = function(reason) {\n	    tr.cancel_request(tr, reason);\n	  };\n	};\n	InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	InviteClientTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	InviteClientTransaction.prototype.send = function() {\n	  var tr = this;\n	  this.stateChanged(C.STATUS_CALLING);\n	  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n	\n	  if(!this.transport.send(this.request)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	InviteClientTransaction.prototype.onTransportError = function() {\n	  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n	  SIP.Timers.clearTimeout(this.B);\n	  SIP.Timers.clearTimeout(this.D);\n	  SIP.Timers.clearTimeout(this.M);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	\n	  if (this.state !== C.STATUS_ACCEPTED) {\n	    this.request_sender.onTransportError();\n	  }\n	};\n	\n	// RFC 6026 7.2\n	InviteClientTransaction.prototype.timer_M = function() {\n	  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);\n	\n	  if(this.state === C.STATUS_ACCEPTED) {\n	    SIP.Timers.clearTimeout(this.B);\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.request_sender.ua.destroyTransaction(this);\n	  }\n	};\n	\n	// RFC 3261 17.1.1\n	InviteClientTransaction.prototype.timer_B = function() {\n	  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);\n	  if(this.state === C.STATUS_CALLING) {\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.request_sender.ua.destroyTransaction(this);\n	    this.request_sender.onRequestTimeout();\n	  }\n	};\n	\n	InviteClientTransaction.prototype.timer_D = function() {\n	  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);\n	  SIP.Timers.clearTimeout(this.B);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.request_sender.ua.destroyTransaction(this);\n	};\n	\n	InviteClientTransaction.prototype.sendACK = function(response) {\n	  var tr = this;\n	\n	  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\\r\\n';\n	  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\\r\\n';\n	\n	  if(this.request.headers['Route']) {\n	    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\\r\\n';\n	  }\n	\n	  this.ack += 'To: ' + response.getHeader('to') + '\\r\\n';\n	  this.ack += 'From: ' + this.request.headers['From'].toString() + '\\r\\n';\n	  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\\r\\n';\n	  this.ack += 'Content-Length: 0\\r\\n';\n	  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];\n	  this.ack += ' ACK\\r\\n\\r\\n';\n	\n	  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);\n	\n	  this.transport.send(this.ack);\n	};\n	\n	InviteClientTransaction.prototype.cancel_request = function(tr, reason) {\n	  var request = tr.request;\n	\n	  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n	  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n	\n	  if(this.request.headers['Route']) {\n	    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n	  }\n	\n	  this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n	  this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n	  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n	  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +\n	  ' CANCEL\\r\\n';\n	\n	  if(reason) {\n	    this.cancel += 'Reason: ' + reason + '\\r\\n';\n	  }\n	\n	  this.cancel += 'Content-Length: 0\\r\\n\\r\\n';\n	\n	  // Send only if a provisional response (>100) has been received.\n	  if(this.state === C.STATUS_PROCEEDING) {\n	    this.transport.send(this.cancel);\n	  }\n	};\n	\n	InviteClientTransaction.prototype.receiveResponse = function(response) {\n	  var\n	  tr = this,\n	  status_code = response.status_code;\n	\n	  if(status_code >= 100 && status_code <= 199) {\n	    switch(this.state) {\n	      case C.STATUS_CALLING:\n	        this.stateChanged(C.STATUS_PROCEEDING);\n	        this.request_sender.receiveResponse(response);\n	        if(this.cancel) {\n	          this.transport.send(this.cancel);\n	        }\n	        break;\n	      case C.STATUS_PROCEEDING:\n	        this.request_sender.receiveResponse(response);\n	        break;\n	    }\n	  } else if(status_code >= 200 && status_code <= 299) {\n	    switch(this.state) {\n	      case C.STATUS_CALLING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_ACCEPTED);\n	        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n	        this.request_sender.receiveResponse(response);\n	        break;\n	      case C.STATUS_ACCEPTED:\n	        this.request_sender.receiveResponse(response);\n	        break;\n	    }\n	  } else if(status_code >= 300 && status_code <= 699) {\n	    switch(this.state) {\n	      case C.STATUS_CALLING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_COMPLETED);\n	        this.sendACK(response);\n	        this.request_sender.receiveResponse(response);\n	        break;\n	      case C.STATUS_COMPLETED:\n	        this.sendACK(response);\n	        break;\n	    }\n	  }\n	};\n	\n	\n	/**\n	 * @augments SIP.Transactions\n	 * @class ACK Client Transaction\n	 * @param {SIP.RequestSender} request_sender\n	 * @param {SIP.OutgoingRequest} request\n	 * @param {SIP.Transport} transport\n	 */\n	var AckClientTransaction = function(request_sender, request, transport) {\n	  var via;\n	\n	  this.transport = transport;\n	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n	  this.request_sender = request_sender;\n	  this.request = request;\n	\n	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n	\n	  via = buildViaHeader(request_sender, transport, this.id);\n	  this.request.setHeader('via', via);\n	};\n	AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	AckClientTransaction.prototype.send = function() {\n	  if(!this.transport.send(this.request)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	AckClientTransaction.prototype.onTransportError = function() {\n	  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n	  this.request_sender.onTransportError();\n	};\n	\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Non Invite Server Transaction\n	* @param {SIP.IncomingRequest} request\n	* @param {SIP.UA} ua\n	*/\n	var NonInviteServerTransaction = function(request, ua) {\n	  this.type = C.NON_INVITE_SERVER;\n	  this.id = request.via_branch;\n	  this.request = request;\n	  this.transport = request.transport;\n	  this.ua = ua;\n	  this.last_response = '';\n	  request.server_transaction = this;\n	\n	  this.logger = ua.getLogger('sip.transaction.nist', this.id);\n	\n	  this.state = C.STATUS_TRYING;\n	\n	  ua.newTransaction(this);\n	};\n	NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	NonInviteServerTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	NonInviteServerTransaction.prototype.timer_J = function() {\n	  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.ua.destroyTransaction(this);\n	};\n	\n	NonInviteServerTransaction.prototype.onTransportError = function() {\n	  if (!this.transportError) {\n	    this.transportError = true;\n	\n	    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n	\n	    SIP.Timers.clearTimeout(this.J);\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.ua.destroyTransaction(this);\n	  }\n	};\n	\n	NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n	  var tr = this;\n	  var deferred = SIP.Utils.defer();\n	\n	  if(status_code === 100) {\n	    /* RFC 4320 4.1\n	     * 'A SIP element MUST NOT\n	     * send any provisional response with a\n	     * Status-Code other than 100 to a non-INVITE request.'\n	     */\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	        this.stateChanged(C.STATUS_PROCEEDING);\n	        if(!this.transport.send(response))  {\n	          this.onTransportError();\n	        }\n	        break;\n	      case C.STATUS_PROCEEDING:\n	        this.last_response = response;\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	          deferred.reject();\n	        } else {\n	          deferred.resolve();\n	        }\n	        break;\n	    }\n	  } else if(status_code >= 200 && status_code <= 699) {\n	    switch(this.state) {\n	      case C.STATUS_TRYING:\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_COMPLETED);\n	        this.last_response = response;\n	        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	          deferred.reject();\n	        } else {\n	          deferred.resolve();\n	        }\n	        break;\n	      case C.STATUS_COMPLETED:\n	        break;\n	    }\n	  }\n	\n	  return deferred.promise;\n	};\n	\n	/**\n	* @augments SIP.Transactions\n	* @class Invite Server Transaction\n	* @param {SIP.IncomingRequest} request\n	* @param {SIP.UA} ua\n	*/\n	var InviteServerTransaction = function(request, ua) {\n	  this.type = C.INVITE_SERVER;\n	  this.id = request.via_branch;\n	  this.request = request;\n	  this.transport = request.transport;\n	  this.ua = ua;\n	  this.last_response = '';\n	  request.server_transaction = this;\n	\n	  this.logger = ua.getLogger('sip.transaction.ist', this.id);\n	\n	  this.state = C.STATUS_PROCEEDING;\n	\n	  ua.newTransaction(this);\n	\n	  this.resendProvisionalTimer = null;\n	\n	  request.reply(100);\n	};\n	InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	InviteServerTransaction.prototype.stateChanged = function(state) {\n	  this.state = state;\n	  this.emit('stateChanged');\n	};\n	\n	InviteServerTransaction.prototype.timer_H = function() {\n	  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);\n	\n	  if(this.state === C.STATUS_COMPLETED) {\n	    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n	  }\n	\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.ua.destroyTransaction(this);\n	};\n	\n	InviteServerTransaction.prototype.timer_I = function() {\n	  this.stateChanged(C.STATUS_TERMINATED);\n	  this.ua.destroyTransaction(this);\n	};\n	\n	// RFC 6026 7.1\n	InviteServerTransaction.prototype.timer_L = function() {\n	  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);\n	\n	  if(this.state === C.STATUS_ACCEPTED) {\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.ua.destroyTransaction(this);\n	  }\n	};\n	\n	InviteServerTransaction.prototype.onTransportError = function() {\n	  if (!this.transportError) {\n	    this.transportError = true;\n	\n	    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n	\n	    if (this.resendProvisionalTimer !== null) {\n	      SIP.Timers.clearInterval(this.resendProvisionalTimer);\n	      this.resendProvisionalTimer = null;\n	    }\n	\n	    SIP.Timers.clearTimeout(this.L);\n	    SIP.Timers.clearTimeout(this.H);\n	    SIP.Timers.clearTimeout(this.I);\n	\n	    this.stateChanged(C.STATUS_TERMINATED);\n	    this.ua.destroyTransaction(this);\n	  }\n	};\n	\n	InviteServerTransaction.prototype.resend_provisional = function() {\n	  if(!this.transport.send(this.last_response)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	// INVITE Server Transaction RFC 3261 17.2.1\n	InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {\n	  var tr = this;\n	  var deferred = SIP.Utils.defer();\n	\n	  if(status_code >= 100 && status_code <= 199) {\n	    switch(this.state) {\n	      case C.STATUS_PROCEEDING:\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	        }\n	        this.last_response = response;\n	        break;\n	    }\n	  }\n	\n	  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n	    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n	    if(this.resendProvisionalTimer === null) {\n	      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),\n	        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n	    }\n	  } else if(status_code >= 200 && status_code <= 299) {\n	    switch(this.state) {\n	      case C.STATUS_PROCEEDING:\n	        this.stateChanged(C.STATUS_ACCEPTED);\n	        this.last_response = response;\n	        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n	\n	        if (this.resendProvisionalTimer !== null) {\n	          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n	          this.resendProvisionalTimer = null;\n	        }\n	        /* falls through */\n	        case C.STATUS_ACCEPTED:\n	          // Note that this point will be reached for proceeding tr.state also.\n	          if(!this.transport.send(response)) {\n	            this.onTransportError();\n	            deferred.reject();\n	          } else {\n	            deferred.resolve();\n	          }\n	          break;\n	    }\n	  } else if(status_code >= 300 && status_code <= 699) {\n	    switch(this.state) {\n	      case C.STATUS_PROCEEDING:\n	        if (this.resendProvisionalTimer !== null) {\n	          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n	          this.resendProvisionalTimer = null;\n	        }\n	\n	        if(!this.transport.send(response)) {\n	          this.onTransportError();\n	          deferred.reject();\n	        } else {\n	          this.stateChanged(C.STATUS_COMPLETED);\n	          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n	          deferred.resolve();\n	        }\n	        break;\n	    }\n	  }\n	\n	  return deferred.promise;\n	};\n	\n	/**\n	 * @function\n	 * @param {SIP.UA} ua\n	 * @param {SIP.IncomingRequest} request\n	 *\n	 * @return {boolean}\n	 * INVITE:\n	 *  _true_ if retransmission\n	 *  _false_ new request\n	 *\n	 * ACK:\n	 *  _true_  ACK to non2xx response\n	 *  _false_ ACK must be passed to TU (accepted state)\n	 *          ACK to 2xx response\n	 *\n	 * CANCEL:\n	 *  _true_  no matching invite transaction\n	 *  _false_ matching invite transaction and no final response sent\n	 *\n	 * OTHER:\n	 *  _true_  retransmission\n	 *  _false_ new request\n	 */\n	var checkTransaction = function(ua, request) {\n	  var tr;\n	\n	  switch(request.method) {\n	    case SIP.C.INVITE:\n	      tr = ua.transactions.ist[request.via_branch];\n	      if(tr) {\n	        switch(tr.state) {\n	          case C.STATUS_PROCEEDING:\n	            tr.transport.send(tr.last_response);\n	            break;\n	\n	            // RFC 6026 7.1 Invite retransmission\n	            //received while in C.STATUS_ACCEPTED state. Absorb it.\n	          case C.STATUS_ACCEPTED:\n	            break;\n	        }\n	        return true;\n	      }\n	      break;\n	    case SIP.C.ACK:\n	      tr = ua.transactions.ist[request.via_branch];\n	\n	      // RFC 6026 7.1\n	      if(tr) {\n	        if(tr.state === C.STATUS_ACCEPTED) {\n	          return false;\n	        } else if(tr.state === C.STATUS_COMPLETED) {\n	          tr.state = C.STATUS_CONFIRMED;\n	          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n	          return true;\n	        }\n	      }\n	\n	      // ACK to 2XX Response.\n	      else {\n	        return false;\n	      }\n	      break;\n	    case SIP.C.CANCEL:\n	      tr = ua.transactions.ist[request.via_branch];\n	      if(tr) {\n	        request.reply_sl(200);\n	        if(tr.state === C.STATUS_PROCEEDING) {\n	          return false;\n	        } else {\n	          return true;\n	        }\n	      } else {\n	        request.reply_sl(481);\n	        return true;\n	      }\n	      break;\n	    default:\n	\n	      // Non-INVITE Server Transaction RFC 3261 17.2.2\n	      tr = ua.transactions.nist[request.via_branch];\n	      if(tr) {\n	        switch(tr.state) {\n	          case C.STATUS_TRYING:\n	            break;\n	          case C.STATUS_PROCEEDING:\n	          case C.STATUS_COMPLETED:\n	            tr.transport.send(tr.last_response);\n	            break;\n	        }\n	        return true;\n	      }\n	      break;\n	  }\n	};\n	\n	SIP.Transactions = {\n	  C: C,\n	  checkTransaction: checkTransaction,\n	  NonInviteClientTransaction: NonInviteClientTransaction,\n	  InviteClientTransaction: InviteClientTransaction,\n	  AckClientTransaction: AckClientTransaction,\n	  NonInviteServerTransaction: NonInviteServerTransaction,\n	  InviteServerTransaction: InviteServerTransaction\n	};\n	\n	};\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview SIP Dialog\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP dialog.\n	 * @param {SIP.RTCSession} owner\n	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message\n	 * @param {Enum} type UAC / UAS\n	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED\n	 */\n	module.exports = function (SIP) {\n	\n	var RequestSender = __webpack_require__(31)(SIP);\n	\n	var Dialog,\n	  C = {\n	    // Dialog states\n	    STATUS_EARLY:       1,\n	    STATUS_CONFIRMED:   2\n	  };\n	\n	// RFC 3261 12.1\n	Dialog = function(owner, message, type, state) {\n	  var contact;\n	\n	  this.uac_pending_reply = false;\n	  this.uas_pending_reply = false;\n	\n	  if(!message.hasHeader('contact')) {\n	    return {\n	      error: 'unable to create a Dialog without Contact header field'\n	    };\n	  }\n	\n	  if(message instanceof SIP.IncomingResponse) {\n	    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n	  } else {\n	    // Create confirmed dialog if state is not defined\n	    state = state || C.STATUS_CONFIRMED;\n	  }\n	\n	  contact = message.parseHeader('contact');\n	\n	  // RFC 3261 12.1.1\n	  if(type === 'UAS') {\n	    this.id = {\n	      call_id: message.call_id,\n	      local_tag: message.to_tag,\n	      remote_tag: message.from_tag,\n	      toString: function() {\n	        return this.call_id + this.local_tag + this.remote_tag;\n	      }\n	    };\n	    this.state = state;\n	    this.remote_seqnum = message.cseq;\n	    this.local_uri = message.parseHeader('to').uri;\n	    this.remote_uri = message.parseHeader('from').uri;\n	    this.remote_target = contact.uri;\n	    this.route_set = message.getHeaders('record-route');\n	    this.invite_seqnum = message.cseq;\n	    this.local_seqnum = message.cseq;\n	  }\n	  // RFC 3261 12.1.2\n	  else if(type === 'UAC') {\n	    this.id = {\n	      call_id: message.call_id,\n	      local_tag: message.from_tag,\n	      remote_tag: message.to_tag,\n	      toString: function() {\n	        return this.call_id + this.local_tag + this.remote_tag;\n	      }\n	    };\n	    this.state = state;\n	    this.invite_seqnum = message.cseq;\n	    this.local_seqnum = message.cseq;\n	    this.local_uri = message.parseHeader('from').uri;\n	    this.pracked = [];\n	    this.remote_uri = message.parseHeader('to').uri;\n	    this.remote_target = contact.uri;\n	    this.route_set = message.getHeaders('record-route').reverse();\n	\n	    //RENDERBODY\n	    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {\n	      this.mediaHandler = owner.mediaHandlerFactory(owner);\n	    }\n	  }\n	\n	  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());\n	  this.owner = owner;\n	  owner.ua.dialogs[this.id.toString()] = this;\n	  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));\n	  owner.emit('dialog', this);\n	};\n	\n	Dialog.prototype = {\n	  /**\n	   * @param {SIP.IncomingMessage} message\n	   * @param {Enum} UAC/UAS\n	   */\n	  update: function(message, type) {\n	    this.state = C.STATUS_CONFIRMED;\n	\n	    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');\n	\n	    if(type === 'UAC') {\n	      // RFC 3261 13.2.2.4\n	      this.route_set = message.getHeaders('record-route').reverse();\n	    }\n	  },\n	\n	  terminate: function() {\n	    this.logger.log('dialog ' + this.id.toString() + ' deleted');\n	    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {\n	      this.mediaHandler.peerConnection.close();\n	    }\n	    delete this.owner.ua.dialogs[this.id.toString()];\n	  },\n	\n	  /**\n	  * @param {String} method request method\n	  * @param {Object} extraHeaders extra headers\n	  * @returns {SIP.OutgoingRequest}\n	  */\n	\n	  // RFC 3261 12.2.1.1\n	  createRequest: function(method, extraHeaders, body) {\n	    var cseq, request;\n	    extraHeaders = (extraHeaders || []).slice();\n	\n	    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }\n	\n	    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;\n	\n	    request = new SIP.OutgoingRequest(\n	      method,\n	      this.remote_target,\n	      this.owner.ua, {\n	        'cseq': cseq,\n	        'call_id': this.id.call_id,\n	        'from_uri': this.local_uri,\n	        'from_tag': this.id.local_tag,\n	        'to_uri': this.remote_uri,\n	        'to_tag': this.id.remote_tag,\n	        'route_set': this.route_set\n	      }, extraHeaders, body);\n	\n	    request.dialog = this;\n	\n	    return request;\n	  },\n	\n	  /**\n	  * @param {SIP.IncomingRequest} request\n	  * @returns {Boolean}\n	  */\n	\n	  // RFC 3261 12.2.2\n	  checkInDialogRequest: function(request) {\n	    var self = this;\n	\n	    if(!this.remote_seqnum) {\n	      this.remote_seqnum = request.cseq;\n	    } else if(request.cseq < this.remote_seqnum) {\n	        //Do not try to reply to an ACK request.\n	        if (request.method !== SIP.C.ACK) {\n	          request.reply(500);\n	        }\n	        if (request.cseq === this.invite_seqnum) {\n	          return true;\n	        }\n	        return false;\n	    } else if(request.cseq > this.remote_seqnum) {\n	      this.remote_seqnum = request.cseq;\n	    }\n	\n	    switch(request.method) {\n	      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-\n	      case SIP.C.INVITE:\n	        if (this.uac_pending_reply === true) {\n	          request.reply(491);\n	        } else if (this.uas_pending_reply === true) {\n	          var retryAfter = (Math.random() * 10 | 0) + 1;\n	          request.reply(500, null, ['Retry-After:' + retryAfter]);\n	          return false;\n	        } else {\n	          this.uas_pending_reply = true;\n	          request.server_transaction.on('stateChanged', function stateChanged(){\n	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n	                this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n	                this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n	\n	              this.removeListener('stateChanged', stateChanged);\n	              self.uas_pending_reply = false;\n	\n	              if (self.uac_pending_reply === false) {\n	                self.owner.onReadyToReinvite();\n	              }\n	            }\n	          });\n	        }\n	\n	        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted\n	        if(request.hasHeader('contact')) {\n	          request.server_transaction.on('stateChanged', function(){\n	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {\n	              self.remote_target = request.parseHeader('contact').uri;\n	            }\n	          });\n	        }\n	        break;\n	      case SIP.C.NOTIFY:\n	        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted\n	        if(request.hasHeader('contact')) {\n	          request.server_transaction.on('stateChanged', function(){\n	            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {\n	              self.remote_target = request.parseHeader('contact').uri;\n	            }\n	          });\n	        }\n	        break;\n	    }\n	\n	    return true;\n	  },\n	\n	  sendRequest: function(applicant, method, options) {\n	    options = options || {};\n	\n	    var\n	      extraHeaders = (options.extraHeaders || []).slice(),\n	      body = options.body || null,\n	      request = this.createRequest(method, extraHeaders, body),\n	      request_sender = new RequestSender(this, applicant, request);\n	\n	    request_sender.send();\n	\n	    return request;\n	  },\n	\n	  /**\n	  * @param {SIP.IncomingRequest} request\n	  */\n	  receiveRequest: function(request) {\n	    //Check in-dialog request\n	    if(!this.checkInDialogRequest(request)) {\n	      return;\n	    }\n	\n	    this.owner.receiveRequest(request);\n	  }\n	};\n	\n	Dialog.C = C;\n	SIP.Dialog = Dialog;\n	};\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview In-Dialog Request Sender\n	 */\n	\n	/**\n	 * @augments SIP.Dialog\n	 * @class Class creating an In-dialog request sender.\n	 * @param {SIP.Dialog} dialog\n	 * @param {Object} applicant\n	 * @param {SIP.OutgoingRequest} request\n	 */\n	/**\n	 * @fileoverview in-Dialog Request Sender\n	 */\n	\n	module.exports = function (SIP) {\n	var RequestSender;\n	\n	RequestSender = function(dialog, applicant, request) {\n	\n	  this.dialog = dialog;\n	  this.applicant = applicant;\n	  this.request = request;\n	\n	  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n	  this.reattempt = false;\n	  this.reattemptTimer = null;\n	};\n	\n	RequestSender.prototype = {\n	  send: function() {\n	    var self = this,\n	      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);\n	\n	      request_sender.send();\n	\n	    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-\n	    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n	      this.dialog.uac_pending_reply = true;\n	      request_sender.clientTransaction.on('stateChanged', function stateChanged(){\n	        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n	            this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n	            this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n	\n	          this.removeListener('stateChanged', stateChanged);\n	          self.dialog.uac_pending_reply = false;\n	\n	          if (self.dialog.uas_pending_reply === false) {\n	            self.dialog.owner.onReadyToReinvite();\n	          }\n	        }\n	      });\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    this.applicant.onRequestTimeout();\n	  },\n	\n	  onTransportError: function() {\n	    this.applicant.onTransportError();\n	  },\n	\n	  receiveResponse: function(response) {\n	    var self = this;\n	\n	    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n	    if (response.status_code === 408 || response.status_code === 481) {\n	      this.applicant.onDialogError(response);\n	    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {\n	      if (this.reattempt) {\n	        this.applicant.receiveResponse(response);\n	      } else {\n	        this.request.cseq.value = this.dialog.local_seqnum += 1;\n	        this.reattemptTimer = SIP.Timers.setTimeout(\n	          function() {\n	            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {\n	              self.reattempt = true;\n	              self.request_sender.send();\n	            }\n	          },\n	          this.getReattemptTimeout()\n	        );\n	      }\n	    } else {\n	      this.applicant.receiveResponse(response);\n	    }\n	  }\n	};\n	\n	return RequestSender;\n	};\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview Request Sender\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a request sender.\n	 * @param {Object} applicant\n	 * @param {SIP.UA} ua\n	 */\n	module.exports = function (SIP) {\n	var RequestSender;\n	\n	RequestSender = function(applicant, ua) {\n	  this.logger = ua.getLogger('sip.requestsender');\n	  this.ua = ua;\n	  this.applicant = applicant;\n	  this.method = applicant.request.method;\n	  this.request = applicant.request;\n	  this.credentials = null;\n	  this.challenged = false;\n	  this.staled = false;\n	\n	  // If ua is in closing process or even closed just allow sending Bye and ACK\n	  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n	    this.onTransportError();\n	  }\n	};\n	\n	/**\n	* Create the client transaction and send the message.\n	*/\n	RequestSender.prototype = {\n	  send: function() {\n	    switch(this.method) {\n	      case \"INVITE\":\n	        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n	        break;\n	      case \"ACK\":\n	        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n	        break;\n	      default:\n	        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n	    }\n	    this.clientTransaction.send();\n	\n	    return this.clientTransaction;\n	  },\n	\n	  /**\n	  * Callback fired when receiving a request timeout error from the client transaction.\n	  * To be re-defined by the applicant.\n	  * @event\n	  */\n	  onRequestTimeout: function() {\n	    this.applicant.onRequestTimeout();\n	  },\n	\n	  /**\n	  * Callback fired when receiving a transport error from the client transaction.\n	  * To be re-defined by the applicant.\n	  * @event\n	  */\n	  onTransportError: function() {\n	    this.applicant.onTransportError();\n	  },\n	\n	  /**\n	  * Called from client transaction when receiving a correct response to the request.\n	  * Authenticate request if needed or pass the response back to the applicant.\n	  * @param {SIP.IncomingResponse} response\n	  */\n	  receiveResponse: function(response) {\n	    var cseq, challenge, authorization_header_name,\n	      status_code = response.status_code;\n	\n	    /*\n	    * Authentication\n	    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n	    */\n	    if (status_code === 401 || status_code === 407) {\n	\n	      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n	      if (response.status_code === 401) {\n	        challenge = response.parseHeader('www-authenticate');\n	        authorization_header_name = 'authorization';\n	      } else {\n	        challenge = response.parseHeader('proxy-authenticate');\n	        authorization_header_name = 'proxy-authorization';\n	      }\n	\n	      // Verify it seems a valid challenge.\n	      if (! challenge) {\n	        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n	        this.applicant.receiveResponse(response);\n	        return;\n	      }\n	\n	      if (!this.challenged || (!this.staled && challenge.stale === true)) {\n	        if (!this.credentials) {\n	          this.credentials = this.ua.configuration.authenticationFactory(this.ua);\n	        }\n	\n	        // Verify that the challenge is really valid.\n	        if (!this.credentials.authenticate(this.request, challenge)) {\n	          this.applicant.receiveResponse(response);\n	          return;\n	        }\n	        this.challenged = true;\n	\n	        if (challenge.stale) {\n	          this.staled = true;\n	        }\n	\n	        if (response.method === SIP.C.REGISTER) {\n	          cseq = this.applicant.cseq += 1;\n	        } else if (this.request.dialog){\n	          cseq = this.request.dialog.local_seqnum += 1;\n	        } else {\n	          cseq = this.request.cseq + 1;\n	          this.request.cseq = cseq;\n	        }\n	        this.request.setHeader('cseq', cseq +' '+ this.method);\n	\n	        this.request.setHeader(authorization_header_name, this.credentials.toString());\n	        this.send();\n	      } else {\n	        this.applicant.receiveResponse(response);\n	      }\n	    } else {\n	      this.applicant.receiveResponse(response);\n	    }\n	  }\n	};\n	\n	SIP.RequestSender = RequestSender;\n	};\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	module.exports = function (SIP) {\n	\n	var RegisterContext;\n	\n	RegisterContext = function (ua) {\n	  var params = {},\n	      regId = 1;\n	\n	  this.registrar = ua.configuration.registrarServer;\n	  this.expires = ua.configuration.registerExpires;\n	\n	\n	  // Contact header\n	  this.contact = ua.contact.toString();\n	\n	  if(regId) {\n	    this.contact += ';reg-id='+ regId;\n	    this.contact += ';+sip.instance=\"<urn:uuid:'+ ua.configuration.instanceId+'>\"';\n	  }\n	\n	  // Call-ID and CSeq values RFC3261 10.2\n	  this.call_id = SIP.Utils.createRandomToken(22);\n	  this.cseq = 80;\n	\n	  this.to_uri = ua.configuration.uri;\n	\n	  params.to_uri = this.to_uri;\n	  params.to_displayName = ua.configuration.displayName;\n	  params.call_id = this.call_id;\n	  params.cseq = this.cseq;\n	\n	  // Extends ClientContext\n	  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);\n	\n	  this.registrationTimer = null;\n	  this.registrationExpiredTimer = null;\n	\n	  // Set status\n	  this.registered = false;\n	\n	  this.logger = ua.getLogger('sip.registercontext');\n	};\n	\n	RegisterContext.prototype = {\n	  register: function (options) {\n	    var self = this, extraHeaders;\n	\n	    // Handle Options\n	    this.options = options || {};\n	    extraHeaders = (this.options.extraHeaders || []).slice();\n	    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n	    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	    // Save original extraHeaders to be used in .close\n	    this.closeHeaders = this.options.closeWithHeaders ?\n	      (this.options.extraHeaders || []).slice() : [];\n	\n	    this.receiveResponse = function(response) {\n	      var contact, expires,\n	        contacts = response.getHeaders('contact').length,\n	        cause;\n	\n	      // Discard responses to older REGISTER/un-REGISTER requests.\n	      if(response.cseq !== this.cseq) {\n	        return;\n	      }\n	\n	      // Clear registration timer\n	      if (this.registrationTimer !== null) {\n	        SIP.Timers.clearTimeout(this.registrationTimer);\n	        this.registrationTimer = null;\n	      }\n	\n	      switch(true) {\n	        case /^1[0-9]{2}$/.test(response.status_code):\n	          this.emit('progress', response);\n	          break;\n	        case /^2[0-9]{2}$/.test(response.status_code):\n	          this.emit('accepted', response);\n	\n	          if(response.hasHeader('expires')) {\n	            expires = response.getHeader('expires');\n	          }\n	\n	          if (this.registrationExpiredTimer !== null) {\n	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n	            this.registrationExpiredTimer = null;\n	          }\n	\n	          // Search the Contact pointing to us and update the expires value accordingly.\n	          if (!contacts) {\n	            this.logger.warn('no Contact header in response to REGISTER, response ignored');\n	            break;\n	          }\n	\n	          while(contacts--) {\n	            contact = response.parseHeader('contact', contacts);\n	            if(contact.uri.user === this.ua.contact.uri.user) {\n	              expires = contact.getParam('expires');\n	              break;\n	            } else {\n	              contact = null;\n	            }\n	          }\n	\n	          if (!contact) {\n	            this.logger.warn('no Contact header pointing to us, response ignored');\n	            break;\n	          }\n	\n	          if(!expires) {\n	            expires = this.expires;\n	          }\n	\n	          // Re-Register before the expiration interval has elapsed.\n	          // For that, decrease the expires value. ie: 3 seconds\n	          this.registrationTimer = SIP.Timers.setTimeout(function() {\n	            self.registrationTimer = null;\n	            self.register(self.options);\n	          }, (expires * 1000) - 3000);\n	          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n	            self.logger.warn('registration expired');\n	            if (self.registered) {\n	              self.unregistered(null, SIP.C.causes.EXPIRES);\n	            }\n	          }, expires * 1000);\n	\n	          //Save gruu values\n	          if (contact.hasParam('temp-gruu')) {\n	            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g,''));\n	          }\n	          if (contact.hasParam('pub-gruu')) {\n	            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g,''));\n	          }\n	\n	          this.registered = true;\n	          this.emit('registered', response || null);\n	          break;\n	        // Interval too brief RFC3261 10.2.8\n	        case /^423$/.test(response.status_code):\n	          if(response.hasHeader('min-expires')) {\n	            // Increase our registration interval to the suggested minimum\n	            this.expires = response.getHeader('min-expires');\n	            // Attempt the registration again immediately\n	            this.register(this.options);\n	          } else { //This response MUST contain a Min-Expires header field\n	            this.logger.warn('423 response received for REGISTER without Min-Expires');\n	            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n	          }\n	          break;\n	        default:\n	          cause = SIP.Utils.sipErrorCause(response.status_code);\n	          this.registrationFailure(response, cause);\n	      }\n	    };\n	\n	    this.onRequestTimeout = function() {\n	      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    };\n	\n	    this.onTransportError = function() {\n	      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n	    };\n	\n	    this.cseq++;\n	    this.request.cseq = this.cseq;\n	    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n	    this.request.extraHeaders = extraHeaders;\n	    this.send();\n	  },\n	\n	  registrationFailure: function (response, cause) {\n	    this.emit('failed', response || null, cause || null);\n	  },\n	\n	  onTransportClosed: function() {\n	    this.registered_before = this.registered;\n	    if (this.registrationTimer !== null) {\n	      SIP.Timers.clearTimeout(this.registrationTimer);\n	      this.registrationTimer = null;\n	    }\n	\n	    if (this.registrationExpiredTimer !== null) {\n	      SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n	      this.registrationExpiredTimer = null;\n	    }\n	\n	    if(this.registered) {\n	      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onTransportConnected: function() {\n	    this.register(this.options);\n	  },\n	\n	  close: function() {\n	    var options = {\n	      all: false,\n	      extraHeaders: this.closeHeaders\n	    };\n	\n	    this.registered_before = this.registered;\n	    this.unregister(options);\n	  },\n	\n	  unregister: function(options) {\n	    var extraHeaders;\n	\n	    options = options || {};\n	\n	    if(!this.registered && !options.all) {\n	      this.logger.warn('already unregistered');\n	      return;\n	    }\n	\n	    extraHeaders = (options.extraHeaders || []).slice();\n	\n	    this.registered = false;\n	\n	    // Clear the registration timer.\n	    if (this.registrationTimer !== null) {\n	      SIP.Timers.clearTimeout(this.registrationTimer);\n	      this.registrationTimer = null;\n	    }\n	\n	    if(options.all) {\n	      extraHeaders.push('Contact: *');\n	      extraHeaders.push('Expires: 0');\n	    } else {\n	      extraHeaders.push('Contact: '+ this.contact + ';expires=0');\n	    }\n	\n	\n	    this.receiveResponse = function(response) {\n	      var cause;\n	\n	      switch(true) {\n	        case /^1[0-9]{2}$/.test(response.status_code):\n	          this.emit('progress', response);\n	          break;\n	        case /^2[0-9]{2}$/.test(response.status_code):\n	          this.emit('accepted', response);\n	          if (this.registrationExpiredTimer !== null) {\n	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n	            this.registrationExpiredTimer = null;\n	          }\n	          this.unregistered(response);\n	          break;\n	        default:\n	          cause = SIP.Utils.sipErrorCause(response.status_code);\n	          this.unregistered(response,cause);\n	      }\n	    };\n	\n	    this.onRequestTimeout = function() {\n	      // Not actually unregistered...\n	      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    };\n	\n	    this.onTransportError = function() {\n	      // Not actually unregistered...\n	      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n	    };\n	\n	    this.cseq++;\n	    this.request.cseq = this.cseq;\n	    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n	    this.request.extraHeaders = extraHeaders;\n	\n	    this.send();\n	  },\n	\n	  unregistered: function(response, cause) {\n	    this.registered = false;\n	    this.emit('unregistered', response || null, cause || null);\n	  }\n	\n	};\n	\n	\n	SIP.RegisterContext = RegisterContext;\n	};\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview MediaHandler\n	 */\n	\n	/* MediaHandler\n	 * @class PeerConnection helper Class.\n	 * @param {SIP.Session} session\n	 * @param {Object} [options]\n	 */\n	module.exports = function (EventEmitter) {\n	var MediaHandler = function(session, options) {\n	  // keep jshint happy\n	  session = session;\n	  options = options;\n	};\n	\n	MediaHandler.prototype = Object.create(EventEmitter.prototype, {\n	  isReady: {value: function isReady () {}},\n	\n	  close: {value: function close () {}},\n	\n	  /**\n	   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.\n	   */\n	  getDescription: {value: function getDescription (mediaHint) {\n	    // keep jshint happy\n	    mediaHint = mediaHint;\n	  }},\n	\n	  /**\n	  * Message reception.\n	  * @param {String} type\n	  * @param {String} description\n	  */\n	  setDescription: {value: function setDescription (description) {\n	    // keep jshint happy\n	    description = description;\n	  }}\n	});\n	\n	return MediaHandler;\n	};\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	module.exports = function (SIP) {\n	var ClientContext;\n	\n	ClientContext = function (ua, method, target, options) {\n	  var originalTarget = target;\n	\n	  // Validate arguments\n	  if (target === undefined) {\n	    throw new TypeError('Not enough arguments');\n	  }\n	\n	  this.ua = ua;\n	  this.logger = ua.getLogger('sip.clientcontext');\n	  this.method = method;\n	  target = ua.normalizeTarget(target);\n	  if (!target) {\n	    throw new TypeError('Invalid target: ' + originalTarget);\n	  }\n	\n	  /* Options\n	   * - extraHeaders\n	   * - params\n	   * - contentType\n	   * - body\n	   */\n	  options = Object.create(options || Object.prototype);\n	  options.extraHeaders = (options.extraHeaders || []).slice();\n	\n	  if (options.contentType) {\n	    this.contentType = options.contentType;\n	    options.extraHeaders.push('Content-Type: ' + this.contentType);\n	  }\n	\n	  // Build the request\n	  this.request = new SIP.OutgoingRequest(this.method,\n	                                         target,\n	                                         this.ua,\n	                                         options.params,\n	                                         options.extraHeaders);\n	  if (options.body) {\n	    this.body = options.body;\n	    this.request.body = this.body;\n	  }\n	\n	  /* Set other properties from the request */\n	  this.localIdentity = this.request.from;\n	  this.remoteIdentity = this.request.to;\n	\n	  this.data = {};\n	};\n	ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	ClientContext.prototype.send = function () {\n	  (new SIP.RequestSender(this, this.ua)).send();\n	  return this;\n	};\n	\n	ClientContext.prototype.cancel = function (options) {\n	  options = options || {};\n	\n	  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n	  this.request.cancel(cancel_reason);\n	\n	  this.emit('cancel');\n	};\n	\n	ClientContext.prototype.receiveResponse = function (response) {\n	  var cause = SIP.Utils.getReasonPhrase(response.status_code);\n	\n	  switch(true) {\n	    case /^1[0-9]{2}$/.test(response.status_code):\n	      this.emit('progress', response, cause);\n	      break;\n	\n	    case /^2[0-9]{2}$/.test(response.status_code):\n	      if(this.ua.applicants[this]) {\n	        delete this.ua.applicants[this];\n	      }\n	      this.emit('accepted', response, cause);\n	      break;\n	\n	    default:\n	      if(this.ua.applicants[this]) {\n	        delete this.ua.applicants[this];\n	      }\n	      this.emit('rejected', response, cause);\n	      this.emit('failed', response, cause);\n	      break;\n	  }\n	\n	};\n	\n	ClientContext.prototype.onRequestTimeout = function () {\n	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n	};\n	\n	ClientContext.prototype.onTransportError = function () {\n	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n	};\n	\n	SIP.ClientContext = ClientContext;\n	};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	module.exports = function (SIP) {\n	var ServerContext;\n	\n	ServerContext = function (ua, request) {\n	  this.ua = ua;\n	  this.logger = ua.getLogger('sip.servercontext');\n	  this.request = request;\n	  if (request.method === SIP.C.INVITE) {\n	    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);\n	  } else {\n	    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);\n	  }\n	\n	  if (request.body) {\n	    this.body = request.body;\n	  }\n	  if (request.hasHeader('Content-Type')) {\n	    this.contentType = request.getHeader('Content-Type');\n	  }\n	  this.method = request.method;\n	\n	  this.data = {};\n	\n	  this.localIdentity = request.to;\n	  this.remoteIdentity = request.from;\n	};\n	\n	ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	ServerContext.prototype.progress = function (options) {\n	  options = Object.create(options || Object.prototype);\n	  options.statusCode || (options.statusCode = 180);\n	  options.minCode = 100;\n	  options.maxCode = 199;\n	  options.events = ['progress'];\n	  return this.reply(options);\n	};\n	\n	ServerContext.prototype.accept = function (options) {\n	  options = Object.create(options || Object.prototype);\n	  options.statusCode || (options.statusCode = 200);\n	  options.minCode = 200;\n	  options.maxCode = 299;\n	  options.events = ['accepted'];\n	  return this.reply(options);\n	};\n	\n	ServerContext.prototype.reject = function (options) {\n	  options = Object.create(options || Object.prototype);\n	  options.statusCode || (options.statusCode = 480);\n	  options.minCode = 300;\n	  options.maxCode = 699;\n	  options.events = ['rejected', 'failed'];\n	  return this.reply(options);\n	};\n	\n	ServerContext.prototype.reply = function (options) {\n	  options = options || {}; // This is okay, so long as we treat options as read-only in this method\n	  var\n	    statusCode = options.statusCode || 100,\n	    minCode = options.minCode || 100,\n	    maxCode = options.maxCode || 699,\n	    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),\n	    extraHeaders = options.extraHeaders || [],\n	    body = options.body,\n	    events = options.events || [],\n	    response;\n	\n	  if (statusCode < minCode || statusCode > maxCode) {\n	    throw new TypeError('Invalid statusCode: ' + statusCode);\n	  }\n	  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n	  events.forEach(function (event) {\n	    this.emit(event, response, reasonPhrase);\n	  }, this);\n	\n	  return this;\n	};\n	\n	ServerContext.prototype.onRequestTimeout = function () {\n	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n	};\n	\n	ServerContext.prototype.onTransportError = function () {\n	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n	};\n	\n	SIP.ServerContext = ServerContext;\n	};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	module.exports = function (SIP, environment) {\n	\n	var DTMF = __webpack_require__(38)(SIP);\n	\n	var Session, InviteServerContext, InviteClientContext,\n	 C = {\n	    //Session states\n	    STATUS_NULL:                        0,\n	    STATUS_INVITE_SENT:                 1,\n	    STATUS_1XX_RECEIVED:                2,\n	    STATUS_INVITE_RECEIVED:             3,\n	    STATUS_WAITING_FOR_ANSWER:          4,\n	    STATUS_ANSWERED:                    5,\n	    STATUS_WAITING_FOR_PRACK:           6,\n	    STATUS_WAITING_FOR_ACK:             7,\n	    STATUS_CANCELED:                    8,\n	    STATUS_TERMINATED:                  9,\n	    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n	    STATUS_EARLY_MEDIA:                11,\n	    STATUS_CONFIRMED:                  12\n	  };\n	\n	/*\n	 * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]\n	 *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)\n	 */\n	Session = function (mediaHandlerFactory) {\n	  this.status = C.STATUS_NULL;\n	  this.dialog = null;\n	  this.earlyDialogs = {};\n	  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;\n	  // this.mediaHandler gets set by ICC/ISC constructors\n	  this.hasOffer = false;\n	  this.hasAnswer = false;\n	\n	  // Session Timers\n	  this.timers = {\n	    ackTimer: null,\n	    expiresTimer: null,\n	    invite2xxTimer: null,\n	    userNoAnswerTimer: null,\n	    rel1xxTimer: null,\n	    prackTimer: null\n	  };\n	\n	  // Session info\n	  this.startTime = null;\n	  this.endTime = null;\n	  this.tones = null;\n	\n	  // Mute/Hold state\n	  this.local_hold = false;\n	  this.remote_hold = false;\n	\n	  this.pending_actions = {\n	    actions: [],\n	\n	    length: function() {\n	      return this.actions.length;\n	    },\n	\n	    isPending: function(name){\n	      var\n	      idx = 0,\n	      length = this.actions.length;\n	\n	      for (idx; idx<length; idx++) {\n	        if (this.actions[idx].name === name) {\n	          return true;\n	        }\n	      }\n	      return false;\n	    },\n	\n	    shift: function() {\n	      return this.actions.shift();\n	    },\n	\n	    push: function(name) {\n	      this.actions.push({\n	        name: name\n	      });\n	    },\n	\n	    pop: function(name) {\n	      var\n	      idx = 0,\n	      length = this.actions.length;\n	\n	      for (idx; idx<length; idx++) {\n	        if (this.actions[idx].name === name) {\n	          this.actions.splice(idx,1);\n	          length --;\n	          idx--;\n	        }\n	      }\n	    }\n	   };\n	\n	  this.early_sdp = null;\n	  this.rel100 = SIP.C.supported.UNSUPPORTED;\n	};\n	\n	Session.prototype = {\n	  dtmf: function(tones, options) {\n	    var tone, dtmfs = [],\n	        self = this;\n	\n	    options = options || {};\n	\n	    if (tones === undefined) {\n	      throw new TypeError('Not enough arguments');\n	    }\n	\n	    // Check Session Status\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    // Check tones\n	    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n	      throw new TypeError('Invalid tones: '+ tones);\n	    }\n	\n	    tones = tones.toString().split('');\n	\n	    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }\n	\n	    if (this.tones) {\n	      // Tones are already queued, just add to the queue\n	      this.tones =  this.tones.concat(dtmfs);\n	      return this;\n	    }\n	\n	    var sendDTMF = function () {\n	      var dtmf, timeout;\n	\n	      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n	        // Stop sending DTMF\n	        self.tones = null;\n	        return this;\n	      }\n	\n	      dtmf = self.tones.shift();\n	\n	      if (tone === ',') {\n	        timeout = 2000;\n	      } else {\n	        dtmf.on('failed', function(){self.tones = null;});\n	        dtmf.send(options);\n	        timeout = dtmf.duration + dtmf.interToneGap;\n	      }\n	\n	      // Set timeout for the next tone\n	      SIP.Timers.setTimeout(sendDTMF, timeout);\n	    };\n	\n	    this.tones = dtmfs;\n	    sendDTMF();\n	    return this;\n	  },\n	\n	  bye: function(options) {\n	    options = Object.create(options || Object.prototype);\n	    var statusCode = options.statusCode;\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_TERMINATED) {\n	      this.logger.error('Error: Attempted to send BYE in a terminated session.');\n	      return this;\n	    }\n	\n	    this.logger.log('terminating Session');\n	\n	    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n	      throw new TypeError('Invalid statusCode: '+ statusCode);\n	    }\n	\n	    options.receiveResponse = function () {};\n	\n	    return this.\n	      sendRequest(SIP.C.BYE, options).\n	      terminated();\n	  },\n	\n	  refer: function(target, options) {\n	    options = options || {};\n	    var extraHeaders = (options.extraHeaders || []).slice(),\n	        withReplaces =\n	          target instanceof SIP.InviteServerContext ||\n	          target instanceof SIP.InviteClientContext,\n	        originalTarget = target;\n	\n	    if (target === undefined) {\n	      throw new TypeError('Not enough arguments');\n	    }\n	\n	    // Check Session Status\n	    if (this.status !== C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    // transform `target` so that it can be a Refer-To header value\n	    if (withReplaces) {\n	      //Attended Transfer\n	      // B.transfer(C)\n	      target = '\"' + target.remoteIdentity.friendlyName + '\" ' +\n	        '<' + target.dialog.remote_target.toString() +\n	        '?Replaces=' + target.dialog.id.call_id +\n	        '%3Bto-tag%3D' + target.dialog.id.remote_tag +\n	        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';\n	    } else {\n	      //Blind Transfer\n	      // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n	      // so try to make one ahead of time\n	      try {\n	        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n	      } catch (e) {\n	        this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n	        this.logger.debug(\"...falling through to normalizeTarget()\");\n	      }\n	\n	      // Check target validity\n	      target = this.ua.normalizeTarget(target);\n	      if (!target) {\n	        throw new TypeError('Invalid target: ' + originalTarget);\n	      }\n	    }\n	\n	    extraHeaders.push('Contact: '+ this.contact);\n	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	    extraHeaders.push('Refer-To: '+ target);\n	\n	    // Send the request\n	    this.sendRequest(SIP.C.REFER, {\n	      extraHeaders: extraHeaders,\n	      body: options.body,\n	      receiveResponse: function (response) {\n	        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {\n	          return;\n	        }\n	        // hang up only if we transferred to a SIP address\n	        if (withReplaces || (target.scheme && target.scheme.match(\"^sips?$\"))) {\n	          this.terminate();\n	        }\n	      }.bind(this)\n	    });\n	    return this;\n	  },\n	\n	  followRefer: function followRefer (callback) {\n	    return function referListener (callback, request) {\n	      // open non-SIP URIs if possible and keep session open\n	      var referTo = request.parseHeader('refer-to');\n	      var target = referTo.uri;\n	      if (!target.scheme.match(\"^sips?$\")) {\n	        var targetString = target.toString();\n	        if (typeof environment.open === \"function\") {\n	          environment.open(targetString);\n	        } else {\n	          this.logger.warn(\"referred to non-SIP URI but `open` isn't in the environment: \" + targetString);\n	        }\n	        return;\n	      }\n	\n	      var extraHeaders = [];\n	\n	      /* Copy the Replaces query into a Replaces header */\n	      /* TODO - make sure we don't copy a poorly formatted header? */\n	      var replaces = target.getHeader('Replaces');\n	      if (replaces !== undefined) {\n	        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));\n	      }\n	\n	      // don't embed headers into Request-URI of INVITE\n	      target.clearHeaders();\n	\n	      /*\n	        Harmless race condition.  Both sides of REFER\n	        may send a BYE, but in the end the dialogs are destroyed.\n	      */\n	      var getReferMedia = this.mediaHandler.getReferMedia;\n	      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;\n	\n	      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);\n	\n	      var referSession = this.ua.invite(target, {\n	        media: mediaHint,\n	        params: {\n	          to_displayName: referTo.friendlyName\n	        },\n	        extraHeaders: extraHeaders\n	      });\n	\n	      callback.call(this, request, referSession);\n	\n	      this.terminate();\n	    }.bind(this, callback);\n	  },\n	\n	  sendRequest: function(method,options) {\n	    options = options || {};\n	    var self = this;\n	\n	    var request = new SIP.OutgoingRequest(\n	      method,\n	      this.dialog.remote_target,\n	      this.ua,\n	      {\n	        cseq: options.cseq || (this.dialog.local_seqnum += 1),\n	        call_id: this.dialog.id.call_id,\n	        from_uri: this.dialog.local_uri,\n	        from_tag: this.dialog.id.local_tag,\n	        to_uri: this.dialog.remote_uri,\n	        to_tag: this.dialog.id.remote_tag,\n	        route_set: this.dialog.route_set,\n	        statusCode: options.statusCode,\n	        reasonPhrase: options.reasonPhrase\n	      },\n	      options.extraHeaders || [],\n	      options.body\n	    );\n	\n	    new SIP.RequestSender({\n	      request: request,\n	      onRequestTimeout: function() {\n	        self.onRequestTimeout();\n	      },\n	      onTransportError: function() {\n	        self.onTransportError();\n	      },\n	      receiveResponse: options.receiveResponse || function(response) {\n	        self.receiveNonInviteResponse(response);\n	      }\n	    }, this.ua).send();\n	\n	    // Emit the request event\n	    this.emit(method.toLowerCase(), request);\n	\n	    return this;\n	  },\n	\n	  close: function() {\n	    var idx;\n	\n	    if(this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    this.logger.log('closing INVITE session ' + this.id);\n	\n	    // 1st Step. Terminate media.\n	    if (this.mediaHandler){\n	      this.mediaHandler.close();\n	    }\n	\n	    // 2nd Step. Terminate signaling.\n	\n	    // Clear session timers\n	    for(idx in this.timers) {\n	      SIP.Timers.clearTimeout(this.timers[idx]);\n	    }\n	\n	    // Terminate dialogs\n	\n	    // Terminate confirmed dialog\n	    if(this.dialog) {\n	      this.dialog.terminate();\n	      delete this.dialog;\n	    }\n	\n	    // Terminate early dialogs\n	    for(idx in this.earlyDialogs) {\n	      this.earlyDialogs[idx].terminate();\n	      delete this.earlyDialogs[idx];\n	    }\n	\n	    this.status = C.STATUS_TERMINATED;\n	\n	    delete this.ua.sessions[this.id];\n	    return this;\n	  },\n	\n	  createDialog: function(message, type, early) {\n	    var dialog, early_dialog,\n	      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],\n	      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],\n	      id = message.call_id + local_tag + remote_tag;\n	\n	    early_dialog = this.earlyDialogs[id];\n	\n	    // Early Dialog\n	    if (early) {\n	      if (early_dialog) {\n	        return true;\n	      } else {\n	        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);\n	\n	        // Dialog has been successfully created.\n	        if(early_dialog.error) {\n	          this.logger.error(early_dialog.error);\n	          this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n	          return false;\n	        } else {\n	          this.earlyDialogs[id] = early_dialog;\n	          return true;\n	        }\n	      }\n	    }\n	    // Confirmed Dialog\n	    else {\n	      // In case the dialog is in _early_ state, update it\n	      if (early_dialog) {\n	        early_dialog.update(message, type);\n	        this.dialog = early_dialog;\n	        delete this.earlyDialogs[id];\n	        for (var dia in this.earlyDialogs) {\n	          this.earlyDialogs[dia].terminate();\n	          delete this.earlyDialogs[dia];\n	        }\n	        return true;\n	      }\n	\n	      // Otherwise, create a _confirmed_ dialog\n	      dialog = new SIP.Dialog(this, message, type);\n	\n	      if(dialog.error) {\n	        this.logger.error(dialog.error);\n	        this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n	        return false;\n	      } else {\n	        this.to_tag = message.to_tag;\n	        this.dialog = dialog;\n	        return true;\n	      }\n	    }\n	  },\n	\n	  /**\n	  * Check if Session is ready for a re-INVITE\n	  *\n	  * @returns {Boolean}\n	  */\n	  isReadyToReinvite: function() {\n	    return this.mediaHandler.isReady() &&\n	      !this.dialog.uac_pending_reply &&\n	      !this.dialog.uas_pending_reply;\n	  },\n	\n	  /**\n	   * Mute\n	   */\n	  mute: function(options) {\n	    var ret = this.mediaHandler.mute(options);\n	    if (ret) {\n	      this.onmute(ret);\n	    }\n	  },\n	\n	  /**\n	   * Unmute\n	   */\n	  unmute: function(options) {\n	    var ret = this.mediaHandler.unmute(options);\n	    if (ret) {\n	      this.onunmute(ret);\n	    }\n	  },\n	\n	  /**\n	   * Hold\n	   */\n	  hold: function() {\n	\n	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.mediaHandler.hold();\n	\n	    // Check if RTCSession is ready to send a reINVITE\n	    if (!this.isReadyToReinvite()) {\n	      /* If there is a pending 'unhold' action, cancel it and don't queue this one\n	       * Else, if there isn't any 'hold' action, add this one to the queue\n	       * Else, if there is already a 'hold' action, skip\n	       */\n	      if (this.pending_actions.isPending('unhold')) {\n	        this.pending_actions.pop('unhold');\n	      } else if (!this.pending_actions.isPending('hold')) {\n	        this.pending_actions.push('hold');\n	      }\n	      return;\n	    } else if (this.local_hold === true) {\n	        return;\n	    }\n	\n	    this.onhold('local');\n	\n	    this.sendReinvite({\n	      mangle: function(body){\n	\n	        // Don't receive media\n	        // TODO - This will break for media streams with different directions.\n	        if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {\n	          body = body.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n	        } else {\n	          body = body.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n	          body = body.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n	        }\n	\n	        return body;\n	      }\n	    });\n	  },\n	\n	  /**\n	   * Unhold\n	   */\n	  unhold: function() {\n	\n	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.mediaHandler.unhold();\n	\n	    if (!this.isReadyToReinvite()) {\n	      /* If there is a pending 'hold' action, cancel it and don't queue this one\n	       * Else, if there isn't any 'unhold' action, add this one to the queue\n	       * Else, if there is already a 'unhold' action, skip\n	       */\n	      if (this.pending_actions.isPending('hold')) {\n	        this.pending_actions.pop('hold');\n	      } else if (!this.pending_actions.isPending('unhold')) {\n	        this.pending_actions.push('unhold');\n	      }\n	      return;\n	    } else if (this.local_hold === false) {\n	      return;\n	    }\n	\n	    this.onunhold('local');\n	\n	    this.sendReinvite();\n	  },\n	\n	  /**\n	   * isOnHold\n	   */\n	  isOnHold: function() {\n	    return {\n	      local: this.local_hold,\n	      remote: this.remote_hold\n	    };\n	  },\n	\n	  /**\n	   * In dialog INVITE Reception\n	   * @private\n	   */\n	  receiveReinvite: function(request) {\n	    var self = this;\n	\n	    if (!request.body) {\n	      return;\n	    }\n	\n	    if (request.getHeader('Content-Type') !== 'application/sdp') {\n	      this.logger.warn('invalid Content-Type');\n	      request.reply(415);\n	      return;\n	    }\n	\n	    this.mediaHandler.setDescription(request.body)\n	    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n	    .then(function(body) {\n	      request.reply(200, null, ['Contact: ' + self.contact], body,\n	        function() {\n	          self.status = C.STATUS_WAITING_FOR_ACK;\n	          self.setInvite2xxTimer(request, body);\n	          self.setACKTimer();\n	\n	          // Are we holding?\n	          var hold = (/a=(sendonly|inactive)/).test(request.body);\n	\n	          if (self.remote_hold && !hold) {\n	            self.onunhold('remote');\n	          } else if (!self.remote_hold && hold) {\n	            self.onhold('remote');\n	          }\n	        });\n	    })\n	    .catch(function onFailure (e) {\n	      var statusCode;\n	      if (e instanceof SIP.Exceptions.GetDescriptionError) {\n	        statusCode = 500;\n	      } else {\n	        self.logger.error(e);\n	        statusCode = 488;\n	      }\n	      request.reply(statusCode);\n	    });\n	  },\n	\n	  sendReinvite: function(options) {\n	    options = options || {};\n	\n	    var\n	      self = this,\n	       extraHeaders = (options.extraHeaders || []).slice(),\n	       eventHandlers = options.eventHandlers || {},\n	       mangle = options.mangle || null;\n	\n	    if (eventHandlers.succeeded) {\n	      this.reinviteSucceeded = eventHandlers.succeeded;\n	    } else {\n	      this.reinviteSucceeded = function(){\n	        SIP.Timers.clearTimeout(self.timers.ackTimer);\n	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n	        self.status = C.STATUS_CONFIRMED;\n	      };\n	    }\n	    if (eventHandlers.failed) {\n	      this.reinviteFailed = eventHandlers.failed;\n	    } else {\n	      this.reinviteFailed = function(){};\n	    }\n	\n	    extraHeaders.push('Contact: ' + this.contact);\n	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	    extraHeaders.push('Content-Type: application/sdp');\n	\n	    this.receiveResponse = this.receiveReinviteResponse;\n	    //REVISIT\n	    this.mediaHandler.getDescription(self.mediaHint)\n	    .then(mangle)\n	    .then(\n	      function(body){\n	        self.dialog.sendRequest(self, SIP.C.INVITE, {\n	          extraHeaders: extraHeaders,\n	          body: body\n	        });\n	      },\n	      function() {\n	        if (self.isReadyToReinvite()) {\n	          self.onReadyToReinvite();\n	        }\n	        self.reinviteFailed();\n	      }\n	    );\n	  },\n	\n	  receiveRequest: function (request) {\n	    switch (request.method) {\n	      case SIP.C.BYE:\n	        request.reply(200);\n	        if(this.status === C.STATUS_CONFIRMED) {\n	          this.emit('bye', request);\n	          this.terminated(request, SIP.C.causes.BYE);\n	        }\n	        break;\n	      case SIP.C.INVITE:\n	        if(this.status === C.STATUS_CONFIRMED) {\n	          this.logger.log('re-INVITE received');\n	          this.receiveReinvite(request);\n	        }\n	        break;\n	      case SIP.C.INFO:\n	        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {\n	          var body, tone, duration,\n	              contentType = request.getHeader('content-type'),\n	              reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/,\n	              reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n	\n	          if (contentType) {\n	            if (contentType.match(/^application\\/dtmf-relay/i)) {\n	              if (request.body) {\n	                body = request.body.split('\\r\\n', 2);\n	                if (body.length === 2) {\n	                  if (reg_tone.test(body[0])) {\n	                    tone = body[0].replace(reg_tone,\"$2\");\n	                  }\n	                  if (reg_duration.test(body[1])) {\n	                    duration = parseInt(body[1].replace(reg_duration,\"$2\"), 10);\n	                  }\n	                }\n	              }\n	\n	              new DTMF(this, tone, {duration: duration}).init_incoming(request);\n	            } else {\n	              request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n	            }\n	          }\n	        }\n	        break;\n	      case SIP.C.REFER:\n	        if(this.status ===  C.STATUS_CONFIRMED) {\n	          this.logger.log('REFER received');\n	          request.reply(202, 'Accepted');\n	          var\n	            hasReferListener = this.listeners('refer').length,\n	            notifyBody = hasReferListener ?\n	              'SIP/2.0 100 Trying' :\n	              // RFC 3515.2.4.2: 'the UA MAY decline the request.'\n	              'SIP/2.0 603 Declined'\n	          ;\n	\n	          this.sendRequest(SIP.C.NOTIFY, {\n	            extraHeaders:[\n	              'Event: refer',\n	              'Subscription-State: terminated',\n	              'Content-Type: message/sipfrag'\n	            ],\n	            body: notifyBody,\n	            receiveResponse: function() {}\n	          });\n	\n	          if (hasReferListener) {\n	            this.emit('refer', request);\n	          }\n	        }\n	        break;\n	      case SIP.C.NOTIFY:\n	        request.reply(200, 'OK');\n	        this.emit('notify', request);\n	        break;\n	    }\n	  },\n	\n	  /**\n	   * Reception of Response for in-dialog INVITE\n	   * @private\n	   */\n	  receiveReinviteResponse: function(response) {\n	    var self = this,\n	        contentType = response.getHeader('Content-Type');\n	\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return;\n	    }\n	\n	    switch(true) {\n	      case /^1[0-9]{2}$/.test(response.status_code):\n	        break;\n	      case /^2[0-9]{2}$/.test(response.status_code):\n	        this.status = C.STATUS_CONFIRMED;\n	\n	        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});\n	\n	        if(!response.body) {\n	          this.reinviteFailed();\n	          break;\n	        } else if (contentType !== 'application/sdp') {\n	          this.reinviteFailed();\n	          break;\n	        }\n	\n	        //REVISIT\n	        this.mediaHandler.setDescription(response.body)\n	        .then(\n	          function onSuccess () {\n	            self.reinviteSucceeded();\n	          },\n	          function onFailure () {\n	            self.reinviteFailed();\n	          }\n	        );\n	        break;\n	      default:\n	        this.reinviteFailed();\n	    }\n	  },\n	\n	  acceptAndTerminate: function(response, status_code, reason_phrase) {\n	    var extraHeaders = [];\n	\n	    if (status_code) {\n	      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));\n	    }\n	\n	    // An error on dialog creation will fire 'failed' event\n	    if (this.dialog || this.createDialog(response, 'UAC')) {\n	      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n	      this.sendRequest(SIP.C.BYE, {\n	        extraHeaders: extraHeaders\n	      });\n	    }\n	\n	    return this;\n	  },\n	\n	  /**\n	   * RFC3261 13.3.1.4\n	   * Response retransmissions cannot be accomplished by transaction layer\n	   *  since it is destroyed when receiving the first 2xx answer\n	   */\n	  setInvite2xxTimer: function(request, body) {\n	    var self = this,\n	        timeout = SIP.Timers.T1;\n	\n	    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n	      if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n	        return;\n	      }\n	\n	      self.logger.log('no ACK received, attempting to retransmit OK');\n	\n	      request.reply(200, null, ['Contact: ' + self.contact], body);\n	\n	      timeout = Math.min(timeout * 2, SIP.Timers.T2);\n	\n	      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n	    }, timeout);\n	  },\n	\n	  /**\n	   * RFC3261 14.2\n	   * If a UAS generates a 2xx response and never receives an ACK,\n	   *  it SHOULD generate a BYE to terminate the dialog.\n	   */\n	  setACKTimer: function() {\n	    var self = this;\n	\n	    this.timers.ackTimer = SIP.Timers.setTimeout(function() {\n	      if(self.status === C.STATUS_WAITING_FOR_ACK) {\n	        self.logger.log('no ACK received for an extended period of time, terminating the call');\n	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n	        self.sendRequest(SIP.C.BYE);\n	        self.terminated(null, SIP.C.causes.NO_ACK);\n	      }\n	    }, SIP.Timers.TIMER_H);\n	  },\n	\n	  /*\n	   * @private\n	   */\n	  onReadyToReinvite: function() {\n	    var action = this.pending_actions.shift();\n	\n	    if (!action || !this[action.name]) {\n	      return;\n	    }\n	\n	    this[action.name]();\n	  },\n	\n	  onTransportError: function() {\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    }\n	  },\n	\n	  onDialogError: function(response) {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(response, SIP.C.causes.DIALOG_ERROR);\n	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n	    }\n	  },\n	\n	  /**\n	   * @private\n	   */\n	  onhold: function(originator) {\n	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;\n	    this.emit('hold', { originator: originator });\n	  },\n	\n	  /**\n	   * @private\n	   */\n	  onunhold: function(originator) {\n	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;\n	    this.emit('unhold', { originator: originator });\n	  },\n	\n	  /*\n	   * @private\n	   */\n	  onmute: function(options) {\n	    this.emit('muted', {\n	      audio: options.audio,\n	      video: options.video\n	    });\n	  },\n	\n	  /*\n	   * @private\n	   */\n	  onunmute: function(options) {\n	    this.emit('unmuted', {\n	      audio: options.audio,\n	      video: options.video\n	    });\n	  },\n	\n	  failed: function(response, cause) {\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	    this.emit('failed', response || null, cause || null);\n	    return this;\n	  },\n	\n	  rejected: function(response, cause) {\n	    this.emit('rejected',\n	      response || null,\n	      cause || null\n	    );\n	    return this;\n	  },\n	\n	  canceled: function() {\n	    this.emit('cancel');\n	    return this;\n	  },\n	\n	  accepted: function(response, cause) {\n	    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);\n	\n	    this.startTime = new Date();\n	\n	    if (this.replacee) {\n	      this.replacee.emit('replaced', this);\n	      this.replacee.terminate();\n	    }\n	    this.emit('accepted', response, cause);\n	    return this;\n	  },\n	\n	  terminated: function(message, cause) {\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    this.endTime = new Date();\n	\n	    this.close();\n	    this.emit('terminated',\n	      message || null,\n	      cause || null\n	    );\n	    return this;\n	  },\n	\n	  connecting: function(request) {\n	    this.emit('connecting', { request: request });\n	    return this;\n	  }\n	};\n	\n	Session.desugar = function desugar(options) {\n	  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {\n	    options = {\n	      media: {\n	        constraints: {\n	          audio: true,\n	          video: options.tagName === 'VIDEO'\n	        },\n	        render: {\n	          remote: options\n	        }\n	      }\n	    };\n	  }\n	  return options || {};\n	};\n	\n	\n	Session.C = C;\n	SIP.Session = Session;\n	\n	\n	InviteServerContext = function(ua, request) {\n	  var expires,\n	    self = this,\n	    contentType = request.getHeader('Content-Type'),\n	    contentDisp = request.parseHeader('Content-Disposition');\n	\n	  // Check body and content type\n	  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {\n	    this.renderbody = request.body;\n	    this.rendertype = contentType;\n	  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {\n	    request.reply(415);\n	    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it\n	    return;\n	  }\n	\n	  //TODO: move this into media handler\n	  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n	  SIP.Hacks.AllBrowsers.maskDtls(request);\n	\n	  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n	\n	  this.status = C.STATUS_INVITE_RECEIVED;\n	  this.from_tag = request.from_tag;\n	  this.id = request.call_id + this.from_tag;\n	  this.request = request;\n	  this.contact = this.ua.contact.toString();\n	\n	  this.receiveNonInviteResponse = function () {}; // intentional no-op\n	\n	  this.logger = ua.getLogger('sip.inviteservercontext', this.id);\n	\n	  //Save the session into the ua sessions collection.\n	  this.ua.sessions[this.id] = this;\n	\n	  //Get the Expires header value if exists\n	  if(request.hasHeader('expires')) {\n	    expires = request.getHeader('expires') * 1000;\n	  }\n	\n	  //Set 100rel if necessary\n	  function set100rel(h,c) {\n	    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n	      self.rel100 = c;\n	    }\n	  }\n	  set100rel('require', SIP.C.supported.REQUIRED);\n	  set100rel('supported', SIP.C.supported.SUPPORTED);\n	\n	  /* Set the to_tag before\n	   * replying a response code that will create a dialog.\n	   */\n	  request.to_tag = SIP.Utils.newTag();\n	\n	  // An error on dialog creation will fire 'failed' event\n	  if(!this.createDialog(request, 'UAS', true)) {\n	    request.reply(500, 'Missing Contact header field');\n	    return;\n	  }\n	\n	  //Initialize Media Session\n	  this.mediaHandler = this.mediaHandlerFactory(this, {\n	    RTCConstraints: {\"optional\": [{'DtlsSrtpKeyAgreement': 'true'}]}\n	  });\n	\n	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n	  }\n	\n	  function fireNewSession() {\n	    var options = {extraHeaders: ['Contact: ' + self.contact]};\n	\n	    if (self.rel100 !== SIP.C.supported.REQUIRED) {\n	      self.progress(options);\n	    }\n	    self.status = C.STATUS_WAITING_FOR_ANSWER;\n	\n	    // Set userNoAnswerTimer\n	    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {\n	      request.reply(408);\n	      self.failed(request, SIP.C.causes.NO_ANSWER);\n	      self.terminated(request, SIP.C.causes.NO_ANSWER);\n	    }, self.ua.configuration.noAnswerTimeout);\n	\n	    /* Set expiresTimer\n	     * RFC3261 13.3.1\n	     */\n	    if (expires) {\n	      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {\n	        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {\n	          request.reply(487);\n	          self.failed(request, SIP.C.causes.EXPIRES);\n	          self.terminated(request, SIP.C.causes.EXPIRES);\n	        }\n	      }, expires);\n	    }\n	\n	    self.emit('invite',request);\n	  }\n	\n	  if (!request.body || this.renderbody) {\n	    SIP.Timers.setTimeout(fireNewSession, 0);\n	  } else {\n	    this.hasOffer = true;\n	    this.mediaHandler.setDescription(request.body)\n	    .then(\n	      fireNewSession,\n	      function onFailure (e) {\n	        self.logger.warn('invalid SDP');\n	        self.logger.warn(e);\n	        request.reply(488);\n	      }\n	    );\n	  }\n	};\n	\n	InviteServerContext.prototype = {\n	  reject: function(options) {\n	    // Check Session Status\n	    if (this.status === C.STATUS_TERMINATED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.logger.log('rejecting RTCSession');\n	\n	    SIP.ServerContext.prototype.reject.call(this, options);\n	    return this.terminated();\n	  },\n	\n	  terminate: function(options) {\n	    options = options || {};\n	\n	    var\n	    extraHeaders = (options.extraHeaders || []).slice(),\n	    body = options.body,\n	    dialog,\n	    self = this;\n	\n	    if (this.status === C.STATUS_WAITING_FOR_ACK &&\n	       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n	      dialog = this.dialog;\n	\n	      this.receiveRequest = function(request) {\n	        if (request.method === SIP.C.ACK) {\n	          this.request(SIP.C.BYE, {\n	            extraHeaders: extraHeaders,\n	            body: body\n	          });\n	          dialog.terminate();\n	        }\n	      };\n	\n	      this.request.server_transaction.on('stateChanged', function(){\n	        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n	          this.request = new SIP.OutgoingRequest(\n	            SIP.C.BYE,\n	            this.dialog.remote_target,\n	            this.ua,\n	            {\n	              'cseq': this.dialog.local_seqnum+=1,\n	              'call_id': this.dialog.id.call_id,\n	              'from_uri': this.dialog.local_uri,\n	              'from_tag': this.dialog.id.local_tag,\n	              'to_uri': this.dialog.remote_uri,\n	              'to_tag': this.dialog.id.remote_tag,\n	              'route_set': this.dialog.route_set\n	            },\n	            extraHeaders,\n	            body\n	          );\n	\n	          new SIP.RequestSender(\n	            {\n	              request: this.request,\n	              onRequestTimeout: function() {\n	                self.onRequestTimeout();\n	              },\n	              onTransportError: function() {\n	                self.onTransportError();\n	              },\n	              receiveResponse: function() {\n	                return;\n	              }\n	            },\n	            this.ua\n	          ).send();\n	          dialog.terminate();\n	        }\n	      });\n	\n	      this.emit('bye', this.request);\n	      this.terminated();\n	\n	      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n	      this.dialog = dialog;\n	\n	      // Restore the dialog into 'ua' so the ACK can reach 'this' session\n	      this.ua.dialogs[dialog.id.toString()] = dialog;\n	\n	    } else if (this.status === C.STATUS_CONFIRMED) {\n	      this.bye(options);\n	    } else {\n	      this.reject(options);\n	    }\n	\n	    return this;\n	  },\n	\n	  /*\n	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	   */\n	  progress: function (options) {\n	    options = options || {};\n	    var\n	      statusCode = options.statusCode || 180,\n	      reasonPhrase = options.reasonPhrase,\n	      extraHeaders = (options.extraHeaders || []).slice(),\n	      iceServers,\n	      stunServers = options.stunServers || null,\n	      turnServers = options.turnServers || null,\n	      body = options.body,\n	      response;\n	\n	    if (statusCode < 100 || statusCode > 199) {\n	      throw new TypeError('Invalid statusCode: ' + statusCode);\n	    }\n	\n	    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    if (stunServers || turnServers) {\n	      if (stunServers) {\n	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid stunServers: '+ stunServers);\n	        } else {\n	          this.stunServers = iceServers;\n	        }\n	      }\n	\n	      if (turnServers) {\n	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid turnServers: '+ turnServers);\n	        } else {\n	          this.turnServers = iceServers;\n	        }\n	      }\n	\n	      this.mediaHandler.updateIceServers({\n	        stunServers: this.stunServers,\n	        turnServers: this.turnServers\n	      });\n	    }\n	\n	    function do100rel() {\n	      /* jshint validthis: true */\n	      statusCode = options.statusCode || 183;\n	\n	      // Set status and add extra headers\n	      this.status = C.STATUS_WAITING_FOR_PRACK;\n	      extraHeaders.push('Contact: '+ this.contact);\n	      extraHeaders.push('Require: 100rel');\n	      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));\n	\n	      // Save media hint for later (referred sessions)\n	      this.mediaHint = options.media;\n	\n	      // Get the session description to add to preaccept with\n	      this.mediaHandler.getDescription(options.media)\n	      .then(\n	        function onSuccess (body) {\n	          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n	            return;\n	          }\n	\n	          this.early_sdp = body;\n	          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;\n	\n	          // Retransmit until we get a response or we time out (see prackTimer below)\n	          var timeout = SIP.Timers.T1;\n	          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n	            this.request.reply(statusCode, null, extraHeaders, body);\n	            timeout *= 2;\n	            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n	          }.bind(this), timeout);\n	\n	          // Timeout and reject INVITE if no response\n	          this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n	            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n	              return;\n	            }\n	\n	            this.logger.log('no PRACK received, rejecting the call');\n	            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n	            this.request.reply(504);\n	            this.terminated(null, SIP.C.causes.NO_PRACK);\n	          }.bind(this), SIP.Timers.T1 * 64);\n	\n	          // Send the initial response\n	          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n	          this.emit('progress', response, reasonPhrase);\n	        }.bind(this),\n	\n	        function onFailure () {\n	          this.request.reply(480);\n	          this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	        }.bind(this)\n	      );\n	    } // end do100rel\n	\n	    function normalReply() {\n	      /* jshint validthis:true */\n	      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n	      this.emit('progress', response, reasonPhrase);\n	    }\n	\n	    if (options.statusCode !== 100 &&\n	        (this.rel100 === SIP.C.supported.REQUIRED ||\n	         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||\n	         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {\n	      do100rel.apply(this);\n	    } else {\n	      normalReply.apply(this);\n	    }\n	    return this;\n	  },\n	\n	  /*\n	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	   */\n	  accept: function(options) {\n	    options = Object.create(Session.desugar(options));\n	    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n	    this.mediaHint = options.media;\n	\n	    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21\n	    var\n	      //idx, length, hasAudio, hasVideo,\n	      self = this,\n	      request = this.request,\n	      extraHeaders = (options.extraHeaders || []).slice(),\n	    //mediaStream = options.mediaStream || null,\n	      iceServers,\n	      stunServers = options.stunServers || null,\n	      turnServers = options.turnServers || null,\n	      sdpCreationSucceeded = function(body) {\n	        var\n	          response,\n	          // run for reply success callback\n	          replySucceeded = function() {\n	            self.status = C.STATUS_WAITING_FOR_ACK;\n	\n	            self.setInvite2xxTimer(request, body);\n	            self.setACKTimer();\n	          },\n	\n	          // run for reply failure callback\n	          replyFailed = function() {\n	            self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n	          };\n	\n	        // Chrome might call onaddstream before accept() is called, which means\n	        // mediaHandler.render() was called without a renderHint, so we need to\n	        // re-render now that mediaHint.render has been set.\n	        //\n	        // Chrome seems to be in the right regarding this, see\n	        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream\n	        self.mediaHandler.render();\n	\n	        extraHeaders.push('Contact: ' + self.contact);\n	        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	        if(!self.hasOffer) {\n	          self.hasOffer = true;\n	        } else {\n	          self.hasAnswer = true;\n	        }\n	        response = request.reply(200, null, extraHeaders,\n	                      body,\n	                      replySucceeded,\n	                      replyFailed\n	                     );\n	        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail\n	          self.accepted(response, SIP.Utils.getReasonPhrase(200));\n	        }\n	      },\n	\n	      sdpCreationFailed = function() {\n	        if (self.status === C.STATUS_TERMINATED) {\n	          return;\n	        }\n	        // TODO - fail out on error\n	        self.request.reply(480);\n	        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n	        self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	      };\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n	      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n	      return this;\n	    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n	      this.status = C.STATUS_ANSWERED;\n	    } else if (this.status !== C.STATUS_EARLY_MEDIA) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    if ((stunServers || turnServers) &&\n	        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {\n	      if (stunServers) {\n	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid stunServers: '+ stunServers);\n	        } else {\n	          this.stunServers = iceServers;\n	        }\n	      }\n	\n	      if (turnServers) {\n	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n	        if (!iceServers) {\n	          throw new TypeError('Invalid turnServers: '+ turnServers);\n	        } else {\n	          this.turnServers = iceServers;\n	        }\n	      }\n	\n	      this.mediaHandler.updateIceServers({\n	        stunServers: this.stunServers,\n	        turnServers: this.turnServers\n	      });\n	    }\n	\n	    // An error on dialog creation will fire 'failed' event\n	    if(!this.createDialog(request, 'UAS')) {\n	      request.reply(500, 'Missing Contact header field');\n	      return this;\n	    }\n	\n	    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);\n	\n	    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21\n	    /*\n	    length = this.getRemoteStreams().length;\n	\n	    for (idx = 0; idx < length; idx++) {\n	      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {\n	        hasVideo = true;\n	      }\n	      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {\n	        hasAudio = true;\n	      }\n	    }\n	\n	    if (!hasAudio && this.mediaConstraints.audio === true) {\n	      this.mediaConstraints.audio = false;\n	      if (mediaStream) {\n	        length = mediaStream.getAudioTracks().length;\n	        for (idx = 0; idx < length; idx++) {\n	          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);\n	        }\n	      }\n	    }\n	\n	    if (!hasVideo && this.mediaConstraints.video === true) {\n	      this.mediaConstraints.video = false;\n	      if (mediaStream) {\n	        length = mediaStream.getVideoTracks().length;\n	        for (idx = 0; idx < length; idx++) {\n	          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);\n	        }\n	      }\n	    }\n	    */\n	\n	    if (this.status === C.STATUS_EARLY_MEDIA) {\n	      sdpCreationSucceeded();\n	    } else {\n	      this.mediaHandler.getDescription(self.mediaHint)\n	      .then(\n	        sdpCreationSucceeded,\n	        sdpCreationFailed\n	      );\n	    }\n	\n	    return this;\n	  },\n	\n	  receiveRequest: function(request) {\n	\n	    // ISC RECEIVE REQUEST\n	\n	    function confirmSession() {\n	      /* jshint validthis:true */\n	      var contentType;\n	\n	      SIP.Timers.clearTimeout(this.timers.ackTimer);\n	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n	      this.status = C.STATUS_CONFIRMED;\n	      this.unmute();\n	\n	      // TODO - this logic assumes Content-Disposition defaults\n	      contentType = request.getHeader('Content-Type');\n	      if (contentType !== 'application/sdp') {\n	        this.renderbody = request.body;\n	        this.rendertype = contentType;\n	      }\n	    }\n	\n	    switch(request.method) {\n	    case SIP.C.CANCEL:\n	      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n	       * was in progress and that the UAC MAY continue with the session established by\n	       * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n	       * established session. So the CANCEL is processed only if the session is not yet\n	       * established.\n	       */\n	\n	      /*\n	       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n	       *request opening the session.\n	       */\n	      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||\n	         this.status === C.STATUS_WAITING_FOR_PRACK ||\n	         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||\n	         this.status === C.STATUS_EARLY_MEDIA ||\n	         this.status === C.STATUS_ANSWERED) {\n	\n	        this.status = C.STATUS_CANCELED;\n	        this.request.reply(487);\n	        this.canceled(request);\n	        this.rejected(request, SIP.C.causes.CANCELED);\n	        this.failed(request, SIP.C.causes.CANCELED);\n	        this.terminated(request, SIP.C.causes.CANCELED);\n	      }\n	      break;\n	    case SIP.C.ACK:\n	      if(this.status === C.STATUS_WAITING_FOR_ACK) {\n	        if (!this.hasAnswer) {\n	          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n	            // ACK contains answer to an INVITE w/o SDP negotiation\n	            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n	            SIP.Hacks.AllBrowsers.maskDtls(request);\n	\n	            this.hasAnswer = true;\n	            this.mediaHandler.setDescription(request.body)\n	            .then(\n	              confirmSession.bind(this),\n	              function onFailure (e) {\n	                this.logger.warn(e);\n	                this.terminate({\n	                  statusCode: '488',\n	                  reasonPhrase: 'Bad Media Description'\n	                });\n	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              }.bind(this)\n	            );\n	          } else if (this.early_sdp) {\n	            confirmSession.apply(this);\n	          } else {\n	            //TODO: Pass to mediahandler\n	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	          }\n	        } else {\n	          confirmSession.apply(this);\n	        }\n	      }\n	      break;\n	    case SIP.C.PRACK:\n	      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n	        //localMedia = session.mediaHandler.localMedia;\n	        if(!this.hasAnswer) {\n	          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n	            this.hasAnswer = true;\n	            this.mediaHandler.setDescription(request.body)\n	            .then(\n	              function onSuccess () {\n	                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n	                SIP.Timers.clearTimeout(this.timers.prackTimer);\n	                request.reply(200);\n	                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n	                  this.status = C.STATUS_EARLY_MEDIA;\n	                  this.accept();\n	                }\n	                this.status = C.STATUS_EARLY_MEDIA;\n	                //REVISIT\n	                this.mute();\n	              }.bind(this),\n	              function onFailure (e) {\n	                //TODO: Send to media handler\n	                this.logger.warn(e);\n	                this.terminate({\n	                  statusCode: '488',\n	                  reasonPhrase: 'Bad Media Description'\n	                });\n	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              }.bind(this)\n	            );\n	          } else {\n	            this.terminate({\n	              statusCode: '488',\n	              reasonPhrase: 'Bad Media Description'\n	            });\n	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	          }\n	        } else {\n	          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n	          SIP.Timers.clearTimeout(this.timers.prackTimer);\n	          request.reply(200);\n	\n	          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n	            this.status = C.STATUS_EARLY_MEDIA;\n	            this.accept();\n	          }\n	          this.status = C.STATUS_EARLY_MEDIA;\n	          //REVISIT\n	          this.mute();\n	        }\n	      } else if(this.status === C.STATUS_EARLY_MEDIA) {\n	        request.reply(200);\n	      }\n	      break;\n	    default:\n	      Session.prototype.receiveRequest.apply(this, [request]);\n	      break;\n	    }\n	  },\n	\n	  onTransportError: function() {\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    }\n	  }\n	\n	};\n	\n	SIP.InviteServerContext = InviteServerContext;\n	\n	InviteClientContext = function(ua, target, options) {\n	  options = Object.create(Session.desugar(options));\n	  options.params = Object.create(options.params || Object.prototype);\n	\n	  var iceServers,\n	    extraHeaders = (options.extraHeaders || []).slice(),\n	    stunServers = options.stunServers || null,\n	    turnServers = options.turnServers || null,\n	    isMediaSupported = ua.configuration.mediaHandlerFactory.isSupported;\n	\n	  // Check WebRTC support\n	  if (isMediaSupported && !isMediaSupported()) {\n	    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n	  }\n	\n	  this.RTCConstraints = options.RTCConstraints || {};\n	  this.inviteWithoutSdp = options.inviteWithoutSdp || false;\n	\n	  // Set anonymous property\n	  this.anonymous = options.anonymous || false;\n	\n	  // Custom data to be sent either in INVITE or in ACK\n	  this.renderbody = options.renderbody || null;\n	  this.rendertype = options.rendertype || 'text/plain';\n	\n	  options.params.from_tag = this.from_tag;\n	\n	  /* Do not add ;ob in initial forming dialog requests if the registration over\n	   *  the current connection got a GRUU URI.\n	   */\n	  this.contact = ua.contact.toString({\n	    anonymous: this.anonymous,\n	    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n	  });\n	\n	  if (this.anonymous) {\n	    options.params.from_displayName = 'Anonymous';\n	    options.params.from_uri = 'sip:anonymous@anonymous.invalid';\n	\n	    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());\n	    extraHeaders.push('Privacy: id');\n	  }\n	  extraHeaders.push('Contact: '+ this.contact);\n	  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	  if (!this.inviteWithoutSdp) {\n	    extraHeaders.push('Content-Type: application/sdp');\n	  } else if (this.renderbody) {\n	    extraHeaders.push('Content-Type: ' + this.rendertype);\n	    extraHeaders.push('Content-Disposition: render;handling=optional');\n	  }\n	\n	  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n	    extraHeaders.push('Require: 100rel');\n	  }\n	  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {\n	    extraHeaders.push('Require: replaces');\n	  }\n	\n	  options.extraHeaders = extraHeaders;\n	\n	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n	\n	  // Check Session Status\n	  if (this.status !== C.STATUS_NULL) {\n	    throw new SIP.Exceptions.InvalidStateError(this.status);\n	  }\n	\n	  // Session parameter initialization\n	  this.from_tag = SIP.Utils.newTag();\n	\n	  // OutgoingSession specific parameters\n	  this.isCanceled = false;\n	  this.received_100 = false;\n	\n	  this.method = SIP.C.INVITE;\n	\n	  this.receiveNonInviteResponse = this.receiveResponse;\n	  this.receiveResponse = this.receiveInviteResponse;\n	\n	  this.logger = ua.getLogger('sip.inviteclientcontext');\n	\n	  if (stunServers) {\n	    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n	    if (!iceServers) {\n	      throw new TypeError('Invalid stunServers: '+ stunServers);\n	    } else {\n	      this.stunServers = iceServers;\n	    }\n	  }\n	\n	  if (turnServers) {\n	    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n	    if (!iceServers) {\n	      throw new TypeError('Invalid turnServers: '+ turnServers);\n	    } else {\n	      this.turnServers = iceServers;\n	    }\n	  }\n	\n	  ua.applicants[this] = this;\n	\n	  this.id = this.request.call_id + this.from_tag;\n	\n	  //Initialize Media Session\n	  this.mediaHandler = this.mediaHandlerFactory(this, {\n	    RTCConstraints: this.RTCConstraints,\n	    stunServers: this.stunServers,\n	    turnServers: this.turnServers\n	  });\n	\n	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n	  }\n	\n	  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n	  this.mediaHint = options.media;\n	};\n	\n	InviteClientContext.prototype = {\n	  invite: function () {\n	    var self = this;\n	\n	    //Save the session into the ua sessions collection.\n	    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n	    this.ua.sessions[this.id] = this;\n	\n	    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level\n	    // and hand sip.js a stream as the mediaHint\n	    if (this.inviteWithoutSdp) {\n	      //just send an invite with no sdp...\n	      this.request.body = self.renderbody;\n	      this.status = C.STATUS_INVITE_SENT;\n	      this.send();\n	    } else {\n	      this.mediaHandler.getDescription(self.mediaHint)\n	      .then(\n	        function onSuccess(offer) {\n	          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n	            return;\n	          }\n	          self.hasOffer = true;\n	          self.request.body = offer;\n	          self.status = C.STATUS_INVITE_SENT;\n	          self.send();\n	        },\n	        function onFailure() {\n	          if (self.status === C.STATUS_TERMINATED) {\n	            return;\n	          }\n	          // TODO...fail out\n	          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n	          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	          self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	        }\n	      );\n	    }\n	\n	    return this;\n	  },\n	\n	  receiveInviteResponse: function(response) {\n	    var cause, //localMedia,\n	      session = this,\n	      id = response.call_id + response.from_tag + response.to_tag,\n	      extraHeaders = [],\n	      options = {};\n	\n	    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n	      return;\n	    }\n	\n	    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {\n	      if (id !== this.dialog.id.toString() ) {\n	        if (!this.createDialog(response, 'UAC', true)) {\n	          return;\n	        }\n	        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,\n	                                          {\n	                                            body: SIP.Utils.generateFakeSDP(response.body)\n	                                          });\n	        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n	\n	        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n	         * leg (due to peerConnection limitations) has been answered first. If your forking\n	         * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n	         */\n	        if(this.status !== C.STATUS_CONFIRMED) {\n	          this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n	          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);\n	        }\n	        return;\n	      } else if (this.status === C.STATUS_CONFIRMED) {\n	        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n	        return;\n	      } else if (!this.hasAnswer) {\n	        // invite w/o sdp is waiting for callback\n	        //an invite with sdp must go on, and hasAnswer is true\n	        return;\n	      }\n	    }\n	\n	    if (this.dialog && response.status_code < 200) {\n	      /*\n	        Early media has been set up with at least one other different branch,\n	        but a final 2xx response hasn't been received\n	      */\n	      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n	          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {\n	        return;\n	      }\n	\n	      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n	        return;\n	      }\n	\n	      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n	          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n	        return;\n	      }\n	\n	      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n	\n	      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n	        extraHeaders: extraHeaders,\n	        body: SIP.Utils.generateFakeSDP(response.body)\n	      });\n	      return;\n	    }\n	\n	    // Proceed to cancellation if the user requested.\n	    if(this.isCanceled) {\n	      if(response.status_code >= 100 && response.status_code < 200) {\n	        this.request.cancel(this.cancelReason);\n	        this.canceled(null);\n	      } else if(response.status_code >= 200 && response.status_code < 299) {\n	        this.acceptAndTerminate(response);\n	        this.emit('bye', this.request);\n	      } else if (response.status_code >= 300) {\n	        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;\n	        this.rejected(response, cause);\n	        this.failed(response, cause);\n	        this.terminated(response, cause);\n	      }\n	      return;\n	    }\n	\n	    switch(true) {\n	      case /^100$/.test(response.status_code):\n	        this.received_100 = true;\n	        this.emit('progress', response);\n	        break;\n	      case (/^1[0-9]{2}$/.test(response.status_code)):\n	        // Do nothing with 1xx responses without To tag.\n	        if(!response.to_tag) {\n	          this.logger.warn('1xx response received without to tag');\n	          break;\n	        }\n	\n	        // Create Early Dialog if 1XX comes with contact\n	        if(response.hasHeader('contact')) {\n	          // An error on dialog creation will fire 'failed' event\n	          if (!this.createDialog(response, 'UAC', true)) {\n	            break;\n	          }\n	        }\n	\n	        this.status = C.STATUS_1XX_RECEIVED;\n	\n	        if(response.hasHeader('require') &&\n	           response.getHeader('require').indexOf('100rel') !== -1) {\n	\n	          // Do nothing if this.dialog is already confirmed\n	          if (this.dialog || !this.earlyDialogs[id]) {\n	            break;\n	          }\n	\n	          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n	              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n	            return;\n	          }\n	\n	          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n	          SIP.Hacks.AllBrowsers.maskDtls(response);\n	\n	          if (!response.body) {\n	            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n	            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n	              extraHeaders: extraHeaders\n	            });\n	            this.emit('progress', response);\n	\n	          } else if (this.hasOffer) {\n	            if (!this.createDialog(response, 'UAC')) {\n	              break;\n	            }\n	            this.hasAnswer = true;\n	            this.dialog.pracked.push(response.getHeader('rseq'));\n	\n	            this.mediaHandler.setDescription(response.body)\n	            .then(\n	              function onSuccess () {\n	                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	\n	                session.sendRequest(SIP.C.PRACK, {\n	                  extraHeaders: extraHeaders,\n	                  receiveResponse: function() {}\n	                });\n	                session.status = C.STATUS_EARLY_MEDIA;\n	                session.mute();\n	                session.emit('progress', response);\n	                /*\n	                if (session.status === C.STATUS_EARLY_MEDIA) {\n	                  localMedia = session.mediaHandler.localMedia;\n	                  if (localMedia.getAudioTracks().length > 0) {\n	                    localMedia.getAudioTracks()[0].enabled = false;\n	                  }\n	                  if (localMedia.getVideoTracks().length > 0) {\n	                    localMedia.getVideoTracks()[0].enabled = false;\n	                  }\n	                }*/\n	              },\n	              function onFailure (e) {\n	                session.logger.warn(e);\n	                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n	                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              }\n	            );\n	          } else {\n	            var earlyDialog = this.earlyDialogs[id];\n	            var earlyMedia = earlyDialog.mediaHandler;\n	\n	            earlyDialog.pracked.push(response.getHeader('rseq'));\n	\n	            earlyMedia.setDescription(response.body)\n	            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))\n	            .then(function onSuccess(sdp) {\n	              extraHeaders.push('Content-Type: application/sdp');\n	              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n	              earlyDialog.sendRequest(session, SIP.C.PRACK, {\n	                extraHeaders: extraHeaders,\n	                body: sdp\n	              });\n	              session.status = C.STATUS_EARLY_MEDIA;\n	              session.emit('progress', response);\n	            })\n	            .catch(function onFailure(e) {\n	              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n	                earlyDialog.pracked.push(response.getHeader('rseq'));\n	                if (session.status === C.STATUS_TERMINATED) {\n	                  return;\n	                }\n	                // TODO - fail out on error\n	                // session.failed(gum error);\n	                session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n	                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n	              } else {\n	                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);\n	                // Could not set remote description\n	                session.logger.warn('invalid SDP');\n	                session.logger.warn(e);\n	              }\n	            });\n	          }\n	        } else {\n	          this.emit('progress', response);\n	        }\n	        break;\n	      case /^2[0-9]{2}$/.test(response.status_code):\n	        var cseq = this.request.cseq + ' ' + this.request.method;\n	        if (cseq !== response.getHeader('cseq')) {\n	          break;\n	        }\n	\n	        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n	          this.status = C.STATUS_CONFIRMED;\n	          this.unmute();\n	          /*localMedia = this.mediaHandler.localMedia;\n	          if (localMedia.getAudioTracks().length > 0) {\n	            localMedia.getAudioTracks()[0].enabled = true;\n	          }\n	          if (localMedia.getVideoTracks().length > 0) {\n	            localMedia.getVideoTracks()[0].enabled = true;\n	          }*/\n	          options = {};\n	          if (this.renderbody) {\n	            extraHeaders.push('Content-Type: ' + this.rendertype);\n	            options.extraHeaders = extraHeaders;\n	            options.body = this.renderbody;\n	          }\n	          options.cseq = response.cseq;\n	          this.sendRequest(SIP.C.ACK, options);\n	          this.accepted(response);\n	          break;\n	        }\n	        // Do nothing if this.dialog is already confirmed\n	        if (this.dialog) {\n	          break;\n	        }\n	\n	        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n	        SIP.Hacks.AllBrowsers.maskDtls(response);\n	\n	        // This is an invite without sdp\n	        if (!this.hasOffer) {\n	          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {\n	            //REVISIT\n	            this.hasOffer = true;\n	            this.hasAnswer = true;\n	            this.mediaHandler = this.earlyDialogs[id].mediaHandler;\n	            if (!this.createDialog(response, 'UAC')) {\n	              break;\n	            }\n	            this.status = C.STATUS_CONFIRMED;\n	            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});\n	\n	            this.unmute();\n	            /*\n	            localMedia = session.mediaHandler.localMedia;\n	            if (localMedia.getAudioTracks().length > 0) {\n	              localMedia.getAudioTracks()[0].enabled = true;\n	            }\n	            if (localMedia.getVideoTracks().length > 0) {\n	              localMedia.getVideoTracks()[0].enabled = true;\n	            }*/\n	            this.accepted(response);\n	          } else {\n	            if(!response.body) {\n	              this.acceptAndTerminate(response, 400, 'Missing session description');\n	              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	              break;\n	            }\n	            if (!this.createDialog(response, 'UAC')) {\n	              break;\n	            }\n	            this.hasOffer = true;\n	            this.mediaHandler.setDescription(response.body)\n	            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))\n	            .then(function onSuccess(sdp) {\n	              //var localMedia;\n	              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {\n	                return;\n	              }\n	\n	              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);\n	\n	              session.status = C.STATUS_CONFIRMED;\n	              session.hasAnswer = true;\n	\n	              session.unmute();\n	              /*localMedia = session.mediaHandler.localMedia;\n	              if (localMedia.getAudioTracks().length > 0) {\n	                localMedia.getAudioTracks()[0].enabled = true;\n	              }\n	              if (localMedia.getVideoTracks().length > 0) {\n	                localMedia.getVideoTracks()[0].enabled = true;\n	              }*/\n	              session.sendRequest(SIP.C.ACK,{\n	                body: sdp,\n	                extraHeaders:['Content-Type: application/sdp'],\n	                cseq:response.cseq\n	              });\n	              session.accepted(response);\n	            })\n	            .catch(function onFailure(e) {\n	              if (e instanceof SIP.Exceptions.GetDescriptionError) {\n	                // TODO do something here\n	                session.logger.warn(\"there was a problem\");\n	              } else {\n	                session.logger.warn('invalid SDP');\n	                session.logger.warn(e);\n	                response.reply(488);\n	              }\n	            });\n	          }\n	        } else if (this.hasAnswer){\n	          if (this.renderbody) {\n	            extraHeaders.push('Content-Type: ' + session.rendertype);\n	            options.extraHeaders = extraHeaders;\n	            options.body = this.renderbody;\n	          }\n	          this.sendRequest(SIP.C.ACK, options);\n	        } else {\n	          if(!response.body) {\n	            this.acceptAndTerminate(response, 400, 'Missing session description');\n	            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            break;\n	          }\n	          if (!this.createDialog(response, 'UAC')) {\n	            break;\n	          }\n	          this.hasAnswer = true;\n	          this.mediaHandler.setDescription(response.body)\n	          .then(\n	            function onSuccess () {\n	              var options = {};//,localMedia;\n	              session.status = C.STATUS_CONFIRMED;\n	              session.unmute();\n	              /*localMedia = session.mediaHandler.localMedia;\n	              if (localMedia.getAudioTracks().length > 0) {\n	                localMedia.getAudioTracks()[0].enabled = true;\n	              }\n	              if (localMedia.getVideoTracks().length > 0) {\n	                localMedia.getVideoTracks()[0].enabled = true;\n	              }*/\n	              if (session.renderbody) {\n	                extraHeaders.push('Content-Type: ' + session.rendertype);\n	                options.extraHeaders = extraHeaders;\n	                options.body = session.renderbody;\n	              }\n	              options.cseq = response.cseq;\n	              session.sendRequest(SIP.C.ACK, options);\n	              session.accepted(response);\n	            },\n	            function onFailure (e) {\n	              session.logger.warn(e);\n	              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n	              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n	            }\n	          );\n	        }\n	        break;\n	      default:\n	        cause = SIP.Utils.sipErrorCause(response.status_code);\n	        this.rejected(response, cause);\n	        this.failed(response, cause);\n	        this.terminated(response, cause);\n	    }\n	  },\n	\n	  cancel: function(options) {\n	    options = options || {};\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {\n	      throw new SIP.Exceptions.InvalidStateError(this.status);\n	    }\n	\n	    this.logger.log('canceling RTCSession');\n	\n	    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n	\n	    // Check Session Status\n	    if (this.status === C.STATUS_NULL ||\n	        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {\n	      this.isCanceled = true;\n	      this.cancelReason = cancel_reason;\n	    } else if (this.status === C.STATUS_INVITE_SENT ||\n	               this.status === C.STATUS_1XX_RECEIVED ||\n	               this.status === C.STATUS_EARLY_MEDIA) {\n	      this.request.cancel(cancel_reason);\n	    }\n	\n	    return this.canceled();\n	  },\n	\n	  terminate: function(options) {\n	    if (this.status === C.STATUS_TERMINATED) {\n	      return this;\n	    }\n	\n	    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n	      this.bye(options);\n	    } else {\n	      this.cancel(options);\n	    }\n	\n	    return this;\n	  },\n	\n	  receiveRequest: function(request) {\n	    // ICC RECEIVE REQUEST\n	\n	    // Reject CANCELs\n	    if (request.method === SIP.C.CANCEL) {\n	      // TODO; make this a switch when it gets added\n	    }\n	\n	    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n	      SIP.Timers.clearTimeout(this.timers.ackTimer);\n	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n	      this.status = C.STATUS_CONFIRMED;\n	      this.unmute();\n	\n	      this.accepted();\n	    }\n	\n	    return Session.prototype.receiveRequest.apply(this, [request]);\n	  },\n	\n	  onTransportError: function() {\n	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n	    }\n	  },\n	\n	  onRequestTimeout: function() {\n	    if (this.status === C.STATUS_CONFIRMED) {\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    } else if (this.status !== C.STATUS_TERMINATED) {\n	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n	    }\n	  }\n	\n	};\n	\n	SIP.InviteClientContext = InviteClientContext;\n	\n	};\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview DTMF\n	 */\n	\n	/**\n	 * @class DTMF\n	 * @param {SIP.Session} session\n	 */\n	module.exports = function (SIP) {\n	\n	var DTMF,\n	  C = {\n	    MIN_DURATION:            70,\n	    MAX_DURATION:            6000,\n	    DEFAULT_DURATION:        100,\n	    MIN_INTER_TONE_GAP:      50,\n	    DEFAULT_INTER_TONE_GAP:  500\n	  };\n	\n	DTMF = function(session, tone, options) {\n	  var duration, interToneGap;\n	\n	  if (tone === undefined) {\n	    throw new TypeError('Not enough arguments');\n	  }\n	\n	  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n	  this.owner = session;\n	  this.direction = null;\n	\n	  options = options || {};\n	  duration = options.duration || null;\n	  interToneGap = options.interToneGap || null;\n	\n	  // Check tone type\n	  if (typeof tone === 'string' ) {\n	    tone = tone.toUpperCase();\n	  } else if (typeof tone === 'number') {\n	    tone = tone.toString();\n	  } else {\n	    throw new TypeError('Invalid tone: '+ tone);\n	  }\n	\n	  // Check tone value\n	  if (!tone.match(/^[0-9A-D#*]$/)) {\n	    throw new TypeError('Invalid tone: '+ tone);\n	  } else {\n	    this.tone = tone;\n	  }\n	\n	  // Check duration\n	  if (duration && !SIP.Utils.isDecimal(duration)) {\n	    throw new TypeError('Invalid tone duration: '+ duration);\n	  } else if (!duration) {\n	    duration = DTMF.C.DEFAULT_DURATION;\n	  } else if (duration < DTMF.C.MIN_DURATION) {\n	    this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');\n	    duration = DTMF.C.MIN_DURATION;\n	  } else if (duration > DTMF.C.MAX_DURATION) {\n	    this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');\n	    duration = DTMF.C.MAX_DURATION;\n	  } else {\n	    duration = Math.abs(duration);\n	  }\n	  this.duration = duration;\n	\n	  // Check interToneGap\n	  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n	    throw new TypeError('Invalid interToneGap: '+ interToneGap);\n	  } else if (!interToneGap) {\n	    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;\n	  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {\n	    this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');\n	    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;\n	  } else {\n	    interToneGap = Math.abs(interToneGap);\n	  }\n	  this.interToneGap = interToneGap;\n	};\n	DTMF.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	\n	DTMF.prototype.send = function(options) {\n	  var extraHeaders, body;\n	\n	  this.direction = 'outgoing';\n	\n	  // Check RTCSession Status\n	  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&\n	    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n	    throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n	  }\n	\n	  // Get DTMF options\n	  options = options || {};\n	  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n	\n	  extraHeaders.push('Content-Type: application/dtmf-relay');\n	\n	  body = \"Signal= \" + this.tone + \"\\r\\n\";\n	  body += \"Duration= \" + this.duration;\n	\n	  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n	    extraHeaders: extraHeaders,\n	    body: body\n	  });\n	\n	  this.owner.emit('dtmf', this.request, this);\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.receiveResponse = function(response) {\n	  var cause;\n	\n	  switch(true) {\n	    case /^1[0-9]{2}$/.test(response.status_code):\n	      // Ignore provisional responses.\n	      break;\n	\n	    case /^2[0-9]{2}$/.test(response.status_code):\n	      this.emit('succeeded', {\n	        originator: 'remote',\n	        response: response\n	      });\n	      break;\n	\n	    default:\n	      cause = SIP.Utils.sipErrorCause(response.status_code);\n	      this.emit('failed', response, cause);\n	      break;\n	  }\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.onRequestTimeout = function() {\n	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n	  this.owner.onRequestTimeout();\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.onTransportError = function() {\n	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n	  this.owner.onTransportError();\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.onDialogError = function(response) {\n	  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n	  this.owner.onDialogError(response);\n	};\n	\n	/**\n	 * @private\n	 */\n	DTMF.prototype.init_incoming = function(request) {\n	  this.direction = 'incoming';\n	  this.request = request;\n	\n	  request.reply(200);\n	\n	  if (!this.tone || !this.duration) {\n	    this.logger.warn('invalid INFO DTMF received, discarded');\n	  } else {\n	    this.owner.emit('dtmf', request, this);\n	  }\n	};\n	\n	DTMF.C = C;\n	return DTMF;\n	};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP Subscription.\n	 */\n	module.exports = function (SIP) {\n	SIP.Subscription = function (ua, target, event, options) {\n	  options = Object.create(options || Object.prototype);\n	  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();\n	\n	  this.id = null;\n	  this.state = 'init';\n	\n	  if (!event) {\n	    throw new TypeError('Event necessary to create a subscription.');\n	  } else {\n	    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n	    //The check may need to/should probably occur on the other side,\n	    this.event = event;\n	  }\n	\n	  if(typeof options.expires !== 'number'){\n	    ua.logger.warn('expires must be a number. Using default of 3600.');\n	    this.expires = 3600;\n	  } else {\n	    this.expires = options.expires;\n	  }\n	\n	  options.extraHeaders.push('Event: ' + this.event);\n	  options.extraHeaders.push('Expires: ' + this.expires);\n	\n	  if (options.body) {\n	    this.body = options.body;\n	  }\n	\n	  this.contact = ua.contact.toString();\n	\n	  options.extraHeaders.push('Contact: '+ this.contact);\n	  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n	\n	  this.logger = ua.getLogger('sip.subscription');\n	\n	  this.dialog = null;\n	  this.timers = {N: null, sub_duration: null};\n	  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];\n	};\n	\n	SIP.Subscription.prototype = {\n	  subscribe: function() {\n	    var sub = this;\n	\n	     //these states point to an existing subscription, no subscribe is necessary\n	    if (this.state === 'active') {\n	      this.refresh();\n	      return this;\n	    } else if (this.state === 'notify_wait') {\n	      return this;\n	    }\n	\n	    SIP.Timers.clearTimeout(this.timers.sub_duration);\n	    SIP.Timers.clearTimeout(this.timers.N);\n	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n	\n	    this.send();\n	\n	    this.state = 'notify_wait';\n	\n	    return this;\n	  },\n	\n	  refresh: function () {\n	    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {\n	      return;\n	    }\n	\n	    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {\n	      extraHeaders: this.extraHeaders,\n	      body: this.body\n	    });\n	  },\n	\n	  receiveResponse: function(response) {\n	    var expires, sub = this,\n	        cause = SIP.Utils.getReasonPhrase(response.status_code);\n	\n	    if ((this.state === 'notify_wait' && response.status_code >= 300) ||\n	        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {\n	      this.failed(response, null);\n	    } else if (/^2[0-9]{2}$/.test(response.status_code)){\n	      expires = response.getHeader('Expires');\n	      SIP.Timers.clearTimeout(this.timers.N);\n	\n	      if (this.createConfirmedDialog(response,'UAC')) {\n	        this.id = this.dialog.id.toString();\n	        this.ua.subscriptions[this.id] = this;\n	        this.emit('accepted', response, cause);\n	        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n	      }\n	\n	      if (expires && expires <= this.expires) {\n	        // Preserve new expires value for subsequent requests\n	        this.expires = expires;\n	        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);\n	      } else {\n	        if (!expires) {\n	          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n	          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n	        } else {\n	          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n	          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n	        }\n	      }\n	    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx\n	  },\n	\n	  unsubscribe: function() {\n	    var extraHeaders = [], sub = this;\n	\n	    this.state = 'terminated';\n	\n	    extraHeaders.push('Event: ' + this.event);\n	    extraHeaders.push('Expires: 0');\n	\n	    extraHeaders.push('Contact: '+ this.contact);\n	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());\n	\n	    //makes sure expires isn't set, and other typical resubscribe behavior\n	    this.receiveResponse = function(){};\n	\n	    this.dialog.sendRequest(this, this.method, {\n	      extraHeaders: extraHeaders,\n	      body: this.body\n	    });\n	\n	    SIP.Timers.clearTimeout(this.timers.sub_duration);\n	    SIP.Timers.clearTimeout(this.timers.N);\n	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  timer_fire: function(){\n	    if (this.state === 'terminated') {\n	      this.terminateDialog();\n	      SIP.Timers.clearTimeout(this.timers.N);\n	      SIP.Timers.clearTimeout(this.timers.sub_duration);\n	\n	      delete this.ua.subscriptions[this.id];\n	    } else if (this.state === 'pending' || this.state === 'notify_wait') {\n	      this.close();\n	    } else {\n	      this.refresh();\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  close: function() {\n	    if(this.state !== 'notify_wait' && this.state !== 'terminated') {\n	      this.unsubscribe();\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  createConfirmedDialog: function(message, type) {\n	    var dialog;\n	\n	    this.terminateDialog();\n	    dialog = new SIP.Dialog(this, message, type);\n	\n	    if(!dialog.error) {\n	      this.dialog = dialog;\n	      return true;\n	    }\n	    // Dialog not created due to an error\n	    else {\n	      return false;\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  terminateDialog: function() {\n	    if(this.dialog) {\n	      delete this.ua.subscriptions[this.id];\n	      this.dialog.terminate();\n	      delete this.dialog;\n	    }\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  receiveRequest: function(request) {\n	    var sub_state, sub = this;\n	\n	    function setExpiresTimeout() {\n	      if (sub_state.expires) {\n	        SIP.Timers.clearTimeout(sub.timers.sub_duration);\n	        sub_state.expires = Math.min(sub.expires,\n	                                     Math.max(sub_state.expires, 0));\n	        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),\n	                                                    sub_state.expires * 900);\n	      }\n	    }\n	\n	    if (!this.matchEvent(request)) { //checks event and subscription_state headers\n	      request.reply(489);\n	      return;\n	    }\n	\n	    sub_state = request.parseHeader('Subscription-State');\n	\n	    request.reply(200, SIP.C.REASON_200);\n	\n	    SIP.Timers.clearTimeout(this.timers.N);\n	\n	    this.emit('notify', {request: request});\n	\n	    // if we've set state to terminated, no further processing should take place\n	    // and we are only interested in cleaning up after the appropriate NOTIFY\n	    if (this.state === 'terminated') {\n	      if (sub_state.state === 'terminated') {\n	        this.terminateDialog();\n	        SIP.Timers.clearTimeout(this.timers.N);\n	        SIP.Timers.clearTimeout(this.timers.sub_duration);\n	\n	        delete this.ua.subscriptions[this.id];\n	      }\n	      return;\n	    }\n	\n	    switch (sub_state.state) {\n	      case 'active':\n	        this.state = 'active';\n	        setExpiresTimeout();\n	        break;\n	      case 'pending':\n	        if (this.state === 'notify_wait') {\n	          setExpiresTimeout();\n	        }\n	        this.state = 'pending';\n	        break;\n	      case 'terminated':\n	        SIP.Timers.clearTimeout(this.timers.sub_duration);\n	        if (sub_state.reason) {\n	          this.logger.log('terminating subscription with reason '+ sub_state.reason);\n	          switch (sub_state.reason) {\n	            case 'deactivated':\n	            case 'timeout':\n	              this.subscribe();\n	              return;\n	            case 'probation':\n	            case 'giveup':\n	              if(sub_state.params && sub_state.params['retry-after']) {\n	                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n	              } else {\n	                this.subscribe();\n	              }\n	              return;\n	            case 'rejected':\n	            case 'noresource':\n	            case 'invariant':\n	              break;\n	          }\n	        }\n	        this.close();\n	        break;\n	    }\n	  },\n	\n	  failed: function(response, cause) {\n	    this.close();\n	    this.emit('failed', response, cause);\n	    return this;\n	  },\n	\n	  onDialogError: function(response) {\n	    this.failed(response, SIP.C.causes.DIALOG_ERROR);\n	  },\n	\n	  /**\n	  * @private\n	  */\n	  matchEvent: function(request) {\n	    var event;\n	\n	    // Check mandatory header Event\n	    if (!request.hasHeader('Event')) {\n	      this.logger.warn('missing Event header');\n	      return false;\n	    }\n	    // Check mandatory header Subscription-State\n	    if (!request.hasHeader('Subscription-State')) {\n	      this.logger.warn('missing Subscription-State header');\n	      return false;\n	    }\n	\n	    // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n	    event = request.parseHeader('event').event;\n	\n	    if (this.event !== event) {\n	      this.logger.warn('event match failed');\n	      request.reply(481, 'Event Match Failed');\n	      return false;\n	    } else {\n	      return true;\n	    }\n	  }\n	};\n	};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview WebRTC\n	 */\n	\n	module.exports = function (SIP, environment) {\n	var WebRTC;\n	\n	WebRTC = {};\n	\n	WebRTC.MediaHandler = __webpack_require__(41)(SIP);\n	WebRTC.MediaStreamManager = __webpack_require__(42)(SIP, environment);\n	\n	var _isSupported;\n	\n	WebRTC.isSupported = function () {\n	  if (_isSupported !== undefined) {\n	    return _isSupported;\n	  }\n	\n	  WebRTC.MediaStream = environment.MediaStream;\n	  WebRTC.getUserMedia = environment.getUserMedia;\n	  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;\n	  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;\n	\n	  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {\n	    if (WebRTC.getUserMedia) {\n	      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');\n	    }\n	    _isSupported = true;\n	  }\n	  else {\n	    _isSupported = false;\n	  }\n	  return _isSupported;\n	};\n	\n	return WebRTC;\n	};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview MediaHandler\n	 */\n	\n	/* MediaHandler\n	 * @class PeerConnection helper Class.\n	 * @param {SIP.Session} session\n	 * @param {Object} [options]\n	 * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]\n	 *        The MediaStreamManager to acquire/release streams from/to.\n	 *        If not provided, a default MediaStreamManager will be used.\n	 */\n	module.exports = function (SIP) {\n	\n	var MediaHandler = function(session, options) {\n	  options = options || {};\n	\n	  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);\n	  this.session = session;\n	  this.localMedia = null;\n	  this.ready = true;\n	  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);\n	  this.audioMuted = false;\n	  this.videoMuted = false;\n	\n	  // old init() from here on\n	  var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n	  this.RTCConstraints = options.RTCConstraints || {};\n	\n	  this.initPeerConnection(servers, this.RTCConstraints);\n	\n	  function selfEmit(mh, event) {\n	    if (mh.mediaStreamManager.on) {\n	      mh.mediaStreamManager.on(event, function () {\n	        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));\n	      });\n	    }\n	  }\n	\n	  selfEmit(this, 'userMediaRequest');\n	  selfEmit(this, 'userMedia');\n	  selfEmit(this, 'userMediaFailed');\n	};\n	\n	MediaHandler.defaultFactory = function defaultFactory (session, options) {\n	  return new MediaHandler(session, options);\n	};\n	MediaHandler.defaultFactory.isSupported = function () {\n	  return SIP.WebRTC.isSupported();\n	};\n	\n	MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {\n	// Functions the session can use\n	  isReady: {writable: true, value: function isReady () {\n	    return this.ready;\n	  }},\n	\n	  close: {writable: true, value: function close () {\n	    this.logger.log('closing PeerConnection');\n	    this._remoteStreams = [];\n	    // have to check signalingState since this.close() gets called multiple times\n	    // TODO figure out why that happens\n	    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n	      this.peerConnection.close();\n	\n	      if(this.localMedia) {\n	        this.mediaStreamManager.release(this.localMedia);\n	      }\n	    }\n	  }},\n	\n	  /**\n	   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]\n	   *        the MediaStream (or the constraints describing it) to be used for the session\n	   */\n	  getDescription: {writable: true, value: function getDescription (mediaHint) {\n	    var self = this;\n	    var acquire = self.mediaStreamManager.acquire;\n	    if (acquire.length > 1) {\n	      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);\n	    }\n	    mediaHint = mediaHint || {};\n	    if (mediaHint.dataChannel === true) {\n	      mediaHint.dataChannel = {};\n	    }\n	    this.mediaHint = mediaHint;\n	\n	    /*\n	     * 1. acquire streams (skip if MediaStreams passed in)\n	     * 2. addStreams\n	     * 3. createOffer/createAnswer\n	     */\n	\n	    var streamPromise;\n	    if (self.localMedia) {\n	      self.logger.log('already have local media');\n	      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);\n	    }\n	    else {\n	      self.logger.log('acquiring local media');\n	      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)\n	        .then(function acquireSucceeded(streams) {\n	          self.logger.log('acquired local media streams');\n	          self.localMedia = streams;\n	          self.session.connecting();\n	          return streams;\n	        }, function acquireFailed(err) {\n	          self.logger.error('unable to acquire streams');\n	          self.logger.error(err);\n	          self.session.connecting();\n	          throw err;\n	        })\n	        .then(this.addStreams.bind(this))\n	      ;\n	    }\n	\n	    return streamPromise\n	      .then(function streamAdditionSucceeded() {\n	        if (self.hasOffer('remote')) {\n	          self.peerConnection.ondatachannel = function (evt) {\n	            self.dataChannel = evt.channel;\n	            self.emit('dataChannel', self.dataChannel);\n	          };\n	        } else if (mediaHint.dataChannel &&\n	                   self.peerConnection.createDataChannel) {\n	          self.dataChannel = self.peerConnection.createDataChannel(\n	            'sipjs',\n	            mediaHint.dataChannel\n	          );\n	          self.emit('dataChannel', self.dataChannel);\n	        }\n	\n	        self.render();\n	        return self.createOfferOrAnswer(self.RTCConstraints);\n	      })\n	    ;\n	  }},\n	\n	  /**\n	  * Message reception.\n	  * @param {String} type\n	  * @param {String} sdp\n	  */\n	  setDescription: {writable: true, value: function setDescription (sdp) {\n	    var rawDescription = {\n	      type: this.hasOffer('local') ? 'answer' : 'offer',\n	      sdp: sdp\n	    };\n	\n	    this.emit('setDescription', rawDescription);\n	\n	    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);\n	    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);\n	  }},\n	\n	  /**\n	   * If the Session associated with this MediaHandler were to be referred,\n	   * what mediaHint should be provided to the UA's invite method?\n	   */\n	  getReferMedia: {writable: true, value: function getReferMedia () {\n	    function hasTracks (trackGetter, stream) {\n	      return stream[trackGetter]().length > 0;\n	    }\n	\n	    function bothHaveTracks (trackGetter) {\n	      /* jshint validthis:true */\n	      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&\n	             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));\n	    }\n	\n	    return {\n	      constraints: {\n	        audio: bothHaveTracks.call(this, 'getAudioTracks'),\n	        video: bothHaveTracks.call(this, 'getVideoTracks')\n	      }\n	    };\n	  }},\n	\n	  updateIceServers: {writeable:true, value: function (options) {\n	    var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n	    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;\n	\n	    this.initPeerConnection(servers, this.RTCConstraints);\n	\n	    /* once updateIce is implemented correctly, this is better than above\n	    //no op if browser does not support this\n	    if (!this.peerConnection.updateIce) {\n	      return;\n	    }\n	\n	    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);\n	    */\n	  }},\n	\n	// Functions the session can use, but only because it's convenient for the application\n	  isMuted: {writable: true, value: function isMuted () {\n	    return {\n	      audio: this.audioMuted,\n	      video: this.videoMuted\n	    };\n	  }},\n	\n	  mute: {writable: true, value: function mute (options) {\n	    if (this.getLocalStreams().length === 0) {\n	      return;\n	    }\n	\n	    options = options || {\n	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n	      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n	    };\n	\n	    var audioMuted = false,\n	        videoMuted = false;\n	\n	    if (options.audio && !this.audioMuted) {\n	      audioMuted = true;\n	      this.audioMuted = true;\n	      this.toggleMuteAudio(true);\n	    }\n	\n	    if (options.video && !this.videoMuted) {\n	      videoMuted = true;\n	      this.videoMuted = true;\n	      this.toggleMuteVideo(true);\n	    }\n	\n	    //REVISIT\n	    if (audioMuted || videoMuted) {\n	      return {\n	        audio: audioMuted,\n	        video: videoMuted\n	      };\n	      /*this.session.onmute({\n	        audio: audioMuted,\n	        video: videoMuted\n	      });*/\n	    }\n	  }},\n	\n	  unmute: {writable: true, value: function unmute (options) {\n	    if (this.getLocalStreams().length === 0) {\n	      return;\n	    }\n	\n	    options = options || {\n	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n	      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n	    };\n	\n	    var audioUnMuted = false,\n	        videoUnMuted = false;\n	\n	    if (options.audio && this.audioMuted) {\n	      audioUnMuted = true;\n	      this.audioMuted = false;\n	      this.toggleMuteAudio(false);\n	    }\n	\n	    if (options.video && this.videoMuted) {\n	      videoUnMuted = true;\n	      this.videoMuted = false;\n	      this.toggleMuteVideo(false);\n	    }\n	\n	    //REVISIT\n	    if (audioUnMuted || videoUnMuted) {\n	      return {\n	        audio: audioUnMuted,\n	        video: videoUnMuted\n	      };\n	      /*this.session.onunmute({\n	        audio: audioUnMuted,\n	        video: videoUnMuted\n	      });*/\n	    }\n	  }},\n	\n	  hold: {writable: true, value: function hold () {\n	    this.toggleMuteAudio(true);\n	    this.toggleMuteVideo(true);\n	  }},\n	\n	  unhold: {writable: true, value: function unhold () {\n	    if (!this.audioMuted) {\n	      this.toggleMuteAudio(false);\n	    }\n	\n	    if (!this.videoMuted) {\n	      this.toggleMuteVideo(false);\n	    }\n	  }},\n	\n	// Functions the application can use, but not the session\n	  getLocalStreams: {writable: true, value: function getLocalStreams () {\n	    var pc = this.peerConnection;\n	    if (pc && pc.signalingState === 'closed') {\n	      this.logger.warn('peerConnection is closed, getLocalStreams returning []');\n	      return [];\n	    }\n	    return (pc.getLocalStreams && pc.getLocalStreams()) ||\n	      pc.localStreams || [];\n	  }},\n	\n	  getRemoteStreams: {writable: true, value: function getRemoteStreams () {\n	    var pc = this.peerConnection;\n	    if (pc && pc.signalingState === 'closed') {\n	      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');\n	      return this._remoteStreams;\n	    }\n	    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||\n	      pc.remoteStreams || [];\n	  }},\n	\n	  render: {writable: true, value: function render (renderHint) {\n	    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);\n	    if (!renderHint) {\n	      return false;\n	    }\n	    var streamGetters = {\n	      local: 'getLocalStreams',\n	      remote: 'getRemoteStreams'\n	    };\n	    Object.keys(streamGetters).forEach(function (loc) {\n	      var streamGetter = streamGetters[loc];\n	      var streams = this[streamGetter]();\n	      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);\n	    }.bind(this));\n	  }},\n	\n	// Internal functions\n	  hasOffer: {writable: true, value: function hasOffer (where) {\n	    var offerState = 'have-' + where + '-offer';\n	    return this.peerConnection.signalingState === offerState;\n	    // TODO consider signalingStates with 'pranswer'?\n	  }},\n	\n	  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {\n	    var idx, jdx, length, server,\n	      servers = [],\n	      config = this.session.ua.configuration;\n	\n	    stunServers = stunServers || null;\n	    turnServers = turnServers || null;\n	\n	    if (!stunServers) {\n	      stunServers = config.stunServers;\n	    }\n	\n	    if(!turnServers) {\n	      turnServers = config.turnServers;\n	    }\n	\n	    /* Change 'url' to 'urls' whenever this issue is solved:\n	     * https://code.google.com/p/webrtc/issues/detail?id=2096\n	     */\n	    [].concat(stunServers).forEach(function (server) {\n	      servers.push({'url': server});\n	    });\n	\n	    length = turnServers.length;\n	    for (idx = 0; idx < length; idx++) {\n	      server = turnServers[idx];\n	      for (jdx = 0; jdx < server.urls.length; jdx++) {\n	        servers.push({\n	          'url': server.urls[jdx],\n	          'username': server.username,\n	          'credential': server.password\n	        });\n	      }\n	    }\n	\n	    return servers;\n	  }},\n	\n	  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {\n	    var self = this,\n	      config = this.session.ua.configuration;\n	\n	    this.onIceCompleted = SIP.Utils.defer();\n	    this.onIceCompleted.promise.then(function(pc) {\n	      self.emit('iceGatheringComplete', pc);\n	      if (self.iceCheckingTimer) {\n	        SIP.Timers.clearTimeout(self.iceCheckingTimer);\n	        self.iceCheckingTimer = null;\n	      }\n	    });\n	\n	    if (this.peerConnection) {\n	      this.peerConnection.close();\n	    }\n	\n	    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);\n	\n	    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams\n	    // even if peerConnection.onaddstream was just called. In order to make\n	    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually\n	    this._remoteStreams = [];\n	\n	    this.peerConnection.onaddstream = function(e) {\n	      self.logger.log('stream added: '+ e.stream.id);\n	      self._remoteStreams.push(e.stream);\n	      self.render();\n	      self.emit('addStream', e);\n	    };\n	\n	    this.peerConnection.onremovestream = function(e) {\n	      self.logger.log('stream removed: '+ e.stream.id);\n	    };\n	\n	    this.startIceCheckingTimer = function () {\n	      if (!self.iceCheckingTimer) {\n	        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {\n	          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');\n	          self.onIceCompleted.resolve(this);\n	        }.bind(this.peerConnection), config.iceCheckingTimeout);\n	      }\n	    };\n	\n	    this.peerConnection.onicecandidate = function(e) {\n	      self.emit('iceCandidate', e);\n	      if (e.candidate) {\n	        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n	        self.startIceCheckingTimer();\n	      } else {\n	        self.onIceCompleted.resolve(this);\n	      }\n	    };\n	\n	    this.peerConnection.onicegatheringstatechange = function () {\n	      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n	      if (this.iceGatheringState === 'gathering') {\n	        self.emit('iceGathering', this);\n	      }\n	      if (this.iceGatheringState === 'complete') {\n	        self.onIceCompleted.resolve(this);\n	      }\n	    };\n	\n	    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case\n	      var stateEvent;\n	\n	      if (this.iceConnectionState === 'checking') {\n	        self.startIceCheckingTimer();\n	      }\n	\n	      switch (this.iceConnectionState) {\n	      case 'new':\n	        stateEvent = 'iceConnection';\n	        break;\n	      case 'checking':\n	        stateEvent = 'iceConnectionChecking';\n	        break;\n	      case 'connected':\n	        stateEvent = 'iceConnectionConnected';\n	        break;\n	      case 'completed':\n	        stateEvent = 'iceConnectionCompleted';\n	        break;\n	      case 'failed':\n	        stateEvent = 'iceConnectionFailed';\n	        break;\n	      case 'disconnected':\n	        stateEvent = 'iceConnectionDisconnected';\n	        break;\n	      case 'closed':\n	        stateEvent = 'iceConnectionClosed';\n	        break;\n	      default:\n	        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);\n	        return;\n	      }\n	      self.emit(stateEvent, this);\n	\n	      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated\n	      //normal calls switch from failed to connected in some cases, so checking for failed and terminated\n	      /*if (this.iceConnectionState === 'failed') {\n	        self.session.terminate({\n	        cause: SIP.C.causes.RTP_TIMEOUT,\n	        status_code: 200,\n	        reason_phrase: SIP.C.causes.RTP_TIMEOUT\n	      });\n	      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {\n	      self.onIceCompleted(this);\n	      }*/\n	    };\n	\n	    this.peerConnection.onstatechange = function() {\n	      self.logger.log('PeerConnection state changed to \"'+ this.readyState +'\"');\n	    };\n	  }},\n	\n	  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {\n	    var self = this;\n	    var methodName;\n	    var pc = self.peerConnection;\n	\n	    self.ready = false;\n	    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n	\n	    return SIP.Utils.promisify(pc, methodName, true)(constraints)\n	      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))\n	      .then(function onSetLocalDescriptionSuccess() {\n	        var deferred = SIP.Utils.defer();\n	        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {\n	          deferred.resolve();\n	        } else {\n	          self.onIceCompleted.promise.then(deferred.resolve);\n	        }\n	        return deferred.promise;\n	      })\n	      .then(function readySuccess () {\n	        var sdp = pc.localDescription.sdp;\n	\n	        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);\n	        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);\n	\n	        var sdpWrapper = {\n	          type: methodName === 'createOffer' ? 'offer' : 'answer',\n	          sdp: sdp\n	        };\n	\n	        self.emit('getDescription', sdpWrapper);\n	\n	        self.ready = true;\n	        return sdpWrapper.sdp;\n	      })\n	      .catch(function methodFailed (e) {\n	        self.logger.error(e);\n	        self.ready = true;\n	        throw new SIP.Exceptions.GetDescriptionError(e);\n	      })\n	    ;\n	  }},\n	\n	  addStreams: {writable: true, value: function addStreams (streams) {\n	    try {\n	      streams = [].concat(streams);\n	      streams.forEach(function (stream) {\n	        this.peerConnection.addStream(stream);\n	      }, this);\n	    } catch(e) {\n	      this.logger.error('error adding stream');\n	      this.logger.error(e);\n	      return SIP.Utils.Promise.reject(e);\n	    }\n	\n	    return SIP.Utils.Promise.resolve();\n	  }},\n	\n	  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {\n	    this.getLocalStreams().forEach(function (stream) {\n	      stream[trackGetter]().forEach(function (track) {\n	        track.enabled = !mute;\n	      });\n	    });\n	  }},\n	\n	  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {\n	    this.toggleMuteHelper('getAudioTracks', mute);\n	  }},\n	\n	  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {\n	    this.toggleMuteHelper('getVideoTracks', mute);\n	  }}\n	});\n	\n	// Return since it will be assigned to a variable.\n	return MediaHandler;\n	};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview MediaStreamManager\n	 */\n	\n	/* MediaStreamManager\n	 * @class Manages the acquisition and release of MediaStreams.\n	 * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()\n	 */\n	module.exports = function (SIP, environment) {\n	\n	// Default MediaStreamManager provides single-use streams created with getUserMedia\n	var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {\n	  if (!SIP.WebRTC.isSupported()) {\n	    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n	  }\n	\n	  this.mediaHint = defaultMediaHint || {\n	    constraints: {audio: true, video: true}\n	  };\n	\n	  // map of streams to acquisition manner:\n	  // true -> passed in as mediaHint.stream\n	  // false -> getUserMedia\n	  this.acquisitions = {};\n	};\n	MediaStreamManager.streamId = function (stream) {\n	  return stream.getAudioTracks().concat(stream.getVideoTracks())\n	    .map(function trackId (track) {\n	      return track.id;\n	    })\n	    .join('');\n	};\n	\n	/**\n	 * @param {(Array of) MediaStream} streams - The streams to render\n	 *\n	 * @param {(Array of) HTMLMediaElement} elements\n	 *        - The <audio>/<video> element(s) that should render the streams\n	 *\n	 * Each stream in streams renders to the corresponding element in elements,\n	 * wrapping around elements if needed.\n	 */\n	MediaStreamManager.render = function render (streams, elements) {\n	  if (!elements) {\n	    return false;\n	  }\n	  if (Array.isArray(elements) && !elements.length) {\n	    throw new TypeError('elements must not be empty');\n	  }\n	\n	  function attachMediaStream(element, stream) {\n	    if (typeof element.src !== 'undefined') {\n	      environment.revokeObjectURL(element.src);\n	      element.src = environment.createObjectURL(stream);\n	    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {\n	      element.srcObject = element.mozSrcObject = stream;\n	    } else {\n	      return false;\n	    }\n	\n	    return true;\n	  }\n	\n	  function ensureMediaPlaying (mediaElement) {\n	    var interval = 100;\n	    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {\n	      if (mediaElement.paused) {\n	        mediaElement.play();\n	      }\n	      else {\n	        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);\n	      }\n	    }, interval);\n	  }\n	\n	  function attachAndPlay (elements, stream, index) {\n	    if (typeof elements === 'function') {\n	      elements = elements();\n	    }\n	    var element = elements[index % elements.length];\n	    (environment.attachMediaStream || attachMediaStream)(element, stream);\n	    ensureMediaPlaying(element);\n	  }\n	\n	  // [].concat \"casts\" `elements` into an array\n	  // so forEach works even if `elements` was a single element\n	  elements = [].concat(elements);\n	  [].concat(streams).forEach(attachAndPlay.bind(null, elements));\n	};\n	\n	MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {\n	  'acquire': {writable: true, value: function acquire (mediaHint) {\n	    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;\n	\n	    var saveSuccess = function (isHintStream, streams) {\n	      streams = [].concat(streams);\n	      streams.forEach(function (stream) {\n	        var streamId = MediaStreamManager.streamId(stream);\n	        this.acquisitions[streamId] = !!isHintStream;\n	      }, this);\n	      return SIP.Utils.Promise.resolve(streams);\n	    }.bind(this);\n	\n	    if (mediaHint.stream) {\n	      return saveSuccess(true, mediaHint.stream);\n	    } else {\n	      // Fallback to audio/video enabled if no mediaHint can be found.\n	      var constraints = mediaHint.constraints ||\n	        (this.mediaHint && this.mediaHint.constraints) ||\n	        {audio: true, video: true};\n	\n	      var deferred = SIP.Utils.defer();\n	\n	      /*\n	       * Make the call asynchronous, so that ICCs have a chance\n	       * to define callbacks to `userMediaRequest`\n	       */\n	      SIP.Timers.setTimeout(function () {\n	        this.emit('userMediaRequest', constraints);\n	\n	        var emitThenCall = function (eventName, callback) {\n	          var callbackArgs = Array.prototype.slice.call(arguments, 2);\n	          // Emit with all of the arguments from the real callback.\n	          var newArgs = [eventName].concat(callbackArgs);\n	\n	          this.emit.apply(this, newArgs);\n	\n	          return callback.apply(null, callbackArgs);\n	        }.bind(this);\n	\n	        if (constraints.audio || constraints.video) {\n	          deferred.resolve(\n	            SIP.WebRTC.getUserMedia(constraints)\n	            .then(\n	              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),\n	              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})\n	            )\n	          );\n	        } else {\n	          // Local streams were explicitly excluded.\n	          deferred.resolve([]);\n	        }\n	      }.bind(this), 0);\n	\n	      return deferred.promise;\n	    }\n	  }},\n	\n	  'release': {writable: true, value: function release (streams) {\n	    streams = [].concat(streams);\n	    streams.forEach(function (stream) {\n	      var streamId = MediaStreamManager.streamId(stream);\n	      if (this.acquisitions[streamId] === false) {\n	        stream.getTracks().forEach(function (track) {\n	          track.stop();\n	        });\n	      }\n	      delete this.acquisitions[streamId];\n	    }, this);\n	  }},\n	});\n	\n	// Return since it will be assigned to a variable.\n	return MediaStreamManager;\n	};\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n	/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n	/**\n	 * @augments SIP\n	 * @class Class creating a SIP User Agent.\n	 * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]\n	 *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.\n	 *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.\n	 *\n	 * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	 */\n	module.exports = function (SIP, environment) {\n	var UA,\n	  C = {\n	    // UA status codes\n	    STATUS_INIT:                0,\n	    STATUS_STARTING:            1,\n	    STATUS_READY:               2,\n	    STATUS_USER_CLOSED:         3,\n	    STATUS_NOT_READY:           4,\n	\n	    // UA error codes\n	    CONFIGURATION_ERROR:  1,\n	    NETWORK_ERROR:        2,\n	\n	    ALLOWED_METHODS: [\n	      'ACK',\n	      'CANCEL',\n	      'INVITE',\n	      'MESSAGE',\n	      'BYE',\n	      'OPTIONS',\n	      'INFO',\n	      'NOTIFY'\n	    ],\n	\n	    ACCEPTED_BODY_TYPES: [\n	      'application/sdp',\n	      'application/dtmf-relay'\n	    ],\n	\n	    MAX_FORWARDS: 70,\n	    TAG_LENGTH: 10\n	  };\n	\n	UA = function(configuration) {\n	  var self = this;\n	\n	  // Helper function for forwarding events\n	  function selfEmit(type) {\n	    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n	    return self.emit.bind(self, type);\n	  }\n	\n	  // Set Accepted Body Types\n	  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n	\n	  this.log = new SIP.LoggerFactory();\n	  this.logger = this.getLogger('sip.ua');\n	\n	  this.cache = {\n	    credentials: {}\n	  };\n	\n	  this.configuration = {};\n	  this.dialogs = {};\n	\n	  //User actions outside any session/dialog (MESSAGE)\n	  this.applicants = {};\n	\n	  this.data = {};\n	  this.sessions = {};\n	  this.subscriptions = {};\n	  this.transport = null;\n	  this.contact = null;\n	  this.status = C.STATUS_INIT;\n	  this.error = null;\n	  this.transactions = {\n	    nist: {},\n	    nict: {},\n	    ist: {},\n	    ict: {}\n	  };\n	\n	  this.transportRecoverAttempts = 0;\n	  this.transportRecoveryTimer = null;\n	\n	  Object.defineProperties(this, {\n	    transactionsCount: {\n	      get: function() {\n	        var type,\n	          transactions = ['nist','nict','ist','ict'],\n	          count = 0;\n	\n	        for (type in transactions) {\n	          count += Object.keys(this.transactions[transactions[type]]).length;\n	        }\n	\n	        return count;\n	      }\n	    },\n	\n	    nictTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['nict']).length;\n	      }\n	    },\n	\n	    nistTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['nist']).length;\n	      }\n	    },\n	\n	    ictTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['ict']).length;\n	      }\n	    },\n	\n	    istTransactionsCount: {\n	      get: function() {\n	        return Object.keys(this.transactions['ist']).length;\n	      }\n	    }\n	  });\n	\n	  /**\n	   * Load configuration\n	   *\n	   * @throws {SIP.Exceptions.ConfigurationError}\n	   * @throws {TypeError}\n	   */\n	\n	  if(configuration === undefined) {\n	    configuration = {};\n	  } else if (typeof configuration === 'string' || configuration instanceof String) {\n	    configuration = {\n	      uri: configuration\n	    };\n	  }\n	\n	  // Apply log configuration if present\n	  if (configuration.log) {\n	    if (configuration.log.hasOwnProperty('builtinEnabled')) {\n	      this.log.builtinEnabled = configuration.log.builtinEnabled;\n	    }\n	\n	    if (configuration.log.hasOwnProperty('level')) {\n	      this.log.level = configuration.log.level;\n	    }\n	\n	    if (configuration.log.hasOwnProperty('connector')) {\n	      this.log.connector = configuration.log.connector;\n	    }\n	  }\n	\n	  try {\n	    this.loadConfig(configuration);\n	  } catch(e) {\n	    this.status = C.STATUS_NOT_READY;\n	    this.error = C.CONFIGURATION_ERROR;\n	    throw e;\n	  }\n	\n	  // Initialize registerContext\n	  this.registerContext = new SIP.RegisterContext(this);\n	  this.registerContext.on('failed', selfEmit('registrationFailed'));\n	  this.registerContext.on('registered', selfEmit('registered'));\n	  this.registerContext.on('unregistered', selfEmit('unregistered'));\n	\n	  if(this.configuration.autostart) {\n	    this.start();\n	  }\n	\n	  if (typeof environment.addEventListener === 'function') {\n	    // Google Chrome Packaged Apps don't allow 'unload' listeners:\n	    // unload is not available in packaged apps\n	    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {\n	      environment.addEventListener('unload', this.stop.bind(this));\n	    }\n	  }\n	};\n	UA.prototype = Object.create(SIP.EventEmitter.prototype);\n	\n	//=================\n	//  High Level API\n	//=================\n	\n	UA.prototype.register = function(options) {\n	  this.configuration.register = true;\n	  this.registerContext.register(options);\n	\n	  return this;\n	};\n	\n	/**\n	 * Unregister.\n	 *\n	 * @param {Boolean} [all] unregister all user bindings.\n	 *\n	 */\n	UA.prototype.unregister = function(options) {\n	  this.configuration.register = false;\n	\n	  var context = this.registerContext;\n	  this.afterConnected(context.unregister.bind(context, options));\n	\n	  return this;\n	};\n	\n	UA.prototype.isRegistered = function() {\n	  return this.registerContext.registered;\n	};\n	\n	/**\n	 * Connection state.\n	 * @param {Boolean}\n	 */\n	UA.prototype.isConnected = function() {\n	  return this.transport ? this.transport.connected : false;\n	};\n	\n	UA.prototype.afterConnected = function afterConnected (callback) {\n	  if (this.isConnected()) {\n	    callback();\n	  } else {\n	    this.once('connected', callback);\n	  }\n	};\n	\n	/**\n	 * Make an outgoing call.\n	 *\n	 * @param {String} target\n	 * @param {Object} views\n	 * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n	 *\n	 * @throws {TypeError}\n	 *\n	 */\n	UA.prototype.invite = function(target, options) {\n	  var context = new SIP.InviteClientContext(this, target, options);\n	\n	  this.afterConnected(context.invite.bind(context));\n	  return context;\n	};\n	\n	UA.prototype.subscribe = function(target, event, options) {\n	  var sub = new SIP.Subscription(this, target, event, options);\n	\n	  this.afterConnected(sub.subscribe.bind(sub));\n	  return sub;\n	};\n	\n	/**\n	 * Send a message.\n	 *\n	 * @param {String} target\n	 * @param {String} body\n	 * @param {Object} [options]\n	 *\n	 * @throws {TypeError}\n	 *\n	 */\n	UA.prototype.message = function(target, body, options) {\n	  if (body === undefined) {\n	    throw new TypeError('Not enough arguments');\n	  }\n	\n	  // There is no Message module, so it is okay that the UA handles defaults here.\n	  options = Object.create(options || Object.prototype);\n	  options.contentType || (options.contentType = 'text/plain');\n	  options.body = body;\n	\n	  return this.request(SIP.C.MESSAGE, target, options);\n	};\n	\n	UA.prototype.request = function (method, target, options) {\n	  var req = new SIP.ClientContext(this, method, target, options);\n	\n	  this.afterConnected(req.send.bind(req));\n	  return req;\n	};\n	\n	/**\n	 * Gracefully close.\n	 *\n	 */\n	UA.prototype.stop = function() {\n	  var session, subscription, applicant,\n	    ua = this;\n	\n	  function transactionsListener() {\n	    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n	        ua.removeListener('transactionDestroyed', transactionsListener);\n	        ua.transport.disconnect();\n	    }\n	  }\n	\n	  this.logger.log('user requested closure...');\n	\n	  if(this.status === C.STATUS_USER_CLOSED) {\n	    this.logger.warn('UA already closed');\n	    return this;\n	  }\n	\n	  // Clear transportRecoveryTimer\n	  SIP.Timers.clearTimeout(this.transportRecoveryTimer);\n	\n	  // Close registerContext\n	  this.logger.log('closing registerContext');\n	  this.registerContext.close();\n	\n	  // Run  _terminate_ on every Session\n	  for(session in this.sessions) {\n	    this.logger.log('closing session ' + session);\n	    this.sessions[session].terminate();\n	  }\n	\n	  //Run _close_ on every Subscription\n	  for(subscription in this.subscriptions) {\n	    this.logger.log('unsubscribing from subscription ' + subscription);\n	    this.subscriptions[subscription].close();\n	  }\n	\n	  // Run  _close_ on every applicant\n	  for(applicant in this.applicants) {\n	    this.applicants[applicant].close();\n	  }\n	\n	  this.status = C.STATUS_USER_CLOSED;\n	\n	  /*\n	   * If the remaining transactions are all INVITE transactions, there is no need to\n	   * wait anymore because every session has already been closed by this method.\n	   * - locally originated sessions where terminated (CANCEL or BYE)\n	   * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n	   * Remaining INVITE transactions belong tho sessions that where answered. This are in\n	   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n	   */\n	  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n	    this.transport.disconnect();\n	  } else {\n	    this.on('transactionDestroyed', transactionsListener);\n	  }\n	\n	  return this;\n	};\n	\n	/**\n	 * Connect to the WS server if status = STATUS_INIT.\n	 * Resume UA after being closed.\n	 *\n	 */\n	UA.prototype.start = function() {\n	  var server;\n	\n	  this.logger.log('user requested startup...');\n	  if (this.status === C.STATUS_INIT) {\n	    server = this.getNextWsServer();\n	    this.status = C.STATUS_STARTING;\n	    new SIP.Transport(this, server);\n	  } else if(this.status === C.STATUS_USER_CLOSED) {\n	    this.logger.log('resuming');\n	    this.status = C.STATUS_READY;\n	    this.transport.connect();\n	  } else if (this.status === C.STATUS_STARTING) {\n	    this.logger.log('UA is in STARTING status, not opening new connection');\n	  } else if (this.status === C.STATUS_READY) {\n	    this.logger.log('UA is in READY status, not resuming');\n	  } else {\n	    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n	  }\n	\n	  return this;\n	};\n	\n	/**\n	 * Normalize a string into a valid SIP request URI\n	 *\n	 * @param {String} target\n	 *\n	 * @returns {SIP.URI|undefined}\n	 */\n	UA.prototype.normalizeTarget = function(target) {\n	  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n	};\n	\n	\n	//===============================\n	//  Private (For internal use)\n	//===============================\n	\n	UA.prototype.saveCredentials = function(credentials) {\n	  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n	  this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n	\n	  return this;\n	};\n	\n	UA.prototype.getCredentials = function(request) {\n	  var realm, credentials;\n	\n	  realm = request.ruri.host;\n	\n	  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n	    credentials = this.cache.credentials[realm][request.ruri];\n	    credentials.method = request.method;\n	  }\n	\n	  return credentials;\n	};\n	\n	UA.prototype.getLogger = function(category, label) {\n	  return this.log.getLogger(category, label);\n	};\n	\n	\n	//==============================\n	// Event Handlers\n	//==============================\n	\n	/**\n	 * Transport Close event\n	 * @private\n	 * @event\n	 * @param {SIP.Transport} transport.\n	 */\n	UA.prototype.onTransportClosed = function(transport) {\n	  // Run _onTransportError_ callback on every client transaction using _transport_\n	  var type, idx, length,\n	    client_transactions = ['nict', 'ict', 'nist', 'ist'];\n	\n	  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;\n	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);\n	\n	  length = client_transactions.length;\n	  for (type = 0; type < length; type++) {\n	    for(idx in this.transactions[client_transactions[type]]) {\n	      this.transactions[client_transactions[type]][idx].onTransportError();\n	    }\n	  }\n	\n	  // Close sessions if GRUU is not being used\n	  if (!this.contact.pub_gruu) {\n	    this.closeSessionsOnTransportError();\n	  }\n	\n	};\n	\n	/**\n	 * Unrecoverable transport event.\n	 * Connection reattempt logic has been done and didn't success.\n	 * @private\n	 * @event\n	 * @param {SIP.Transport} transport.\n	 */\n	UA.prototype.onTransportError = function(transport) {\n	  var server;\n	\n	  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);\n	\n	  // Close sessions.\n	  //Mark this transport as 'down'\n	  transport.server.status = SIP.Transport.C.STATUS_ERROR;\n	\n	  this.emit('disconnected', {\n	    transport: transport\n	  });\n	\n	  // try the next transport if the UA isn't closed\n	  if(this.status === C.STATUS_USER_CLOSED) {\n	    return;\n	  }\n	\n	  server = this.getNextWsServer();\n	\n	  if(server) {\n	    new SIP.Transport(this, server);\n	  }else {\n	    this.closeSessionsOnTransportError();\n	    if (!this.error || this.error !== C.NETWORK_ERROR) {\n	      this.status = C.STATUS_NOT_READY;\n	      this.error = C.NETWORK_ERROR;\n	    }\n	    // Transport Recovery process\n	    this.recoverTransport();\n	  }\n	};\n	\n	/**\n	 * Transport connection event.\n	 * @private\n	 * @event\n	 * @param {SIP.Transport} transport.\n	 */\n	UA.prototype.onTransportConnected = function(transport) {\n	  this.transport = transport;\n	\n	  // Reset transport recovery counter\n	  this.transportRecoverAttempts = 0;\n	\n	  transport.server.status = SIP.Transport.C.STATUS_READY;\n	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);\n	\n	  if(this.status === C.STATUS_USER_CLOSED) {\n	    return;\n	  }\n	\n	  this.status = C.STATUS_READY;\n	  this.error = null;\n	\n	  if(this.configuration.register) {\n	    this.configuration.authenticationFactory.initialize().then(function () {\n	      this.registerContext.onTransportConnected();\n	    }.bind(this));\n	  }\n	\n	  this.emit('connected', {\n	    transport: transport\n	  });\n	};\n	\n	\n	/**\n	 * Transport connecting event\n	 * @private\n	 * @param {SIP.Transport} transport.\n	 * #param {Integer} attempts.\n	 */\n	  UA.prototype.onTransportConnecting = function(transport, attempts) {\n	    this.emit('connecting', {\n	      transport: transport,\n	      attempts: attempts\n	    });\n	  };\n	\n	\n	/**\n	 * new Transaction\n	 * @private\n	 * @param {SIP.Transaction} transaction.\n	 */\n	UA.prototype.newTransaction = function(transaction) {\n	  this.transactions[transaction.type][transaction.id] = transaction;\n	  this.emit('newTransaction', {transaction: transaction});\n	};\n	\n	\n	/**\n	 * destroy Transaction\n	 * @private\n	 * @param {SIP.Transaction} transaction.\n	 */\n	UA.prototype.destroyTransaction = function(transaction) {\n	  delete this.transactions[transaction.type][transaction.id];\n	  this.emit('transactionDestroyed', {\n	    transaction: transaction\n	  });\n	};\n	\n	\n	//=========================\n	// receiveRequest\n	//=========================\n	\n	/**\n	 * Request reception\n	 * @private\n	 * @param {SIP.IncomingRequest} request.\n	 */\n	UA.prototype.receiveRequest = function(request) {\n	  var dialog, session, message,\n	    method = request.method,\n	    transaction,\n	    replaces,\n	    replacedDialog,\n	    self = this;\n	\n	  function ruriMatches (uri) {\n	    return uri && uri.user === request.ruri.user;\n	  }\n	\n	  // Check that request URI points to us\n	  if(!(ruriMatches(this.configuration.uri) ||\n	       ruriMatches(this.contact.uri) ||\n	       ruriMatches(this.contact.pub_gruu) ||\n	       ruriMatches(this.contact.temp_gruu))) {\n	    this.logger.warn('Request-URI does not point to us');\n	    if (request.method !== SIP.C.ACK) {\n	      request.reply_sl(404);\n	    }\n	    return;\n	  }\n	\n	  // Check request URI scheme\n	  if(request.ruri.scheme === SIP.C.SIPS) {\n	    request.reply_sl(416);\n	    return;\n	  }\n	\n	  // Check transaction\n	  if(SIP.Transactions.checkTransaction(this, request)) {\n	    return;\n	  }\n	\n	  /* RFC3261 12.2.2\n	   * Requests that do not change in any way the state of a dialog may be\n	   * received within a dialog (for example, an OPTIONS request).\n	   * They are processed as if they had been received outside the dialog.\n	   */\n	  if(method === SIP.C.OPTIONS) {\n	    new SIP.Transactions.NonInviteServerTransaction(request, this);\n	    request.reply(200, null, [\n	      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),\n	      'Accept: '+ C.ACCEPTED_BODY_TYPES\n	    ]);\n	  } else if (method === SIP.C.MESSAGE) {\n	    message = new SIP.ServerContext(this, request);\n	    message.body = request.body;\n	    message.content_type = request.getHeader('Content-Type') || 'text/plain';\n	\n	    request.reply(200, null);\n	    this.emit('message', message);\n	  } else if (method !== SIP.C.INVITE &&\n	             method !== SIP.C.ACK) {\n	    // Let those methods pass through to normal processing for now.\n	    transaction = new SIP.ServerContext(this, request);\n	  }\n	\n	  // Initial Request\n	  if(!request.to_tag) {\n	    switch(method) {\n	      case SIP.C.INVITE:\n	        replaces =\n	          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&\n	          request.parseHeader('replaces');\n	\n	        if (replaces) {\n	          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];\n	\n	          if (!replacedDialog) {\n	            //Replaced header without a matching dialog, reject\n	            request.reply_sl(481, null);\n	            return;\n	          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {\n	            request.reply_sl(603, null);\n	            return;\n	          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {\n	            request.reply_sl(486, null);\n	            return;\n	          }\n	        }\n	\n	        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;\n	        if(!isMediaSupported || isMediaSupported()) {\n	          session = new SIP.InviteServerContext(this, request);\n	          session.replacee = replacedDialog && replacedDialog.owner;\n	          session.on('invite', function() {\n	            self.emit('invite', this);\n	          });\n	        } else {\n	          this.logger.warn('INVITE received but WebRTC is not supported');\n	          request.reply(488);\n	        }\n	        break;\n	      case SIP.C.BYE:\n	        // Out of dialog BYE received\n	        request.reply(481);\n	        break;\n	      case SIP.C.CANCEL:\n	        session = this.findSession(request);\n	        if(session) {\n	          session.receiveRequest(request);\n	        } else {\n	          this.logger.warn('received CANCEL request for a non existent session');\n	        }\n	        break;\n	      case SIP.C.ACK:\n	        /* Absorb it.\n	         * ACK request without a corresponding Invite Transaction\n	         * and without To tag.\n	         */\n	        break;\n	      default:\n	        request.reply(405);\n	        break;\n	    }\n	  }\n	  // In-dialog request\n	  else {\n	    dialog = this.findDialog(request);\n	\n	    if(dialog) {\n	      if (method === SIP.C.INVITE) {\n	        new SIP.Transactions.InviteServerTransaction(request, this);\n	      }\n	      dialog.receiveRequest(request);\n	    } else if (method === SIP.C.NOTIFY) {\n	      session = this.findSession(request);\n	      if(session) {\n	        session.receiveRequest(request);\n	      } else {\n	        this.logger.warn('received NOTIFY request for a non existent session');\n	        request.reply(481, 'Subscription does not exist');\n	      }\n	    }\n	    /* RFC3261 12.2.2\n	     * Request with to tag, but no matching dialog found.\n	     * Exception: ACK for an Invite request for which a dialog has not\n	     * been created.\n	     */\n	    else {\n	      if(method !== SIP.C.ACK) {\n	        request.reply(481);\n	      }\n	    }\n	  }\n	};\n	\n	//=================\n	// Utils\n	//=================\n	\n	/**\n	 * Get the session to which the request belongs to, if any.\n	 * @private\n	 * @param {SIP.IncomingRequest} request.\n	 * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n	 */\n	UA.prototype.findSession = function(request) {\n	  return this.sessions[request.call_id + request.from_tag] ||\n	          this.sessions[request.call_id + request.to_tag] ||\n	          null;\n	};\n	\n	/**\n	 * Get the dialog to which the request belongs to, if any.\n	 * @private\n	 * @param {SIP.IncomingRequest}\n	 * @returns {SIP.Dialog|null}\n	 */\n	UA.prototype.findDialog = function(request) {\n	  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||\n	          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||\n	          null;\n	};\n	\n	/**\n	 * Retrieve the next server to which connect.\n	 * @private\n	 * @returns {Object} ws_server\n	 */\n	UA.prototype.getNextWsServer = function() {\n	  // Order servers by weight\n	  var idx, length, ws_server,\n	    candidates = [];\n	\n	  length = this.configuration.wsServers.length;\n	  for (idx = 0; idx < length; idx++) {\n	    ws_server = this.configuration.wsServers[idx];\n	\n	    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {\n	      continue;\n	    } else if (candidates.length === 0) {\n	      candidates.push(ws_server);\n	    } else if (ws_server.weight > candidates[0].weight) {\n	      candidates = [ws_server];\n	    } else if (ws_server.weight === candidates[0].weight) {\n	      candidates.push(ws_server);\n	    }\n	  }\n	\n	  idx = Math.floor(Math.random() * candidates.length);\n	\n	  return candidates[idx];\n	};\n	\n	/**\n	 * Close all sessions on transport error.\n	 * @private\n	 */\n	UA.prototype.closeSessionsOnTransportError = function() {\n	  var idx;\n	\n	  // Run _transportError_ for every Session\n	  for(idx in this.sessions) {\n	    this.sessions[idx].onTransportError();\n	  }\n	  // Call registerContext _onTransportClosed_\n	  this.registerContext.onTransportClosed();\n	};\n	\n	UA.prototype.recoverTransport = function(ua) {\n	  var idx, length, k, nextRetry, count, server;\n	\n	  ua = ua || this;\n	  count = ua.transportRecoverAttempts;\n	\n	  length = ua.configuration.wsServers.length;\n	  for (idx = 0; idx < length; idx++) {\n	    ua.configuration.wsServers[idx].status = 0;\n	  }\n	\n	  server = ua.getNextWsServer();\n	\n	  k = Math.floor((Math.random() * Math.pow(2,count)) +1);\n	  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;\n	\n	  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {\n	    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');\n	    nextRetry = ua.configuration.connectionRecoveryMinInterval;\n	    count = 0;\n	  }\n	\n	  this.logger.log('next connection attempt in '+ nextRetry +' seconds');\n	\n	  this.transportRecoveryTimer = SIP.Timers.setTimeout(\n	    function(){\n	      ua.transportRecoverAttempts = count + 1;\n	      new SIP.Transport(ua, server);\n	    }, nextRetry * 1000);\n	};\n	\n	function checkAuthenticationFactory (authenticationFactory) {\n	  if (!(authenticationFactory instanceof Function)) {\n	    return;\n	  }\n	  if (!authenticationFactory.initialize) {\n	    authenticationFactory.initialize = function initialize () {\n	      return SIP.Utils.Promise.resolve();\n	    };\n	  }\n	  return authenticationFactory;\n	}\n	\n	/**\n	 * Configuration load.\n	 * @private\n	 * returns {Boolean}\n	 */\n	UA.prototype.loadConfig = function(configuration) {\n	  // Settings and default values\n	  var parameter, value, checked_value, hostportParams, registrarServer,\n	    settings = {\n	      /* Host address\n	      * Value to be set in Via sent_by and host part of Contact FQDN\n	      */\n	      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n	\n	      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n	      wsServers: [{\n	        scheme: 'WSS',\n	        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n	        status: 0,\n	        weight: 0,\n	        ws_uri: 'wss://edge.sip.onsip.com'\n	      }],\n	\n	      // Password\n	      password: null,\n	\n	      // Registration parameters\n	      registerExpires: 600,\n	      register: true,\n	      registrarServer: null,\n	\n	      // Transport related parameters\n	      wsServerMaxReconnection: 3,\n	      wsServerReconnectionTimeout: 4,\n	\n	      connectionRecoveryMinInterval: 2,\n	      connectionRecoveryMaxInterval: 30,\n	\n	      keepAliveInterval: 0,\n	\n	      extraSupported: [],\n	\n	      usePreloadedRoute: false,\n	\n	      //string to be inserted into User-Agent request header\n	      userAgentString: SIP.C.USER_AGENT,\n	\n	      // Session parameters\n	      iceCheckingTimeout: 5000,\n	      noAnswerTimeout: 60,\n	      stunServers: ['stun:stun.l.google.com:19302'],\n	      turnServers: [],\n	\n	      // Logging parameters\n	      traceSip: false,\n	\n	      // Hacks\n	      hackViaTcp: false,\n	      hackIpInContact: false,\n	      hackWssInTransport: false,\n	      hackAllowUnregisteredOptionTags: false,\n	\n	      contactTransport: 'ws',\n	      forceRport: false,\n	\n	      //autostarting\n	      autostart: true,\n	\n	      //Reliable Provisional Responses\n	      rel100: SIP.C.supported.UNSUPPORTED,\n	\n	      // Replaces header (RFC 3891)\n	      // http://tools.ietf.org/html/rfc3891\n	      replaces: SIP.C.supported.UNSUPPORTED,\n	\n	      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,\n	\n	      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {\n	        return new SIP.DigestAuthentication(ua);\n	      })\n	    };\n	\n	  // Pre-Configuration\n	  function aliasUnderscored (parameter, logger) {\n	    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n	      return m[0] + '_' + m[1].toLowerCase();\n	    });\n	\n	    if (parameter === underscored) {\n	      return;\n	    }\n	\n	    var hasParameter = configuration.hasOwnProperty(parameter);\n	    if (configuration.hasOwnProperty(underscored)) {\n	      logger.warn(underscored + ' is deprecated, please use ' + parameter);\n	      if (hasParameter) {\n	        logger.warn(parameter + ' overriding ' + underscored);\n	      }\n	    }\n	\n	    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n	  }\n	\n	  // Check Mandatory parameters\n	  for(parameter in UA.configuration_check.mandatory) {\n	    aliasUnderscored(parameter, this.logger);\n	    if(!configuration.hasOwnProperty(parameter)) {\n	      throw new SIP.Exceptions.ConfigurationError(parameter);\n	    } else {\n	      value = configuration[parameter];\n	      checked_value = UA.configuration_check.mandatory[parameter](value);\n	      if (checked_value !== undefined) {\n	        settings[parameter] = checked_value;\n	      } else {\n	        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n	      }\n	    }\n	  }\n	\n	  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);\n	\n	  var emptyArraysAllowed = ['stunServers', 'turnServers'];\n	\n	  // Check Optional parameters\n	  for(parameter in UA.configuration_check.optional) {\n	    aliasUnderscored(parameter, this.logger);\n	    if(configuration.hasOwnProperty(parameter)) {\n	      value = configuration[parameter];\n	\n	      // If the parameter value is an empty array, but shouldn't be, apply its default value.\n	      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }\n	\n	      // If the parameter value is null, empty string, or undefined then apply its default value.\n	      if(value === null || value === \"\" || value === undefined) { continue; }\n	      // If it's a number with NaN value then also apply its default value.\n	      // NOTE: JS does not allow \"value === NaN\", the following does the work:\n	      else if(typeof(value) === 'number' && isNaN(value)) { continue; }\n	\n	      checked_value = UA.configuration_check.optional[parameter](value);\n	      if (checked_value !== undefined) {\n	        settings[parameter] = checked_value;\n	      } else {\n	        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n	      }\n	    }\n	  }\n	\n	  // Sanity Checks\n	\n	  // Connection recovery intervals\n	  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {\n	    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);\n	  }\n	\n	  // Post Configuration Process\n	\n	  // Allow passing 0 number as displayName.\n	  if (settings.displayName === 0) {\n	    settings.displayName = '0';\n	  }\n	\n	  // Instance-id for GRUU\n	  if (!settings.instanceId) {\n	    settings.instanceId = SIP.Utils.newUUID();\n	  }\n	\n	  // sipjsId instance parameter. Static random tag of length 5\n	  settings.sipjsId = SIP.Utils.createRandomToken(5);\n	\n	  // String containing settings.uri without scheme and user.\n	  hostportParams = settings.uri.clone();\n	  hostportParams.user = null;\n	  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');\n	\n	  /* Check whether authorizationUser is explicitly defined.\n	   * Take 'settings.uri.user' value if not.\n	   */\n	  if (!settings.authorizationUser) {\n	    settings.authorizationUser = settings.uri.user;\n	  }\n	\n	  /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n	  if (!settings.registrarServer) {\n	    registrarServer = settings.uri.clone();\n	    registrarServer.user = null;\n	    settings.registrarServer = registrarServer;\n	  }\n	\n	  // User noAnswerTimeout\n	  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;\n	\n	  // Via Host\n	  if (settings.hackIpInContact) {\n	    if (typeof settings.hackIpInContact === 'boolean') {\n	      settings.viaHost = SIP.Utils.getRandomTestNetIP();\n	    }\n	    else if (typeof settings.hackIpInContact === 'string') {\n	      settings.viaHost = settings.hackIpInContact;\n	    }\n	  }\n	\n	  // Contact transport parameter\n	  if (settings.hackWssInTransport) {\n	    settings.contactTransport = 'wss';\n	  }\n	\n	  this.contact = {\n	    pub_gruu: null,\n	    temp_gruu: null,\n	    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),\n	    toString: function(options){\n	      options = options || {};\n	\n	      var\n	        anonymous = options.anonymous || null,\n	        outbound = options.outbound || null,\n	        contact = '<';\n	\n	      if (anonymous) {\n	        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();\n	      } else {\n	        contact += (this.pub_gruu || this.uri).toString();\n	      }\n	\n	      if (outbound) {\n	        contact += ';ob';\n	      }\n	\n	      contact += '>';\n	\n	      return contact;\n	    }\n	  };\n	\n	  // media overrides mediaConstraints\n	  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);\n	\n	  // Fill the value of the configuration_skeleton\n	  for(parameter in settings) {\n	    UA.configuration_skeleton[parameter].value = settings[parameter];\n	  }\n	\n	  Object.defineProperties(this.configuration, UA.configuration_skeleton);\n	\n	  // Clean UA.configuration_skeleton\n	  for(parameter in settings) {\n	    UA.configuration_skeleton[parameter].value = '';\n	  }\n	\n	  this.logger.log('configuration parameters after validation:');\n	  for(parameter in settings) {\n	    switch(parameter) {\n	      case 'uri':\n	      case 'registrarServer':\n	      case 'mediaHandlerFactory':\n	        this.logger.log(' ' + parameter + ': ' + settings[parameter]);\n	        break;\n	      case 'password':\n	        this.logger.log(' ' + parameter + ': ' + 'NOT SHOWN');\n	        break;\n	      default:\n	        this.logger.log(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n	    }\n	  }\n	\n	  return;\n	};\n	\n	/**\n	 * Configuration Object skeleton.\n	 * @private\n	 */\n	UA.configuration_skeleton = (function() {\n	  var idx,  parameter,\n	    skeleton = {},\n	    parameters = [\n	      // Internal parameters\n	      \"sipjsId\",\n	      \"hostportParams\",\n	\n	      // Optional user configurable parameters\n	      \"uri\",\n	      \"wsServers\",\n	      \"authorizationUser\",\n	      \"connectionRecoveryMaxInterval\",\n	      \"connectionRecoveryMinInterval\",\n	      \"keepAliveInterval\",\n	      \"extraSupported\",\n	      \"displayName\",\n	      \"hackViaTcp\", // false.\n	      \"hackIpInContact\", //false\n	      \"hackWssInTransport\", //false\n	      \"hackAllowUnregisteredOptionTags\", //false\n	      \"contactTransport\", // 'ws'\n	      \"forceRport\", // false\n	      \"iceCheckingTimeout\",\n	      \"instanceId\",\n	      \"noAnswerTimeout\", // 30 seconds.\n	      \"password\",\n	      \"registerExpires\", // 600 seconds.\n	      \"registrarServer\",\n	      \"reliable\",\n	      \"rel100\",\n	      \"replaces\",\n	      \"userAgentString\", //SIP.C.USER_AGENT\n	      \"autostart\",\n	      \"stunServers\",\n	      \"traceSip\",\n	      \"turnServers\",\n	      \"usePreloadedRoute\",\n	      \"wsServerMaxReconnection\",\n	      \"wsServerReconnectionTimeout\",\n	      \"mediaHandlerFactory\",\n	      \"media\",\n	      \"mediaConstraints\",\n	      \"authenticationFactory\",\n	\n	      // Post-configuration generated parameters\n	      \"via_core_value\",\n	      \"viaHost\"\n	    ];\n	\n	  for(idx in parameters) {\n	    parameter = parameters[idx];\n	    skeleton[parameter] = {\n	      value: '',\n	      writable: false,\n	      configurable: false\n	    };\n	  }\n	\n	  skeleton['register'] = {\n	    value: '',\n	    writable: true,\n	    configurable: false\n	  };\n	\n	  return skeleton;\n	}());\n	\n	/**\n	 * Configuration checker.\n	 * @private\n	 * @return {Boolean}\n	 */\n	UA.configuration_check = {\n	  mandatory: {\n	  },\n	\n	  optional: {\n	\n	    uri: function(uri) {\n	      var parsed;\n	\n	      if (!(/^sip:/i).test(uri)) {\n	        uri = SIP.C.SIP + ':' + uri;\n	      }\n	      parsed = SIP.URI.parse(uri);\n	\n	      if(!parsed) {\n	        return;\n	      } else if(!parsed.user) {\n	        return;\n	      } else {\n	        return parsed;\n	      }\n	    },\n	\n	    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n	    wsServers: function(wsServers) {\n	      var idx, length, url;\n	\n	      /* Allow defining wsServers parameter as:\n	       *  String: \"host\"\n	       *  Array of Strings: [\"host1\", \"host2\"]\n	       *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n	       *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n	       */\n	      if (typeof wsServers === 'string') {\n	        wsServers = [{ws_uri: wsServers}];\n	      } else if (wsServers instanceof Array) {\n	        length = wsServers.length;\n	        for (idx = 0; idx < length; idx++) {\n	          if (typeof wsServers[idx] === 'string'){\n	            wsServers[idx] = {ws_uri: wsServers[idx]};\n	          }\n	        }\n	      } else {\n	        return;\n	      }\n	\n	      if (wsServers.length === 0) {\n	        return false;\n	      }\n	\n	      length = wsServers.length;\n	      for (idx = 0; idx < length; idx++) {\n	        if (!wsServers[idx].ws_uri) {\n	          return;\n	        }\n	        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {\n	          return;\n	        }\n	\n	        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');\n	\n	        if(url === -1) {\n	          return;\n	        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {\n	          return;\n	        } else {\n	          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';\n	\n	          if (!wsServers[idx].weight) {\n	            wsServers[idx].weight = 0;\n	          }\n	\n	          wsServers[idx].status = 0;\n	          wsServers[idx].scheme = url.scheme.toUpperCase();\n	        }\n	      }\n	      return wsServers;\n	    },\n	\n	    authorizationUser: function(authorizationUser) {\n	      if(SIP.Grammar.parse('\"'+ authorizationUser +'\"', 'quoted_string') === -1) {\n	        return;\n	      } else {\n	        return authorizationUser;\n	      }\n	    },\n	\n	    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {\n	      var value;\n	      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {\n	        value = Number(connectionRecoveryMaxInterval);\n	        if(value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {\n	      var value;\n	      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {\n	        value = Number(connectionRecoveryMinInterval);\n	        if(value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    displayName: function(displayName) {\n	      if(SIP.Grammar.parse('\"' + displayName + '\"', 'displayName') === -1) {\n	        return;\n	      } else {\n	        return displayName;\n	      }\n	    },\n	\n	    hackViaTcp: function(hackViaTcp) {\n	      if (typeof hackViaTcp === 'boolean') {\n	        return hackViaTcp;\n	      }\n	    },\n	\n	    hackIpInContact: function(hackIpInContact) {\n	      if (typeof hackIpInContact === 'boolean') {\n	        return hackIpInContact;\n	      }\n	      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {\n	        return hackIpInContact;\n	      }\n	    },\n	\n	    iceCheckingTimeout: function(iceCheckingTimeout) {\n	      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {\n	        return Math.max(500, iceCheckingTimeout);\n	      }\n	    },\n	\n	    hackWssInTransport: function(hackWssInTransport) {\n	      if (typeof hackWssInTransport === 'boolean') {\n	        return hackWssInTransport;\n	      }\n	    },\n	\n	    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {\n	      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {\n	        return hackAllowUnregisteredOptionTags;\n	      }\n	    },\n	\n	    contactTransport: function(contactTransport) {\n	      if (typeof contactTransport === 'string') {\n	        return contactTransport;\n	      }\n	    },\n	\n	    forceRport: function(forceRport) {\n	      if (typeof forceRport === 'boolean') {\n	        return forceRport;\n	      }\n	    },\n	\n	    instanceId: function(instanceId) {\n	      if(typeof instanceId !== 'string') {\n	        return;\n	      }\n	\n	      if ((/^uuid:/i.test(instanceId))) {\n	        instanceId = instanceId.substr(5);\n	      }\n	\n	      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {\n	        return;\n	      } else {\n	        return instanceId;\n	      }\n	    },\n	\n	    keepAliveInterval: function(keepAliveInterval) {\n	      var value;\n	      if (SIP.Utils.isDecimal(keepAliveInterval)) {\n	        value = Number(keepAliveInterval);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    extraSupported: function(optionTags) {\n	      var idx, length;\n	\n	      if (!(optionTags instanceof Array)) {\n	        return;\n	      }\n	\n	      length = optionTags.length;\n	      for (idx = 0; idx < length; idx++) {\n	        if (typeof optionTags[idx] !== 'string') {\n	          return;\n	        }\n	      }\n	\n	      return optionTags;\n	    },\n	\n	    noAnswerTimeout: function(noAnswerTimeout) {\n	      var value;\n	      if (SIP.Utils.isDecimal(noAnswerTimeout)) {\n	        value = Number(noAnswerTimeout);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    password: function(password) {\n	      return String(password);\n	    },\n	\n	    rel100: function(rel100) {\n	      if(rel100 === SIP.C.supported.REQUIRED) {\n	        return SIP.C.supported.REQUIRED;\n	      } else if (rel100 === SIP.C.supported.SUPPORTED) {\n	        return SIP.C.supported.SUPPORTED;\n	      } else  {\n	        return SIP.C.supported.UNSUPPORTED;\n	      }\n	    },\n	\n	    replaces: function(replaces) {\n	      if(replaces === SIP.C.supported.REQUIRED) {\n	        return SIP.C.supported.REQUIRED;\n	      } else if (replaces === SIP.C.supported.SUPPORTED) {\n	        return SIP.C.supported.SUPPORTED;\n	      } else  {\n	        return SIP.C.supported.UNSUPPORTED;\n	      }\n	    },\n	\n	    register: function(register) {\n	      if (typeof register === 'boolean') {\n	        return register;\n	      }\n	    },\n	\n	    registerExpires: function(registerExpires) {\n	      var value;\n	      if (SIP.Utils.isDecimal(registerExpires)) {\n	        value = Number(registerExpires);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    registrarServer: function(registrarServer) {\n	      var parsed;\n	\n	      if(typeof registrarServer !== 'string') {\n	        return;\n	      }\n	\n	      if (!/^sip:/i.test(registrarServer)) {\n	        registrarServer = SIP.C.SIP + ':' + registrarServer;\n	      }\n	      parsed = SIP.URI.parse(registrarServer);\n	\n	      if(!parsed) {\n	        return;\n	      } else if(parsed.user) {\n	        return;\n	      } else {\n	        return parsed;\n	      }\n	    },\n	\n	    stunServers: function(stunServers) {\n	      var idx, length, stun_server;\n	\n	      if (typeof stunServers === 'string') {\n	        stunServers = [stunServers];\n	      } else if (!(stunServers instanceof Array)) {\n	        return;\n	      }\n	\n	      length = stunServers.length;\n	      for (idx = 0; idx < length; idx++) {\n	        stun_server = stunServers[idx];\n	        if (!(/^stuns?:/.test(stun_server))) {\n	          stun_server = 'stun:' + stun_server;\n	        }\n	\n	        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {\n	          return;\n	        } else {\n	          stunServers[idx] = stun_server;\n	        }\n	      }\n	      return stunServers;\n	    },\n	\n	    traceSip: function(traceSip) {\n	      if (typeof traceSip === 'boolean') {\n	        return traceSip;\n	      }\n	    },\n	\n	    turnServers: function(turnServers) {\n	      var idx, jdx, length, turn_server, num_turn_server_urls, url;\n	\n	      if (turnServers instanceof Array) {\n	        // Do nothing\n	      } else {\n	        turnServers = [turnServers];\n	      }\n	\n	      length = turnServers.length;\n	      for (idx = 0; idx < length; idx++) {\n	        turn_server = turnServers[idx];\n	        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.\n	        if (turn_server.server) {\n	          turn_server.urls = [turn_server.server];\n	        }\n	\n	        if (!turn_server.urls || !turn_server.username || !turn_server.password) {\n	          return;\n	        }\n	\n	        if (turn_server.urls instanceof Array) {\n	          num_turn_server_urls = turn_server.urls.length;\n	        } else {\n	          turn_server.urls = [turn_server.urls];\n	          num_turn_server_urls = 1;\n	        }\n	\n	        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {\n	          url = turn_server.urls[jdx];\n	\n	          if (!(/^turns?:/.test(url))) {\n	            url = 'turn:' + url;\n	          }\n	\n	          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {\n	            return;\n	          }\n	        }\n	      }\n	      return turnServers;\n	    },\n	\n	    userAgentString: function(userAgentString) {\n	      if (typeof userAgentString === 'string') {\n	        return userAgentString;\n	      }\n	    },\n	\n	    usePreloadedRoute: function(usePreloadedRoute) {\n	      if (typeof usePreloadedRoute === 'boolean') {\n	        return usePreloadedRoute;\n	      }\n	    },\n	\n	    wsServerMaxReconnection: function(wsServerMaxReconnection) {\n	      var value;\n	      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {\n	        value = Number(wsServerMaxReconnection);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {\n	      var value;\n	      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {\n	        value = Number(wsServerReconnectionTimeout);\n	        if (value > 0) {\n	          return value;\n	        }\n	      }\n	    },\n	\n	    autostart: function(autostart) {\n	      if (typeof autostart === 'boolean') {\n	        return autostart;\n	      }\n	    },\n	\n	    mediaHandlerFactory: function(mediaHandlerFactory) {\n	      if (mediaHandlerFactory instanceof Function) {\n	        var promisifiedFactory = function promisifiedFactory () {\n	          var mediaHandler = mediaHandlerFactory.apply(this, arguments);\n	\n	          function patchMethod (methodName) {\n	            var method = mediaHandler[methodName];\n	            if (method.length > 1) {\n	              var callbacksFirst = methodName === 'getDescription';\n	              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);\n	            }\n	          }\n	\n	          patchMethod('getDescription');\n	          patchMethod('setDescription');\n	\n	          return mediaHandler;\n	        };\n	\n	        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;\n	        return promisifiedFactory;\n	      }\n	    },\n	\n	    authenticationFactory: checkAuthenticationFactory\n	  }\n	};\n	\n	UA.C = C;\n	SIP.UA = UA;\n	};\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Hacks - This file contains all of the things we\n	 * wish we didn't have to do, just for interop.  It is similar to\n	 * Utils, which provides actually useful and relevant functions for\n	 * a SIP library. Methods in this file are grouped by vendor, so\n	 * as to most easily track when particular hacks may not be necessary anymore.\n	 */\n	\n	module.exports = function (SIP) {\n	\n	//keep to quiet jshint, and remain consistent with other files\n	SIP = SIP;\n	\n	var Hacks = {\n	  AllBrowsers: {\n	    maskDtls: function (message) {\n	      if (message.body) {\n	        message.body = message.body.replace(/ UDP\\/TLS\\/RTP\\/SAVP/gmi, \" RTP/SAVP\");\n	      }\n	    },\n	    unmaskDtls: function (sdp) {\n	      /**\n	       * Chrome does not handle DTLS correctly (Canaray does, but not production)\n	       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)\n	       *\n	       * UPDATE: May 21, 2014\n	       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES\n	       *\n	       * UPDATE: 2014-09-24\n	       * Opera now supports DTLS by default as well.\n	       *\n	       **/\n	      return sdp.replace(/ RTP\\/SAVP/gmi, \" UDP/TLS/RTP/SAVP\");\n	    }\n	  },\n	  Firefox: {\n	    /* Condition to detect if hacks are applicable */\n	    isFirefox: function () {\n	      return typeof mozRTCPeerConnection !== 'undefined';\n	    },\n	\n	    cannotHandleExtraWhitespace: function (message) {\n	      if (this.isFirefox() && message.body) {\n	        message.body = message.body.replace(/ \\r\\n/g, \"\\r\\n\");\n	      }\n	    },\n	\n	    hasMissingCLineInSDP: function (sdp) {\n	      /*\n	       * This is a Firefox hack to insert valid sdp when getDescription is\n	       * called with the constraint offerToReceiveVideo = false.\n	       * We search for either a c-line at the top of the sdp above all\n	       * m-lines. If that does not exist then we search for a c-line\n	       * beneath each m-line. If it is missing a c-line, we insert\n	       * a fake c-line with the ip address 0.0.0.0. This is then valid\n	       * sdp and no media will be sent for that m-line.\n	       *\n	       * Valid SDP is:\n	       * m=\n	       * i=\n	       * c=\n	       */\n	      var insertAt, mlines;\n	      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {\n	\n	        // Find all m= lines\n	        mlines = sdp.match(/m=.*\\r\\n.*/g);\n	        for (var i=0; i<mlines.length; i++) {\n	\n	          // If it has an i= line, check if the next line is the c= line\n	          if (mlines[i].toString().search(/i=.*/) >= 0) {\n	            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;\n	            if (sdp.substr(insertAt,2)!=='c=') {\n	              sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n	            }\n	\n	          // else add the C line if it's missing\n	          } else if (mlines[i].toString().search(/c=.*/) < 0) {\n	            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;\n	            sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n	          }\n	        }\n	      }\n	      return sdp;\n	    },\n	  },\n	\n	  Chrome: {\n	    needsExplicitlyInactiveSDP: function (sdp) {\n	      var sub, index;\n	\n	      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending\n	        index = sdp.indexOf('m=video 0');\n	        if (index !== -1) {\n	          sub = sdp.substr(index);\n	          sub = sub.replace(/\\r\\nc=IN IP4.*\\r\\n$/,\n	                            '\\r\\nc=IN IP4 0.0.0.0\\r\\na=inactive\\r\\n');\n	          return sdp.substr(0, index) + sub;\n	        }\n	      }\n	      return sdp;\n	    },\n	\n	    getsConfusedAboutGUM: function (session) {\n	      if (session.mediaHandler) {\n	        session.mediaHandler.close();\n	      }\n	    }\n	  }\n	};\n	return Hacks;\n	};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Incoming SIP Message Sanity Check\n	 */\n	\n	/**\n	 * SIP message sanity check.\n	 * @augments SIP\n	 * @function\n	 * @param {SIP.IncomingMessage} message\n	 * @param {SIP.UA} ua\n	 * @param {SIP.Transport} transport\n	 * @returns {Boolean}\n	 */\n	module.exports = function (SIP) {\n	var sanityCheck,\n	 logger,\n	 message, ua, transport,\n	 requests = [],\n	 responses = [],\n	 all = [];\n	\n	// Reply\n	function reply(status_code) {\n	  var to,\n	    response = SIP.Utils.buildStatusLine(status_code),\n	    vias = message.getHeaders('via'),\n	    length = vias.length,\n	    idx = 0;\n	\n	  for(idx; idx < length; idx++) {\n	    response += \"Via: \" + vias[idx] + \"\\r\\n\";\n	  }\n	\n	  to = message.getHeader('To');\n	\n	  if(!message.to_tag) {\n	    to += ';tag=' + SIP.Utils.newTag();\n	  }\n	\n	  response += \"To: \" + to + \"\\r\\n\";\n	  response += \"From: \" + message.getHeader('From') + \"\\r\\n\";\n	  response += \"Call-ID: \" + message.call_id + \"\\r\\n\";\n	  response += \"CSeq: \" + message.cseq + \" \" + message.method + \"\\r\\n\";\n	  response += \"\\r\\n\";\n	\n	  transport.send(response);\n	}\n	\n	/*\n	 * Sanity Check for incoming Messages\n	 *\n	 * Requests:\n	 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n	 *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n	 *   Does not look at via sent-by but at sipjsId, which is inserted as\n	 *   a prefix in all initial requests generated by the ua\n	 *  - _rfc3261_18_3_request_ Body Content-Length\n	 *  - _rfc3261_8_2_2_2_ Merged Requests\n	 *\n	 * Responses:\n	 *  - _rfc3261_8_1_3_3_ Multiple Via headers\n	 *  - _rfc3261_18_1_2_ sent-by mismatch\n	 *  - _rfc3261_18_3_response_ Body Content-Length\n	 *\n	 * All:\n	 *  - Minimum headers in a SIP message\n	 */\n	\n	// Sanity Check functions for requests\n	function rfc3261_8_2_2_1() {\n	  if(!message.ruri || message.ruri.scheme !== 'sip') {\n	    reply(416);\n	    return false;\n	  }\n	}\n	\n	function rfc3261_16_3_4() {\n	  if(!message.to_tag) {\n	    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {\n	      reply(482);\n	      return false;\n	    }\n	  }\n	}\n	\n	function rfc3261_18_3_request() {\n	  var len = SIP.Utils.str_utf8_length(message.body),\n	  contentLength = message.getHeader('content-length');\n	\n	  if(len < contentLength) {\n	    reply(400);\n	    return false;\n	  }\n	}\n	\n	function rfc3261_8_2_2_2() {\n	  var tr, idx,\n	    fromTag = message.from_tag,\n	    call_id = message.call_id,\n	    cseq = message.cseq;\n	\n	  if(!message.to_tag) {\n	    if(message.method === SIP.C.INVITE) {\n	      tr = ua.transactions.ist[message.via_branch];\n	      if(tr) {\n	        return;\n	      } else {\n	        for(idx in ua.transactions.ist) {\n	          tr = ua.transactions.ist[idx];\n	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n	            reply(482);\n	            return false;\n	          }\n	        }\n	      }\n	    } else {\n	      tr = ua.transactions.nist[message.via_branch];\n	      if(tr) {\n	        return;\n	      } else {\n	        for(idx in ua.transactions.nist) {\n	          tr = ua.transactions.nist[idx];\n	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n	            reply(482);\n	            return false;\n	          }\n	        }\n	      }\n	    }\n	  }\n	}\n	\n	// Sanity Check functions for responses\n	function rfc3261_8_1_3_3() {\n	  if(message.getHeaders('via').length > 1) {\n	    logger.warn('More than one Via header field present in the response. Dropping the response');\n	    return false;\n	  }\n	}\n	\n	function rfc3261_18_1_2() {\n	  var viaHost = ua.configuration.viaHost;\n	  if(message.via.host !== viaHost || message.via.port !== undefined) {\n	    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');\n	    return false;\n	  }\n	}\n	\n	function rfc3261_18_3_response() {\n	  var\n	    len = SIP.Utils.str_utf8_length(message.body),\n	    contentLength = message.getHeader('content-length');\n	\n	    if(len < contentLength) {\n	      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');\n	      return false;\n	    }\n	}\n	\n	// Sanity Check functions for requests and responses\n	function minimumHeaders() {\n	  var\n	    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],\n	    idx = mandatoryHeaders.length;\n	\n	  while(idx--) {\n	    if(!message.hasHeader(mandatoryHeaders[idx])) {\n	      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');\n	      return false;\n	    }\n	  }\n	}\n	\n	requests.push(rfc3261_8_2_2_1);\n	requests.push(rfc3261_16_3_4);\n	requests.push(rfc3261_18_3_request);\n	requests.push(rfc3261_8_2_2_2);\n	\n	responses.push(rfc3261_8_1_3_3);\n	responses.push(rfc3261_18_1_2);\n	responses.push(rfc3261_18_3_response);\n	\n	all.push(minimumHeaders);\n	\n	sanityCheck = function(m, u, t) {\n	  var len, pass;\n	\n	  message = m;\n	  ua = u;\n	  transport = t;\n	\n	  logger = ua.getLogger('sip.sanitycheck');\n	\n	  len = all.length;\n	  while(len--) {\n	    pass = all[len](message);\n	    if(pass === false) {\n	      return false;\n	    }\n	  }\n	\n	  if(message instanceof SIP.IncomingRequest) {\n	    len = requests.length;\n	    while(len--) {\n	      pass = requests[len](message);\n	      if(pass === false) {\n	        return false;\n	      }\n	    }\n	  }\n	\n	  else if(message instanceof SIP.IncomingResponse) {\n	    len = responses.length;\n	    while(len--) {\n	      pass = responses[len](message);\n	      if(pass === false) {\n	        return false;\n	      }\n	    }\n	  }\n	\n	  //Everything is OK\n	  return true;\n	};\n	\n	SIP.sanityCheck = sanityCheck;\n	};\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	/**\n	 * @fileoverview SIP Digest Authentication\n	 */\n	\n	/**\n	 * SIP Digest Authentication.\n	 * @augments SIP.\n	 * @function Digest Authentication\n	 * @param {SIP.UA} ua\n	 */\n	module.exports = function (Utils) {\n	var DigestAuthentication;\n	\n	DigestAuthentication = function(ua) {\n	  this.logger = ua.getLogger('sipjs.digestauthentication');\n	  this.username = ua.configuration.authorizationUser;\n	  this.password = ua.configuration.password;\n	  this.cnonce = null;\n	  this.nc = 0;\n	  this.ncHex = '00000000';\n	  this.response = null;\n	};\n	\n	\n	/**\n	* Performs Digest authentication given a SIP request and the challenge\n	* received in a response to that request.\n	* Returns true if credentials were successfully generated, false otherwise.\n	*\n	* @param {SIP.OutgoingRequest} request\n	* @param {Object} challenge\n	*/\n	DigestAuthentication.prototype.authenticate = function(request, challenge) {\n	  // Inspect and validate the challenge.\n	\n	  this.algorithm = challenge.algorithm;\n	  this.realm = challenge.realm;\n	  this.nonce = challenge.nonce;\n	  this.opaque = challenge.opaque;\n	  this.stale = challenge.stale;\n	\n	  if (this.algorithm) {\n	    if (this.algorithm !== 'MD5') {\n	      this.logger.warn('challenge with Digest algorithm different than \"MD5\", authentication aborted');\n	      return false;\n	    }\n	  } else {\n	    this.algorithm = 'MD5';\n	  }\n	\n	  if (! this.realm) {\n	    this.logger.warn('challenge without Digest realm, authentication aborted');\n	    return false;\n	  }\n	\n	  if (! this.nonce) {\n	    this.logger.warn('challenge without Digest nonce, authentication aborted');\n	    return false;\n	  }\n	\n	  // 'qop' can contain a list of values (Array). Let's choose just one.\n	  if (challenge.qop) {\n	    if (challenge.qop.indexOf('auth') > -1) {\n	      this.qop = 'auth';\n	    } else if (challenge.qop.indexOf('auth-int') > -1) {\n	      this.qop = 'auth-int';\n	    } else {\n	      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n	      this.logger.warn('challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n	      return false;\n	    }\n	  } else {\n	    this.qop = null;\n	  }\n	\n	  // Fill other attributes.\n	\n	  this.method = request.method;\n	  this.uri = request.ruri;\n	  this.cnonce = Utils.createRandomToken(12);\n	  this.nc += 1;\n	  this.updateNcHex();\n	\n	  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n	  if (this.nc === 4294967296) {\n	    this.nc = 1;\n	    this.ncHex = '00000001';\n	  }\n	\n	  // Calculate the Digest \"response\" value.\n	  this.calculateResponse();\n	\n	  return true;\n	};\n	\n	\n	/**\n	* Generate Digest 'response' value.\n	* @private\n	*/\n	DigestAuthentication.prototype.calculateResponse = function() {\n	  var ha1, ha2;\n	\n	  // HA1 = MD5(A1) = MD5(username:realm:password)\n	  ha1 = Utils.calculateMD5(this.username + \":\" + this.realm + \":\" + this.password);\n	\n	  if (this.qop === 'auth') {\n	    // HA2 = MD5(A2) = MD5(method:digestURI)\n	    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n	    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n	\n	  } else if (this.qop === 'auth-int') {\n	    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n	    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri + \":\" + Utils.calculateMD5(this.body ? this.body : \"\"));\n	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n	    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n	\n	  } else if (this.qop === null) {\n	    // HA2 = MD5(A2) = MD5(method:digestURI)\n	    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n	    // response = MD5(HA1:nonce:HA2)\n	    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n	  }\n	};\n	\n	\n	/**\n	* Return the Proxy-Authorization or WWW-Authorization header value.\n	*/\n	DigestAuthentication.prototype.toString = function() {\n	  var auth_params = [];\n	\n	  if (! this.response) {\n	    throw new Error('response field does not exist, cannot generate Authorization header');\n	  }\n	\n	  auth_params.push('algorithm=' + this.algorithm);\n	  auth_params.push('username=\"' + this.username + '\"');\n	  auth_params.push('realm=\"' + this.realm + '\"');\n	  auth_params.push('nonce=\"' + this.nonce + '\"');\n	  auth_params.push('uri=\"' + this.uri + '\"');\n	  auth_params.push('response=\"' + this.response + '\"');\n	  if (this.opaque) {\n	    auth_params.push('opaque=\"' + this.opaque + '\"');\n	  }\n	  if (this.qop) {\n	    auth_params.push('qop=' + this.qop);\n	    auth_params.push('cnonce=\"' + this.cnonce + '\"');\n	    auth_params.push('nc=' + this.ncHex);\n	  }\n	\n	  return 'Digest ' + auth_params.join(', ');\n	};\n	\n	\n	/**\n	* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n	* @private\n	*/\n	DigestAuthentication.prototype.updateNcHex = function() {\n	  var hex = Number(this.nc).toString(16);\n	  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;\n	};\n	\n	return DigestAuthentication;\n	};\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n	var Grammar = __webpack_require__(48);\n	\n	module.exports = function (SIP) {\n	\n	return {\n	  parse: function parseCustom (input, startRule) {\n	    var options = {startRule: startRule, SIP: SIP};\n	    try {\n	      Grammar.parse(input, options);\n	    } catch (e) {\n	      options.data = -1;\n	    }\n	    return options.data;\n	  }\n	};\n	\n	};\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n	module.exports = (function() {\n	  /*\n	   * Generated by PEG.js 0.8.0.\n	   *\n	   * http://pegjs.majda.cz/\n	   */\n	\n	  function peg$subclass(child, parent) {\n	    function ctor() { this.constructor = child; }\n	    ctor.prototype = parent.prototype;\n	    child.prototype = new ctor();\n	  }\n	\n	  function SyntaxError(message, expected, found, offset, line, column) {\n	    this.message  = message;\n	    this.expected = expected;\n	    this.found    = found;\n	    this.offset   = offset;\n	    this.line     = line;\n	    this.column   = column;\n	\n	    this.name     = \"SyntaxError\";\n	  }\n	\n	  peg$subclass(SyntaxError, Error);\n	\n	  function parse(input) {\n	    var options = arguments.length > 1 ? arguments[1] : {},\n	\n	        peg$FAILED = {},\n	\n	        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },\n	        peg$startRuleIndex   = 118,\n	\n	        peg$consts = [\n	          \"\\r\\n\",\n	          { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n	          /^[0-9]/,\n	          { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n	          /^[a-zA-Z]/,\n	          { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n	          /^[0-9a-fA-F]/,\n	          { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n	          /^[\\0-\\xFF]/,\n	          { type: \"class\", value: \"[\\\\0-\\\\xFF]\", description: \"[\\\\0-\\\\xFF]\" },\n	          /^[\"]/,\n	          { type: \"class\", value: \"[\\\"]\", description: \"[\\\"]\" },\n	          \" \",\n	          { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n	          \"\\t\",\n	          { type: \"literal\", value: \"\\t\", description: \"\\\"\\\\t\\\"\" },\n	          /^[a-zA-Z0-9]/,\n	          { type: \"class\", value: \"[a-zA-Z0-9]\", description: \"[a-zA-Z0-9]\" },\n	          \";\",\n	          { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n	          \"/\",\n	          { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n	          \"?\",\n	          { type: \"literal\", value: \"?\", description: \"\\\"?\\\"\" },\n	          \":\",\n	          { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n	          \"@\",\n	          { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n	          \"&\",\n	          { type: \"literal\", value: \"&\", description: \"\\\"&\\\"\" },\n	          \"=\",\n	          { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n	          \"+\",\n	          { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n	          \"$\",\n	          { type: \"literal\", value: \"$\", description: \"\\\"$\\\"\" },\n	          \",\",\n	          { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n	          \"-\",\n	          { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n	          \"_\",\n	          { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n	          \".\",\n	          { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n	          \"!\",\n	          { type: \"literal\", value: \"!\", description: \"\\\"!\\\"\" },\n	          \"~\",\n	          { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n	          \"*\",\n	          { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n	          \"'\",\n	          { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\n	          \"(\",\n	          { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n	          \")\",\n	          { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n	          peg$FAILED,\n	          \"%\",\n	          { type: \"literal\", value: \"%\", description: \"\\\"%\\\"\" },\n	          null,\n	          [],\n	          function() {return \" \"; },\n	          function() {return ':'; },\n	          /^[!-~]/,\n	          { type: \"class\", value: \"[!-~]\", description: \"[!-~]\" },\n	          /^[\\x80-\\uFFFF]/,\n	          { type: \"class\", value: \"[\\\\x80-\\\\uFFFF]\", description: \"[\\\\x80-\\\\uFFFF]\" },\n	          /^[\\x80-\\xBF]/,\n	          { type: \"class\", value: \"[\\\\x80-\\\\xBF]\", description: \"[\\\\x80-\\\\xBF]\" },\n	          /^[a-f]/,\n	          { type: \"class\", value: \"[a-f]\", description: \"[a-f]\" },\n	          \"`\",\n	          { type: \"literal\", value: \"`\", description: \"\\\"`\\\"\" },\n	          \"<\",\n	          { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n	          \">\",\n	          { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n	          \"\\\\\",\n	          { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n	          \"[\",\n	          { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n	          \"]\",\n	          { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n	          \"{\",\n	          { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n	          \"}\",\n	          { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n	          function() {return \"*\"; },\n	          function() {return \"/\"; },\n	          function() {return \"=\"; },\n	          function() {return \"(\"; },\n	          function() {return \")\"; },\n	          function() {return \">\"; },\n	          function() {return \"<\"; },\n	          function() {return \",\"; },\n	          function() {return \";\"; },\n	          function() {return \":\"; },\n	          function() {return \"\\\"\"; },\n	          /^[!-']/,\n	          { type: \"class\", value: \"[!-']\", description: \"[!-']\" },\n	          /^[*-[]/,\n	          { type: \"class\", value: \"[*-[]\", description: \"[*-[]\" },\n	          /^[\\]-~]/,\n	          { type: \"class\", value: \"[\\\\]-~]\", description: \"[\\\\]-~]\" },\n	          function(contents) {\n	                                  return contents; },\n	          /^[#-[]/,\n	          { type: \"class\", value: \"[#-[]\", description: \"[#-[]\" },\n	          /^[\\0-\\t]/,\n	          { type: \"class\", value: \"[\\\\0-\\\\t]\", description: \"[\\\\0-\\\\t]\" },\n	          /^[\\x0B-\\f]/,\n	          { type: \"class\", value: \"[\\\\x0B-\\\\f]\", description: \"[\\\\x0B-\\\\f]\" },\n	          /^[\\x0E-]/,\n	          { type: \"class\", value: \"[\\\\x0E-]\", description: \"[\\\\x0E-]\" },\n	          function() {\n	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);\n	                                  delete options.data.scheme;\n	                                  delete options.data.user;\n	                                  delete options.data.host;\n	                                  delete options.data.host_type;\n	                                  delete options.data.port;\n	                                },\n	          function() {\n	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n	                                  delete options.data.scheme;\n	                                  delete options.data.user;\n	                                  delete options.data.host;\n	                                  delete options.data.host_type;\n	                                  delete options.data.port;\n	                                  delete options.data.uri_params;\n	\n	                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}\n	                                },\n	          \"sips\",\n	          { type: \"literal\", value: \"sips\", description: \"\\\"sips\\\"\" },\n	          \"sip\",\n	          { type: \"literal\", value: \"sip\", description: \"\\\"sip\\\"\" },\n	          function(uri_scheme) {\n	                              options.data.scheme = uri_scheme; },\n	          function() {\n	                              options.data.user = decodeURIComponent(text().slice(0, -1));},\n	          function() {\n	                              options.data.password = text(); },\n	          function() {\n	                              options.data.host = text();\n	                              return options.data.host; },\n	          function() {\n	                            options.data.host_type = 'domain';\n	                            return text(); },\n	          /^[a-zA-Z0-9_\\-]/,\n	          { type: \"class\", value: \"[a-zA-Z0-9_\\\\-]\", description: \"[a-zA-Z0-9_\\\\-]\" },\n	          /^[a-zA-Z0-9\\-]/,\n	          { type: \"class\", value: \"[a-zA-Z0-9\\\\-]\", description: \"[a-zA-Z0-9\\\\-]\" },\n	          function() {\n	                              options.data.host_type = 'IPv6';\n	                              return text(); },\n	          \"::\",\n	          { type: \"literal\", value: \"::\", description: \"\\\"::\\\"\" },\n	          function() {\n	                            options.data.host_type = 'IPv6';\n	                            return text(); },\n	          function() {\n	                              options.data.host_type = 'IPv4';\n	                              return text(); },\n	          \"25\",\n	          { type: \"literal\", value: \"25\", description: \"\\\"25\\\"\" },\n	          /^[0-5]/,\n	          { type: \"class\", value: \"[0-5]\", description: \"[0-5]\" },\n	          \"2\",\n	          { type: \"literal\", value: \"2\", description: \"\\\"2\\\"\" },\n	          /^[0-4]/,\n	          { type: \"class\", value: \"[0-4]\", description: \"[0-4]\" },\n	          \"1\",\n	          { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n	          /^[1-9]/,\n	          { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n	          function(port) {\n	                              port = parseInt(port.join(''));\n	                              options.data.port = port;\n	                              return port; },\n	          \"transport=\",\n	          { type: \"literal\", value: \"transport=\", description: \"\\\"transport=\\\"\" },\n	          \"udp\",\n	          { type: \"literal\", value: \"udp\", description: \"\\\"udp\\\"\" },\n	          \"tcp\",\n	          { type: \"literal\", value: \"tcp\", description: \"\\\"tcp\\\"\" },\n	          \"sctp\",\n	          { type: \"literal\", value: \"sctp\", description: \"\\\"sctp\\\"\" },\n	          \"tls\",\n	          { type: \"literal\", value: \"tls\", description: \"\\\"tls\\\"\" },\n	          function(transport) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['transport'] = transport.toLowerCase(); },\n	          \"user=\",\n	          { type: \"literal\", value: \"user=\", description: \"\\\"user=\\\"\" },\n	          \"phone\",\n	          { type: \"literal\", value: \"phone\", description: \"\\\"phone\\\"\" },\n	          \"ip\",\n	          { type: \"literal\", value: \"ip\", description: \"\\\"ip\\\"\" },\n	          function(user) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['user'] = user.toLowerCase(); },\n	          \"method=\",\n	          { type: \"literal\", value: \"method=\", description: \"\\\"method=\\\"\" },\n	          function(method) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['method'] = method; },\n	          \"ttl=\",\n	          { type: \"literal\", value: \"ttl=\", description: \"\\\"ttl=\\\"\" },\n	          function(ttl) {\n	                                if(!options.data.params) options.data.params={};\n	                                options.data.params['ttl'] = ttl; },\n	          \"maddr=\",\n	          { type: \"literal\", value: \"maddr=\", description: \"\\\"maddr=\\\"\" },\n	          function(maddr) {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['maddr'] = maddr; },\n	          \"lr\",\n	          { type: \"literal\", value: \"lr\", description: \"\\\"lr\\\"\" },\n	          function() {\n	                                if(!options.data.uri_params) options.data.uri_params={};\n	                                options.data.uri_params['lr'] = undefined; },\n	          function(param, value) {\n	                                if(!options.data.uri_params) options.data.uri_params = {};\n	                                if (value === null){\n	                                  value = undefined;\n	                                }\n	                                else {\n	                                  value = value[1];\n	                                }\n	                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},\n	          function(hname, hvalue) {\n	                                hname = hname.join('').toLowerCase();\n	                                hvalue = hvalue.join('');\n	                                if(!options.data.uri_headers) options.data.uri_headers = {};\n	                                if (!options.data.uri_headers[hname]) {\n	                                  options.data.uri_headers[hname] = [hvalue];\n	                                } else {\n	                                  options.data.uri_headers[hname].push(hvalue);\n	                                }},\n	          function() {\n	                                // lots of tests fail if this isn't guarded...\n	                                if (options.startRule === 'Refer_To') {\n	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n	                                  delete options.data.scheme;\n	                                  delete options.data.user;\n	                                  delete options.data.host;\n	                                  delete options.data.host_type;\n	                                  delete options.data.port;\n	                                  delete options.data.uri_params;\n	                                }\n	                              },\n	          \"//\",\n	          { type: \"literal\", value: \"//\", description: \"\\\"//\\\"\" },\n	          function() {\n	                              options.data.scheme= text(); },\n	          { type: \"literal\", value: \"SIP\", description: \"\\\"SIP\\\"\" },\n	          function() {\n	                              options.data.sip_version = text(); },\n	          \"INVITE\",\n	          { type: \"literal\", value: \"INVITE\", description: \"\\\"INVITE\\\"\" },\n	          \"ACK\",\n	          { type: \"literal\", value: \"ACK\", description: \"\\\"ACK\\\"\" },\n	          \"VXACH\",\n	          { type: \"literal\", value: \"VXACH\", description: \"\\\"VXACH\\\"\" },\n	          \"OPTIONS\",\n	          { type: \"literal\", value: \"OPTIONS\", description: \"\\\"OPTIONS\\\"\" },\n	          \"BYE\",\n	          { type: \"literal\", value: \"BYE\", description: \"\\\"BYE\\\"\" },\n	          \"CANCEL\",\n	          { type: \"literal\", value: \"CANCEL\", description: \"\\\"CANCEL\\\"\" },\n	          \"REGISTER\",\n	          { type: \"literal\", value: \"REGISTER\", description: \"\\\"REGISTER\\\"\" },\n	          \"SUBSCRIBE\",\n	          { type: \"literal\", value: \"SUBSCRIBE\", description: \"\\\"SUBSCRIBE\\\"\" },\n	          \"NOTIFY\",\n	          { type: \"literal\", value: \"NOTIFY\", description: \"\\\"NOTIFY\\\"\" },\n	          \"REFER\",\n	          { type: \"literal\", value: \"REFER\", description: \"\\\"REFER\\\"\" },\n	          function() {\n	\n	                              options.data.method = text();\n	                              return options.data.method; },\n	          function(status_code) {\n	                            options.data.status_code = parseInt(status_code.join('')); },\n	          function() {\n	                            options.data.reason_phrase = text(); },\n	          function() {\n	                        options.data = text(); },\n	          function() {\n	                                  var idx, length;\n	                                  length = options.data.multi_header.length;\n	                                  for (idx = 0; idx < length; idx++) {\n	                                    if (options.data.multi_header[idx].parsed === null) {\n	                                      options.data = null;\n	                                      break;\n	                                    }\n	                                  }\n	                                  if (options.data !== null) {\n	                                    options.data = options.data.multi_header;\n	                                  } else {\n	                                    options.data = -1;\n	                                  }},\n	          function() {\n	                                  var header;\n	                                  if(!options.data.multi_header) options.data.multi_header = [];\n	                                  try {\n	                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                                    delete options.data.uri;\n	                                    delete options.data.displayName;\n	                                    delete options.data.params;\n	                                  } catch(e) {\n	                                    header = null;\n	                                  }\n	                                  options.data.multi_header.push( { 'position': peg$currPos,\n	                                                            'offset': offset(),\n	                                                            'parsed': header\n	                                                          });},\n	          function(displayName) {\n	                                  displayName = text().trim();\n	                                  if (displayName[0] === '\\\"') {\n	                                    displayName = displayName.substring(1, displayName.length-1);\n	                                  }\n	                                  options.data.displayName = displayName; },\n	          \"q\",\n	          { type: \"literal\", value: \"q\", description: \"\\\"q\\\"\" },\n	          function(q) {\n	                                  if(!options.data.params) options.data.params = {};\n	                                  options.data.params['q'] = q; },\n	          \"expires\",\n	          { type: \"literal\", value: \"expires\", description: \"\\\"expires\\\"\" },\n	          function(expires) {\n	                                  if(!options.data.params) options.data.params = {};\n	                                  options.data.params['expires'] = expires; },\n	          function(delta_seconds) {\n	                                  return parseInt(delta_seconds.join('')); },\n	          \"0\",\n	          { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n	          function() {\n	                                  return parseFloat(text()); },\n	          function(param, value) {\n	                                  if(!options.data.params) options.data.params = {};\n	                                  if (value === null){\n	                                    value = undefined;\n	                                  }\n	                                  else {\n	                                    value = value[1];\n	                                  }\n	                                  options.data.params[param.toLowerCase()] = value;},\n	          \"render\",\n	          { type: \"literal\", value: \"render\", description: \"\\\"render\\\"\" },\n	          \"session\",\n	          { type: \"literal\", value: \"session\", description: \"\\\"session\\\"\" },\n	          \"icon\",\n	          { type: \"literal\", value: \"icon\", description: \"\\\"icon\\\"\" },\n	          \"alert\",\n	          { type: \"literal\", value: \"alert\", description: \"\\\"alert\\\"\" },\n	          function() {\n	                                      if (options.startRule === 'Content_Disposition') {\n	                                        options.data.type = text().toLowerCase();\n	                                      }\n	                                    },\n	          \"handling\",\n	          { type: \"literal\", value: \"handling\", description: \"\\\"handling\\\"\" },\n	          \"optional\",\n	          { type: \"literal\", value: \"optional\", description: \"\\\"optional\\\"\" },\n	          \"required\",\n	          { type: \"literal\", value: \"required\", description: \"\\\"required\\\"\" },\n	          function(length) {\n	                                  options.data = parseInt(length.join('')); },\n	          function() {\n	                                  options.data = text(); },\n	          \"text\",\n	          { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n	          \"image\",\n	          { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n	          \"audio\",\n	          { type: \"literal\", value: \"audio\", description: \"\\\"audio\\\"\" },\n	          \"video\",\n	          { type: \"literal\", value: \"video\", description: \"\\\"video\\\"\" },\n	          \"application\",\n	          { type: \"literal\", value: \"application\", description: \"\\\"application\\\"\" },\n	          \"message\",\n	          { type: \"literal\", value: \"message\", description: \"\\\"message\\\"\" },\n	          \"multipart\",\n	          { type: \"literal\", value: \"multipart\", description: \"\\\"multipart\\\"\" },\n	          \"x-\",\n	          { type: \"literal\", value: \"x-\", description: \"\\\"x-\\\"\" },\n	          function(cseq_value) {\n	                            options.data.value=parseInt(cseq_value.join('')); },\n	          function(expires) {options.data = expires; },\n	          function(event_type) {\n	                                 options.data.event = event_type.toLowerCase(); },\n	          function() {\n	                          var tag = options.data.tag;\n	                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                            if (tag) {options.data.setParam('tag',tag)}\n	                          },\n	          \"tag\",\n	          { type: \"literal\", value: \"tag\", description: \"\\\"tag\\\"\" },\n	          function(tag) {options.data.tag = tag; },\n	          function(forwards) {\n	                            options.data = parseInt(forwards.join('')); },\n	          function(min_expires) {options.data = min_expires; },\n	          function() {\n	                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                                },\n	          \"digest\",\n	          { type: \"literal\", value: \"Digest\", description: \"\\\"Digest\\\"\" },\n	          \"realm\",\n	          { type: \"literal\", value: \"realm\", description: \"\\\"realm\\\"\" },\n	          function(realm) { options.data.realm = realm; },\n	          \"domain\",\n	          { type: \"literal\", value: \"domain\", description: \"\\\"domain\\\"\" },\n	          \"nonce\",\n	          { type: \"literal\", value: \"nonce\", description: \"\\\"nonce\\\"\" },\n	          function(nonce) { options.data.nonce=nonce; },\n	          \"opaque\",\n	          { type: \"literal\", value: \"opaque\", description: \"\\\"opaque\\\"\" },\n	          function(opaque) { options.data.opaque=opaque; },\n	          \"stale\",\n	          { type: \"literal\", value: \"stale\", description: \"\\\"stale\\\"\" },\n	          \"true\",\n	          { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\n	          function() { options.data.stale=true; },\n	          \"false\",\n	          { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\n	          function() { options.data.stale=false; },\n	          \"algorithm\",\n	          { type: \"literal\", value: \"algorithm\", description: \"\\\"algorithm\\\"\" },\n	          \"md5\",\n	          { type: \"literal\", value: \"MD5\", description: \"\\\"MD5\\\"\" },\n	          \"md5-sess\",\n	          { type: \"literal\", value: \"MD5-sess\", description: \"\\\"MD5-sess\\\"\" },\n	          function(algorithm) {\n	                                options.data.algorithm=algorithm.toUpperCase(); },\n	          \"qop\",\n	          { type: \"literal\", value: \"qop\", description: \"\\\"qop\\\"\" },\n	          \"auth-int\",\n	          { type: \"literal\", value: \"auth-int\", description: \"\\\"auth-int\\\"\" },\n	          \"auth\",\n	          { type: \"literal\", value: \"auth\", description: \"\\\"auth\\\"\" },\n	          function(qop_value) {\n	                                  options.data.qop || (options.data.qop=[]);\n	                                  options.data.qop.push(qop_value.toLowerCase()); },\n	          function(rack_value) {\n	                            options.data.value=parseInt(rack_value.join('')); },\n	          function() {\n	                            var idx, length;\n	                            length = options.data.multi_header.length;\n	                            for (idx = 0; idx < length; idx++) {\n	                              if (options.data.multi_header[idx].parsed === null) {\n	                                options.data = null;\n	                                break;\n	                              }\n	                            }\n	                            if (options.data !== null) {\n	                              options.data = options.data.multi_header;\n	                            } else {\n	                              options.data = -1;\n	                            }},\n	          function() {\n	                            var header;\n	                            if(!options.data.multi_header) options.data.multi_header = [];\n	                            try {\n	                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                              delete options.data.uri;\n	                              delete options.data.displayName;\n	                              delete options.data.params;\n	                            } catch(e) {\n	                              header = null;\n	                            }\n	                            options.data.multi_header.push( { 'position': peg$currPos,\n	                                                      'offset': offset(),\n	                                                      'parsed': header\n	                                                    });},\n	          function() {\n	                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                      },\n	          function() {\n	                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {\n	                                  options.data = -1;\n	                                }\n	                              },\n	          function() {\n	                                options.data = {\n	                                  call_id: options.data\n	                                };\n	                              },\n	          \"from-tag\",\n	          { type: \"literal\", value: \"from-tag\", description: \"\\\"from-tag\\\"\" },\n	          function(from_tag) {\n	                                options.data.replaces_from_tag = from_tag;\n	                              },\n	          \"to-tag\",\n	          { type: \"literal\", value: \"to-tag\", description: \"\\\"to-tag\\\"\" },\n	          function(to_tag) {\n	                                options.data.replaces_to_tag = to_tag;\n	                              },\n	          \"early-only\",\n	          { type: \"literal\", value: \"early-only\", description: \"\\\"early-only\\\"\" },\n	          function() {\n	                                options.data.early_only = true;\n	                              },\n	          function(r) {return r;},\n	          function(first, rest) { return list(first, rest); },\n	          function(value) {\n	                          if (options.startRule === 'Require') {\n	                            options.data = value || [];\n	                          }\n	                        },\n	          function(rseq_value) {\n	                            options.data.value=parseInt(rseq_value.join('')); },\n	          \"active\",\n	          { type: \"literal\", value: \"active\", description: \"\\\"active\\\"\" },\n	          \"pending\",\n	          { type: \"literal\", value: \"pending\", description: \"\\\"pending\\\"\" },\n	          \"terminated\",\n	          { type: \"literal\", value: \"terminated\", description: \"\\\"terminated\\\"\" },\n	          function() {\n	                                  options.data.state = text(); },\n	          \"reason\",\n	          { type: \"literal\", value: \"reason\", description: \"\\\"reason\\\"\" },\n	          function(reason) {\n	                                  if (typeof reason !== 'undefined') options.data.reason = reason; },\n	          function(expires) {\n	                                  if (typeof expires !== 'undefined') options.data.expires = expires; },\n	          \"retry_after\",\n	          { type: \"literal\", value: \"retry_after\", description: \"\\\"retry_after\\\"\" },\n	          function(retry_after) {\n	                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },\n	          \"deactivated\",\n	          { type: \"literal\", value: \"deactivated\", description: \"\\\"deactivated\\\"\" },\n	          \"probation\",\n	          { type: \"literal\", value: \"probation\", description: \"\\\"probation\\\"\" },\n	          \"rejected\",\n	          { type: \"literal\", value: \"rejected\", description: \"\\\"rejected\\\"\" },\n	          \"timeout\",\n	          { type: \"literal\", value: \"timeout\", description: \"\\\"timeout\\\"\" },\n	          \"giveup\",\n	          { type: \"literal\", value: \"giveup\", description: \"\\\"giveup\\\"\" },\n	          \"noresource\",\n	          { type: \"literal\", value: \"noresource\", description: \"\\\"noresource\\\"\" },\n	          \"invariant\",\n	          { type: \"literal\", value: \"invariant\", description: \"\\\"invariant\\\"\" },\n	          function(value) {\n	                          if (options.startRule === 'Supported') {\n	                            options.data = value || [];\n	                          }\n	                        },\n	          function() {\n	                        var tag = options.data.tag;\n	                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n	                          if (tag) {options.data.setParam('tag',tag)}\n	                        },\n	          \"ttl\",\n	          { type: \"literal\", value: \"ttl\", description: \"\\\"ttl\\\"\" },\n	          function(via_ttl_value) {\n	                                options.data.ttl = via_ttl_value; },\n	          \"maddr\",\n	          { type: \"literal\", value: \"maddr\", description: \"\\\"maddr\\\"\" },\n	          function(via_maddr) {\n	                                options.data.maddr = via_maddr; },\n	          \"received\",\n	          { type: \"literal\", value: \"received\", description: \"\\\"received\\\"\" },\n	          function(via_received) {\n	                                options.data.received = via_received; },\n	          \"branch\",\n	          { type: \"literal\", value: \"branch\", description: \"\\\"branch\\\"\" },\n	          function(via_branch) {\n	                                options.data.branch = via_branch; },\n	          \"rport\",\n	          { type: \"literal\", value: \"rport\", description: \"\\\"rport\\\"\" },\n	          function() {\n	                                if(typeof response_port !== 'undefined')\n	                                  options.data.rport = response_port.join(''); },\n	          function(via_protocol) {\n	                                options.data.protocol = via_protocol; },\n	          { type: \"literal\", value: \"UDP\", description: \"\\\"UDP\\\"\" },\n	          { type: \"literal\", value: \"TCP\", description: \"\\\"TCP\\\"\" },\n	          { type: \"literal\", value: \"TLS\", description: \"\\\"TLS\\\"\" },\n	          { type: \"literal\", value: \"SCTP\", description: \"\\\"SCTP\\\"\" },\n	          function(via_transport) {\n	                                options.data.transport = via_transport; },\n	          function() {\n	                                options.data.host = text(); },\n	          function(via_sent_by_port) {\n	                                options.data.port = parseInt(via_sent_by_port.join('')); },\n	          function(ttl) {\n	                                return parseInt(ttl.join('')); },\n	          function(deltaSeconds) {\n	                                if (options.startRule === 'Session_Expires') {\n	                                  options.data.deltaSeconds = deltaSeconds;\n	                                }\n	                              },\n	          \"refresher\",\n	          { type: \"literal\", value: \"refresher\", description: \"\\\"refresher\\\"\" },\n	          \"uas\",\n	          { type: \"literal\", value: \"uas\", description: \"\\\"uas\\\"\" },\n	          \"uac\",\n	          { type: \"literal\", value: \"uac\", description: \"\\\"uac\\\"\" },\n	          function(endpoint) {\n	                                if (options.startRule === 'Session_Expires') {\n	                                  options.data.refresher = endpoint;\n	                                }\n	                              },\n	          function(deltaSeconds) {\n	                                if (options.startRule === 'Min_SE') {\n	                                  options.data = deltaSeconds;\n	                                }\n	                              },\n	          \"stuns\",\n	          { type: \"literal\", value: \"stuns\", description: \"\\\"stuns\\\"\" },\n	          \"stun\",\n	          { type: \"literal\", value: \"stun\", description: \"\\\"stun\\\"\" },\n	          function(scheme) {\n	                                options.data.scheme = scheme; },\n	          function(host) {\n	                                options.data.host = host; },\n	          \"?transport=\",\n	          { type: \"literal\", value: \"?transport=\", description: \"\\\"?transport=\\\"\" },\n	          \"turns\",\n	          { type: \"literal\", value: \"turns\", description: \"\\\"turns\\\"\" },\n	          \"turn\",\n	          { type: \"literal\", value: \"turn\", description: \"\\\"turn\\\"\" },\n	          function() {\n	                                options.data.transport = transport; },\n	          function() {\n	                            options.data = text(); }\n	        ],\n	\n	        peg$bytecode = [\n	          peg$decode(\". \\\"\\\"2 3!\"),\n	          peg$decode(\"0\\\"\\\"\\\"1!3#\"),\n	          peg$decode(\"0$\\\"\\\"1!3%\"),\n	          peg$decode(\"0&\\\"\\\"1!3'\"),\n	          peg$decode(\"7'*# \\\"7(\"),\n	          peg$decode(\"0(\\\"\\\"1!3)\"),\n	          peg$decode(\"0*\\\"\\\"1!3+\"),\n	          peg$decode(\".,\\\"\\\"2,3-\"),\n	          peg$decode(\"..\\\"\\\"2.3/\"),\n	          peg$decode(\"00\\\"\\\"1!31\"),\n	          peg$decode(\".2\\\"\\\"2233*\\x89 \\\".4\\\"\\\"2435*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n	          peg$decode(\"7)*# \\\"7,\"),\n	          peg$decode(\".F\\\"\\\"2F3G*} \\\".H\\\"\\\"2H3I*q \\\".J\\\"\\\"2J3K*e \\\".L\\\"\\\"2L3M*Y \\\".N\\\"\\\"2N3O*M \\\".P\\\"\\\"2P3Q*A \\\".R\\\"\\\"2R3S*5 \\\".T\\\"\\\"2T3U*) \\\".V\\\"\\\"2V3W\"),\n	          peg$decode(\"!!.Y\\\"\\\"2Y3Z+7$7#+-%7#+#%'#%$## X$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"!! \\\\7$,#&7$\\\"+-$7 +#%'\\\"%$\\\"# X\\\"# X*# \\\" [+@$ \\\\7$+&$,#&7$\\\"\\\"\\\" X+'%4\\\"6]\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7.*# \\\" [\"),\n	          peg$decode(\"! \\\\7'*# \\\"7(,)&7'*# \\\"7(\\\"+A$.8\\\"\\\"2839+1%7/+'%4#6^# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!! \\\\72+&$,#&72\\\"\\\"\\\" X+o$ \\\\! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X,@&! \\\\7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"0_\\\"\\\"1!3`*# \\\"73\"),\n	          peg$decode(\"0a\\\"\\\"1!3b\"),\n	          peg$decode(\"0c\\\"\\\"1!3d\"),\n	          peg$decode(\"7!*) \\\"0e\\\"\\\"1!3f\"),\n	          peg$decode(\"! \\\\7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x9E$,\\x9B&7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"! \\\\7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x92$,\\x8F&7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".g\\\"\\\"2g3h*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\".T\\\"\\\"2T3U*\\xE3 \\\".V\\\"\\\"2V3W*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".k\\\"\\\"2k3l*\\xBF \\\".:\\\"\\\"2:3;*\\xB3 \\\".D\\\"\\\"2D3E*\\xA7 \\\".2\\\"\\\"2233*\\x9B \\\".8\\\"\\\"2839*\\x8F \\\".m\\\"\\\"2m3n*\\x83 \\\"7&*} \\\".4\\\"\\\"2435*q \\\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".6\\\"\\\"2637*M \\\".>\\\"\\\"2>3?*A \\\".s\\\"\\\"2s3t*5 \\\".u\\\"\\\"2u3v*) \\\"7'*# \\\"7(\"),\n	          peg$decode(\"! \\\\7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v+\\u0134$,\\u0131&7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".g\\\"\\\"2g3h*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".i\\\"\\\"2i3j*\\x8F \\\".k\\\"\\\"2k3l*\\x83 \\\".8\\\"\\\"2839*w \\\".m\\\"\\\"2m3n*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".o\\\"\\\"2o3p*M \\\".q\\\"\\\"2q3r*A \\\".6\\\"\\\"2637*5 \\\".s\\\"\\\"2s3t*) \\\".u\\\"\\\"2u3v\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"!7/+A$.P\\\"\\\"2P3Q+1%7/+'%4#6w# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.4\\\"\\\"2435+1%7/+'%4#6x# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.>\\\"\\\"2>3?+1%7/+'%4#6y# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.T\\\"\\\"2T3U+1%7/+'%4#6z# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.V\\\"\\\"2V3W+1%7/+'%4#6{# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.k\\\"\\\"2k3l+1$7/+'%4\\\"6|\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+7$.i\\\"\\\"2i3j+'%4\\\"6}\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.D\\\"\\\"2D3E+1%7/+'%4#6~# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.2\\\"\\\"2233+1%7/+'%4#6# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+A$.8\\\"\\\"2839+1%7/+'%4#6\\x80# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7/+1$7&+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7&+1$7/+'%4\\\"6\\x81\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7=+W$ \\\\7G*) \\\"7K*# \\\"7F,/&7G*) \\\"7K*# \\\"7F\\\"+-%7>+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"0\\x82\\\"\\\"1!3\\x83*A \\\"0\\x84\\\"\\\"1!3\\x85*5 \\\"0\\x86\\\"\\\"1!3\\x87*) \\\"73*# \\\"7.\"),\n	          peg$decode(\"!!7/+U$7&+K% \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+-%7&+#%'$%$$# X$## X$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"!7/+`$7&+V%! \\\\7J*# \\\"7K,)&7J*# \\\"7K\\\"+! (%+2%7&+(%4$6\\x88$!!%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7.*G \\\".L\\\"\\\"2L3M*; \\\"0\\x89\\\"\\\"1!3\\x8A*/ \\\"0\\x86\\\"\\\"1!3\\x87*# \\\"73\"),\n	          peg$decode(\"!.m\\\"\\\"2m3n+K$0\\x8B\\\"\\\"1!3\\x8C*5 \\\"0\\x8D\\\"\\\"1!3\\x8E*) \\\"0\\x8F\\\"\\\"1!3\\x90+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7N+Q$.8\\\"\\\"2839+A%7O*# \\\" [+1%7S+'%4$6\\x91$ %$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7N+k$.8\\\"\\\"2839+[%7O*# \\\" [+K%7S+A%7_+7%7l*# \\\" [+'%4&6\\x92& %$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\x93\\\"\\\"1$3\\x94*) \\\"/\\x95\\\"\\\"1#3\\x96+' 4!6\\x97!! %\"),\n	          peg$decode(\"!7P+b$!.8\\\"\\\"2839+-$7R+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+7%.:\\\"\\\"2:3;+'%4#6\\x98# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\7+*) \\\"7-*# \\\"7Q+2$,/&7+*) \\\"7-*# \\\"7Q\\\"\\\"\\\" X\"),\n	          peg$decode(\".<\\\"\\\"2<3=*q \\\".>\\\"\\\"2>3?*e \\\".@\\\"\\\"2@3A*Y \\\".B\\\"\\\"2B3C*M \\\".D\\\"\\\"2D3E*A \\\".2\\\"\\\"2233*5 \\\".6\\\"\\\"2637*) \\\".4\\\"\\\"2435\"),\n	          peg$decode(\"! \\\\7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E,e&7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\\\"+& 4!6\\x99! %\"),\n	          peg$decode(\"!7T+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\x9A! %\"),\n	          peg$decode(\"! \\\\!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X,>&!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X\\\"+G$7W+=%.J\\\"\\\"2J3K*# \\\" [+'%4#6\\x9B# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\0\\x9C\\\"\\\"1!3\\x9D+,$,)&0\\x9C\\\"\\\"1!3\\x9D\\\"\\\"\\\" X\"),\n	          peg$decode(\"!0$\\\"\\\"1!3%+A$ \\\\0\\x9E\\\"\\\"1!3\\x9F,)&0\\x9E\\\"\\\"1!3\\x9F\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.o\\\"\\\"2o3p+A$7Y+7%.q\\\"\\\"2q3r+'%4#6\\xA0# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!!7Z+\\xBF$.8\\\"\\\"2839+\\xAF%7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0838 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\xAF$7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0795 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95$7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u070C \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+{$7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u069D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+a$7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0648 \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+G$7Z+=%.8\\\"\\\"2839+-%7[+#%'$%$$# X$## X$\\\"# X\\\"# X*\\u060D \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7[+#%'\\\"%$\\\"# X\\\"# X*\\u05EC \\\"!.\\xA1\\\"\\\"2\\xA13\\xA2+-$7Z+#%'\\\"%$\\\"# X\\\"# X*\\u05CB \\\"!7Z+\\xA5$.\\xA1\\\"\\\"2\\xA13\\xA2+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0538 \\\"!7Z+\\xB6$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x8B%.\\xA1\\\"\\\"2\\xA13\\xA2+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0494 \\\"!7Z+\\xC7$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x9C%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+q%.\\xA1\\\"\\\"2\\xA13\\xA2+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u03DF \\\"!7Z+\\xD8$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xAD%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x82%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+W%.\\xA1\\\"\\\"2\\xA13\\xA2+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0319 \\\"!7Z+\\xE9$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0242 \\\"!7Z+\\u0114$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xE9%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+=%.\\xA1\\\"\\\"2\\xA13\\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0140 \\\"!7Z+\\u0135$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\u010A%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xDF%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\xB4%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+\\x89%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+^%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+3%.\\xA1\\\"\\\"2\\xA13\\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X+& 4!6\\xA3! %\"),\n	          peg$decode(\"!7#+S$7#*# \\\" [+C%7#*# \\\" [+3%7#*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7Z+=$.8\\\"\\\"2839+-%7Z+#%'#%$## X$\\\"# X\\\"# X*# \\\"7\\\\\"),\n	          peg$decode(\"!7]+u$.J\\\"\\\"2J3K+e%7]+[%.J\\\"\\\"2J3K+K%7]+A%.J\\\"\\\"2J3K+1%7]+'%4'6\\xA4' %$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.\\xA5\\\"\\\"2\\xA53\\xA6+3$0\\xA7\\\"\\\"1!3\\xA8+#%'\\\"%$\\\"# X\\\"# X*\\xA0 \\\"!.\\xA9\\\"\\\"2\\xA93\\xAA+=$0\\xAB\\\"\\\"1!3\\xAC+-%7!+#%'#%$## X$\\\"# X\\\"# X*o \\\"!.\\xAD\\\"\\\"2\\xAD3\\xAE+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X*D \\\"!0\\xAF\\\"\\\"1!3\\xB0+-$7!+#%'\\\"%$\\\"# X\\\"# X*# \\\"7!\"),\n	          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\xB1!! %\"),\n	          peg$decode(\" \\\\!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X\\\"\"),\n	          peg$decode(\"7a*A \\\"7b*; \\\"7c*5 \\\"7d*/ \\\"7e*) \\\"7f*# \\\"7g\"),\n	          peg$decode(\"!/\\xB2\\\"\\\"1*3\\xB3+b$/\\xB4\\\"\\\"1#3\\xB5*G \\\"/\\xB6\\\"\\\"1#3\\xB7*; \\\"/\\xB8\\\"\\\"1$3\\xB9*/ \\\"/\\xBA\\\"\\\"1#3\\xBB*# \\\"76+(%4\\\"6\\xBC\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xBD\\\"\\\"1%3\\xBE+J$/\\xBF\\\"\\\"1%3\\xC0*/ \\\"/\\xC1\\\"\\\"1\\\"3\\xC2*# \\\"76+(%4\\\"6\\xC3\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xC4\\\"\\\"1'3\\xC5+2$7\\x8F+(%4\\\"6\\xC6\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xC7\\\"\\\"1$3\\xC8+2$7\\xEF+(%4\\\"6\\xC9\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xCA\\\"\\\"1&3\\xCB+2$7T+(%4\\\"6\\xCC\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xCD\\\"\\\"1\\\"3\\xCE+R$!.>\\\"\\\"2>3?+-$76+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xCF\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7h+T$!.>\\\"\\\"2>3?+-$7i+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xD0\\\"\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"! \\\\7j+&$,#&7j\\\"\\\"\\\" X+! (%\"),\n	          peg$decode(\"7k*) \\\"7+*# \\\"7-\"),\n	          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".8\\\"\\\"2839*A \\\".<\\\"\\\"2<3=*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n	          peg$decode(\"!.6\\\"\\\"2637+u$7m+k% \\\\!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X,>&!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7n+C$.>\\\"\\\"2>3?+3%7o+)%4#6\\xD1#\\\"\\\" %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-+2$,/&7p*) \\\"7+*# \\\"7-\\\"\\\"\\\" X\"),\n	          peg$decode(\" \\\\7p*) \\\"7+*# \\\"7-,/&7p*) \\\"7+*# \\\"7-\\\"\"),\n	          peg$decode(\".o\\\"\\\"2o3p*e \\\".q\\\"\\\"2q3r*Y \\\".4\\\"\\\"2435*M \\\".6\\\"\\\"2637*A \\\".8\\\"\\\"2839*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n	          peg$decode(\"7\\x90*# \\\"7r\"),\n	          peg$decode(\"!7\\x8F+K$7'+A%7s+7%7'+-%7\\x84+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7M*# \\\"7t\"),\n	          peg$decode(\"!7+G$.8\\\"\\\"2839+7%7u*# \\\"7x+'%4#6\\xD2# %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7v*# \\\"7w+N$!.6\\\"\\\"2637+-$7\\x83+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.\\xD3\\\"\\\"2\\xD33\\xD4+=$7\\x80+3%7w*# \\\" [+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!.4\\\"\\\"2435+-$7{+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7z+5$ \\\\7y,#&7y\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"7**) \\\"7+*# \\\"7-\"),\n	          peg$decode(\"7+*\\x8F \\\"7-*\\x89 \\\".2\\\"\\\"2233*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n	          peg$decode(\"!7|+k$ \\\\!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X,>&!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7~,#&7~\\\"+k$ \\\\!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\7~,#&7~\\\"\"),\n	          peg$decode(\"7+*w \\\"7-*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n	          peg$decode(\"!7\\\"+\\x8D$ \\\\7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K,M&7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K\\\"+'%4\\\"6\\xD5\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\x81*# \\\"7\\x82\"),\n	          peg$decode(\"!!7O+3$.:\\\"\\\"2:3;+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+-$7S+#%'\\\"%$\\\"# X\\\"# X*# \\\" [\"),\n	          peg$decode(\" \\\\7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A+\\x8C$,\\x89&7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A\\\"\\\"\\\" X\"),\n	          peg$decode(\" \\\\7y,#&7y\\\"\"),\n	          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6+y$.4\\\"\\\"2435+i% \\\\7!+&$,#&7!\\\"\\\"\\\" X+P%.J\\\"\\\"2J3K+@% \\\\7!+&$,#&7!\\\"\\\"\\\" X+'%4%6\\xD7% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\".\\xD8\\\"\\\"2\\xD83\\xD9\"),\n	          peg$decode(\".\\xDA\\\"\\\"2\\xDA3\\xDB\"),\n	          peg$decode(\".\\xDC\\\"\\\"2\\xDC3\\xDD\"),\n	          peg$decode(\".\\xDE\\\"\\\"2\\xDE3\\xDF\"),\n	          peg$decode(\".\\xE0\\\"\\\"2\\xE03\\xE1\"),\n	          peg$decode(\".\\xE2\\\"\\\"2\\xE23\\xE3\"),\n	          peg$decode(\".\\xE4\\\"\\\"2\\xE43\\xE5\"),\n	          peg$decode(\".\\xE6\\\"\\\"2\\xE63\\xE7\"),\n	          peg$decode(\".\\xE8\\\"\\\"2\\xE83\\xE9\"),\n	          peg$decode(\".\\xEA\\\"\\\"2\\xEA3\\xEB\"),\n	          peg$decode(\"!7\\x85*S \\\"7\\x86*M \\\"7\\x88*G \\\"7\\x89*A \\\"7\\x8A*; \\\"7\\x8B*5 \\\"7\\x8C*/ \\\"7\\x8D*) \\\"7\\x8E*# \\\"76+& 4!6\\xEC! %\"),\n	          peg$decode(\"!7\\x84+K$7'+A%7\\x91+7%7'+-%7\\x93+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x92+' 4!6\\xED!! %\"),\n	          peg$decode(\"!7!+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(,G&7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(\\\"+& 4!6\\xEE! %\"),\n	          peg$decode(\"!7\\xB5+_$ \\\\!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!79+R$!.:\\\"\\\"2:3;+-$79+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xEF\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7:*j \\\"!7\\x97+_$ \\\\!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+& 4!6\\xF0! %\"),\n	          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\xF1\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x99*# \\\" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!!76+_$ \\\\!7.+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7.+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\"7H+' 4!6\\xF2!! %\"),\n	          peg$decode(\"7\\x9B*) \\\"7\\x9C*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\xF3\\\"\\\"1!3\\xF4+<$7<+2%7\\x9E+(%4#6\\xF5#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\xF8#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\xF9!! %\"),\n	          peg$decode(\"!.\\xFA\\\"\\\"2\\xFA3\\xFB+x$!.J\\\"\\\"2J3K+S$7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\xFC\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+N$!7<+-$7\\xA0+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+)%4\\\"6\\xFD\\\"\\\"! %$\\\"# X\\\"# X\"),\n	          peg$decode(\"76*) \\\"7T*# \\\"7H\"),\n	          peg$decode(\"!7\\xA2+_$ \\\\!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\xFE\\\"\\\"1&3\\xFF*G \\\"/\\u0100\\\"\\\"1'3\\u0101*; \\\"/\\u0102\\\"\\\"1$3\\u0103*/ \\\"/\\u0104\\\"\\\"1%3\\u0105*# \\\"76+& 4!6\\u0106! %\"),\n	          peg$decode(\"7\\xA4*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\u0107\\\"\\\"1(3\\u0108+O$7<+E%/\\u0109\\\"\\\"1(3\\u010A*/ \\\"/\\u010B\\\"\\\"1(3\\u010C*# \\\"76+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u010D!! %\"),\n	          peg$decode(\"!7\\xA8+& 4!6\\u010E! %\"),\n	          peg$decode(\"!7\\xA9+s$7;+i%7\\xAE+_% \\\\!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xAA*# \\\"7\\xAB\"),\n	          peg$decode(\"/\\u010F\\\"\\\"1$3\\u0110*S \\\"/\\u0111\\\"\\\"1%3\\u0112*G \\\"/\\u0113\\\"\\\"1%3\\u0114*; \\\"/\\u0115\\\"\\\"1%3\\u0116*/ \\\"/\\u0117\\\"\\\"1+3\\u0118*# \\\"7\\xAC\"),\n	          peg$decode(\"/\\u0119\\\"\\\"1'3\\u011A*/ \\\"/\\u011B\\\"\\\"1)3\\u011C*# \\\"7\\xAC\"),\n	          peg$decode(\"76*# \\\"7\\xAD\"),\n	          peg$decode(\"!/\\u011D\\\"\\\"1\\\"3\\u011E+-$76+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xAC*# \\\"76\"),\n	          peg$decode(\"!76+7$7<+-%7\\xB0+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"76*# \\\"7H\"),\n	          peg$decode(\"!7\\xB2+7$7.+-%7\\x8F+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u011F!! %\"),\n	          peg$decode(\"!7\\x9D+' 4!6\\u0120!! %\"),\n	          peg$decode(\"!7\\xB5+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0121\\\"!!%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!!77+k$ \\\\!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X,>&!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n	          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0122\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\u0123\\\"\\\"1#3\\u0124+<$7<+2%76+(%4#6\\u0125#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0126!! %\"),\n	          peg$decode(\"!7\\x9D+' 4!6\\u0127!! %\"),\n	          peg$decode(\"! \\\\7\\x99,#&7\\x99\\\"+\\x81$7@+w%7M+m%7?+c% \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4%6\\u0128% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xBD\"),\n	          peg$decode(\"!/\\u0129\\\"\\\"1&3\\u012A+s$7.+i%7\\xC0+_% \\\\!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\"7\\xBE\"),\n	          peg$decode(\"!76+s$7.+i%7\\xBF+_% \\\\!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+=$7<+3%76*# \\\"7H+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xC1*G \\\"7\\xC3*A \\\"7\\xC5*; \\\"7\\xC7*5 \\\"7\\xC8*/ \\\"7\\xC9*) \\\"7\\xCA*# \\\"7\\xBF\"),\n	          peg$decode(\"!/\\u012B\\\"\\\"1%3\\u012C+7$7<+-%7\\xC2+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7I+' 4!6\\u012D!! %\"),\n	          peg$decode(\"!/\\u012E\\\"\\\"1&3\\u012F+\\xA5$7<+\\x9B%7D+\\x91%7\\xC4+\\x87% \\\\! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X,G&! \\\\7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X\\\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7t*# \\\"7w\"),\n	          peg$decode(\"!/\\u0130\\\"\\\"1%3\\u0131+7$7<+-%7\\xC6+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7I+' 4!6\\u0132!! %\"),\n	          peg$decode(\"!/\\u0133\\\"\\\"1&3\\u0134+<$7<+2%7I+(%4#6\\u0135#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0136\\\"\\\"1%3\\u0137+_$7<+U%!/\\u0138\\\"\\\"1$3\\u0139+& 4!6\\u013A! %*4 \\\"!/\\u013B\\\"\\\"1%3\\u013C+& 4!6\\u013D! %+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u013E\\\"\\\"1)3\\u013F+T$7<+J%/\\u0140\\\"\\\"1#3\\u0141*/ \\\"/\\u0142\\\"\\\"1(3\\u0143*# \\\"76+(%4#6\\u0144#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0145\\\"\\\"1#3\\u0146+\\x9E$7<+\\x94%7D+\\x8A%!7\\xCB+k$ \\\\!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X,>&!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+-%7E+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0147\\\"\\\"1(3\\u0148*/ \\\"/\\u0149\\\"\\\"1$3\\u014A*# \\\"76+' 4!6\\u014B!! %\"),\n	          peg$decode(\"!76+_$ \\\\!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xCE+K$7.+A%7\\xCE+7%7.+-%7\\x8F+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u014C!! %\"),\n	          peg$decode(\"!7\\xD0+c$ \\\\!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014D\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x98+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014E\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7L*T \\\"7\\x98*N \\\"!7@*# \\\" [+=$7t+3%7?*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+c$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u014F\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xD3+c$ \\\\!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0150\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x95+& 4!6\\u0151! %\"),\n	          peg$decode(\"!/\\u0152\\\"\\\"1(3\\u0153+<$7<+2%76+(%4#6\\u0154#! %$## X$\\\"# X\\\"# X*j \\\"!/\\u0155\\\"\\\"1&3\\u0156+<$7<+2%76+(%4#6\\u0157#! %$## X$\\\"# X\\\"# X*: \\\"!/\\u0158\\\"\\\"1*3\\u0159+& 4!6\\u015A! %*# \\\"7\\x9F\"),\n	          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u015D!! %\"),\n	          peg$decode(\"!7\\xD7+_$ \\\\!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD7+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x98+_$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"! \\\\7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u015E!! %\"),\n	          peg$decode(\"!7\\xDA+_$ \\\\!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xDB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u015F\\\"\\\"1&3\\u0160*; \\\"/\\u0161\\\"\\\"1'3\\u0162*/ \\\"/\\u0163\\\"\\\"1*3\\u0164*# \\\"76+& 4!6\\u0165! %\"),\n	          peg$decode(\"!/\\u0166\\\"\\\"1&3\\u0167+<$7<+2%7\\xDC+(%4#6\\u0168#! %$## X$\\\"# X\\\"# X*\\x83 \\\"!/\\xF6\\\"\\\"1'3\\xF7+<$7<+2%7\\x9D+(%4#6\\u0169#! %$## X$\\\"# X\\\"# X*S \\\"!/\\u016A\\\"\\\"1+3\\u016B+<$7<+2%7\\x9D+(%4#6\\u016C#! %$## X$\\\"# X\\\"# X*# \\\"7\\x9F\"),\n	          peg$decode(\"/\\u016D\\\"\\\"1+3\\u016E*k \\\"/\\u016F\\\"\\\"1)3\\u0170*_ \\\"/\\u0171\\\"\\\"1(3\\u0172*S \\\"/\\u0173\\\"\\\"1'3\\u0174*G \\\"/\\u0175\\\"\\\"1&3\\u0176*; \\\"/\\u0177\\\"\\\"1*3\\u0178*/ \\\"/\\u0179\\\"\\\"1)3\\u017A*# \\\"76\"),\n	          peg$decode(\"71*# \\\" [\"),\n	          peg$decode(\"!!76+o$ \\\\!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X,=&!7A+2$76+(%4\\\"6\\u015B\\\"! %$\\\"# X\\\"# X\\\"+)%4\\\"6\\u015C\\\"\\\"! %$\\\"# X\\\"# X*# \\\" [+' 4!6\\u017B!! %\"),\n	          peg$decode(\"!7L*# \\\"7\\x98+c$ \\\\!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u017C\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n	          peg$decode(\"!7\\xE2+_$ \\\\!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xE2+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xE9+s$7.+i%7\\xEC+_% \\\\!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xE4*; \\\"7\\xE5*5 \\\"7\\xE6*/ \\\"7\\xE7*) \\\"7\\xE8*# \\\"7\\x9F\"),\n	          peg$decode(\"!/\\u017D\\\"\\\"1#3\\u017E+<$7<+2%7\\xEF+(%4#6\\u017F#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0180\\\"\\\"1%3\\u0181+<$7<+2%7T+(%4#6\\u0182#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0183\\\"\\\"1(3\\u0184+B$7<+8%7\\\\*# \\\"7Y+(%4#6\\u0185#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0186\\\"\\\"1&3\\u0187+<$7<+2%76+(%4#6\\u0188#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u0189\\\"\\\"1%3\\u018A+T$!7<+5$ \\\\7!,#&7!\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+'%4\\\"6\\u018B\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\xEA+K$7;+A%76+7%7;+-%7\\xEB+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\x95\\\"\\\"1#3\\xD6*# \\\"76+' 4!6\\u018C!! %\"),\n	          peg$decode(\"!/\\xB4\\\"\\\"1#3\\u018D*G \\\"/\\xB6\\\"\\\"1#3\\u018E*; \\\"/\\xBA\\\"\\\"1#3\\u018F*/ \\\"/\\xB8\\\"\\\"1$3\\u0190*# \\\"76+' 4!6\\u0191!! %\"),\n	          peg$decode(\"!7\\xED+H$!7C+-$7\\xEE+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\u0192! %\"),\n	          peg$decode(\"!!7!*# \\\" [+c$7!*# \\\" [+S%7!*# \\\" [+C%7!*# \\\" [+3%7!*# \\\" [+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\u0193!! %\"),\n	          peg$decode(\"!!7!+C$7!*# \\\" [+3%7!*# \\\" [+#%'#%$## X$\\\"# X\\\"# X+' 4!6\\u0194!! %\"),\n	          peg$decode(\"7\\xBD\"),\n	          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xF2+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0195\\\"!!%$\\\"# X\\\"# X\"),\n	          peg$decode(\"7\\xF3*# \\\"7\\x9F\"),\n	          peg$decode(\"!.\\u0196\\\"\\\"2\\u01963\\u0197+N$7<+D%.\\u0198\\\"\\\"2\\u01983\\u0199*) \\\".\\u019A\\\"\\\"2\\u019A3\\u019B+(%4#6\\u019C#! %$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\x9D+d$ \\\\!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u019D\\\"!!%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!76+7$70+-%7\\xF6+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\" \\\\72*) \\\"74*# \\\"7.,/&72*) \\\"74*# \\\"7.\\\"\"),\n	          peg$decode(\" \\\\7%,#&7%\\\"\"),\n	          peg$decode(\"!7\\xF9+=$.8\\\"\\\"2839+-%7\\xFA+#%'#%$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u019E\\\"\\\"1%3\\u019F*) \\\"/\\u01A0\\\"\\\"1$3\\u01A1+' 4!6\\u01A2!! %\"),\n	          peg$decode(\"!7\\xFB+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\\\*) \\\"7X*# \\\"7\\x82+' 4!6\\u01A3!! %\"),\n	          peg$decode(\"! \\\\7\\xFD*) \\\"7-*# \\\"7\\xFE,/&7\\xFD*) \\\"7-*# \\\"7\\xFE\\\"+! (%\"),\n	          peg$decode(\"7\\\"*S \\\"7!*M \\\".F\\\"\\\"2F3G*A \\\".J\\\"\\\"2J3K*5 \\\".H\\\"\\\"2H3I*) \\\".N\\\"\\\"2N3O\"),\n	          peg$decode(\".L\\\"\\\"2L3M*\\x95 \\\".B\\\"\\\"2B3C*\\x89 \\\".<\\\"\\\"2<3=*} \\\".R\\\"\\\"2R3S*q \\\".T\\\"\\\"2T3U*e \\\".V\\\"\\\"2V3W*Y \\\".P\\\"\\\"2P3Q*M \\\".@\\\"\\\"2@3A*A \\\".D\\\"\\\"2D3E*5 \\\".2\\\"\\\"2233*) \\\".>\\\"\\\"2>3?\"),\n	          peg$decode(\"!7\\u0100+h$.8\\\"\\\"2839+X%7\\xFA+N%!.\\u01A4\\\"\\\"2\\u01A43\\u01A5+-$7\\xEB+#%'\\\"%$\\\"# X\\\"# X*# \\\" [+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!/\\u01A6\\\"\\\"1%3\\u01A7*) \\\"/\\u01A8\\\"\\\"1$3\\u01A9+' 4!6\\u01A2!! %\"),\n	          peg$decode(\"!7\\xEB+Q$/\\xB4\\\"\\\"1#3\\xB5*7 \\\"/\\xB6\\\"\\\"1#3\\xB7*+ \\\" \\\\7+,#&7+\\\"+'%4\\\"6\\u01AA\\\" %$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\u0104+\\x8F$.F\\\"\\\"2F3G+%7\\u0103+u%.F\\\"\\\"2F3G+e%7\\u0103+[%.F\\\"\\\"2F3G+K%7\\u0103+A%.F\\\"\\\"2F3G+1%7\\u0105+'%4)6\\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\u0103+-$7\\u0103+#%'\\\"%$\\\"# X\\\"# X\"),\n	          peg$decode(\"!7\\u0103+7$7\\u0103+-%7\\u0103+#%'#%$## X$\\\"# X\\\"# X\")\n	        ],\n	\n	        peg$currPos          = 0,\n	        peg$reportedPos      = 0,\n	        peg$cachedPos        = 0,\n	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n	        peg$maxFailPos       = 0,\n	        peg$maxFailExpected  = [],\n	        peg$silentFails      = 0,\n	\n	        peg$result;\n	\n	    if (\"startRule\" in options) {\n	      if (!(options.startRule in peg$startRuleIndices)) {\n	        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n	      }\n	\n	      peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n	    }\n	\n	    function text() {\n	      return input.substring(peg$reportedPos, peg$currPos);\n	    }\n	\n	    function offset() {\n	      return peg$reportedPos;\n	    }\n	\n	    function line() {\n	      return peg$computePosDetails(peg$reportedPos).line;\n	    }\n	\n	    function column() {\n	      return peg$computePosDetails(peg$reportedPos).column;\n	    }\n	\n	    function expected(description) {\n	      throw peg$buildException(\n	        null,\n	        [{ type: \"other\", description: description }],\n	        peg$reportedPos\n	      );\n	    }\n	\n	    function error(message) {\n	      throw peg$buildException(message, null, peg$reportedPos);\n	    }\n	\n	    function peg$computePosDetails(pos) {\n	      function advance(details, startPos, endPos) {\n	        var p, ch;\n	\n	        for (p = startPos; p < endPos; p++) {\n	          ch = input.charAt(p);\n	          if (ch === \"\\n\") {\n	            if (!details.seenCR) { details.line++; }\n	            details.column = 1;\n	            details.seenCR = false;\n	          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n	            details.line++;\n	            details.column = 1;\n	            details.seenCR = true;\n	          } else {\n	            details.column++;\n	            details.seenCR = false;\n	          }\n	        }\n	      }\n	\n	      if (peg$cachedPos !== pos) {\n	        if (peg$cachedPos > pos) {\n	          peg$cachedPos = 0;\n	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n	        }\n	        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n	        peg$cachedPos = pos;\n	      }\n	\n	      return peg$cachedPosDetails;\n	    }\n	\n	    function peg$fail(expected) {\n	      if (peg$currPos < peg$maxFailPos) { return; }\n	\n	      if (peg$currPos > peg$maxFailPos) {\n	        peg$maxFailPos = peg$currPos;\n	        peg$maxFailExpected = [];\n	      }\n	\n	      peg$maxFailExpected.push(expected);\n	    }\n	\n	    function peg$buildException(message, expected, pos) {\n	      function cleanupExpected(expected) {\n	        var i = 1;\n	\n	        expected.sort(function(a, b) {\n	          if (a.description < b.description) {\n	            return -1;\n	          } else if (a.description > b.description) {\n	            return 1;\n	          } else {\n	            return 0;\n	          }\n	        });\n	\n	        while (i < expected.length) {\n	          if (expected[i - 1] === expected[i]) {\n	            expected.splice(i, 1);\n	          } else {\n	            i++;\n	          }\n	        }\n	      }\n	\n	      function buildMessage(expected, found) {\n	        function stringEscape(s) {\n	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n	\n	          return s\n	            .replace(/\\\\/g,   '\\\\\\\\')\n	            .replace(/\"/g,    '\\\\\"')\n	            .replace(/\\x08/g, '\\\\b')\n	            .replace(/\\t/g,   '\\\\t')\n	            .replace(/\\n/g,   '\\\\n')\n	            .replace(/\\f/g,   '\\\\f')\n	            .replace(/\\r/g,   '\\\\r')\n	            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n	            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n	            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n	            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n	        }\n	\n	        var expectedDescs = new Array(expected.length),\n	            expectedDesc, foundDesc, i;\n	\n	        for (i = 0; i < expected.length; i++) {\n	          expectedDescs[i] = expected[i].description;\n	        }\n	\n	        expectedDesc = expected.length > 1\n	          ? expectedDescs.slice(0, -1).join(\", \")\n	              + \" or \"\n	              + expectedDescs[expected.length - 1]\n	          : expectedDescs[0];\n	\n	        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n	\n	        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n	      }\n	\n	      var posDetails = peg$computePosDetails(pos),\n	          found      = pos < input.length ? input.charAt(pos) : null;\n	\n	      if (expected !== null) {\n	        cleanupExpected(expected);\n	      }\n	\n	      return new SyntaxError(\n	        message !== null ? message : buildMessage(expected, found),\n	        expected,\n	        found,\n	        pos,\n	        posDetails.line,\n	        posDetails.column\n	      );\n	    }\n	\n	    function peg$decode(s) {\n	      var bc = new Array(s.length), i;\n	\n	      for (i = 0; i < s.length; i++) {\n	        bc[i] = s.charCodeAt(i) - 32;\n	      }\n	\n	      return bc;\n	    }\n	\n	    function peg$parseRule(index) {\n	      var bc    = peg$bytecode[index],\n	          ip    = 0,\n	          ips   = [],\n	          end   = bc.length,\n	          ends  = [],\n	          stack = [],\n	          params, i;\n	\n	      function protect(object) {\n	        return Object.prototype.toString.apply(object) === \"[object Array]\" ? [] : object;\n	      }\n	\n	      while (true) {\n	        while (ip < end) {\n	          switch (bc[ip]) {\n	            case 0:\n	              stack.push(protect(peg$consts[bc[ip + 1]]));\n	              ip += 2;\n	              break;\n	\n	            case 1:\n	              stack.push(peg$currPos);\n	              ip++;\n	              break;\n	\n	            case 2:\n	              stack.pop();\n	              ip++;\n	              break;\n	\n	            case 3:\n	              peg$currPos = stack.pop();\n	              ip++;\n	              break;\n	\n	            case 4:\n	              stack.length -= bc[ip + 1];\n	              ip += 2;\n	              break;\n	\n	            case 5:\n	              stack.splice(-2, 1);\n	              ip++;\n	              break;\n	\n	            case 6:\n	              stack[stack.length - 2].push(stack.pop());\n	              ip++;\n	              break;\n	\n	            case 7:\n	              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n	              ip += 2;\n	              break;\n	\n	            case 8:\n	              stack.pop();\n	              stack.push(input.substring(stack[stack.length - 1], peg$currPos));\n	              ip++;\n	              break;\n	\n	            case 9:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (stack[stack.length - 1]) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 10:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (stack[stack.length - 1] === peg$FAILED) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 11:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (stack[stack.length - 1] !== peg$FAILED) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 12:\n	              if (stack[stack.length - 1] !== peg$FAILED) {\n	                ends.push(end);\n	                ips.push(ip);\n	\n	                end = ip + 2 + bc[ip + 1];\n	                ip += 2;\n	              } else {\n	                ip += 2 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 13:\n	              ends.push(end);\n	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n	\n	              if (input.length > peg$currPos) {\n	                end = ip + 3 + bc[ip + 1];\n	                ip += 3;\n	              } else {\n	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n	                ip += 3 + bc[ip + 1];\n	              }\n	\n	              break;\n	\n	            case 14:\n	              ends.push(end);\n	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n	\n	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n	                end = ip + 4 + bc[ip + 2];\n	                ip += 4;\n	              } else {\n	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n	                ip += 4 + bc[ip + 2];\n	              }\n	\n	              break;\n	\n	            case 15:\n	              ends.push(end);\n	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n	\n	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n	                end = ip + 4 + bc[ip + 2];\n	                ip += 4;\n	              } else {\n	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n	                ip += 4 + bc[ip + 2];\n	              }\n	\n	              break;\n	\n	            case 16:\n	              ends.push(end);\n	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n	\n	              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n	                end = ip + 4 + bc[ip + 2];\n	                ip += 4;\n	              } else {\n	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n	                ip += 4 + bc[ip + 2];\n	              }\n	\n	              break;\n	\n	            case 17:\n	              stack.push(input.substr(peg$currPos, bc[ip + 1]));\n	              peg$currPos += bc[ip + 1];\n	              ip += 2;\n	              break;\n	\n	            case 18:\n	              stack.push(peg$consts[bc[ip + 1]]);\n	              peg$currPos += peg$consts[bc[ip + 1]].length;\n	              ip += 2;\n	              break;\n	\n	            case 19:\n	              stack.push(peg$FAILED);\n	              if (peg$silentFails === 0) {\n	                peg$fail(peg$consts[bc[ip + 1]]);\n	              }\n	              ip += 2;\n	              break;\n	\n	            case 20:\n	              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];\n	              ip += 2;\n	              break;\n	\n	            case 21:\n	              peg$reportedPos = peg$currPos;\n	              ip++;\n	              break;\n	\n	            case 22:\n	              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n	              for (i = 0; i < bc[ip + 3]; i++) {\n	                params[i] = stack[stack.length - 1 - params[i]];\n	              }\n	\n	              stack.splice(\n	                stack.length - bc[ip + 2],\n	                bc[ip + 2],\n	                peg$consts[bc[ip + 1]].apply(null, params)\n	              );\n	\n	              ip += 4 + bc[ip + 3];\n	              break;\n	\n	            case 23:\n	              stack.push(peg$parseRule(bc[ip + 1]));\n	              ip += 2;\n	              break;\n	\n	            case 24:\n	              peg$silentFails++;\n	              ip++;\n	              break;\n	\n	            case 25:\n	              peg$silentFails--;\n	              ip++;\n	              break;\n	\n	            default:\n	              throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n	          }\n	        }\n	\n	        if (ends.length > 0) {\n	          end = ends.pop();\n	          ip = ips.pop();\n	        } else {\n	          break;\n	        }\n	      }\n	\n	      return stack[0];\n	    }\n	\n	\n	      options.data = {}; // Object to which header attributes will be assigned during parsing\n	\n	      function list (first, rest) {\n	        return [first].concat(rest);\n	      }\n	\n	\n	    peg$result = peg$parseRule(peg$startRuleIndex);\n	\n	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n	      return peg$result;\n	    } else {\n	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n	        peg$fail({ type: \"end\", description: \"end of input\" });\n	      }\n	\n	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n	    }\n	  }\n	\n	  return {\n	    SyntaxError: SyntaxError,\n	    parse:       parse\n	  };\n	})();\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n	\n	var toplevel = global.window || global;\n	\n	function getPrefixedProperty (object, name) {\n	  if (object == null) {\n	    return;\n	  }\n	  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n	  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n	  for (var i in prefixedNames) {\n	    var property = object[prefixedNames[i]];\n	    if (property) {\n	      return property.bind(object);\n	    }\n	  }\n	}\n	\n	module.exports = {\n	  WebSocket: toplevel.WebSocket,\n	  Transport: __webpack_require__(50),\n	  open: toplevel.open,\n	  Promise: toplevel.Promise,\n	  timers: toplevel,\n	\n	  // Console is not defined in ECMAScript, so just in case...\n	  console: toplevel.console || {\n	    debug: function () {},\n	    log: function () {},\n	    warn: function () {},\n	    error: function () {}\n	  },\n	\n	  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),\n	  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),\n	  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),\n	  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),\n	\n	  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),\n	  HTMLMediaElement: toplevel.HTMLMediaElement,\n	\n	  attachMediaStream: toplevel.attachMediaStream,\n	  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,\n	  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL\n	};\n	\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	/**\n	 * @fileoverview Transport\n	 */\n	\n	/**\n	 * @augments SIP\n	 * @class Transport\n	 * @param {SIP.UA} ua\n	 * @param {Object} server ws_server Object\n	 */\n	module.exports = function (SIP, WebSocket) {\n	var Transport,\n	  C = {\n	    // Transport status codes\n	    STATUS_READY:        0,\n	    STATUS_DISCONNECTED: 1,\n	    STATUS_ERROR:        2\n	  };\n	\n	/**\n	 * Compute an amount of time in seconds to wait before sending another\n	 * keep-alive.\n	 * @returns {Number}\n	 */\n	function computeKeepAliveTimeout(upperBound) {\n	  var lowerBound = upperBound * 0.8;\n	  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n	}\n	\n	Transport = function(ua, server) {\n	\n	  this.logger = ua.getLogger('sip.transport');\n	  this.ua = ua;\n	  this.ws = null;\n	  this.server = server;\n	  this.reconnection_attempts = 0;\n	  this.closed = false;\n	  this.connected = false;\n	  this.reconnectTimer = null;\n	  this.lastTransportError = {};\n	\n	  this.keepAliveInterval = ua.configuration.keepAliveInterval;\n	  this.keepAliveTimeout = null;\n	  this.keepAliveTimer = null;\n	\n	  this.ua.transport = this;\n	\n	  // Connect\n	  this.connect();\n	};\n	\n	Transport.prototype = {\n	  /**\n	   * Send a message.\n	   * @param {SIP.OutgoingRequest|String} msg\n	   * @returns {Boolean}\n	   */\n	  send: function(msg) {\n	    var message = msg.toString();\n	\n	    if(this.ws && this.ws.readyState === WebSocket.OPEN) {\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n	      }\n	      this.ws.send(message);\n	      return true;\n	    } else {\n	      this.logger.warn('unable to send message, WebSocket is not open');\n	      return false;\n	    }\n	  },\n	\n	  /**\n	   * Send a keep-alive (a double-CRLF sequence).\n	   * @private\n	   * @returns {Boolean}\n	   */\n	  sendKeepAlive: function() {\n	    if(this.keepAliveTimeout) { return; }\n	\n	    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {\n	      this.ua.emit('keepAliveTimeout');\n	    }.bind(this), 10000);\n	\n	    return this.send('\\r\\n\\r\\n');\n	  },\n	\n	  /**\n	   * Start sending keep-alives.\n	   * @private\n	   */\n	  startSendingKeepAlives: function() {\n	    if (this.keepAliveInterval && !this.keepAliveTimer) {\n	      this.keepAliveTimer = SIP.Timers.setTimeout(function() {\n	        this.sendKeepAlive();\n	        this.keepAliveTimer = null;\n	        this.startSendingKeepAlives();\n	      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));\n	    }\n	  },\n	\n	  /**\n	   * Stop sending keep-alives.\n	   * @private\n	   */\n	  stopSendingKeepAlives: function() {\n	    SIP.Timers.clearTimeout(this.keepAliveTimer);\n	    SIP.Timers.clearTimeout(this.keepAliveTimeout);\n	    this.keepAliveTimer = null;\n	    this.keepAliveTimeout = null;\n	  },\n	\n	  /**\n	  * Disconnect socket.\n	  */\n	  disconnect: function() {\n	    if(this.ws) {\n	      // Clear reconnectTimer\n	      SIP.Timers.clearTimeout(this.reconnectTimer);\n	\n	      this.stopSendingKeepAlives();\n	\n	      this.closed = true;\n	      this.logger.log('closing WebSocket ' + this.server.ws_uri);\n	      this.ws.close();\n	    }\n	\n	    if (this.reconnectTimer !== null) {\n	      SIP.Timers.clearTimeout(this.reconnectTimer);\n	      this.reconnectTimer = null;\n	      this.ua.emit('disconnected', {\n	        transport: this,\n	        code: this.lastTransportError.code,\n	        reason: this.lastTransportError.reason\n	      });\n	    }\n	  },\n	\n	  /**\n	  * Connect socket.\n	  */\n	  connect: function() {\n	    var transport = this;\n	\n	    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n	      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');\n	      return false;\n	    }\n	\n	    if(this.ws) {\n	      this.ws.close();\n	    }\n	\n	    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n	    this.ua.onTransportConnecting(this,\n	      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);\n	\n	    try {\n	      this.ws = new WebSocket(this.server.ws_uri, 'sip');\n	    } catch(e) {\n	      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);\n	    }\n	\n	    this.ws.binaryType = 'arraybuffer';\n	\n	    this.ws.onopen = function() {\n	      transport.onOpen();\n	    };\n	\n	    this.ws.onclose = function(e) {\n	      transport.onClose(e);\n	    };\n	\n	    this.ws.onmessage = function(e) {\n	      transport.onMessage(e);\n	    };\n	\n	    this.ws.onerror = function(e) {\n	      transport.onError(e);\n	    };\n	  },\n	\n	  // Transport Event Handlers\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onOpen: function() {\n	    this.connected = true;\n	\n	    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');\n	    // Clear reconnectTimer since we are not disconnected\n	    if (this.reconnectTimer !== null) {\n	      SIP.Timers.clearTimeout(this.reconnectTimer);\n	      this.reconnectTimer = null;\n	    }\n	    // Reset reconnection_attempts\n	    this.reconnection_attempts = 0;\n	    // Disable closed\n	    this.closed = false;\n	    // Trigger onTransportConnected callback\n	    this.ua.onTransportConnected(this);\n	    // Start sending keep-alives\n	    this.startSendingKeepAlives();\n	  },\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onClose: function(e) {\n	    var connected_before = this.connected;\n	\n	    this.lastTransportError.code = e.code;\n	    this.lastTransportError.reason = e.reason;\n	\n	    this.stopSendingKeepAlives();\n	\n	    if (this.reconnection_attempts > 0) {\n	      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n	      this.reconnect();\n	    } else {\n	      this.connected = false;\n	      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n	\n	      if(e.wasClean === false) {\n	        this.logger.warn('WebSocket abrupt disconnection');\n	      }\n	      // Transport was connected\n	      if(connected_before === true) {\n	        this.ua.onTransportClosed(this);\n	        // Check whether the user requested to close.\n	        if(!this.closed) {\n	          this.reconnect();\n	        } else {\n	          this.ua.emit('disconnected', {\n	            transport: this,\n	            code: this.lastTransportError.code,\n	            reason: this.lastTransportError.reason\n	          });\n	\n	        }\n	      } else {\n	        // This is the first connection attempt\n	        //Network error\n	        this.ua.onTransportError(this);\n	      }\n	    }\n	  },\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onMessage: function(e) {\n	    var message, transaction,\n	      data = e.data;\n	\n	    // CRLF Keep Alive response from server. Ignore it.\n	    if(data === '\\r\\n') {\n	      SIP.Timers.clearTimeout(this.keepAliveTimeout);\n	      this.keepAliveTimeout = null;\n	\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('received WebSocket message with CRLF Keep Alive response');\n	      }\n	\n	      return;\n	    }\n	\n	    // WebSocket binary message.\n	    else if (typeof data !== 'string') {\n	      try {\n	        data = String.fromCharCode.apply(null, new Uint8Array(data));\n	      } catch(evt) {\n	        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n	        return;\n	      }\n	\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n	      }\n	    }\n	\n	    // WebSocket text message.\n	    else {\n	      if (this.ua.configuration.traceSip === true) {\n	        this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n	      }\n	    }\n	\n	    message = SIP.Parser.parseMessage(data, this.ua);\n	\n	    if (!message) {\n	      return;\n	    }\n	\n	    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n	      return;\n	    }\n	\n	    // Do some sanity check\n	    if(SIP.sanityCheck(message, this.ua, this)) {\n	      if(message instanceof SIP.IncomingRequest) {\n	        message.transport = this;\n	        this.ua.receiveRequest(message);\n	      } else if(message instanceof SIP.IncomingResponse) {\n	        /* Unike stated in 18.1.2, if a response does not match\n	        * any transaction, it is discarded here and no passed to the core\n	        * in order to be discarded there.\n	        */\n	        switch(message.method) {\n	          case SIP.C.INVITE:\n	            transaction = this.ua.transactions.ict[message.via_branch];\n	            if(transaction) {\n	              transaction.receiveResponse(message);\n	            }\n	            break;\n	          case SIP.C.ACK:\n	            // Just in case ;-)\n	            break;\n	          default:\n	            transaction = this.ua.transactions.nict[message.via_branch];\n	            if(transaction) {\n	              transaction.receiveResponse(message);\n	            }\n	            break;\n	        }\n	      }\n	    }\n	  },\n	\n	  /**\n	  * @event\n	  * @param {event} e\n	  */\n	  onError: function(e) {\n	    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));\n	  },\n	\n	  /**\n	  * Reconnection attempt logic.\n	  * @private\n	  */\n	  reconnect: function() {\n	    var transport = this;\n	\n	    this.reconnection_attempts += 1;\n	\n	    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {\n	      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n	      this.ua.onTransportError(this);\n	    } else if (this.reconnection_attempts === 1) {\n	      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');\n	      transport.connect();\n	    } else {\n	      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');\n	\n	      this.reconnectTimer = SIP.Timers.setTimeout(function() {\n	        transport.connect();\n	        transport.reconnectTimer = null;\n	      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);\n	    }\n	  }\n	};\n	\n	Transport.C = C;\n	return Transport;\n	};\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var LoginService = function (sdk) {\n	    var onLoginHandler = [];\n	    return {\n	        login: function login(username, extension, password) {\n	            return _rcSdk.RC.sdk.platform().login({\n	                'username': username,\n	                'extension': extension,\n	                'password': password\n	            });\n	        },\n	        logout: function logout() {\n	            return _rcSdk.RC.sdk.platform().logout();\n	        },\n	        checkLoginStatus: function checkLoginStatus() {\n	            return _rcSdk.RC.sdk.platform().loggedIn().then(function (isLoggedIn) {\n	                if (isLoggedIn) {\n	                    onLoginHandler.forEach(function (handler) {\n	                        return handler();\n	                    });\n	                }\n	                return isLoggedIn;\n	            });\n	        },\n	        oauth: function oauth() {\n	            return new Promise(function (resolve, reject) {\n	                var redirectUri = 'https://ringcentral.github.io/ringcentral-js-widget/page/redirect.html';\n	                var url = _rcSdk.RC.sdk.platform().authUrl({\n	                    redirectUri: redirectUri\n	                });\n	                var oauthWindow = window.open(url, 'rc-iframe-2', 'width=400, height=600');\n	                var interval = setInterval(check, 500);\n	                function check() {\n	                    if (!oauthWindow) {\n	                        return;\n	                    }\n	                    if (oauthWindow.closed) {\n	                        reject(new Error('RingCentral Oauth window is closed abnormally.'));\n	                        clearInterval(interval);\n	                    }\n	                }\n	                window.addEventListener('message', function oauthChannel(e) {\n	                    if (e.data.type === 'oauth') {\n	                        var qs = _rcSdk.RC.sdk.platform().parseAuthRedirectUrl(e.data.value);\n	                        qs.redirectUri = redirectUri;\n	                        window.removeEventListener('message', oauthChannel);\n	                        clearInterval(interval);\n	                        resolve(_rcSdk.RC.sdk.platform().login(qs));\n	                    } else if (e.data.type === 'oauth-fail') {\n	                        window.removeEventListener('message', oauthChannel);\n	                        clearInterval(interval);\n	                        reject(new Error('RingCentral Oauth window is closed abnormally.'));\n	                    }\n	                });\n	            });\n	        }\n	    };\n	}();\n	exports.default = LoginService;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _rcSubscriptionService = __webpack_require__(53);\n	\n	var _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var CallLogService = function (sdk) {\n	    var period = 7 * 24 * 3600 * 1000;\n	    var dateFrom = new Date(Date.now() - period);\n	    return {\n	        getCallLogs: function getCallLogs() {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', { dateFrom: dateFrom.toISOString() }).then(function (response) {\n	                return response.json().records;\n	            });\n	        },\n	        getCallLogsByNumber: function getCallLogsByNumber(phoneNumber, hourFrom, hourTo) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/call-log', {\n	                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n	                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n	                phoneNumber: phoneNumber\n	            }).then(function (response) {\n	                return response.json();\n	            }).then(function (data) {\n	                return data.records;\n	            }).then(function (records) {\n	                return records.reverse();\n	            });\n	        }\n	    };\n	}();\n	\n	exports.default = CallLogService;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var rcSubscription = function () {\n	    var _init = false;\n	    var cacheKey = 'ringcentral-subscription';\n	    var subscription;\n	    var handlers = {};\n	    function init() {\n	        _init = true;\n	        subscription = _rcSdk.RC.sdk.createCachedSubscription(cacheKey).restore();\n	        subscription.on(subscription.events.notification, function (msg) {\n	            for (var key in handlers) {\n	                if (handlers.hasOwnProperty(key)) {\n	                    if (msg.event.indexOf(key) > -1) {\n	                        handlers[key].forEach(function (h) {\n	                            try {\n	                                h(msg);\n	                            } catch (e) {\n	                                console.error('Error occurs when invoking subscription notification handler for \"' + msg.event + '\": ' + e);\n	                            }\n	                        });\n	                    }\n	                }\n	            }\n	        });\n	    }\n	\n	    return {\n	        subscribe: function subscribe(suffix, event, handler) {\n	            if (!_init) init();\n	            if (event && suffix) {\n	                if (!handlers[suffix]) {\n	                    handlers[suffix] = [];\n	                }\n	                handlers[suffix].push(handler);\n	                subscription.addEventFilters(event).register();\n	            }\n	        }\n	    };\n	}();\n	\n	exports.default = rcSubscription;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var accountService = function (RC) {\n	    var info;\n	    var numbers;\n	    var fetchNumbers = null;\n	\n	    function getNumbersByType(numbers, type) {\n	        if (!numbers) return Error('Need to fetch numbers first using accountService.getPhoneNumber');\n	        return numbers.filter(function (number) {\n	            return number.type === type;\n	        });\n	    }\n	\n	    function getNumbersByFeatures(numbers, features) {\n	        if (!Array.isArray(features)) features = [features];\n	        // if has duplicate features\n	        return numbers.filter(function (number) {\n	            return features.filter(function (f) {\n	                return number.features.indexOf(f) > -1;\n	            }).length > 0;\n	        });\n	    }\n	\n	    return {\n	        getAccountInfo: function getAccountInfo() {\n	            return RC.sdk.platform().get('/account/~/extension/~').then(function (response) {\n	                info = response.json();\n	                return info;\n	            }).catch(function (e) {\n	                return console.error('Recent Calls Error: ' + e.message);\n	            });\n	        },\n	\n	        getPhoneNumber: function getPhoneNumber() {\n	            fetchNumbers = RC.sdk.platform().get('/account/~/extension/~/phone-number').then(function (response) {\n	                var data = response.json();\n	                numbers = data.records;\n	                fetchNumbers = null;\n	                return data.records;\n	            }).catch(function (e) {\n	                return console.error('Recent Calls Error: ' + e.message);\n	            });\n	            return fetchNumbers;\n	        },\n	\n	        hasServiceFeature: function hasServiceFeature(name) {\n	            if (!info) return Error('Need to fetch account info by accountService.getAccountInfo');\n	            return info.serviceFeatures.filter(function (feature) {\n	                return feature.featureName.toLowerCase() === name.toLowerCase();\n	            }).length > 0;\n	        },\n	\n	        listNumber: function listNumber(type) {\n	            var features = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n	\n	            if (fetchNumbers) {\n	                return fetchNumbers.then(function () {\n	                    return getNumbersByFeatures(getNumbersByType(numbers, type), features).map(function (number) {\n	                        return number.phoneNumber;\n	                    });\n	                });\n	            } else {\n	                return getNumbersByFeatures(getNumbersByType(numbers, type), features).sort(function (number1, number2) {\n	                    if (number2.usageType === 'DirectNumber') return 1;\n	                    return -1;\n	                }).map(function (number) {\n	                    return number.phoneNumber;\n	                });\n	            }\n	        }\n	    };\n	}(_rcSdk.RC);\n	\n	exports.default = accountService;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _lzString = __webpack_require__(56);\n	\n	var _lzString2 = _interopRequireDefault(_lzString);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcContactService = function () {\n	    var companyContacts = [];\n	    var completeCompanyContacts = null;\n	\n	    var fetchingCompanyContacts = null;\n	    var fetchingCompleteCompanyContacts = null;\n	\n	    function Contact() {\n	        this.firstName = null;\n	        this.lastName = null;\n	        this.displayName = null;\n	        this.extension = null;\n	        this.email = null;\n	        this.type = null;\n	        this.id = null;\n	        this.phoneNumber = [];\n	    }\n	\n	    function createContact(extension) {\n	        var contact = new Contact();\n	        contact.extension = extension.extensionNumber;\n	        contact.firstName = extension.contact.firstName;\n	        contact.lastName = extension.contact.lastName;\n	        contact.displayName = contact.firstName + ' ' + contact.lastName;\n	        contact.email = extension.contact.email;\n	        contact.type = 'rc';\n	        contact.id = extension.id;\n	        contact.profileImage = extension.profileImage.uri;\n	        return contact;\n	    }\n	\n	    function addToCompanyContact(response) {\n	        var records = response.json().records.filter(function (extension) {\n	            return extension.status === 'Enabled' && ['DigitalUser', 'User'].indexOf(extension.type) >= 0;\n	        }).map(function (extension) {\n	            return createContact(extension);\n	        });\n	        companyContacts.push.apply(companyContacts, records);\n	    }\n	\n	    function fetchCompanyContactByPage(page) {\n	        return _rcSdk.RC.sdk.platform().get('/account/~/extension/', { perPage: 250, page: page });\n	    }\n	\n	    function fetchCompanyDirectNumbersByPage(page) {\n	        return _rcSdk.RC.sdk.platform().get('/account/~/phone-number', { perPage: 250, page: page });\n	    }\n	\n	    function fetchCompanyContacts() {\n	        var page = 1;\n	        fetchingCompanyContacts = fetchCompanyContactByPage(page).then(function (response) {\n	            var respObj = response.json();\n	            if (respObj.paging && respObj.paging.totalPages > page) {\n	                var promises = [];\n	                while (respObj.paging.totalPages > page) {\n	                    page++;\n	                    promises.push(fetchCompanyContactByPage(page));\n	                }\n	\n	                return Promise.all(promises).then(function (responses) {\n	                    responses.forEach(function (response) {\n	                        addToCompanyContact(response);\n	                    });\n	                    fetchingCompanyContacts = null;\n	                    return companyContacts;\n	                });\n	            } else {\n	                addToCompanyContact(response);\n	                return companyContacts;\n	            }\n	        }).catch(function (e) {\n	            console.error(e);\n	        });\n	        return fetchingCompanyContacts;\n	    }\n	\n	    function fetchCompanyDirectNumbers() {\n	        var page = 1;\n	        return fetchCompanyDirectNumbersByPage(page).then(function (response) {\n	            var respObj = response.json();\n	            if (respObj.paging && respObj.paging.totalPages > page) {\n	                var promises = [];\n	                while (respObj.paging.totalPages > page) {\n	                    page++;\n	                    promises.push(fetchCompanyDirectNumbersByPage(page));\n	                }\n	\n	                return Promise.all(promises).then(function (responses) {\n	                    var numbers = {};\n	                    responses.forEach(function (response) {\n	                        var resp = response.json();\n	                        resp.records.forEach(function (el) {\n	                            if (el.extension && el.extension.extensionNumber) {\n	                                if (!numbers[el.extension.extensionNumber]) {\n	                                    numbers[el.extension.extensionNumber] = [];\n	                                }\n	\n	                                numbers[el.extension.extensionNumber].push(el);\n	                            }\n	                        });\n	                    });\n	                    companyContacts.forEach(function (contact) {\n	                        var phones = numbers[contact.extension];\n	                        if (phones) {\n	                            phones.forEach(function (phone) {\n	                                contact.phoneNumber.push(phone.phoneNumber);\n	                            });\n	                        }\n	                    });\n	                });\n	            }\n	        });\n	    }\n	\n	    return {\n	        get companyContacts() {\n	            return companyContacts;\n	        },\n	        accessToken: function accessToken() {\n	            return _rcSdk.RC.sdk.platform().auth().accessToken();\n	        },\n	        asyncGetCompanyContact: function asyncGetCompanyContact() {\n	            if (fetchingCompanyContacts) {\n	                return fetchingCompanyContacts;\n	            } else {\n	                return Promise.resolve(companyContacts);\n	            }\n	        },\n	        syncCompanyContact: function syncCompanyContact() {\n	            companyContacts.length = 0;\n	            fetchCompanyContacts();\n	            fetchCompanyDirectNumbers();\n	        },\n	        completeCompanyContact: function completeCompanyContact() {\n	            if (completeCompanyContacts) return Promise.resolve(completeCompanyContacts);\n	            if (fetchingCompleteCompanyContacts) return fetchingCompleteCompanyContacts;\n	            fetchingCompleteCompanyContacts = fetchCompanyContacts().then(fetchCompanyDirectNumbers);\n	            return fetchingCompleteCompanyContacts.then(function () {\n	                completeCompanyContacts = companyContacts;\n	                fetchingCompleteCompanyContacts = null;\n	                return companyContacts;\n	            });\n	        },\n	        cacheContacts: function () {\n	            var contact = null;\n	            var data = localStorage.getItem('rc-contacts');\n	            return function () {\n	                if (contact) {\n	                    contact.then(function (value) {\n	                        completeCompanyContacts = companyContacts = value;\n	                    });\n	                    return contact;\n	                }\n	                // For test\n	                if (window.location.href.indexOf('127.0.0.11') === -1) {\n	                    var fetch = new Promise(function (resolve, reject) {\n	                        // Hack for delay the refreshing request\n	                        setTimeout(function () {\n	                            rcContactService.completeCompanyContact().then(function (data) {\n	                                if (data) {\n	                                    completeCompanyContacts = companyContacts = data;\n	                                    localStorage.setItem('rc-contacts', _lzString2.default.compressToUTF16(JSON.stringify(data)));\n	                                }\n	                                return resolve(data);\n	                            });\n	                        }, 100);\n	                    });\n	                } else {\n	                    var fetch;\n	                }\n	                if (data) {\n	                    var fetchedContact = JSON.parse(_lzString2.default.decompressFromUTF16(data));\n	                    completeCompanyContacts = companyContacts = fetchedContact;\n	                    contact = Promise.resolve(fetchedContact);\n	                } else {\n	                    contact = fetch;\n	                }\n	                return contact;\n	            };\n	        }()\n	    };\n	}();\n	\n	exports.default = rcContactService;\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n	// This work is free. You can redistribute it and/or modify it\n	// under the terms of the WTFPL, Version 2\n	// For more information see LICENSE.txt or http://www.wtfpl.net/\n	//\n	// For more information, the home page:\n	// http://pieroxy.net/blog/pages/lz-string/testing.html\n	//\n	// LZ-based compression algorithm, version 1.4.4\n	var LZString = (function() {\n	\n	// private property\n	var f = String.fromCharCode;\n	var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n	var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n	var baseReverseDic = {};\n	\n	function getBaseValue(alphabet, character) {\n	  if (!baseReverseDic[alphabet]) {\n	    baseReverseDic[alphabet] = {};\n	    for (var i=0 ; i<alphabet.length ; i++) {\n	      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n	    }\n	  }\n	  return baseReverseDic[alphabet][character];\n	}\n	\n	var LZString = {\n	  compressToBase64 : function (input) {\n	    if (input == null) return \"\";\n	    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n	    switch (res.length % 4) { // To produce valid Base64\n	    default: // When could this happen ?\n	    case 0 : return res;\n	    case 1 : return res+\"===\";\n	    case 2 : return res+\"==\";\n	    case 3 : return res+\"=\";\n	    }\n	  },\n	\n	  decompressFromBase64 : function (input) {\n	    if (input == null) return \"\";\n	    if (input == \"\") return null;\n	    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n	  },\n	\n	  compressToUTF16 : function (input) {\n	    if (input == null) return \"\";\n	    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n	  },\n	\n	  decompressFromUTF16: function (compressed) {\n	    if (compressed == null) return \"\";\n	    if (compressed == \"\") return null;\n	    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n	  },\n	\n	  //compress into uint8array (UCS-2 big endian format)\n	  compressToUint8Array: function (uncompressed) {\n	    var compressed = LZString.compress(uncompressed);\n	    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n	\n	    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n	      var current_value = compressed.charCodeAt(i);\n	      buf[i*2] = current_value >>> 8;\n	      buf[i*2+1] = current_value % 256;\n	    }\n	    return buf;\n	  },\n	\n	  //decompress from uint8array (UCS-2 big endian format)\n	  decompressFromUint8Array:function (compressed) {\n	    if (compressed===null || compressed===undefined){\n	        return LZString.decompress(compressed);\n	    } else {\n	        var buf=new Array(compressed.length/2); // 2 bytes per character\n	        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n	          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n	        }\n	\n	        var result = [];\n	        buf.forEach(function (c) {\n	          result.push(f(c));\n	        });\n	        return LZString.decompress(result.join(''));\n	\n	    }\n	\n	  },\n	\n	\n	  //compress into a string that is already URI encoded\n	  compressToEncodedURIComponent: function (input) {\n	    if (input == null) return \"\";\n	    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n	  },\n	\n	  //decompress from an output of compressToEncodedURIComponent\n	  decompressFromEncodedURIComponent:function (input) {\n	    if (input == null) return \"\";\n	    if (input == \"\") return null;\n	    input = input.replace(/ /g, \"+\");\n	    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n	  },\n	\n	  compress: function (uncompressed) {\n	    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n	  },\n	  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n	    if (uncompressed == null) return \"\";\n	    var i, value,\n	        context_dictionary= {},\n	        context_dictionaryToCreate= {},\n	        context_c=\"\",\n	        context_wc=\"\",\n	        context_w=\"\",\n	        context_enlargeIn= 2, // Compensate for the first entry which should not count\n	        context_dictSize= 3,\n	        context_numBits= 2,\n	        context_data=[],\n	        context_data_val=0,\n	        context_data_position=0,\n	        ii;\n	\n	    for (ii = 0; ii < uncompressed.length; ii += 1) {\n	      context_c = uncompressed.charAt(ii);\n	      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n	        context_dictionary[context_c] = context_dictSize++;\n	        context_dictionaryToCreate[context_c] = true;\n	      }\n	\n	      context_wc = context_w + context_c;\n	      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n	        context_w = context_wc;\n	      } else {\n	        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n	          if (context_w.charCodeAt(0)<256) {\n	            for (i=0 ; i<context_numBits ; i++) {\n	              context_data_val = (context_data_val << 1);\n	              if (context_data_position == bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	            }\n	            value = context_w.charCodeAt(0);\n	            for (i=0 ; i<8 ; i++) {\n	              context_data_val = (context_data_val << 1) | (value&1);\n	              if (context_data_position == bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	              value = value >> 1;\n	            }\n	          } else {\n	            value = 1;\n	            for (i=0 ; i<context_numBits ; i++) {\n	              context_data_val = (context_data_val << 1) | value;\n	              if (context_data_position ==bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	              value = 0;\n	            }\n	            value = context_w.charCodeAt(0);\n	            for (i=0 ; i<16 ; i++) {\n	              context_data_val = (context_data_val << 1) | (value&1);\n	              if (context_data_position == bitsPerChar-1) {\n	                context_data_position = 0;\n	                context_data.push(getCharFromInt(context_data_val));\n	                context_data_val = 0;\n	              } else {\n	                context_data_position++;\n	              }\n	              value = value >> 1;\n	            }\n	          }\n	          context_enlargeIn--;\n	          if (context_enlargeIn == 0) {\n	            context_enlargeIn = Math.pow(2, context_numBits);\n	            context_numBits++;\n	          }\n	          delete context_dictionaryToCreate[context_w];\n	        } else {\n	          value = context_dictionary[context_w];\n	          for (i=0 ; i<context_numBits ; i++) {\n	            context_data_val = (context_data_val << 1) | (value&1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = value >> 1;\n	          }\n	\n	\n	        }\n	        context_enlargeIn--;\n	        if (context_enlargeIn == 0) {\n	          context_enlargeIn = Math.pow(2, context_numBits);\n	          context_numBits++;\n	        }\n	        // Add wc to the dictionary.\n	        context_dictionary[context_wc] = context_dictSize++;\n	        context_w = String(context_c);\n	      }\n	    }\n	\n	    // Output the code for w.\n	    if (context_w !== \"\") {\n	      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n	        if (context_w.charCodeAt(0)<256) {\n	          for (i=0 ; i<context_numBits ; i++) {\n	            context_data_val = (context_data_val << 1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	          }\n	          value = context_w.charCodeAt(0);\n	          for (i=0 ; i<8 ; i++) {\n	            context_data_val = (context_data_val << 1) | (value&1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = value >> 1;\n	          }\n	        } else {\n	          value = 1;\n	          for (i=0 ; i<context_numBits ; i++) {\n	            context_data_val = (context_data_val << 1) | value;\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = 0;\n	          }\n	          value = context_w.charCodeAt(0);\n	          for (i=0 ; i<16 ; i++) {\n	            context_data_val = (context_data_val << 1) | (value&1);\n	            if (context_data_position == bitsPerChar-1) {\n	              context_data_position = 0;\n	              context_data.push(getCharFromInt(context_data_val));\n	              context_data_val = 0;\n	            } else {\n	              context_data_position++;\n	            }\n	            value = value >> 1;\n	          }\n	        }\n	        context_enlargeIn--;\n	        if (context_enlargeIn == 0) {\n	          context_enlargeIn = Math.pow(2, context_numBits);\n	          context_numBits++;\n	        }\n	        delete context_dictionaryToCreate[context_w];\n	      } else {\n	        value = context_dictionary[context_w];\n	        for (i=0 ; i<context_numBits ; i++) {\n	          context_data_val = (context_data_val << 1) | (value&1);\n	          if (context_data_position == bitsPerChar-1) {\n	            context_data_position = 0;\n	            context_data.push(getCharFromInt(context_data_val));\n	            context_data_val = 0;\n	          } else {\n	            context_data_position++;\n	          }\n	          value = value >> 1;\n	        }\n	\n	\n	      }\n	      context_enlargeIn--;\n	      if (context_enlargeIn == 0) {\n	        context_enlargeIn = Math.pow(2, context_numBits);\n	        context_numBits++;\n	      }\n	    }\n	\n	    // Mark the end of the stream\n	    value = 2;\n	    for (i=0 ; i<context_numBits ; i++) {\n	      context_data_val = (context_data_val << 1) | (value&1);\n	      if (context_data_position == bitsPerChar-1) {\n	        context_data_position = 0;\n	        context_data.push(getCharFromInt(context_data_val));\n	        context_data_val = 0;\n	      } else {\n	        context_data_position++;\n	      }\n	      value = value >> 1;\n	    }\n	\n	    // Flush the last char\n	    while (true) {\n	      context_data_val = (context_data_val << 1);\n	      if (context_data_position == bitsPerChar-1) {\n	        context_data.push(getCharFromInt(context_data_val));\n	        break;\n	      }\n	      else context_data_position++;\n	    }\n	    return context_data.join('');\n	  },\n	\n	  decompress: function (compressed) {\n	    if (compressed == null) return \"\";\n	    if (compressed == \"\") return null;\n	    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n	  },\n	\n	  _decompress: function (length, resetValue, getNextValue) {\n	    var dictionary = [],\n	        next,\n	        enlargeIn = 4,\n	        dictSize = 4,\n	        numBits = 3,\n	        entry = \"\",\n	        result = [],\n	        i,\n	        w,\n	        bits, resb, maxpower, power,\n	        c,\n	        data = {val:getNextValue(0), position:resetValue, index:1};\n	\n	    for (i = 0; i < 3; i += 1) {\n	      dictionary[i] = i;\n	    }\n	\n	    bits = 0;\n	    maxpower = Math.pow(2,2);\n	    power=1;\n	    while (power!=maxpower) {\n	      resb = data.val & data.position;\n	      data.position >>= 1;\n	      if (data.position == 0) {\n	        data.position = resetValue;\n	        data.val = getNextValue(data.index++);\n	      }\n	      bits |= (resb>0 ? 1 : 0) * power;\n	      power <<= 1;\n	    }\n	\n	    switch (next = bits) {\n	      case 0:\n	          bits = 0;\n	          maxpower = Math.pow(2,8);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	        c = f(bits);\n	        break;\n	      case 1:\n	          bits = 0;\n	          maxpower = Math.pow(2,16);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	        c = f(bits);\n	        break;\n	      case 2:\n	        return \"\";\n	    }\n	    dictionary[3] = c;\n	    w = c;\n	    result.push(c);\n	    while (true) {\n	      if (data.index > length) {\n	        return \"\";\n	      }\n	\n	      bits = 0;\n	      maxpower = Math.pow(2,numBits);\n	      power=1;\n	      while (power!=maxpower) {\n	        resb = data.val & data.position;\n	        data.position >>= 1;\n	        if (data.position == 0) {\n	          data.position = resetValue;\n	          data.val = getNextValue(data.index++);\n	        }\n	        bits |= (resb>0 ? 1 : 0) * power;\n	        power <<= 1;\n	      }\n	\n	      switch (c = bits) {\n	        case 0:\n	          bits = 0;\n	          maxpower = Math.pow(2,8);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	\n	          dictionary[dictSize++] = f(bits);\n	          c = dictSize-1;\n	          enlargeIn--;\n	          break;\n	        case 1:\n	          bits = 0;\n	          maxpower = Math.pow(2,16);\n	          power=1;\n	          while (power!=maxpower) {\n	            resb = data.val & data.position;\n	            data.position >>= 1;\n	            if (data.position == 0) {\n	              data.position = resetValue;\n	              data.val = getNextValue(data.index++);\n	            }\n	            bits |= (resb>0 ? 1 : 0) * power;\n	            power <<= 1;\n	          }\n	          dictionary[dictSize++] = f(bits);\n	          c = dictSize-1;\n	          enlargeIn--;\n	          break;\n	        case 2:\n	          return result.join('');\n	      }\n	\n	      if (enlargeIn == 0) {\n	        enlargeIn = Math.pow(2, numBits);\n	        numBits++;\n	      }\n	\n	      if (dictionary[c]) {\n	        entry = dictionary[c];\n	      } else {\n	        if (c === dictSize) {\n	          entry = w + w.charAt(0);\n	        } else {\n	          return null;\n	        }\n	      }\n	      result.push(entry);\n	\n	      // Add w+entry[0] to the dictionary.\n	      dictionary[dictSize++] = w + entry.charAt(0);\n	      enlargeIn--;\n	\n	      w = entry;\n	\n	      if (enlargeIn == 0) {\n	        enlargeIn = Math.pow(2, numBits);\n	        numBits++;\n	      }\n	\n	    }\n	  }\n	};\n	  return LZString;\n	})();\n	\n	if (true) {\n	  !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return LZString; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	} else if( typeof module !== 'undefined' && module != null ) {\n	  module.exports = LZString\n	}\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	var contactSearchService = function () {\n	    var searchProviders = [];\n	    var queryCompletedHandlers = [];\n	\n	    function createResult(item) {\n	        return {\n	            name: item.name,\n	            value: item.value,\n	            type: item.type,\n	            id: item.id\n	        };\n	    }\n	    return {\n	        query: function query(searchFunctions, filter) {\n	            return Promise.all(searchFunctions).then(function (results) {\n	                var searchResultsKeys = {};\n	                var searchResults = [];\n	                results.forEach(function (result) {\n	                    result.forEach(function (item) {\n	                        if (filter) {\n	                            if (filter(item)) {\n	                                var key = item.name + item.value;\n	                                if (!searchResultsKeys[key]) {\n	                                    var toAddItem = createResult(item);\n	                                    searchResultsKeys[key] = toAddItem;\n	                                    searchResults.push(toAddItem);\n	                                }\n	                            }\n	                        } else {\n	                            var key = item.name + item.value;\n	                            if (!searchResultsKeys[key]) {\n	                                var toAddItem = createResult(item);\n	                                searchResultsKeys[key] = toAddItem;\n	                                searchResults.push(toAddItem);\n	                            }\n	                        }\n	                    });\n	                });\n	                return searchResults;\n	            });\n	        }\n	    };\n	}();\n	exports.default = contactSearchService;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcContactService = __webpack_require__(55);\n	\n	var _rcContactService2 = _interopRequireDefault(_rcContactService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcContactSearchProvider = function () {\n	    return {\n	        search: function search(text) {\n	            var results = [];\n	            if (text) {\n	                text = text.toLowerCase();\n	                _rcContactService2.default.companyContacts.map(function (contact) {\n	                    if (contact.displayName && contact.displayName.toLowerCase().indexOf(text) >= 0) {\n	                        results.push({\n	                            name: contact.displayName,\n	                            value: contact.extension,\n	                            type: 'rc',\n	                            id: contact.id\n	                        });\n	                        contact.phoneNumber.forEach(function (phone) {\n	                            results.push({\n	                                name: contact.displayName,\n	                                value: phone,\n	                                type: 'rc',\n	                                id: contact.id\n	                            });\n	                        });\n	                    } else {\n	                        if (contact.extension && contact.extension.indexOf(text) >= 0) {\n	                            results.push({\n	                                name: contact.displayName,\n	                                value: contact.extension,\n	                                type: 'rc',\n	                                id: contact.id\n	                            });\n	                        }\n	\n	                        contact.phoneNumber.forEach(function (phone) {\n	                            if (phone.indexOf(text) >= 0) {\n	                                results.push({\n	                                    name: contact.displayName,\n	                                    value: phone,\n	                                    type: 'rc',\n	                                    id: contact.id\n	                                });\n	                            }\n	                        });\n	                    }\n	                });\n	            }\n	\n	            return results;\n	        },\n	        searchAll: function searchAll() {\n	            return _rcContactService2.default.completeCompanyContact().then(function (companyContacts) {\n	                return companyContacts.map(function (contact) {\n	                    return {\n	                        name: contact.displayName,\n	                        type: 'rc',\n	                        id: contact.id\n	                    };\n	                });\n	            }).catch(function (e) {\n	                return console.error(e);\n	            });\n	        }\n	    };\n	}();\n	\n	exports.default = rcContactSearchProvider;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var _rcSubscriptionService = __webpack_require__(53);\n	\n	var _rcSubscriptionService2 = _interopRequireDefault(_rcSubscriptionService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcMessageService = function () {\n	    var messages = {};\n	    var fetchingPromise = null;\n	    var syncToken = null;\n	    var messageUpdateHandlers = [];\n	\n	    function fullSyncMessages(hour) {\n	        return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n	            dateFrom: new Date(Date.now() - hour * 3600 * 1000).toISOString(),\n	            syncType: 'FSync'\n	        }).then(function (responses) {\n	            var jsonResponse = responses.json();\n	            syncToken = jsonResponse.syncInfo.syncToken;\n	            var results = jsonResponse.records;\n	            addMessageToList(results);\n	            fetchingPromise = null;\n	            return results;\n	        });\n	    }\n	\n	    function incrementalSyncMessages() {\n	        if (syncToken) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-sync', {\n	                syncType: 'ISync',\n	                syncToken: syncToken\n	            }).then(function (responses) {\n	                var jsonResponse = responses.json();\n	                var results = jsonResponse.records;\n	                syncToken = jsonResponse.syncInfo.syncToken;\n	                updateMessageList(results);\n	                messageUpdateHandlers.forEach(function (h) {\n	                    return h(results);\n	                });\n	            });\n	        }\n	    }\n	\n	    function concatMessages() {\n	        var results = [];\n	        for (var key in messages) {\n	            if (messages.hasOwnProperty(key)) {\n	                results = results.concat(messages[key]);\n	            }\n	        }\n	        return results;\n	    }\n	\n	    function addMessageToList(results) {\n	        results.forEach(function (message) {\n	            if (!messages[message.type]) {\n	                messages[message.type] = [];\n	            }\n	            messages[message.type].push(message);\n	        });\n	    }\n	\n	    function updateMessageList(results) {\n	        results.forEach(function (message) {\n	            var messageList = messages[message.type];\n	            if (!messageList) {\n	                if (message.availability === 'Alive') {\n	                    messages[message.type] = [];\n	                    messages[message.type].splice(0, 0, message);\n	                }\n	            } else {\n	                var index = 0;\n	                for (; index < messageList.length; index++) {\n	                    if (messageList[index].id === message.id) {\n	                        if (message.availability === 'Alive') {\n	                            messageList[index] = message;\n	                        } else {\n	                            messageList.splice(index, 1);\n	                        }\n	                        break;\n	                    }\n	                }\n	                if (index === messageList.length) {\n	                    if (message.availability === 'Alive') {\n	                        messageList.splice(0, 0, message);\n	                    }\n	                }\n	            }\n	        });\n	    }\n	\n	    return {\n	        syncMessages: function syncMessages(hour) {\n	            fetchingPromise = fullSyncMessages(hour);\n	            return fetchingPromise;\n	        },\n	        getMessagesByType: function getMessagesByType(type) {\n	            if (!fetchingPromise) {\n	                if (messages[type]) {\n	                    return messages[type];\n	                } else {\n	                    return [];\n	                }\n	            } else {\n	                return fetchingPromise.then(function () {\n	                    return messages[type];\n	                });\n	            }\n	        },\n	        getAllMessages: function getAllMessages() {\n	            return !fetchingPromise ? concatMessages() : fetchingPromise.then(concatMessages);\n	        },\n	        subscribeToMessageUpdate: function subscribeToMessageUpdate() {\n	            _rcSubscriptionService2.default.subscribe('message-store', '/restapi/v1.0/account/~/extension/~/message-store', incrementalSyncMessages);\n	        },\n	        onMessageUpdated: function onMessageUpdated(handler) {\n	            if (handler) {\n	                messageUpdateHandlers.push(handler);\n	            }\n	        },\n	        sendSMSMessage: function sendSMSMessage(text, fromNumber, toNumber) {\n	            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/sms/', {\n	                from: { phoneNumber: fromNumber },\n	                to: [{ phoneNumber: toNumber }],\n	                text: text\n	            }).then(function (response) {\n	                return response.json();\n	            });\n	        },\n	        sendPagerMessage: function sendPagerMessage(text, fromNumber, toNumber) {\n	            console.log(fromNumber);\n	            return _rcSdk.RC.sdk.platform().post('/account/~/extension/~/company-pager/', {\n	                from: { extensionNumber: fromNumber },\n	                to: [{ extensionNumber: toNumber }],\n	                text: text\n	            }).then(function (response) {\n	                return response.json();\n	            });\n	        },\n	        getConversation: function getConversation(conversationId, hourFrom, hourTo) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n	                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n	                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n	                conversationId: conversationId\n	            }).then(function (response) {\n	                return response.json();\n	            }).then(function (data) {\n	                return data.records;\n	            }).then(function (records) {\n	                return records.reverse();\n	            });\n	        },\n	        getMessagesByNumber: function getMessagesByNumber(phoneNumber, hourFrom, hourTo) {\n	            return _rcSdk.RC.sdk.platform().get('/account/~/extension/~/message-store', {\n	                dateFrom: new Date(Date.now() - hourFrom * 3600 * 1000).toISOString(),\n	                dateTo: new Date(Date.now() - (hourTo || 0) * 3600 * 1000).toISOString(),\n	                phoneNumber: phoneNumber\n	            }).then(function (response) {\n	                return response.json();\n	            }).then(function (data) {\n	                return data.records;\n	            }).then(function (records) {\n	                return records.reverse();\n	            });\n	        }\n	    };\n	}();\n	\n	exports.default = rcMessageService;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcMessageService = __webpack_require__(59);\n	\n	var _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	var rcMessageProvider = function () {\n	    var messageUpdatedHandlers = [];\n	    var conversations = {};\n	    var cachedHour = 0;\n	\n	    _rcMessageService2.default.onMessageUpdated(function (results) {\n	        messageUpdatedHandlers.forEach(function (h) {\n	            try {\n	                h(results.slice());\n	            } catch (e) {\n	                console.error(e);\n	            }\n	        });\n	    });\n	\n	    function createResult(message) {\n	        return {\n	            id: message.id,\n	            time: message.lastModifiedTime,\n	            readStatus: message.readStatus,\n	            type: getType(message),\n	            contact: getNumber(message.type, getDirection(message, 'Outbound')),\n	            subject: message.subject || null,\n	            convId: message.conversation ? message.conversation.id : null,\n	            author: getNumber(message, getDirection(message, 'Inbound'))\n	        };\n	\n	        function getDirection(message, dir) {\n	            return message.direction === dir ? message.to[0] : message.from;\n	        }\n	\n	        function getNumber(message, info) {\n	            return message.type === 'Pager' ? info.extensionNumber : info.phoneNumber;\n	        }\n	\n	        function getType(message) {\n	            return message.type === 'Fax' || message.type === 'VoiceMail' ? 'Text' : message.type;\n	        }\n	    }\n	\n	    return {\n	        getTextMessages: function getTextMessages() {\n	            return Promise.resolve(_rcMessageService2.default.getMessagesByType('SMS')).then(function (messages) {\n	                var results = [];\n	                messages.forEach(function (message) {\n	                    results.push(createResult(message));\n	                });\n	                return results;\n	            });\n	        },\n	\n	        getLastMessagesOfAllType: function getLastMessagesOfAllType() {\n	            var results = [];\n	            return this.getMessagesOfAllType().then(function (msgs) {\n	                for (var key in msgs) {\n	                    if (msgs.hasOwnProperty(key)) {\n	                        if (key === 'anonymous') results = results.concat(msgs.anonymous[0]);else results.push(msgs[key][0]);\n	                    }\n	                }\n	                return results;\n	            });\n	        },\n	        // Return all messages of type 'VoiceMail' and 'Fax'. For SMS and Pager, only last message in a conversation\n	        // will be returned.\n	        getMessagesOfAllType: function getMessagesOfAllType() {\n	            return Promise.resolve(_rcMessageService2.default.getAllMessages()).then(function (messages) {\n	                var results = [];\n	                var target = {};\n	                messages.forEach(function (message) {\n	                    var result = createResult(message);\n	                    //Combine SMS/Pager messages in conversation\n	                    if (message.conversation && message.conversation.id) {\n	                        target[message.conversation.id] = target[message.conversation.id] || [];\n	                        target[message.conversation.id].push(result);\n	                        conversations[message.conversation.id] = conversations[message.conversation.id] || [];\n	                        conversations[message.conversation.id].push(message);\n	                    } else {\n	                        target['anonymous'] = target['anonymous'] || [];\n	                        target['anonymous'].push(result);\n	                    }\n	                });\n	                return target;\n	            });\n	        },\n	\n	        getConversation: function getConversation(convId, hourFrom) {\n	            if (conversations[convId] && (!hourFrom || hourFrom < cachedHour)) {\n	                return Promise.resolve(conversations[convId].reverse());\n	            } else {\n	                return _rcMessageService2.default.getConversation(convId, hourFrom, cachedHour).then(function (result) {\n	                    cachedHour = hourFrom;\n	                    return result;\n	                });\n	            }\n	        },\n	\n	        onMessageUpdated: function onMessageUpdated(handler) {\n	            messageUpdatedHandlers.push(handler);\n	        }\n	    };\n	}();\n	exports.default = rcMessageProvider;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _rcSdk = __webpack_require__(4);\n	\n	var rcConferenceSerivce = function () {\n	    var fetchingConferenceInfo = null;\n	\n	    function fetchConferenceInfo() {\n	        fetchingConferenceInfo = _rcSdk.RC.sdk.platform().get('/account/~/extension/~/conferencing').then(function (responses) {\n	            var jsonResponse = responses.json();\n	            var conferenceInfo = {};\n	            conferenceInfo.hostCode = jsonResponse.hostCode;\n	            conferenceInfo.phoneNumber = jsonResponse.phoneNumber;\n	            conferenceInfo.participantCode = jsonResponse.participantCode;\n	            fetchingConferenceInfo = null;\n	            return conferenceInfo;\n	        });\n	        return fetchingConferenceInfo;\n	    }\n	\n	    return {\n	        getConferenceInfo: function getConferenceInfo() {\n	            if (fetchingConferenceInfo) {\n	                return fetchingConferenceInfo;\n	            } else {\n	                return fetchConferenceInfo();\n	            }\n	        }\n	    };\n	}();\n	\n	exports.default = rcConferenceSerivce;\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _callLogService = __webpack_require__(52);\n	\n	var _callLogService2 = _interopRequireDefault(_callLogService);\n	\n	var _rcMessageService = __webpack_require__(59);\n	\n	var _rcMessageService2 = _interopRequireDefault(_rcMessageService);\n	\n	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n	\n	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n	\n	var conversationService = function () {\n	    var cachedHour = 24 * 7;\n	    function groupMessageToContact(msgs, contacts) {\n	        var relatedContacts = contacts.filter(function (contact) {\n	            var knownContactsIndex = [];\n	            var contactNums = contact.phoneNumber.concat(contact.extension);\n	            var contactMsgs = msgs.filter(function (msg, index) {\n	                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	                var contain = contactNums.indexOf(msgNumber) > -1;\n	                contact.msg = contact.msg || [];\n	                var alreadyExist = contact.msg.find(function (contactMsg) {\n	                    return contactMsg.id == msg.id;\n	                });\n	                if (contain && !alreadyExist) {\n	\n	                    contact.msg.push(msg);\n	                    knownContactsIndex.push(index);\n	                }\n	                return contain;\n	            });\n	            knownContactsIndex.reverse().forEach(function (index) {\n	                return msgs.splice(index, 1);\n	            });\n	            return contactMsgs.length > 0;\n	        });\n	        msgs.forEach(function (msg) {\n	            var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	            var contact = relatedContacts.filter(function (contact) {\n	                return contact.id === msgNumber;\n	            })[0];\n	            if (contact) {\n	                contact.msg.push(msg);\n	            } else {\n	                relatedContacts.push(fakeContact(msg));\n	            }\n	        });\n	        return relatedContacts;\n	    }\n	\n	    function groupContactToMessage(msgs, contacts) {\n	        return msgs.map(function (msg) {\n	            var unknownContact = true;\n	            contacts.forEach(function (contact) {\n	                var contactNums = contact.phoneNumber.concat(contact.extension);\n	                var msgNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	                var contain = contactNums.indexOf(msgNumber) > -1;\n	                if (contain) {\n	                    msg.contact = contact;\n	                    unknownContact = false;\n	                }\n	            });\n	            // if (unknownContact) {\n	            //     console.log(msg);\n	            //     var fake = fakeContact(msg)\n	            //     msg.contact = fake\n	            //     contacts.push(fake)\n	            // }\n	            return msg;\n	        });\n	    }\n	\n	    function combineAdjacentMessage(contents) {\n	        // group related SMS message\n	        var savedContent;\n	        var result = [];\n	        for (var i = contents.length - 1; i > 0; --i) {\n	            var content = contents[i];\n	            // if (content.type !== 'SMS') {\n	            //     if (savedContent) {\n	            //         result.push(savedContent)\n	            //         savedContent = null\n	            //     }\n	            //     result.push(content)\n	            //     continue\n	            // }\n	            if (savedContent && savedContent.type === content.type && savedContent.contact.id === content.contact.id) {\n	                savedContent.others.push(content);\n	            } else {\n	                savedContent && result.push(savedContent);\n	                content.others = [];\n	                savedContent = content;\n	            }\n	        }\n	        savedContent && result.push(savedContent);\n	        return result;\n	    }\n	\n	    function combine() {\n	        for (var _len = arguments.length, targets = Array(_len), _key = 0; _key < _len; _key++) {\n	            targets[_key] = arguments[_key];\n	        }\n	\n	        return targets.reduce(function (result, target) {\n	            return result.concat(target);\n	        }, []);\n	    }\n	\n	    function sortTime(target) {\n	        return target.slice().sort(function (a, b) {\n	            return Date.parse(a.time) - Date.parse(b.time);\n	        });\n	    }\n	    function containSameVal(array1, array2) {\n	        return array1.filter(function (n) {\n	            return array2.indexOf(n) != -1;\n	        }).length > 0;\n	    }\n	    function uniqueArray(target) {\n	        var seen = {};\n	        return target.filter(function (item) {\n	            return seen.hasOwnProperty(item) ? false : seen[item] = true;\n	        });\n	    }\n	\n	    function fakeContact(msg) {\n	        var phoneNumber = msg.direction === 'Inbound' ? msg.from : msg.to;\n	        return {\n	            displayName: phoneNumber,\n	            id: phoneNumber,\n	            phoneNumber: [phoneNumber],\n	            extension: null,\n	            msg: [msg]\n	        };\n	    }\n	\n	    function adaptMessage(msg) {\n	        return {\n	            id: msg.id,\n	            from: !msg.from && 'anonymous' || // For fax\n	            msg.from.extensionNumber || msg.from.phoneNumber,\n	            to: msg.to.phoneNumber || msg.to.extensionNumber || msg.to[0].extensionNumber || msg.to[0].phoneNumber,\n	            direction: msg.direction,\n	            type: msg.type,\n	            time: msg.creationTime || msg.startTime,\n	            lastModifiedTime: msg.lastModifiedTime || msg.startTime,\n	            subject: msg.recording || msg.subject || msg.action || msg.attachments[0],\n	            status: {\n	                sendConfirmed: false,\n	                receiveConfirmed: false\n	            }\n	        };\n	    }\n	    function getMessagesByNumber(contact, offset) {\n	        return Promise.all(contact.phoneNumber.map(function (number) {\n	            return _rcMessageService2.default.getMessagesByNumber(\n	            // FIXME\n	            number, cachedHour + offset, cachedHour);\n	        })).then(function (result) {\n	            return combine.apply(undefined, _toConsumableArray(result));\n	        });\n	    }\n	    function getCallLogsByNumber(contact, offset) {\n	        return Promise.all(contact.phoneNumber.map(function (number) {\n	            return _callLogService2.default.getCallLogsByNumber(number, cachedHour + offset, cachedHour);\n	        })).then(function (result) {\n	            return combine.apply(undefined, _toConsumableArray(result));\n	        });\n	    }\n	    function uniqId(target) {\n	        var seen = {};\n	        return target.filter(function (item) {\n	            return seen.hasOwnProperty(item.id) ? false : seen[item.id] = true;\n	        });\n	    }\n	    function combineContent() {\n	        for (var _len2 = arguments.length, sources = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n	            sources[_key2] = arguments[_key2];\n	        }\n	\n	        return sortTime(combine.apply(undefined, _toConsumableArray(sources.map(function (source) {\n	            return source.map(adaptMessage);\n	        }))));\n	    }\n	    return {\n	        get cachedHour() {\n	            return cachedHour;\n	        },\n	        syncContent: function syncContent(contacts) {\n	            for (var _len3 = arguments.length, sources = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n	                sources[_key3 - 1] = arguments[_key3];\n	            }\n	\n	            var contents = combineContent.apply(undefined, sources);\n	            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n	            contents = groupContactToMessage(contents, relatedContacts);\n	            return contents;\n	        },\n	        organizeContent: function organizeContent(contacts) {\n	            for (var _len4 = arguments.length, sources = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n	                sources[_key4 - 1] = arguments[_key4];\n	            }\n	\n	            var contents = combineContent.apply(undefined, sources);\n	            var relatedContacts = groupMessageToContact(contents.slice(), contacts);\n	            contents = groupContactToMessage(contents, relatedContacts);\n	            contents = combineAdjacentMessage(contents);\n	            return contents;\n	        },\n	        getConversations: function getConversations(contacts) {\n	            for (var _len5 = arguments.length, sources = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n	                sources[_key5 - 1] = arguments[_key5];\n	            }\n	\n	            var contents = combineContent.apply(undefined, sources);\n	            var relatedContacts = groupMessageToContact(contents, contacts).map(function (contact) {\n	                contact.syncHour = cachedHour;\n	                return contact;\n	            }).map(function (contact) {\n	                contact.phoneNumber = uniqueArray(contact.phoneNumber.concat(contact.extension));\n	                return contact;\n	            }).reduce(function (map, contact) {\n	                map[contact.id] = contact;\n	                return map;\n	            }, {});\n	            return relatedContacts;\n	        },\n	        loadContent: function loadContent(contact, offset) {\n	            return Promise.all([getCallLogsByNumber(contact, offset), getMessagesByNumber(contact, offset)]).then(function (result) {\n	                return combineContent.apply(undefined, _toConsumableArray(result));\n	            }).then(function (contents) {\n	                contact.msg = contents.concat(contact.msg);\n	                cachedHour += offset;\n	                return contents;\n	            });\n	        },\n	        onConversationUpdate: function onConversationUpdate(handler) {\n	            _rcMessageService2.default.onMessageUpdated(function (msgs) {\n	                try {\n	                    var msgs = sortTime(msgs.map(adaptMessage));\n	                    handler(msgs);\n	                } catch (e) {\n	                    console.error(e);\n	                    throw e;\n	                }\n	            });\n	        },\n	        adaptMessage: adaptMessage\n	    };\n	}();\n	\n	exports.default = conversationService;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n	var __WEBPACK_AMD_DEFINE_RESULT__;/*\n	 * JavaScript MD5\n	 * https://github.com/blueimp/JavaScript-MD5\n	 *\n	 * Copyright 2011, Sebastian Tschan\n	 * https://blueimp.net\n	 *\n	 * Licensed under the MIT license:\n	 * http://www.opensource.org/licenses/MIT\n	 *\n	 * Based on\n	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n	 * Digest Algorithm, as defined in RFC 1321.\n	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n	 * Distributed under the BSD License\n	 * See http://pajhome.org.uk/crypt/md5 for more info.\n	 */\n	\n	/*global unescape, define, module */\n	\n	;(function ($) {\n	  'use strict'\n	\n	  /*\n	  * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n	  * to work around bugs in some JS interpreters.\n	  */\n	  function safe_add (x, y) {\n	    var lsw = (x & 0xFFFF) + (y & 0xFFFF)\n	    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n	    return (msw << 16) | (lsw & 0xFFFF)\n	  }\n	\n	  /*\n	  * Bitwise rotate a 32-bit number to the left.\n	  */\n	  function bit_rol (num, cnt) {\n	    return (num << cnt) | (num >>> (32 - cnt))\n	  }\n	\n	  /*\n	  * These functions implement the four basic operations the algorithm uses.\n	  */\n	  function md5_cmn (q, a, b, x, s, t) {\n	    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)\n	  }\n	  function md5_ff (a, b, c, d, x, s, t) {\n	    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)\n	  }\n	  function md5_gg (a, b, c, d, x, s, t) {\n	    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)\n	  }\n	  function md5_hh (a, b, c, d, x, s, t) {\n	    return md5_cmn(b ^ c ^ d, a, b, x, s, t)\n	  }\n	  function md5_ii (a, b, c, d, x, s, t) {\n	    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)\n	  }\n	\n	  /*\n	  * Calculate the MD5 of an array of little-endian words, and a bit length.\n	  */\n	  function binl_md5 (x, len) {\n	    /* append padding */\n	    x[len >> 5] |= 0x80 << (len % 32)\n	    x[(((len + 64) >>> 9) << 4) + 14] = len\n	\n	    var i\n	    var olda\n	    var oldb\n	    var oldc\n	    var oldd\n	    var a = 1732584193\n	    var b = -271733879\n	    var c = -1732584194\n	    var d = 271733878\n	\n	    for (i = 0; i < x.length; i += 16) {\n	      olda = a\n	      oldb = b\n	      oldc = c\n	      oldd = d\n	\n	      a = md5_ff(a, b, c, d, x[i], 7, -680876936)\n	      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)\n	      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)\n	      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)\n	      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)\n	      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)\n	      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)\n	      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)\n	      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)\n	      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)\n	      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)\n	      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)\n	      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)\n	      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)\n	      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)\n	      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)\n	\n	      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)\n	      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)\n	      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)\n	      b = md5_gg(b, c, d, a, x[i], 20, -373897302)\n	      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)\n	      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)\n	      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)\n	      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)\n	      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)\n	      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)\n	      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)\n	      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)\n	      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)\n	      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)\n	      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)\n	      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)\n	\n	      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)\n	      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)\n	      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)\n	      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)\n	      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)\n	      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)\n	      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)\n	      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)\n	      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)\n	      d = md5_hh(d, a, b, c, x[i], 11, -358537222)\n	      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)\n	      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)\n	      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)\n	      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)\n	      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)\n	      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)\n	\n	      a = md5_ii(a, b, c, d, x[i], 6, -198630844)\n	      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)\n	      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)\n	      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)\n	      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)\n	      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)\n	      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)\n	      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)\n	      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)\n	      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)\n	      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)\n	      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)\n	      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)\n	      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)\n	      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)\n	      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)\n	\n	      a = safe_add(a, olda)\n	      b = safe_add(b, oldb)\n	      c = safe_add(c, oldc)\n	      d = safe_add(d, oldd)\n	    }\n	    return [a, b, c, d]\n	  }\n	\n	  /*\n	  * Convert an array of little-endian words to a string\n	  */\n	  function binl2rstr (input) {\n	    var i\n	    var output = ''\n	    for (i = 0; i < input.length * 32; i += 8) {\n	      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)\n	    }\n	    return output\n	  }\n	\n	  /*\n	  * Convert a raw string to an array of little-endian words\n	  * Characters >255 have their high-byte silently ignored.\n	  */\n	  function rstr2binl (input) {\n	    var i\n	    var output = []\n	    output[(input.length >> 2) - 1] = undefined\n	    for (i = 0; i < output.length; i += 1) {\n	      output[i] = 0\n	    }\n	    for (i = 0; i < input.length * 8; i += 8) {\n	      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)\n	    }\n	    return output\n	  }\n	\n	  /*\n	  * Calculate the MD5 of a raw string\n	  */\n	  function rstr_md5 (s) {\n	    return binl2rstr(binl_md5(rstr2binl(s), s.length * 8))\n	  }\n	\n	  /*\n	  * Calculate the HMAC-MD5, of a key and some data (raw strings)\n	  */\n	  function rstr_hmac_md5 (key, data) {\n	    var i\n	    var bkey = rstr2binl(key)\n	    var ipad = []\n	    var opad = []\n	    var hash\n	    ipad[15] = opad[15] = undefined\n	    if (bkey.length > 16) {\n	      bkey = binl_md5(bkey, key.length * 8)\n	    }\n	    for (i = 0; i < 16; i += 1) {\n	      ipad[i] = bkey[i] ^ 0x36363636\n	      opad[i] = bkey[i] ^ 0x5C5C5C5C\n	    }\n	    hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n	    return binl2rstr(binl_md5(opad.concat(hash), 512 + 128))\n	  }\n	\n	  /*\n	  * Convert a raw string to a hex string\n	  */\n	  function rstr2hex (input) {\n	    var hex_tab = '0123456789abcdef'\n	    var output = ''\n	    var x\n	    var i\n	    for (i = 0; i < input.length; i += 1) {\n	      x = input.charCodeAt(i)\n	      output += hex_tab.charAt((x >>> 4) & 0x0F) +\n	      hex_tab.charAt(x & 0x0F)\n	    }\n	    return output\n	  }\n	\n	  /*\n	  * Encode a string as utf-8\n	  */\n	  function str2rstr_utf8 (input) {\n	    return unescape(encodeURIComponent(input))\n	  }\n	\n	  /*\n	  * Take string arguments and return either raw or hex encoded strings\n	  */\n	  function raw_md5 (s) {\n	    return rstr_md5(str2rstr_utf8(s))\n	  }\n	  function hex_md5 (s) {\n	    return rstr2hex(raw_md5(s))\n	  }\n	  function raw_hmac_md5 (k, d) {\n	    return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))\n	  }\n	  function hex_hmac_md5 (k, d) {\n	    return rstr2hex(raw_hmac_md5(k, d))\n	  }\n	\n	  function md5 (string, key, raw) {\n	    if (!key) {\n	      if (!raw) {\n	        return hex_md5(string)\n	      }\n	      return raw_md5(string)\n	    }\n	    if (!raw) {\n	      return hex_hmac_md5(key, string)\n	    }\n	    return raw_hmac_md5(key, string)\n	  }\n	\n	  if (true) {\n	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n	      return md5\n	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n	  } else if (typeof module === 'object' && module.exports) {\n	    module.exports = md5\n	  } else {\n	    $.md5 = md5\n	  }\n	}(this))\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n	'use strict';\n	\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	\n	var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n	\n	/*!\n	 * EventEmitter v5.0.0 - git.io/ee\n	 * Unlicense - http://unlicense.org/\n	 * Oliver Caldwell - http://oli.me.uk/\n	 * @preserve\n	 */\n	\n	/**\n	 * Class for managing events.\n	 * Can be extended to provide event functionality in other classes.\n	 *\n	 * @class EventEmitter Manages event registering and emitting.\n	 */\n	function EventEmitter() {}\n	\n	// Shortcuts to improve speed and size\n	var proto = EventEmitter.prototype;\n	\n	/**\n	 * Finds the index of the listener for the event in its storage array.\n	 *\n	 * @param {Function[]} listeners Array of listeners to search through.\n	 * @param {Function} listener Method to look for.\n	 * @return {Number} Index of the specified listener, -1 if not found\n	 * @api private\n	 */\n	function indexOfListener(listeners, listener) {\n	    var i = listeners.length;\n	    while (i--) {\n	        if (listeners[i].listener === listener) {\n	            return i;\n	        }\n	    }\n	\n	    return -1;\n	}\n	\n	/**\n	 * Alias a method while keeping the context correct, to allow for overwriting of target method.\n	 *\n	 * @param {String} name The name of the target method.\n	 * @return {Function} The aliased method\n	 * @api private\n	 */\n	function alias(name) {\n	    return function aliasClosure() {\n	        return this[name].apply(this, arguments);\n	    };\n	}\n	\n	/**\n	 * Returns the listener array for the specified event.\n	 * Will initialise the event object and listener arrays if required.\n	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n	 * Each property in the object response is an array of listener functions.\n	 *\n	 * @param {String|RegExp} evt Name of the event to return the listeners from.\n	 * @return {Function[]|Object} All listener functions for the event.\n	 */\n	proto.getListeners = function getListeners(evt) {\n	    var events = this._getEvents();\n	    var response;\n	    var key;\n	\n	    // Return a concatenated array of all matching events if\n	    // the selector is a regular expression.\n	    if (evt instanceof RegExp) {\n	        response = {};\n	        for (key in events) {\n	            if (events.hasOwnProperty(key) && evt.test(key)) {\n	                response[key] = events[key];\n	            }\n	        }\n	    } else {\n	        response = events[evt] || (events[evt] = []);\n	    }\n	\n	    return response;\n	};\n	\n	/**\n	 * Takes a list of listener objects and flattens it into a list of listener functions.\n	 *\n	 * @param {Object[]} listeners Raw listener objects.\n	 * @return {Function[]} Just the listener functions.\n	 */\n	proto.flattenListeners = function flattenListeners(listeners) {\n	    var flatListeners = [];\n	    var i;\n	\n	    for (i = 0; i < listeners.length; i += 1) {\n	        flatListeners.push(listeners[i].listener);\n	    }\n	\n	    return flatListeners;\n	};\n	\n	/**\n	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n	 *\n	 * @param {String|RegExp} evt Name of the event to return the listeners from.\n	 * @return {Object} All listener functions for an event in an object.\n	 */\n	proto.getListenersAsObject = function getListenersAsObject(evt) {\n	    var listeners = this.getListeners(evt);\n	    var response;\n	\n	    if (listeners instanceof Array) {\n	        response = {};\n	        response[evt] = listeners;\n	    }\n	\n	    return response || listeners;\n	};\n	\n	/**\n	 * Adds a listener function to the specified event.\n	 * The listener will not be added if it is a duplicate.\n	 * If the listener returns true then it will be removed after it is called.\n	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to attach the listener to.\n	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.addListener = function addListener(evt, listener) {\n	    var listeners = this.getListenersAsObject(evt);\n	    var listenerIsWrapped = (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object';\n	    var key;\n	\n	    for (key in listeners) {\n	        if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n	            listeners[key].push(listenerIsWrapped ? listener : {\n	                listener: listener,\n	                once: false\n	            });\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of addListener\n	 */\n	proto.on = alias('addListener');\n	\n	/**\n	 * Semi-alias of addListener. It will add a listener that will be\n	 * automatically removed after its first execution.\n	 *\n	 * @param {String|RegExp} evt Name of the event to attach the listener to.\n	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.addOnceListener = function addOnceListener(evt, listener) {\n	    return this.addListener(evt, {\n	        listener: listener,\n	        once: true\n	    });\n	};\n	\n	/**\n	 * Alias of addOnceListener.\n	 */\n	proto.once = alias('addOnceListener');\n	\n	/**\n	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n	 * You need to tell it what event names should be matched by a regex.\n	 *\n	 * @param {String} evt Name of the event to create.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.defineEvent = function defineEvent(evt) {\n	    this.getListeners(evt);\n	    return this;\n	};\n	\n	/**\n	 * Uses defineEvent to define multiple events.\n	 *\n	 * @param {String[]} evts An array of event names to define.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.defineEvents = function defineEvents(evts) {\n	    for (var i = 0; i < evts.length; i += 1) {\n	        this.defineEvent(evts[i]);\n	    }\n	    return this;\n	};\n	\n	/**\n	 * Removes a listener function from the specified event.\n	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to remove the listener from.\n	 * @param {Function} listener Method to remove from the event.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.removeListener = function removeListener(evt, listener) {\n	    var listeners = this.getListenersAsObject(evt);\n	    var index;\n	    var key;\n	\n	    for (key in listeners) {\n	        if (listeners.hasOwnProperty(key)) {\n	            index = indexOfListener(listeners[key], listener);\n	\n	            if (index !== -1) {\n	                listeners[key].splice(index, 1);\n	            }\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of removeListener\n	 */\n	proto.off = alias('removeListener');\n	\n	/**\n	 * Adds listeners in bulk using the manipulateListeners method.\n	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n	 * You can also pass it a regular expression to add the array of listeners to all events that match it.\n	 * Yeah, this function does quite a bit. That's probably a bad thing.\n	 *\n	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n	 * @param {Function[]} [listeners] An optional array of listener functions to add.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.addListeners = function addListeners(evt, listeners) {\n	    // Pass through to manipulateListeners\n	    return this.manipulateListeners(false, evt, listeners);\n	};\n	\n	/**\n	 * Removes listeners in bulk using the manipulateListeners method.\n	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n	 * You can also pass it an event name and an array of listeners to be removed.\n	 * You can also pass it a regular expression to remove the listeners from all events that match it.\n	 *\n	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n	 * @param {Function[]} [listeners] An optional array of listener functions to remove.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.removeListeners = function removeListeners(evt, listeners) {\n	    // Pass through to manipulateListeners\n	    return this.manipulateListeners(true, evt, listeners);\n	};\n	\n	/**\n	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n	 * The first argument will determine if the listeners are removed (true) or added (false).\n	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n	 * You can also pass it an event name and an array of listeners to be added/removed.\n	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n	 *\n	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n	    var i;\n	    var value;\n	    var single = remove ? this.removeListener : this.addListener;\n	    var multiple = remove ? this.removeListeners : this.addListeners;\n	\n	    // If evt is an object then pass each of its properties to this method\n	    if ((typeof evt === 'undefined' ? 'undefined' : _typeof(evt)) === 'object' && !(evt instanceof RegExp)) {\n	        for (i in evt) {\n	            if (evt.hasOwnProperty(i) && (value = evt[i])) {\n	                // Pass the single listener straight through to the singular method\n	                if (typeof value === 'function') {\n	                    single.call(this, i, value);\n	                } else {\n	                    // Otherwise pass back to the multiple function\n	                    multiple.call(this, i, value);\n	                }\n	            }\n	        }\n	    } else {\n	        // So evt must be a string\n	        // And listeners must be an array of listeners\n	        // Loop over it and pass each one to the multiple method\n	        i = listeners.length;\n	        while (i--) {\n	            single.call(this, evt, listeners[i]);\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Removes all listeners from a specified event.\n	 * If you do not specify an event then all listeners will be removed.\n	 * That means every event will be emptied.\n	 * You can also pass a regex to remove all events that match it.\n	 *\n	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.removeEvent = function removeEvent(evt) {\n	    var type = typeof evt === 'undefined' ? 'undefined' : _typeof(evt);\n	    var events = this._getEvents();\n	    var key;\n	\n	    // Remove different things depending on the state of evt\n	    if (type === 'string') {\n	        // Remove all listeners for the specified event\n	        delete events[evt];\n	    } else if (evt instanceof RegExp) {\n	        // Remove all events matching the regex.\n	        for (key in events) {\n	            if (events.hasOwnProperty(key) && evt.test(key)) {\n	                delete events[key];\n	            }\n	        }\n	    } else {\n	        // Remove all listeners in all events\n	        delete this._events;\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of removeEvent.\n	 *\n	 * Added to mirror the node API.\n	 */\n	proto.removeAllListeners = alias('removeEvent');\n	\n	/**\n	 * Emits an event of your choice.\n	 * When emitted, every listener attached to that event will be executed.\n	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n	 * So they will not arrive within the array on the other side, they will be separate.\n	 * You can also pass a regular expression to emit to all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n	 * @param {Array} [args] Optional array of arguments to be passed to each listener.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.emitEvent = function emitEvent(evt, args) {\n	    var listenersMap = this.getListenersAsObject(evt);\n	    var listeners;\n	    var listener;\n	    var i;\n	    var key;\n	    var response;\n	\n	    for (key in listenersMap) {\n	        if (listenersMap.hasOwnProperty(key)) {\n	            listeners = listenersMap[key].slice(0);\n	\n	            for (i = 0; i < listeners.length; i++) {\n	                // If the listener returns true then it shall be removed from the event\n	                // The function is executed either with a basic call or an apply if there is an args array\n	                listener = listeners[i];\n	\n	                if (listener.once === true) {\n	                    this.removeListener(evt, listener.listener);\n	                }\n	\n	                response = listener.listener.apply(this, args || []);\n	\n	                if (response === this._getOnceReturnValue()) {\n	                    this.removeListener(evt, listener.listener);\n	                }\n	            }\n	        }\n	    }\n	\n	    return this;\n	};\n	\n	/**\n	 * Alias of emitEvent\n	 */\n	proto.trigger = alias('emitEvent');\n	\n	/**\n	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n	 *\n	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n	 * @param {...*} Optional additional arguments to be passed to each listener.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.emit = function emit(evt) {\n	    var args = Array.prototype.slice.call(arguments, 1);\n	    return this.emitEvent(evt, args);\n	};\n	\n	/**\n	 * Sets the current value to check against when executing listeners. If a\n	 * listeners return value matches the one set here then it will be removed\n	 * after execution. This value defaults to true.\n	 *\n	 * @param {*} value The new value to check for when executing listeners.\n	 * @return {Object} Current instance of EventEmitter for chaining.\n	 */\n	proto.setOnceReturnValue = function setOnceReturnValue(value) {\n	    this._onceReturnValue = value;\n	    return this;\n	};\n	\n	/**\n	 * Fetches the current value to check against when executing listeners. If\n	 * the listeners return value matches this one then it should be removed\n	 * automatically. It will return true by default.\n	 *\n	 * @return {*|Boolean} The current value to check for or the default, true.\n	 * @api private\n	 */\n	proto._getOnceReturnValue = function _getOnceReturnValue() {\n	    if (this.hasOwnProperty('_onceReturnValue')) {\n	        return this._onceReturnValue;\n	    } else {\n	        return true;\n	    }\n	};\n	\n	/**\n	 * Fetches the events object and creates one if required.\n	 *\n	 * @return {Object} The events storage object.\n	 * @api private\n	 */\n	proto._getEvents = function _getEvents() {\n	    return this._events || (this._events = {});\n	};\n	\n	exports.default = EventEmitter;\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map",
template:'<div>\n    <div class=window>\n        <span data-info=remove class="icon-RC_close2 window__button window__button--remove"></span>\n        <span data-info=resize class="icon-RC_status window__button window__button--resize"></span>\n    </div>\n    \n    <div data-info=phone id=phone class=rc-phone>\n        <div class="window window--right">\n            <span data-info=logout class="icon-RC_Logout window__button window__button--logout"></span>\n        </div>\n        <div data-info=auth-panel id=auth-panel class=auth-panel></div>\n        <div data-info=toolbar id=toolbar></div>\n        <div class=phone-container data-info=container>\n        </div>\n        <div data-info=conversation class="panel panel--extra" id=conversation></div>\n        <div data-info=call-panel class="panel panel--extra" id=call-panel></div>\n        <div data-info=call-panel-incoming class="panel panel--extra" id=call-panel-incoming></div>\n        <div data-info=contact-detail class="panel panel--extra" id=contact-detail></div>\n        <div data-info=notification class="panel panel--extra" id=notification></div>\n    </div>\n</div>',style:"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-phone {\n    position: relative;\n    width: 250px;\n    height: 100%;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    overflow: hidden;\n    margin: 0 auto;\n    -webkit-transition: height .150s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: height .150s cubic-bezier(0.4, 0.0, 0.2, 1);\n}\n\n.rc-phone > .phone-container {\n    width: 3000px;\n    -webkit-transition: -webkit-transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: -webkit-transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition: transform .1s cubic-bezier(0.4, 0.0, 0.2, 1), -webkit-transform .1s cubic-bezier(0.4, 0.0, 0.2, 1);\n}\n.rc-phone .panel {\n    min-height: 1px;\n}\n.rc-phone .panel--extra {\n    position: absolute;\n    /* extra panel should have the highest z-index */\n    z-index: 10;\n    left: 0;\n}\n.rc-phone .auth-panel {\n    position: absolute;\n    /* overlap with container */\n    z-index: 5;\n}\n.window {\n    position: absolute;\n    z-index: 5;\n    top: 3px;\n    left: 3px;\n    /* need some space to fit the icon font */\n    padding-right: 2px\n}\n.window__button {\n    width: 12px;\n    height: 12px;\n    cursor: pointer;\n}\n.window__button--remove {\n    color: #E57373;\n}\n.window__button--resize {\n    color: #FFD740;\n}\n.window__button--logout {}\n.window--right {\n    left: auto;\n    right: 3px;\n    z-index: 2;\n}\n",imports:{scripts:["https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"],styles:[]},options:{scopedStyle:!1}},__w_widgets["time-line-item"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	function _pad(t) {\n	  return 100 > t ? "0" + t : t;\n	}w.register(function () {\n	  this.actions = { init: { after: function after() {\n	        this.props.selectedMessage = null, this.props.content = null, this.props.contact = null, this.props.time = null, this.props.subject = null, this.props.count = 0, this.fillData(this.data), this.root.firstChild.style.opacity = 0, this.root.firstChild.style.transform = "translateY(20px)", this.root.firstChild.style["transition-delay"] = "." + _pad(this.data.showingDelay || 0) + "s";\n	      } }, mount: { after: function after() {\n	        var t = this;setTimeout(function () {\n	          t.root.firstChild.style.opacity = 1, t.root.firstChild.style.transform = "translateY(0px)";\n	        }, 17);\n	      } }, fillData: { before: function before() {\n	        this.root.style["background-color"] = "#eee";\n	      }, method: function method(t, e) {\n	        var s = this;this.props.content = e, this.props.subject = e.subject;var i = new Date(e.time);if ("SMS" === e.type ? this.dom.icon.classList.add("icon-uni2487") : "Voice" === e.type ? (this.dom.icon.classList.add("icon-uniAE"), !this.props.subject || "Automatic" !== this.props.subject.type && "OnDemand" !== this.props.subject.type || (this.props.subject = "Call recording")) : "Pager" === e.type ? this.dom.icon.classList.add("icon-uniCB") : "VoiceMail" === e.type ? (this.dom.icon.classList.add("icon-uniCB"), this.props.subject = "Call recording") : "Fax" === e.type && (this.dom.icon.classList.add("icon-uniCB"), this.props.subject = "Fax"), this.dom.subject.textContent = this.props.subject, e.contact && (this.dom.contact.textContent = this.props.contact = e.contact.displayName), this.dom.time.textContent = this.props.time = "\\n                " + (i.getMonth() + 1) + "/" + i.getDate() + ", \\n                " + i.getHours() + ":" + i.getMinutes() + ":" + i.getSeconds() + "\\n                ", e.others && e.others.length > 0) {\n	          this.dom["count-wrapper"].classList.remove("display-none"), this.dom.count.textContent = this.props.count = e.others.length;for (var o; this.dom.collapse.firstChild;) {\n	            this.dom.collapse.removeChild(this.dom.collapse.firstChild);\n	          }e.others.forEach(function (t) {\n	            var e = new Date(t.time),\n	                i = document.createElement("div"),\n	                n = e.getMonth() + 1,\n	                a = e.getDate(),\n	                c = "",\n	                r = a > o ? n + "/" + a + "," : "";"SMS" === t.type ? c = t.subject : "Voice" === t.type ? c = !t.subject || "Automatic" !== t.subject.type && "OnDemand" !== t.subject.type ? t.subject : "Call recording" : "Pager" === t.type ? c = t.subject : "VoiceMail" === t.type ? c = "Call recording" : "Fax" === t.type && (c = "Fax"), i.innerHTML = "<div class=\'timeline-extra clearfix\'>\\n                            <div class=\'timeline-extra__content\'>" + c + "</div>\\n                            <div class=\'rc-timeline-item__time\'>\\n                                " + r + " \\n                                " + e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds() + "\\n                            </div>\\n                        </div>", i.firstChild.addEventListener("click", function (e) {\n	              e.stopPropagation(), s.enter(t);\n	            }), o = a, s.dom.collapse.appendChild(i.firstChild);\n	          });\n	        }\n	      }, after: function after(t) {\n	        var e = this;setTimeout(function () {\n	          return e.root.style["background-color"] = "#fff";\n	        }, 1e3);\n	      } }, collapse: { after: function after() {\n	        var t = this.dom.collapse;if (!t.classList.contains("--collapsing")) if (t.classList.contains("--active")) t.style.height = getComputedStyle(t).height, t.offsetWidth, t.style.height = "0px", t.classList.remove("--active"), t.classList.add("--collapsing"), t.addEventListener("transitionend", function i(e) {\n	          "height" == e.propertyName && (t.classList.remove("--collapsing"), t.removeEventListener("transitionend", i, !1));\n	        }, !1);else {\n	          var e = t.style.height;t.style.height = "auto";var s = getComputedStyle(t).height;t.style.height = e, t.offsetWidth, t.style.height = s, t.classList.add("--collapsing"), t.addEventListener("transitionend", function o(e) {\n	            "height" == e.propertyName && (t.style.transition = "", t.style.height = "auto", t.classList.remove("--collapsing"), t.removeEventListener("transitionend", o, !1));\n	          }, !1), t.classList.add("--active");\n	        }\n	      } }, enter: { method: function method(t, e) {\n	        e && (this.props.selectedMessage = e);\n	      } } }, this.on("click", function (t) {\n	    t.target === this.dom["count-wrapper"] || t.target.parentNode === this.dom["count-wrapper"] ? (this.collapse(), t.stopPropagation()) : this.enter();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class="rc-panel rc-timeline-item transition-in">\n        <div class=rc-timeline-item__content>\n        <div class=rc-timeline-item__line>\n            <span class=rc-timeline-item__icon data-info=icon></span>\n            <span class=rc-timeline-item__contact data-info=contact></span>\n        </div>\n            <div class=rc-timeline-item__time data-info=time></div>\n            <div class=rc-timeline-item__subject data-info=subject></div>\n        </div>\n        <div class="rc-timeline-item__count display-none" data-info=count-wrapper>\n            <span class=__number data-info=count></span>\n            <span class=icon-uni2466></span>\n        </div>\n        <div data-info=collapse class=rc-timeline-item__collapse>\n        </div>\n    </div>\n',style:"\n\n.rc-timeline-item {\n    padding:  .5em .7em;\n    box-shadow:  0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    margin-bottom:  5px;\n    overflow: hidden;\n    cursor: pointer;\n    background: #fff;\n    -webkit-transition:  opacity, -webkit-transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n    transition:  opacity, -webkit-transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n    transition:  opacity, transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n    transition: opacity, transform .350s cubic-bezier(0.0, 0.0, 0.2, 1), -webkit-transform .350s cubic-bezier(0.0, 0.0, 0.2, 1);\n}\n.rc-timeline-item .timeline-extra {}\n.rc-timeline-item .timeline-extra__content {}\n.rc-timeline-item .timeline-extra:hover {\n    background-color:  #eee;\n}\n.rc-timeline-item__line {\n    margin-bottom:  10px;\n}\n.rc-timeline-item__icon {}\n.rc-timeline-item__contact {\n    font-size:  .9em;\n}\n.rc-timeline-item__time {\n    float:  right;\n    font-size:  .7em;\n    color:  $timeline-gray;\n}\n.rc-timeline-item__subject {\n    font-size:  .8em;\n    overflow:  hidden;\n    text-overflow:  ellipsis;\n}\n.rc-timeline-item__count {\n    padding:  .5em .7em;\n    position:  absolute;\n    top:  0;\n    right:  0;\n    font-size:  .8em;\n}\n.rc-timeline-item__count > .__number {\n    color:  $timeline-gray;\n}\n.rc-timeline-item__count:hover > .__number {\n    color:  #000;\n}\n.rc-timeline-item__content {\n    padding:  .5em .7em;\n    position:  relative;\n}\n.rc-timeline-item__collapse {\n    box-shadow:  0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    height:  0;\n    overflow:  hidden;\n    -webkit-transition:  height .350s cubic-bezier(0.4, 0.0, 0.2, 1);\n    transition:  height .350s cubic-bezier(0.4, 0.0, 0.2, 1);\n}\n.rc-timeline-item__collapse > .timeline-extra {\n    padding:  .5em .7em;\n    font-size:  .8em;\n}\n.rc-timeline-item:hover {\n    box-shadow:  0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n    /*background-color: #eee;*/\n}\n    \n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["time-line"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	function transition(t) {\n	  var e = t.trans,\n	      r = t.layerHozTrans,\n	      n = t.layerVerticalTrans,\n	      o = (t.initPosition, t.transitionStart),\n	      i = t.transitionTo,\n	      s = t.createLayer;return function (t) {\n	    var a = (t.srcScene, t.targetScene),\n	        l = t.srcDOM,\n	        d = t.targetDOM,\n	        c = t.transitionEnd;a && (a.style.display = "block");var h = l.getBoundingClientRect(),\n	        p = d.getBoundingClientRect(),\n	        f = { width: l.offsetWidth, height: l.offsetHeight, left: h.left, top: h.top },\n	        u = { width: d.offsetWidth, height: d.offsetHeight, left: p.left, top: p.top },\n	        y = s({ src: f, target: u }),\n	        g = _slicedToArray(y, 2),\n	        m = g[0],\n	        v = g[1],\n	        w = div(m, { overflow: "hidden" }),\n	        x = div(v, { position: "fixed" }),\n	        M = div(f, { position: "static" });console.log(window.getComputedStyle(l).marginTop), M.style.marginBottom = window.getComputedStyle(l).marginBottom, M.style.marginTop = window.getComputedStyle(l).marginTop;var C = { src: l, target: d, layerHoz: w, layerVertical: x };a && (a.style.display = "none"), document.body.appendChild(x), l.parentNode.insertBefore(M, l), x.appendChild(w), w.appendChild(l), l.style.transition = e, w.style.transition = r, x.style.transition = n, o({ src: f, target: u, layerHoz: m, layerVertical: v, dom: C });var T = function T() {\n	      a && (a.style.display = "block"), x.parentNode.removeChild(x), M.parentNode.removeChild(M), c();\n	    };setTimeout(function () {\n	      return i(T, { src: f, target: u, layerHoz: m, layerVertical: v, dom: C });\n	    }, 17);\n	  };\n	}function div(t, e) {\n	  var r = e.overflow,\n	      n = void 0 === r ? "inherite" : r,\n	      o = e.position,\n	      i = void 0 === o ? "absolute" : o,\n	      s = document.createElement("div");return s.style.width = t.width + "px", s.style.height = t.height + "px", s.style.left = t.left + "px", s.style.top = t.top + "px", s.style.position = i, s.style.overflow = n, s;\n	}var _slicedToArray = function () {\n	  function t(t, e) {\n	    var r = [],\n	        n = !0,\n	        o = !1,\n	        i = void 0;try {\n	      for (var s, a = t[Symbol.iterator](); !(n = (s = a.next()).done) && (r.push(s.value), !e || r.length !== e); n = !0) {}\n	    } catch (l) {\n	      o = !0, i = l;\n	    } finally {\n	      try {\n	        !n && a["return"] && a["return"]();\n	      } finally {\n	        if (o) throw i;\n	      }\n	    }return r;\n	  }return function (e, r) {\n	    if (Array.isArray(e)) return e;if (Symbol.iterator in Object(e)) return t(e, r);throw new TypeError("Invalid attempt to destructure non-iterable instance");\n	  };\n	}(),\n	    _extends = Object.assign || function (t) {\n	  for (var e = 1; e < arguments.length; e++) {\n	    var r = arguments[e];for (var n in r) {\n	      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n	    }\n	  }return t;\n	};w.register(function () {\n	  var t = [];this.data = {}, this.actions = { init: { after: function after() {\n	        this.props.mounted = !1, this.props.latestMessage = null;\n	      } }, mount: { after: function after() {\n	        this.props.mounted || (this.fetchData(), this.props.mounted = !0);\n	      } }, fetchData: { method: function method(t) {\n	        return t();\n	      }, after: function after(t) {\n	        var e = this;this.dom.loading.classList.add("display-none"), t && t[0] && (this.props.latestMessage = t[0], t.forEach(function (t, r) {\n	          return e.addLine(t, !1, 30 * r);\n	        }));\n	      } }, updateTimeline: { after: function after(e) {\n	        var r = this;e.filter(function (e) {\n	          return -1 === t.indexOf(e.id);\n	        }).forEach(function (e) {\n	          r.props.latestMessage && r.props.latestMessage.type === e.type && r.props.latestMessage.contact.id === e.contact.id && (r.props.latestMessage.others = r.props.latestMessage.others || [], e.others = e.others || [], e.others.push(r.props.latestMessage), e.others = e.others.concat(r.props.latestMessage.others), r.props.latestMessage.widget.unmount()), r.addLine(e, !0), r.props.latestMessage = e, t.push(e.id);\n	        });\n	      } }, addLine: { after: function after(t, e, r) {\n	        var n = this,\n	            o = w("time-line-item", { data: _extends({}, t, { showingDelay: r }), actions: { enter: { after: function after() {\n	                var t = this;n.props.selectedContent = this.props.selectedMessage || this.props.content, console.log(this.root.firstChild);var e = this.root.firstChild;enlarge({ srcDOM: e, targetDOM: n.dom.content, transitionEnd: function transitionEnd() {\n	                    n.enterItem(), t.root.appendChild(e), e.style.width = "auto", e.style.height = "auto";\n	                  } });\n	              } } } });t.widget = o, o.mount(this.dom.timeline, e);\n	      } }, search: { method: function method(t) {\n	        return t();\n	      } }, focusSearchBox: { method: function method(t) {\n	        return t();\n	      }, after: function after() {} }, blurSearchBox: { method: function method(t) {\n	        return t();\n	      }, after: function after() {} }, switchContent: { method: function method() {}, after: function after() {} }, enterItem: { method: function method() {}, after: function after() {} } };\n	});var enlarge = transition({ trans: "all .3s cubic-bezier(0.4, 0.0, 0.2, 1)", layerHozTrans: "all .375s ease-in", layerVerticalTrans: "all .375s ease-out", transitionStart: function transitionStart(t) {\n	    var e = t.src,\n	        r = (t.target, t.layerHoz),\n	        n = t.layerVertical,\n	        o = t.dom,\n	        i = o.src;i.style.width = e.width + "px", i.style.height = e.height + "px", i.style.left = e.left - r.left + "px", i.style.top = e.top - n.top + "px";\n	  }, transitionTo: function transitionTo(t, e) {\n	    var r = (e.src, e.target),\n	        n = e.layerHoz,\n	        o = (e.layerVertical, e.dom),\n	        i = o.src;setTimeout(function () {\n	      var e = 0;i.style.height = n.height + "px", i.style.top = "0px", i.addEventListener("transitionend", function r(n) {\n	        ++e >= 3 && (t(), i.removeEventListener("transitionend", r));\n	      });\n	    }, 30), i.style.width = n.width + "px", i.style.left = "0px", o.layerHoz.style.left = r.left + "px", o.layerVertical.style.top = r.top + "px";\n	  }, createLayer: function createLayer(t) {\n	    var e = t.src,\n	        r = t.target;return [{ width: r.width, height: r.height, left: r.left, top: 0 }, { width: r.width, height: r.height, left: 0, top: e.top }];\n	  } });\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'\n    <div class="rc-panel rc-timeline">\n        <div class="rc-panel__content rc-panel__content--full" data-info=content>\n            <div class=rc-timeline__loading data-info=loading>Loading ...</div>\n            <div class=rc-timeline__list data-info=timeline>\n                \n            </div>\n            <div class="rc-timeline__mask display-none" data-info=mask></div>\n        </div>\n    </div>\n',style:"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-timeline > .rc-panel__content {\n    overflow: auto;\n}\n.rc-timeline__list {}\n.rc-timeline__mask {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n}\n.rc-timeline__loading {\n    padding: .9em 1.1em;\n    color: #878787;\n    text-align: center;\n}\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}},__w_widgets["tool-bar"]={script:'/******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = "";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n	"use strict";\n	w.register(function () {\n	  var t = w.transition("slide-down");this.props = { itemCount: 0 }, this.actions = { init: { method: function method() {\n	        this.state = [], this.itemCount = 0;\n	      } }, mount: { after: function after() {\n	        var n = this;t.init(this.dom.menu), window.addEventListener("click", function (t) {\n	          n.hideMenu();\n	        }, !1), this.root.addEventListener("click", function (t) {\n	          t.stopPropagation();\n	        });\n	      } }, adjustMenuButton: { after: function after() {\n	        Array.from(this.dom.toolbar.childNodes).forEach(function (t) {\n	          3 === t.nodeType && t.parentNode.removeChild(t);\n	        });var t = Math.floor((Array.from(this.dom.toolbar.childNodes).length - 1) / 2) + 1,\n	            n = this.dom.toolbar.childNodes[t];n.parentNode.insertBefore(this.dom["menu-button"], n);\n	      } }, addItem: { method: function method() {}, after: function after(t, n, o) {\n	        var e,\n	            i = document.createElement("div");if (this.itemCount >= 4) {\n	          var s = "<div class=\'rc-toolbar__more-item text-center\'>\\n                                        <button class=\'rc-button rc-button--circle\'>\\n                                            " + t + "\\n                                        </button>\\n                                        <div>" + n + "</div>\\n                                    </div>";i.innerHTML = s, e = i.childNodes[0], this.dom.menu.appendChild(e);\n	        } else {\n	          var s = "<button class=\'rc-toolbar__item rc-button rc-button--ghost rc-icon-switch\'>\\n                                        " + t + "\\n                                    </button>";i.innerHTML = s, e = i.childNodes[0], this.dom.toolbar.appendChild(e);\n	        }return this.adjustMenuButton(), ++this.itemCount, this.props.itemCount = this.itemCount, e;\n	      } }, clickItem: { method: function method(t, n, o) {\n	        var e = this;"number" == typeof n || n.addEventListener("click", function () {\n	          o.call(e), e.hideMenu(), e.state.push(o);\n	        });\n	      } }, pop: { method: function method() {\n	        console.log(this.state), this.state.length > 1 && (this.state.pop(), this.state[this.state.length - 1].call(this));\n	      } }, toggleMenu: { after: function after() {\n	        t.toggle(this.dom.menu);\n	      } }, hideMenu: { after: function after() {\n	        t.out(this.dom.menu);\n	      } }, disableMenu: { after: function after() {\n	        this.dom["menu-button"].classList.add("display-none");\n	      } } }, this.on("click", "menu-button", function (t) {\n	    this.props.itemCount > 4 && this.toggleMenu();\n	  });\n	});\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=bundle.js.map',template:'<div class=rc-toolbar>\n    <div class="rc-toolbar__bar text-center" data-info=toolbar>\n        <button class="rc-button rc-toolbar__menu-button" data-info=menu-button data-event=click:toggleMenu>\n            <span class=icon-ActionButtons_down></span>\n        </button>\n    </div>\n    <div class=rc-toolbar__panel data-info=menu>\n    </div>\n</div>',style:"/* rc-input.--round, rc-button.--round */\n/* rc-panel */\n.rc-toolbar {\n    /* used as a positioned reference */\n    position: relative;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    z-index: 1;\n    height: 100%\n}\n.rc-toolbar__bar {\n    /* used as a positioned reference */\n    position: relative;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    height: 100%;\n    z-index: 1;\n    background-color: #FAFAFA\n}\n.rc-toolbar__menu-button {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    position: relative;\n    z-index: 1;\n    border: 0;\n    border-left: 1px solid #bdc3c7;\n    border-right: 1px solid #bdc3c7;\n    border-bottom: 1px solid #bdc3c7;\n    height: calc(25px + 20px);\n    margin-bottom: -20px\n}\n.rc-toolbar__panel {\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-flex-wrap: wrap;\n    -ms-flex-wrap: wrap;\n    flex-wrap: wrap;\n    -webkit-justify-content: space-around;\n    -ms-flex-pack: distribute;\n    justify-content: space-around;\n    position: absolute;\n    width: 100%;\n    min-height: 100px;\n    background-color: #fff\n}\n.rc-toolbar__item {\n    background-color: #FAFAFA\n}\n.rc-toolbar__item:hover {\n    background-color: #FAFAFA;\n    color: #2196F3\n}\n.rc-toolbar__more-item {\n    font-size: .6em;\n    margin: 5px;\n}\n.rc-toolbar__more-item > .rc-button {\n    font-size: 1.8em;\n    width: 45px;\n    height: 45px\n}\n.rc-toolbar__more-item:hover {\n    color: #333\n}\n\n",imports:{scripts:[],styles:[]},options:{scopedStyle:!1}};