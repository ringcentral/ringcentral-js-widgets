{"version":3,"sources":["lib/LoggerBase/index.test.inactive.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// import chai, { expect } from 'chai';\n// import chaiAsPromised from 'chai-as-promised';\n// import dirtyChai from 'dirty-chai';\n// import sinon from 'sinon';\n// import { createStore } from 'redux';\n// import { ObjectMap } from '@ringcentral-integration/core/lib/ObjectMap';\n// import LoggerBase, {\n//   defaultIdentityFunction,\n//   convertListToMap,\n// } from './index';\n// import baseActionTypes from './baseActionTypes';\n// import { sleep } from '../sleep';\n\n// chai.use(chaiAsPromised);\n// chai.use(dirtyChai);\n\n// describe('defaultIdentityFunction', () => {\n//   it('should be a function', () => {\n//     expect(defaultIdentityFunction).to.be.a('function');\n//   });\n//   it('should accept an object and return object.id', () => {\n//     const obj = {\n//       id: 'foo',\n//     };\n//     expect(defaultIdentityFunction(obj)).to.equal(obj.id);\n//   });\n// });\n\n// describe('convertListToMap', () => {\n//   it('should be a function', () => {\n//     expect(convertListToMap).to.be.a('function');\n//   });\n//   it('should convert loggingLists to loggingMaps', () => {\n//     const loggingList = [];\n//     const expectedResult = {};\n//     Array.from(new Array(5)).forEach((_, idx) => {\n//       loggingList.push({\n//         name: 'foo',\n//         id: `item-${idx}`,\n//       });\n//       loggingList.push({\n//         name: 'bar',\n//         id: `item-${idx}`,\n//       });\n//       expectedResult[`item-${idx}`] = {\n//         foo: true,\n//         bar: true,\n//       };\n//     });\n//     expect(convertListToMap(loggingList))\n//       .to.deep.equal(expectedResult);\n//   });\n// });\n\n// describe('LoggerBase', () => {\n//   describe('constructor', () => {\n//     it('should be a function', () => {\n//       expect(LoggerBase).to.be.a('function');\n//     });\n//     it('should throw if options.name is not defined', () => {\n//       expect(() => new LoggerBase({})).to.throw();\n//     });\n//     it('should default options.actionTypes to prefixed baseActionTypes', () => {\n//       const name = 'foo';\n//       const instance = new LoggerBase({ name });\n//       expect(instance.actionTypes)\n//         .to.deep.equal(ObjectMap.prefixKeys([...ObjectMap.keys(baseActionTypes)], name ));\n//     });\n//     it('should allow options.actionTypes to be customized', () => {\n//       const actionTypes = { bar: 'rogue' };\n//       const name = 'foo';\n//       const instance = new LoggerBase({ name, actionTypes });\n//       expect(instance.actionTypes)\n//         .to.deep.equal(actionTypes);\n//     });\n//   });\n//   describe('instance of LoggerBase', () => {\n//     describe('addLogProvider', () => {\n//       it('should throw if options.name is undefined', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         expect(() => instance.addLogProvider({})).to.throw();\n//       });\n//       it('should throw if options.logFn is not a function', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         [undefined, 0, 'bar', {}, []].forEach((logFn) => {\n//           expect(() => instance.addLogProvider({ name: 'bar', logFn }))\n//             .to.throw();\n//         });\n//       });\n//       it('should throw if options.readyCheckFn is not a function', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         const logFn = async () => { };\n//         [undefined, 0, 'bar', {}, []].forEach((readyCheckFn) => {\n//           expect(() => instance.addLogProvider({\n//             name: 'bar',\n//             logFn,\n//             readyCheckFn,\n//           })).to.throw();\n//         });\n//       });\n//       it('should add named log provider to _logProviders', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         const logFn = async () => { };\n//         const readyCheckFn = () => true;\n//         const name = 'bar';\n//         expect(() => instance.addLogProvider({\n//           name,\n//           logFn,\n//           readyCheckFn,\n//         })).to.not.throw();\n//         expect(instance._logProviders.has(name)).to.equal(true);\n//         expect(instance._logProviders.get(name))\n//           .to.deep.equal({\n//             logFn,\n//             readyCheckFn,\n//           });\n//       });\n//       it('should throw if called with the same name twice', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         const logFn = async () => { };\n//         const readyCheckFn = () => true;\n//         const name = 'bar';\n//         instance.addLogProvider({\n//           name,\n//           logFn,\n//           readyCheckFn,\n//         });\n//         expect(() => instance.addLogProvider({\n//           name,\n//           logFn,\n//           readyCheckFn,\n//         })).to.throw();\n//       });\n//       it('should pass the rest of options into providers', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         const logFn = async () => { };\n//         const readyCheckFn = () => true;\n//         const name = 'bar';\n//         const otherOptions = {\n//           rogue: 'one',\n//           yoda: 'puppet',\n//         };\n//         instance.addLogProvider({\n//           name,\n//           logFn,\n//           readyCheckFn,\n//           ...otherOptions,\n//         });\n//         expect(instance._logProviders.get(name))\n//           .to.deep.equal({\n//             logFn,\n//             readyCheckFn,\n//             ...otherOptions,\n//           });\n//       });\n//     });\n//     describe('logProvidersReady', () => {\n//       it('should return true when no providers are added', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         expect(instance.logProvidersReady).to.equal(true);\n//       });\n//       it('should return true when all providers are ready', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance.addLogProvider({\n//           name: 'foo',\n//           logFn: async () => { },\n//           readyCheckFn: () => true,\n//         });\n//         instance.addLogProvider({\n//           name: 'bar',\n//           logFn: async () => { },\n//           readyCheckFn: () => true,\n//         });\n//         expect(instance.logProvidersReady).to.equal(true);\n//       });\n//       it('should return false when some providers are not ready', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance.addLogProvider({\n//           name: 'foo',\n//           logFn: async () => { },\n//           readyCheckFn: () => true,\n//         });\n//         instance.addLogProvider({\n//           name: 'bar',\n//           logFn: async () => { },\n//           readyCheckFn: () => false,\n//         });\n//         expect(instance.logProvidersReady).to.equal(false);\n//       });\n//     });\n//     describe('_shouldInit', () => {\n//       [true, false].forEach((pending) => {\n//         [true, false].forEach((providersReady) => {\n//           const result = pending && providersReady;\n//           it(`should return ${result} when this.pending === ${pending}\n//           and this.logProvidersReady === ${providersReady}`,\n//             () => {\n//               const instance = new LoggerBase({ name: 'foo' });\n//               sinon.stub(instance, 'pending', {\n//                 get() {\n//                   return pending;\n//                 },\n//               });\n//               sinon.stub(instance, 'logProvidersReady', {\n//                 get() {\n//                   return providersReady;\n//                 },\n//               });\n//               expect(instance._shouldInit()).to.equal(result);\n//             },\n//           );\n//         });\n//       });\n//     });\n//     describe('_shouldReset', () => {\n//       [true, false].forEach((ready) => {\n//         [true, false].forEach((providersReady) => {\n//           const result = ready && !providersReady;\n//           it(`should return ${result} when this.ready === ${ready}\n//           and this.logProvidersReady === ${providersReady}`,\n//             () => {\n//               const instance = new LoggerBase({ name: 'foo' });\n//               sinon.stub(instance, 'ready', {\n//                 get() {\n//                   return ready;\n//                 },\n//               });\n//               sinon.stub(instance, 'logProvidersReady', {\n//                 get() {\n//                   return providersReady;\n//                 },\n//               });\n//               expect(instance._shouldReset()).to.equal(result);\n//             },\n//           );\n//         });\n//       });\n//     });\n//     describe('_onStateChange', () => {\n//       it('should initialize module when _shouldInit() === true', async () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance._store = {\n//           dispatch: sinon.stub(),\n//         };\n//         sinon.stub(instance, '_shouldInit').callsFake(() => true);\n//         sinon.stub(instance, '_shouldReset').callsFake(() => false);\n//         await instance._onStateChange();\n//         sinon.assert.calledTwice(instance._store.dispatch);\n//         expect(instance._store.dispatch.args[0][0].type)\n//           .to.equal(instance.actionTypes.init);\n//         expect(instance._store.dispatch.args[1][0].type)\n//           .to.equal(instance.actionTypes.initSuccess);\n//       });\n//       it('should call _onInit when _shouldInit() === true and _onInit is a function',\n//         async () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           instance._store = {\n//             dispatch: sinon.stub(),\n//           };\n//           sinon.stub(instance, '_shouldInit').callsFake(() => true);\n//           sinon.stub(instance, '_shouldReset').callsFake(() => false);\n//           instance._onInit = sinon.stub();\n//           await instance._onStateChange();\n//           sinon.assert.calledTwice(instance._store.dispatch);\n//           expect(instance._store.dispatch.args[0][0].type)\n//             .to.equal(instance.actionTypes.init);\n//           expect(instance._store.dispatch.args[1][0].type)\n//             .to.equal(instance.actionTypes.initSuccess);\n//           sinon.assert.calledOnce(instance._onInit);\n//         },\n//       );\n//       it('should reset module when _shouldReset() === true', async () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance._store = {\n//           dispatch: sinon.stub(),\n//         };\n//         sinon.stub(instance, '_shouldInit').callsFake(() => false);\n//         sinon.stub(instance, '_shouldReset').callsFake(() => true);\n//         await instance._onStateChange();\n//         sinon.assert.calledTwice(instance._store.dispatch);\n//         expect(instance._store.dispatch.args[0][0].type)\n//           .to.equal(instance.actionTypes.reset);\n//         expect(instance._store.dispatch.args[1][0].type)\n//           .to.equal(instance.actionTypes.resetSuccess);\n//       });\n//       it('should call _onReset when _shouldReset() === true and _onReset is a function',\n//         async () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           instance._store = {\n//             dispatch: sinon.stub(),\n//           };\n//           sinon.stub(instance, '_shouldInit').callsFake(() => false);\n//           sinon.stub(instance, '_shouldReset').callsFake(() => true);\n//           instance._onReset = sinon.stub();\n//           await instance._onStateChange();\n//           sinon.assert.calledTwice(instance._store.dispatch);\n//           expect(instance._store.dispatch.args[0][0].type)\n//             .to.equal(instance.actionTypes.reset);\n//           expect(instance._store.dispatch.args[1][0].type)\n//             .to.equal(instance.actionTypes.resetSuccess);\n//           sinon.assert.calledOnce(instance._onReset);\n//         },\n//       );\n//       it('should do nothing when _shouldReset() and _shouldInit() are false',\n//         async () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           instance._store = {\n//             dispatch: sinon.stub(),\n//           };\n//           sinon.stub(instance, '_shouldInit').callsFake(() => false);\n//           sinon.stub(instance, '_shouldReset').callsFake(() => false);\n//           instance._onReset = sinon.stub();\n//           instance._onInit = sinon.stub();\n//           await instance._onStateChange();\n//           sinon.assert.notCalled(instance._store.dispatch);\n//           sinon.assert.notCalled(instance._onReset);\n//           sinon.assert.notCalled(instance._onInit);\n//         },\n//       );\n//     });\n//     describe('_log', () => {\n//       it('should throw if module is not ready', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance._store = createStore(instance.reducer);\n//         const item = {\n//           id: 'rogue',\n//         };\n//         return expect(instance._log({ name: 'bar', item }))\n//           .to.be.rejectedWith(Error);\n//       });\n//       it('should throw if options.item is undefined', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance._store = createStore(instance.reducer);\n//         instance._onStateChange();\n//         return expect(instance._log({ name: 'bar' }))\n//           .to.be.rejectedWith(Error);\n//       });\n//       it('should throw if options.name is undefined', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance._store = createStore(instance.reducer);\n//         instance._onStateChange();\n//         const item = {\n//           id: 'rogue',\n//         };\n//         return expect(instance._log({ item }))\n//           .to.be.rejectedWith(Error);\n//       });\n//       it('should call logFn of the provider and return a promise', async () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         const name = 'bar';\n//         instance._store = createStore(instance.reducer);\n//         instance.addLogProvider({\n//           name,\n//           logFn: sinon.stub().callsFake(async () => {\n//             await sleep(50);\n//           }),\n//           readyCheckFn: () => true,\n//         });\n//         instance._onStateChange();\n//         const item = {\n//           id: 'rogue',\n//         };\n//         const promise = instance._log({\n//           name,\n//           item,\n//         });\n//         expect(promise).to.be.instanceOf(Promise);\n//         await promise;\n//         sinon.assert.calledOnce(instance._logProviders.get(name).logFn);\n//       });\n//       it('should dispatch log and logSuccess before and after successful log',\n//         async () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           const name = 'bar';\n//           instance._store = createStore(instance.reducer);\n//           instance.addLogProvider({\n//             name,\n//             logFn: sinon.stub().callsFake(async () => {\n//               await sleep(50);\n//             }),\n//             readyCheckFn: () => true,\n//           });\n//           instance._onStateChange();\n//           const item = {\n//             id: 'rogue',\n//           };\n//           sinon.spy(instance._store, 'dispatch');\n//           const promise = instance._log({\n//             name,\n//             item,\n//           });\n//           expect(instance._store.dispatch.args[0][0].type)\n//             .to.equal(instance.actionTypes.log);\n//           await promise;\n//           sinon.assert.calledOnce(instance._logProviders.get(name).logFn);\n//           expect(instance._store.dispatch.args[1][0].type)\n//             .to.equal(instance.actionTypes.logSuccess);\n//         },\n//       );\n//       it('should dispatch log and logError before and after failed log',\n//         async () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           const name = 'bar';\n//           instance._store = createStore(instance.reducer);\n//           instance.addLogProvider({\n//             name,\n//             logFn: sinon.stub().callsFake(async () => {\n//               await sleep(50);\n//               throw new Error();\n//             }),\n//             readyCheckFn: () => true,\n//           });\n//           instance._onStateChange();\n//           const item = {\n//             id: 'rogue',\n//           };\n//           sinon.spy(instance._store, 'dispatch');\n//           const promise = instance._log({\n//             name,\n//             item,\n//           });\n//           expect(instance._store.dispatch.args[0][0].type)\n//             .to.equal(instance.actionTypes.log);\n//           try {\n//             await promise;\n//           } catch (error) {\n//             /* ignores error */\n//           }\n//           sinon.assert.calledOnce(instance._logProviders.get(name).logFn);\n//           expect(instance._store.dispatch.args[1][0].type)\n//             .to.equal(instance.actionTypes.logError);\n//         },\n//       );\n//       it('should wait for the last call to logFn of the provider', async () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         const name = 'bar';\n//         instance._store = createStore(instance.reducer);\n//         instance.addLogProvider({\n//           name,\n//           logFn: sinon.stub().callsFake(async () => {\n//             await sleep(50);\n//           }),\n//           readyCheckFn: () => true,\n//         });\n//         instance._onStateChange();\n//         const item = {\n//           id: 'rogue',\n//         };\n//         instance._log({\n//           name,\n//           item,\n//         });\n//         await sleep(30);\n//         sinon.assert.calledOnce(instance._logProviders.get(name).logFn);\n//         instance._log({\n//           name,\n//           item,\n//         });\n//         sinon.assert.calledOnce(instance._logProviders.get(name).logFn);\n//         await sleep(30);\n//         sinon.assert.calledTwice(instance._logProviders.get(name).logFn);\n//       });\n//     });\n//     describe('log', () => {\n//       it('should throw if module is not ready', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance._store = createStore(instance.reducer);\n//         const item = {\n//           id: 'rogue',\n//         };\n//         return expect(instance.log({ item }))\n//           .to.be.rejectedWith(Error);\n//       });\n//       it('should throw if options.item is undefined', () => {\n//         const instance = new LoggerBase({ name: 'foo' });\n//         instance._store = createStore(instance.reducer);\n//         instance._onStateChange();\n//         return expect(instance.log({}))\n//           .to.be.rejectedWith(Error);\n//       });\n//       it('should call _log with all provider names if options.name is not specified',\n//         async () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           instance._store = createStore(instance.reducer);\n//           instance.addLogProvider({\n//             name: 'bar',\n//             logFn: async () => {},\n//             readyCheckFn: () => true,\n//           });\n//           instance.addLogProvider({\n//             name: 'baz',\n//             logFn: async () => {},\n//             readyCheckFn: () => true,\n//           });\n//           instance._onStateChange();\n//           const item = {\n//             id: 'rogue',\n//           };\n//           sinon.stub(instance, '_log');\n//           await instance.log({\n//             item,\n//           });\n//           sinon.assert.calledTwice(instance._log);\n//           expect(instance._log.args[0][0].name).to.equal('bar');\n//           expect(instance._log.args[1][0].name).to.equal('baz');\n//         },\n//       );\n//       it('should call _log options.name if specified',\n//         async () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           instance._store = createStore(instance.reducer);\n//           instance.addLogProvider({\n//             name: 'bar',\n//             logFn: async () => {},\n//             readyCheckFn: () => true,\n//           });\n//           instance.addLogProvider({\n//             name: 'baz',\n//             logFn: async () => {},\n//             readyCheckFn: () => true,\n//           });\n//           instance._onStateChange();\n//           const item = {\n//             id: 'rogue',\n//           };\n//           sinon.stub(instance, '_log');\n//           await instance.log({\n//             name: 'bar',\n//             item,\n//           });\n//           sinon.assert.calledOnce(instance._log);\n//           expect(instance._log.args[0][0].name).to.equal('bar');\n//         },\n//       );\n//       it('should throw if provider of options.name does not exist',\n//         () => {\n//           const instance = new LoggerBase({ name: 'foo' });\n//           instance._store = createStore(instance.reducer);\n//           instance._onStateChange();\n//           const item = {\n//             id: 'rogue',\n//           };\n//           return expect(instance.log({\n//             name: 'bar',\n//             item,\n//           })).to.be.rejectedWith(Error);\n//         },\n//       );\n//     });\n//   });\n// });\n"],"file":"index.test.inactive.js"}