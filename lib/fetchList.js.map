{"version":3,"sources":["lib/fetchList.js"],"names":["fn","perPage","params","page","data","list","records","slice","paging","totalPages","promises","i","push","all","output","item","reduce","parallelFetch","fetchedPages","serialFetch","parallel","fetchList"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wEACA,iBAA6BA,EAA7B,EAAiCC,OAAjC,EAA0CC,MAA1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACqBF,8BACdE,MADc;AAEjBD,8BAFiB;AAGjBE,oBAAM;AAHW,eADrB;;AAAA;AACQC,gBADR;AAMQC,gBANR,GAMeD,KAAKE,OAAL,CAAaC,KAAb,EANf;;AAAA,kBAOMH,KAAKI,MAAL,CAAYC,UAAZ,GAAyB,CAP/B;AAAA;AAAA;AAAA;;AAQUC,oBARV,GAQqB,EARrB;;AASI,iBAASC,CAAT,GAAaP,KAAKI,MAAL,CAAYC,UAAzB,EAAqCE,IAAI,CAAzC,EAA4CA,KAAK,CAAjD,EAAoD;AAClDD,uBAASE,IAAT,CAAcZ,8BACTE,MADS;AAEZD,gCAFY;AAGZE,sBAAMQ;AAHM,iBAAd;AAKD;AAfL;AAAA,mBAgBW,kBAAQE,GAAR,CAAYH,QAAZ,CAhBX;;AAAA;AAAA,0BAgByC,UAACI,MAAD,EAASC,IAAT,EAAkB;AACrDD,qBAAOF,IAAP,gDAAeG,KAAKT,OAApB;AACA,qBAAOQ,MAAP;AACD,aAnBL;;AAAA,0BAmBOT,IAnBP;;AAAA,0BAgBkCW,MAhBlC;;AAAA;AAAA,6CAqBSX,IArBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeY,a;;;;;;yEAwBf,kBAA2BjB,EAA3B,EAA+BC,OAA/B,EAAwCC,MAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AACMgB,wBADN,GACqB,CADrB;AAEMT,sBAFN,GAEmB,CAFnB;AAGQJ,gBAHR,GAGe,EAHf;;AAAA;AAAA,kBAKSa,eAAeT,UALxB;AAAA;AAAA;AAAA;;AAMIS,4BAAgB,CAAhB;AANJ;AAAA,mBAOuBlB,8BACdE,MADc;AAEjBD,8BAFiB;AAGjBE,oBAAMe;AAHW,eAPvB;;AAAA;AAOUd,gBAPV;;AAYI;AACAK,yBAAaL,KAAKI,MAAL,CAAYC,UAAzB;AACAJ,iBAAKO,IAAL,8CAAaR,KAAKE,OAAlB;AAdJ;AAAA;;AAAA;AAAA,8CAgBSD,IAhBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAec,W;;;;;;;;yEAmBA,kBAAyBnB,EAAzB;AAAA,oFAIX,EAJW;;AAAA,8BACbC,OADa;AAAA,QACbA,OADa,iCACH,KADG;AAAA,+BAEbmB,QAFa;AAAA,QAEbA,QAFa,kCAEF,IAFE;AAAA,QAGVlB,MAHU;AAAA;AAAA;AAAA;AAAA;AAAA,8CAKNkB,WACLH,cAAcjB,EAAd,EAAkBC,OAAlB,EAA2BC,MAA3B,CADK,GAELiB,YAAYnB,EAAZ,EAAgBC,OAAhB,EAAyBC,MAAzB,CAPW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;WAAemB,S;;;;SAAAA,S","file":"fetchList.js","sourcesContent":["\nasync function parallelFetch(fn, perPage, params) {\n  const data = await fn({\n    ...params,\n    perPage,\n    page: 1,\n  });\n  const list = data.records.slice();\n  if (data.paging.totalPages > 1) {\n    const promises = [];\n    for (let i = data.paging.totalPages; i > 1; i -= 1) {\n      promises.push(fn({\n        ...params,\n        perPage,\n        page: i,\n      }));\n    }\n    (await Promise.all(promises)).reduce((output, item) => {\n      output.push(...item.records);\n      return output;\n    }, list);\n  }\n  return list;\n}\n\nasync function serialFetch(fn, perPage, params) {\n  let fetchedPages = 0;\n  let totalPages = 1;\n  const list = [];\n\n  while (fetchedPages < totalPages) {\n    fetchedPages += 1;\n    const data = await fn({\n      ...params,\n      perPage,\n      page: fetchedPages,\n    });\n    /* eslint { \"prefer-destructuring\": 0 } */\n    totalPages = data.paging.totalPages;\n    list.push(...data.records);\n  }\n  return list;\n}\n\nexport default async function fetchList(fn, {\n  perPage = 'MAX',\n  parallel = true,\n  ...params\n} = {}) {\n  return parallel ?\n    parallelFetch(fn, perPage, params) :\n    serialFetch(fn, perPage, params);\n}\n"]}