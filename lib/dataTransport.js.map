{"version":3,"sources":["lib/dataTransport.ts"],"names":["listen","target","key","descriptor","fn","value","process","env","NODE_ENV","console","warn","listeners","Error","bindListeners","instance","transport","func","name","bind"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAEA;AACA;AACA;AACA,IAAMA,MAAM,GAAG,SAATA,MAAS,CACbC,MADa,EAEbC,GAFa,EAGbC,UAHa,EAIV;AAAA;;AACH,MAAMC,EAAE,GAAGD,UAAU,CAACE,KAAtB;;AACA,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAI,OAAOJ,EAAP,KAAc,UAAlB,EAA8B;AAC5BK,MAAAA,OAAO,CAACC,IAAR,+DACyDR,GADzD;AAGA,aAAOC,UAAP;AACD;AACF;;AACD,uBAAAF,MAAM,CAACU,SAAP,iEAAAV,MAAM,CAACU,SAAP,GAAqB,EAArB;AACAV,EAAAA,MAAM,CAACU,SAAP,CAAiBT,GAAjB,IAAwBE,EAAxB;AACA,yCACKD,UADL;AAEQE,IAAAA,KAFR,mBAE+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACvBC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YADF;AAAA;AAAA;AAAA;;AAAA,sBAEnB,IAAII,KAAJ,uBACWV,GADX,6DAFmB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAM5B;AARH;AAUD,CA1BD;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACA,IAAMW,aAAa,GAAG,SAAhBA,aAAgB,CAACC,QAAD,EAAmBC,SAAnB,EAAsD;AAAA;;AAC1E,gCACE,UAACC,IAAD,EAAOC,IAAP,EAAgB;AACdF,IAAAA,SAAS,CAACf,MAAV,CAAiBiB,IAAjB,EAAuBD,IAAI,CAACE,IAAL,CAAUJ,QAAV,CAAvB;AACD,GAHH,gBAKIA,QADF,CAIEH,SARJ,mDAQiB,EARjB;AAUD,CAXD","sourcesContent":["import { Transport } from 'data-transport';\nimport { forEachObjIndexed } from 'ramda';\n\nexport * from 'data-transport';\n\n/**\n * `@listen` decorator, that will auto binding event with `data-transport`\n */\nconst listen = (\n  target: any,\n  key: string,\n  descriptor: TypedPropertyDescriptor<(...args: any) => Promise<any>>,\n) => {\n  const fn = descriptor.value;\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof fn !== 'function') {\n      console.warn(\n        `The decorator '@listen' can only decorate methods, '${key}' is NOT a methods.`,\n      );\n      return descriptor;\n    }\n  }\n  target.listeners ??= {};\n  target.listeners[key] = fn;\n  return {\n    ...descriptor,\n    async value(this: Transport) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `The method '${key}' is a listen function that can NOT be actively called.`,\n        );\n      }\n    },\n  };\n};\n\n/**\n * bind current class listenable,\n * that your class `@listen` work\n *\n * @example\n *\n  ```ts\n\n  class Adapter implements ToInternal, ToExternal {\n\n    transport?: Transport<ToInternal, ToExternal>;\n\n    constructor(){\n      this.transport = createTransport('IFrameMain', {\n        iframe: this.appIFrame,\n      });\n      bindListeners(this, this.transport);\n    }\n\n    @listen\n    async fetchIsMatchCaseId(caseId: string): Promise<string> {\n      return this.visualforceRequest('fetchIsMatchCaseId', caseId);\n    }\n  }\n * ```\n */\nconst bindListeners = (instance: object, transport: Transport<any, any>) => {\n  forEachObjIndexed(\n    (func, name) => {\n      transport.listen(name, func.bind(instance));\n    },\n    (\n      instance as {\n        listeners?: Record<string, (...args: any) => any>;\n      }\n    ).listeners ?? {},\n  );\n};\n\nexport { bindListeners, listen };\n"],"file":"dataTransport.js"}