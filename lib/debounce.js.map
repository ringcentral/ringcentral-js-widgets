{"version":3,"sources":["lib/debounce.js"],"names":["debounce","func","threshold","immediate","Error","timer","debounced","args","context","callNow","later","apply","clearTimeout","setTimeout"],"mappings":";;;;;kBAWwBA,Q;AAXxB;;;;;;;;;;;AAWe,SAASA,QAAT,CAAkBC,IAAlB,EAA4D;AAAA,MAApCC,SAAoC,uEAAxB,GAAwB;AAAA,MAAnBC,SAAmB,uEAAP,KAAO;;AACzE,MAAI,OAAOF,IAAP,KAAgB,UAApB,EAAgC;AAC9B,UAAM,IAAIG,KAAJ,CAAU,0DAAV,CAAN;AACD;AACD,MAAIC,QAAQ,IAAZ;AACA,SAAO,SAASC,SAAT,GAA4B;AAAA,sCAANC,IAAM;AAANA,UAAM;AAAA;;AACjC,QAAMC,UAAU,IAAhB;AACA,QAAMC,UAAUN,aAAa,CAACE,KAA9B;AACA,QAAMK,QAAQ,SAARA,KAAQ,GAAM;AAClBL,cAAQ,IAAR;AACA,UAAI,CAACI,OAAL,EAAcR,KAAKU,KAAL,CAAWH,OAAX,EAAoBD,IAApB;AACf,KAHD;AAIAK,iBAAaP,KAAb;AACAA,YAAQQ,WAAWH,KAAX,EAAkBR,SAAlB,CAAR;AACA,QAAIO,OAAJ,EAAaR,KAAKU,KAAL,CAAWH,OAAX,EAAoBD,IAApB;AACd,GAVD;AAWD","file":"debounce.js","sourcesContent":["/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @param {Function} func - target function\n * @param {Number} threshold - execution threshold\n * @param {Boolean} immediate - trigger on leading edge\n * @return {Function}\n */\nexport default function debounce(func, threshold = 500, immediate = false) {\n  if (typeof func !== 'function') {\n    throw new Error('First argument of debounce function should be a function');\n  }\n  let timer = null;\n  return function debounced(...args) {\n    const context = this;\n    const callNow = immediate && !timer;\n    const later = () => {\n      timer = null;\n      if (!callNow) func.apply(context, args);\n    };\n    clearTimeout(timer);\n    timer = setTimeout(later, threshold);\n    if (callNow) func.apply(context, args);\n  };\n}\n"]}