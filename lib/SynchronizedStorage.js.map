{"version":3,"sources":["lib/SynchronizedStorage.ts"],"names":["SynchronizedStorage","storageKey","_storageKey","_id","_localStorage","_storageHandler","Error","uuid","v4","localStorage","window","event","key","substring","length","JSON","parse","newValue","setter","value","id","emit","error","addEventListener","MemoryStorage","len","keys","i","push","output","getLocalStorageKeys","forEach","dataKey","getItem","undefined","setItem","stringify","removeItem","removeEventListener","EventEmitter"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;IAEaA,mB;;;;;AASX,qCAAoD;AAAA;;AAAA,QAAtCC,UAAsC,QAAtCA,UAAsC;;AAAA;;AAClD;AADkD,UAL5CC,WAK4C;AAAA,UAJ5CC,GAI4C;AAAA,UAH5CC,aAG4C;AAAA,UAF5CC,eAE4C;;AAElD,QAAI,CAACJ,UAAL,EAAiB;AACf,YAAMK,KAAK,CAAC,wDAAD,CAAX;AACD;;AACD,UAAKJ,WAAL,GAAmBD,UAAnB;AACA,UAAKE,GAAL,GAAWI,IAAI,CAACC,EAAL,EAAX;;AACA,QAAI,OAAOC,YAAP,KAAwB,WAAxB,IAAuC,OAAOC,MAAP,KAAkB,WAA7D,EAA0E;AACxE,YAAKL,eAAL,GAAuB,UAACM,KAAD,EAAW;AAChC,YACEA,KAAK,CAACC,GAAN,KAAc,IAAd,IACA,OAAOD,KAAK,CAACC,GAAb,KAAqB,WADrB,IAEAD,KAAK,CAACC,GAAN,CAAUC,SAAV,CAAoB,CAApB,EAAuB,MAAKX,WAAL,CAAiBY,MAAxC,MAAoD,MAAKZ,WAH3D,EAIE;AACA,cAAI;AAAA,8BACwBa,IAAI,CAACC,KAAL,CAAWL,KAAK,CAACM,QAAjB,CADxB;AAAA,gBACMC,MADN,eACMA,MADN;AAAA,gBACcC,KADd,eACcA,KADd;;AAEF,gBAAID,MAAM,IAAIA,MAAM,KAAK,MAAKE,EAA9B,EAAkC;AAChC,kBAAMR,GAAG,GAAGD,KAAK,CAACC,GAAN,CAAUC,SAAV,CAAoB,MAAKX,WAAL,CAAiBY,MAAjB,GAA0B,CAA9C,CAAZ,CADgC,CAEhC;AACA;AACA;;AACA,oBAAKO,IAAL,CAAU,SAAV,EAAqB;AACnBT,gBAAAA,GAAG,EAAHA,GADmB;AAEnBO,gBAAAA,KAAK,EAALA;AAFmB,eAArB,EALgC,CAShC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACD;AACF,WApBD,CAoBE,OAAOG,KAAP,EAAc;AACd;AACD;AACF;AACF,OA9BD;;AA+BA,YAAKlB,aAAL,GAAqBK,YAArB;AACAC,MAAAA,MAAM,CAACa,gBAAP,CAAwB,SAAxB,EAAmC,MAAKlB,eAAxC;AACD,KAlCD,MAkCO;AACL,YAAKD,aAAL,GAAqB,IAAIoB,4BAAJ,EAArB;AACD;;AA3CiD;AA4CnD;;;;0CAEqB;AACpB,UAAMC,GAAG,GAAG,KAAKrB,aAAL,CAAmBU,MAA/B;AACA,UAAMY,IAAI,GAAG,EAAb;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,IAAI,CAA9B,EAAiC;AAC/B,YAAMf,GAAG,GAAG,KAAKR,aAAL,CAAmBQ,GAAnB,CAAuBe,CAAvB,CAAZ;;AACA,YAAIf,GAAG,IAAIA,GAAG,KAAK,EAAnB,EAAuB;AACrBc,UAAAA,IAAI,CAACE,IAAL,CAAUhB,GAAV;AACD;AACF;;AACD,aAAOc,IAAP;AACD;;;8BAES;AAAA;;AACR,UAAMG,MAA4C,GAAG,EAArD;AACA,WAAKC,mBAAL,GAA2BC,OAA3B,CAAmC,UAACnB,GAAD,EAAS;AAC1C,YAAIA,GAAG,CAACC,SAAJ,CAAc,CAAd,EAAiB,MAAI,CAACX,WAAL,CAAiBY,MAAlC,MAA8C,MAAI,CAACZ,WAAvD,EAAoE;AAClE,cAAM8B,OAAO,GAAGpB,GAAG,CAACC,SAAJ,CAAc,MAAI,CAACX,WAAL,CAAiBY,MAAjB,GAA0B,CAAxC,CAAhB;AACAe,UAAAA,MAAM,CAACG,OAAD,CAAN,GAAkB,MAAI,CAACC,OAAL,CAAaD,OAAb,CAAlB;AACD;AACF,OALD;AAMA,aAAOH,MAAP;AACD;;;4BAEOjB,G,EAAa;AACnB,UAAI;AAAA,2BAC6BG,IAAI,CAACC,KAAL,CAC7B,KAAKZ,aAAL,CAAmB6B,OAAnB,WAA8B,KAAK/B,WAAnC,cAAkDU,GAAlD,EAD6B,CAD7B;AAAA,YACMO,KADN,gBACMA,KADN;;AAIF,eAAOA,KAAP;AACD,OALD,CAKE,OAAOG,KAAP,EAAc;AACd,eAAOY,SAAP;AACD;AACF;;;4BAEOtB,G,EAAaO,K,EAA6B;AAChD,WAAKf,aAAL,CAAmB+B,OAAnB,WACK,KAAKjC,WADV,cACyBU,GADzB,GAEEG,IAAI,CAACqB,SAAL,CAAe;AACbjB,QAAAA,KAAK,EAALA,KADa;AAEbD,QAAAA,MAAM,EAAE,KAAKE;AAFA,OAAf,CAFF;AAOD;;;+BAEUR,G,EAAa;AACtB,WAAKR,aAAL,CAAmBiC,UAAnB,WAAiC,KAAKnC,WAAtC,cAAqDU,GAArD;AACD;;;8BAES;AACR,UAAI,KAAKP,eAAT,EAA0B;AACxBK,QAAAA,MAAM,CAAC4B,mBAAP,CAA2B,SAA3B,EAAsC,KAAKjC,eAA3C;AACD;AACF;;;wBAEQ;AACP,aAAO,KAAKF,GAAZ;AACD;;;wBAEY;AACX,UAAI,KAAKC,aAAL,KAAuBK,YAA3B,EAAyC;AACvC,eAAO,cAAP;AACD;;AACD,aAAO,eAAP;AACD;;;;EArHO8B,oB","sourcesContent":["import { EventEmitter } from 'events';\nimport * as uuid from 'uuid';\n\nimport {\n  GenericStorage,\n  StorageItem,\n} from '../interfaces/GenericStorage.interface';\nimport { MemoryStorage } from './MemoryStorage';\n\n// TODO: experiment with a managed list of keys to watch rather than matching every event with\n// storageKey might provide better performance\n\nexport class SynchronizedStorage\n  extends EventEmitter\n  implements GenericStorage\n{\n  private _storageKey: string;\n  private _id: string;\n  private _localStorage: Storage | MemoryStorage<string | null>;\n  private _storageHandler: (this: Window, ev: StorageEvent) => any;\n\n  constructor({ storageKey }: { storageKey: string }) {\n    super();\n    if (!storageKey) {\n      throw Error('SynchronizedStorage must be created with a storage key');\n    }\n    this._storageKey = storageKey;\n    this._id = uuid.v4();\n    if (typeof localStorage !== 'undefined' && typeof window !== 'undefined') {\n      this._storageHandler = (event) => {\n        if (\n          event.key !== null &&\n          typeof event.key !== 'undefined' &&\n          event.key.substring(0, this._storageKey.length) === this._storageKey\n        ) {\n          try {\n            const { setter, value } = JSON.parse(event.newValue);\n            if (setter && setter !== this.id) {\n              const key = event.key.substring(this._storageKey.length + 1);\n              // fire storage event directly from the native event\n              // may reduce the chance of failing to get updated data\n              // if there is heavy localStorage load\n              this.emit('storage', {\n                key,\n                value,\n              });\n              // It seems that IE11 does not update the actual localStorage object\n              // in the same event cycle...\n              // setTimeout(() => {\n              //   this.emit('storage', {\n              //     key,\n              //     value: this.getItem(key),\n              //   });\n              // }, 0);\n            }\n          } catch (error) {\n            /* ignore error */\n          }\n        }\n      };\n      this._localStorage = localStorage;\n      window.addEventListener('storage', this._storageHandler);\n    } else {\n      this._localStorage = new MemoryStorage();\n    }\n  }\n\n  getLocalStorageKeys() {\n    const len = this._localStorage.length;\n    const keys = [];\n    for (let i = 0; i < len; i += 1) {\n      const key = this._localStorage.key(i);\n      if (key && key !== '') {\n        keys.push(key);\n      }\n    }\n    return keys;\n  }\n\n  getData() {\n    const output: Record<string, StorageItem['value']> = {};\n    this.getLocalStorageKeys().forEach((key) => {\n      if (key.substring(0, this._storageKey.length) === this._storageKey) {\n        const dataKey = key.substring(this._storageKey.length + 1);\n        output[dataKey] = this.getItem(dataKey);\n      }\n    });\n    return output;\n  }\n\n  getItem(key: string) {\n    try {\n      const { value }: StorageItem = JSON.parse(\n        this._localStorage.getItem(`${this._storageKey}-${key}`),\n      );\n      return value;\n    } catch (error) {\n      return undefined;\n    }\n  }\n\n  setItem(key: string, value: StorageItem['value']) {\n    this._localStorage.setItem(\n      `${this._storageKey}-${key}`,\n      JSON.stringify({\n        value,\n        setter: this.id,\n      }),\n    );\n  }\n\n  removeItem(key: string) {\n    this._localStorage.removeItem(`${this._storageKey}-${key}`);\n  }\n\n  destroy() {\n    if (this._storageHandler) {\n      window.removeEventListener('storage', this._storageHandler);\n    }\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get driver() {\n    if (this._localStorage === localStorage) {\n      return 'LOCALSTORAGE';\n    }\n    return 'MEMORYSTORAGE';\n  }\n}\n"],"file":"SynchronizedStorage.js"}