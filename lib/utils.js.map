{"version":3,"sources":["lib/utils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;wEAeO,iBAAyB,EAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AACD,wBADC,GACc,CADd;AAED,sBAFC,GAEY,CAFZ;AAGD,gBAHC,GAGM,EAHN;;AAAA;AAAA,kBAIE,eAAe,UAJjB;AAAA;AAAA;AAAA;;AAKH;AALG;AAAA,mBAMgB,GAAG;AACpB,oBAAM;AADc,aAAH,CANhB;;AAAA;AAMG,gBANH;;AASH,yBAAa,KAAK,MAAL,CAAY,UAAzB;AACA,mBAAO,KAAK,MAAL,CAAY,KAAK,OAAjB,CAAP;AAVG;AAAA;;AAAA;AAAA,6CAYE,IAZF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,S;;;;;AAetB;;;;;;;;AAWA;;;;;yEAIO,kBAAqB,CAArB;AAAA;AAAA;AAAA;AAAA;AAAA,8CACE,sBAAY,mBAAW;AAC5B,yBAAW,OAAX,EAAoB,CAApB;AACD,aAFM,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,K;;;;;QA7CN,W,GAAA,W;QAoCA,I,GAAA,I;;;;AApCT,SAAS,WAAT,CAAqB,KAArB,EAA4B;AACjC,MAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,WAAO,MAAM,GAAN,CAAU;AAAA,aAAQ,YAAY,IAAZ,CAAR;AAAA,KAAV,CAAP;AACD,GAFD,MAEO,IAAI,QAAO,KAAP,uDAAO,KAAP,OAAiB,QAArB,EAA+B;AACpC,QAAM,OAAO,EAAb;AACA,SAAK,IAAM,GAAX,IAAkB,KAAlB,EAAyB;AACvB,UAAI,IAAI,CAAJ,MAAW,GAAX,IAAkB,MAAM,cAAN,CAAqB,GAArB,CAAtB,EAAiD;AAC/C,aAAK,GAAL,IAAY,YAAY,MAAM,GAAN,CAAZ,CAAZ;AACD;AACF;AACD,WAAO,IAAP;AACD;AACD,SAAO,KAAP;AACD;;AAuBM,SAAS,IAAT,CAAc,SAAd,EAAyB,KAAzB,EAA6C;AAAA,oCAAV,QAAU;AAAV,YAAU;AAAA;;AAClD,OAAK,IAAL,cAAU,KAAV,SAAoB,QAApB;AACA,OAAK,IAAL,cAAU,SAAV,EAAqB,KAArB,SAA+B,QAA/B;AACD","file":"utils.js","sourcesContent":["export function extractData(model) {\n  if (Array.isArray(model)) {\n    return model.map(item => extractData(item));\n  } else if (typeof model === 'object') {\n    const data = {};\n    for (const key in model) {\n      if (key[0] !== '_' && model.hasOwnProperty(key)) {\n        data[key] = extractData(model[key]);\n      }\n    }\n    return data;\n  }\n  return model;\n}\n\nexport async function fetchList(fn) {\n  let fetchedPages = 0;\n  let totalPages = 1;\n  let list = [];\n  while (fetchedPages < totalPages) {\n    fetchedPages++;\n    const data = await fn({\n      page: fetchedPages,\n    });\n    totalPages = data.paging.totalPages;\n    list = list.concat(data.records);\n  }\n  return list;\n}\n\n/**\n * @function\n * @param {String} eventType\n * @param {String} event\n * @description Helper function to emit eventTyped events and the event itself\n */\nexport function emit(eventType, event, ...payloads) {\n  this.emit(event, ...payloads);\n  this.emit(eventType, event, ...payloads);\n}\n\n/**\n * @function\n * @param {Number} t\n */\nexport async function sleep(t) {\n  return new Promise(resolve => {\n    setTimeout(resolve, t);\n  });\n}\n"]}