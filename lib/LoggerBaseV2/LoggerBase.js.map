{"version":3,"sources":["lib/LoggerBaseV2/LoggerBase.ts"],"names":["LoggerBase","that","loggingList","deps","options","_identityFunction","defaultIdentityFunction","_logFunction","_readyCheckFunction","_logPromises","Map","id","indexOf","push","filter","item","ready","resetLoggingList","Error","constructor","name","has","get","setLoggingList","promise","set","filterLoggingListById","_log","RcModuleV2","state","action","proxify"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAOA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAEsBA,U,WA+FnB,oBAAS,UAACC,IAAD;AAAA,SAAsB,CAACA,IAAI,CAACC,WAAN,CAAtB;AAAA,CAAT,C;;;;;AArFD,sBAAYC,IAAZ,EAAqBC,OAArB,EAAuC;AAAA;;AAAA;;AACrC;AACED,MAAAA,IAAI,EAAJA;AADF,OAEKC,OAFL;AADqC,UAT7BC,iBAS6B,GARrCC,yCAQqC;AAAA,UAN9BC,YAM8B;AAAA,UAJ9BC,mBAI8B;AAAA,UAF7BC,YAE6B,GAFd,IAAIC,GAAJ,EAEc;;AAAA;;AAAA;AAKtC;;;;mCAMcC,E,EAAY;AACzB,UAAI,KAAKT,WAAL,CAAiBU,OAAjB,CAAyBD,EAAzB,MAAiC,CAAC,CAAtC,EAAyC;AACvC,aAAKT,WAAL,CAAiBW,IAAjB,CAAsBF,EAAtB;AACD;AACF;;;0CAGqBA,E,EAAY;AAChC,WAAKT,WAAL,GAAmB,KAAKA,WAAL,CAAiBY,MAAjB,CAAwB,UAACC,IAAD;AAAA,eAAUA,IAAI,KAAKJ,EAAnB;AAAA,OAAxB,CAAnB;AACD;;;uCAGkB;AACjB,WAAKT,WAAL,GAAmB,EAAnB;AACD;;;kCAEa;AACZ,aAAO,CAAC,EAAE,+EAAuB,KAAKM,mBAAL,EAAzB,CAAR;AACD;;;mCAEc;AACb,aAAO,CAAC,EACN,gFACC,KAAKQ,KAAL,IAAc,CAAC,KAAKR,mBAAL,EAFV,CAAR;AAID;;;8BAES;AACR,WAAKS,gBAAL;AACD;;;;;;;;;;AAGkBF,gBAAAA,I,QAAAA,I,EAASX,O;;oBACrB,KAAKY,K;;;;;sBACF,IAAIE,KAAJ,WAAa,KAAKC,WAAL,CAAiBC,IAA9B,iC;;;oBAEHL,I;;;;;sBACG,IAAIG,KAAJ,WACD,KAAKC,WAAL,CAAiBC,IADhB,uC;;;AAKFT,gBAAAA,E,GAAK,KAAKN,iBAAL,CAAuBU,IAAvB,C,EACX;;qBACI,KAAKN,YAAL,CAAkBY,GAAlB,CAAsBV,EAAtB,C;;;;;;uBACI,KAAKF,YAAL,CAAkBa,GAAlB,CAAsBX,EAAtB,C;;;;AAGN,qBAAKY,cAAL,CAAoBZ,EAApB;AACMa,gBAAAA,O,GAAU,KAAKjB,YAAL;AAAoBQ,kBAAAA,IAAI,EAAJA;AAApB,mBAA6BX,OAA7B,E;;AAChB,qBAAKK,YAAL,CAAkBgB,GAAlB,CAAsBd,EAAtB,EAA0Ba,OAA1B;;;uBACMA,O;;;AACN,qBAAKf,YAAL,WAAyBE,EAAzB;;AACA,qBAAKe,qBAAL,CAA2Bf,EAA3B;;;;;;;;AAEA,qBAAKF,YAAL,WAAyBE,EAAzB;;AACA,qBAAKe,qBAAL,CAA2Bf,EAA3B;;;;;;;;;;;;;;;;;;;;;;;;;;AAMcI,gBAAAA,I,SAAAA,I,EAASX,O;;oBACpB,KAAKY,K;;;;;sBACF,IAAIE,KAAJ,WAAa,KAAKC,WAAL,CAAiBC,IAA9B,gC;;;oBAEHL,I;;;;;sBACG,IAAIG,KAAJ,WACD,KAAKC,WAAL,CAAiBC,IADhB,sC;;;;uBAIF,KAAKO,IAAL;AAAYZ,kBAAAA,IAAI,EAAJA;AAAZ,mBAAqBX,OAArB,E;;;;;;;;;;;;;;;;;;wBAIS;AACf,aAAO,wCAAiB,KAAKF,WAAtB,CAAP;AACD;;;;EAlG6D0B,gB,8EAiB7DC,W;;;;;WACuB,E;;mEAEvBC,Y,iKAOAA,Y,mKAKAA,Y,kJAoBAC,gB,qIA8BAA,gB","sourcesContent":["import {\n  action,\n  computed,\n  RcModuleV2,\n  state,\n} from '@ringcentral-integration/core';\n\nimport { proxify } from '../proxy/proxify';\nimport { Deps, LogOptions, Options } from './LoggerBase.interface';\nimport { convertListToMap, defaultIdentityFunction } from './loggerBaseHelper';\n\nexport abstract class LoggerBase<T extends Deps = Deps> extends RcModuleV2<T> {\n  protected _identityFunction: (...args: any) => string =\n    defaultIdentityFunction;\n\n  abstract _logFunction: <P, S>(options: LogOptions<P, S>) => Promise<void>;\n\n  abstract _readyCheckFunction: () => boolean;\n\n  protected _logPromises = new Map<string, Promise<void>>();\n\n  constructor(deps: T, options: Options) {\n    super({\n      deps,\n      ...options,\n    });\n  }\n\n  @state\n  loggingList: string[] = [];\n\n  @action\n  setLoggingList(id: string) {\n    if (this.loggingList.indexOf(id) === -1) {\n      this.loggingList.push(id);\n    }\n  }\n\n  @action\n  filterLoggingListById(id: string) {\n    this.loggingList = this.loggingList.filter((item) => item !== id);\n  }\n\n  @action\n  resetLoggingList() {\n    this.loggingList = [];\n  }\n\n  _shouldInit() {\n    return !!(super._shouldInit() && this._readyCheckFunction());\n  }\n\n  _shouldReset() {\n    return !!(\n      super._shouldReset() ||\n      (this.ready && !this._readyCheckFunction())\n    );\n  }\n\n  onReset() {\n    this.resetLoggingList();\n  }\n\n  @proxify\n  async _log<P, S>({ item, ...options }: LogOptions<P, S>) {\n    if (!this.ready) {\n      throw new Error(`${this.constructor.name}._log: module is not ready.`);\n    }\n    if (!item) {\n      throw new Error(\n        `${this.constructor.name}._log: options.item is undefined.`,\n      );\n    }\n\n    const id = this._identityFunction(item);\n    // wait for the previous log action to finish\n    if (this._logPromises.has(id)) {\n      await this._logPromises.get(id);\n    }\n    try {\n      this.setLoggingList(id);\n      const promise = this._logFunction({ item, ...options });\n      this._logPromises.set(id, promise);\n      await promise;\n      this._logPromises.delete(id);\n      this.filterLoggingListById(id);\n    } catch (error) {\n      this._logPromises.delete(id);\n      this.filterLoggingListById(id);\n      throw error;\n    }\n  }\n\n  @proxify\n  async log<P, S>({ item, ...options }: LogOptions<P, S>) {\n    if (!this.ready) {\n      throw new Error(`${this.constructor.name}.log: module is not ready.`);\n    }\n    if (!item) {\n      throw new Error(\n        `${this.constructor.name}.log: options.item is undefined.`,\n      );\n    }\n    await this._log({ item, ...options });\n  }\n\n  @computed((that: LoggerBase) => [that.loggingList])\n  get loggingMap() {\n    return convertListToMap(this.loggingList);\n  }\n}\n"],"file":"LoggerBase.js"}