{"version":3,"sources":["lib/usm-redux/decorators/action.ts"],"names":["action","target","key","descriptor","fn","value","Error","String","args","time","process","env","NODE_ENV","Date","now","lastState","storeKey","getState","state","patches","inversePatches","recipe","draftState","apply","enablePatches","undefined","changed","console","warn","identifierKey","toString","executionTime","type","method","params","_state","_usm","usm","_patches","_inversePatches","requiredWarning","dispatch"],"mappings":"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","sourcesContent":["/* eslint-disable func-names */\nimport { produceWithPatches, produce, Patch } from 'immer';\nimport { Service, Action } from '../interface';\nimport { storeKey, identifierKey, usm } from '../constant';\nimport { getPatchesToggle } from '../createStore';\nimport { getStagedState, setStagedState } from '../utils/index';\nimport { checkPatches } from '../checkPatches';\n\nexport const action = (\n  target: object,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => void>,\n) => {\n  const fn = descriptor.value;\n  if (typeof fn !== 'function') {\n    throw new Error(\n      `${String(key)} can only be decorated by '@action' as a class method.`,\n    );\n  }\n  const value = function (this: Service, ...args: unknown[]) {\n    let time: number;\n    if (process.env.NODE_ENV === 'development') {\n      time = Date.now();\n    }\n    if (typeof getStagedState() === 'undefined') {\n      try {\n        const lastState = this[storeKey].getState();\n        let state: Record<string, any> | undefined;\n        let patches: Patch[] = [];\n        let inversePatches: Patch[] = [];\n        const recipe = (draftState: Record<string, unknown>) => {\n          setStagedState(draftState);\n          fn.apply(this, args);\n        };\n        const enablePatches = getPatchesToggle();\n        if (enablePatches) {\n          [state, patches, inversePatches] = produceWithPatches(\n            lastState,\n            recipe,\n          );\n        } else {\n          state = produce(lastState, recipe);\n        }\n        setStagedState(undefined);\n        const changed = lastState !== state;\n        if (process.env.NODE_ENV === 'development') {\n          if (!changed) {\n            console.warn(\n              `There are no state updates to method '${\n                this[identifierKey]\n              }.${key.toString()}' with arguments:`,\n              ...args,\n            );\n          }\n          // performance checking\n          const executionTime = Date.now() - time!;\n          if (executionTime > 100)\n            console.warn(\n              `The execution time of method '${\n                this[identifierKey]\n              }.${key.toString()}' is ${executionTime} ms, it's recommended to use 'dispatch' API.`,\n            );\n          // performance detail: https://immerjs.github.io/immer/docs/performance\n        }\n\n        if (changed) {\n          const action: Action = {\n            type: this[identifierKey],\n            method: key,\n            params: args,\n            _state: state,\n            _usm: usm,\n            ...(enablePatches\n              ? {\n                  _patches: patches,\n                  _inversePatches: inversePatches,\n                }\n              : {}),\n          };\n          if (process.env.NODE_ENV === 'development') {\n            const requiredWarning = checkPatches(lastState, action);\n            if (requiredWarning) {\n              console.warn(\n                `The state update operation in the method '${this[\n                  identifierKey\n                ].toString()}.${key.toString()}'  is a replacement update operation. If there is a performance issue, be sure to use mutation updates to ensure the minimum set of update patches.`,\n              );\n            }\n          }\n          this[storeKey].dispatch(action);\n        }\n      } finally {\n        setStagedState(undefined);\n      }\n    } else {\n      // enable staged state mode.\n      fn.apply(this, args);\n    }\n  };\n  return {\n    ...descriptor,\n    value,\n  };\n};\n"],"file":"action.js"}