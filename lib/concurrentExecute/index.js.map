{"version":3,"sources":["lib/concurrentExecute/index.ts"],"names":["concurrentExecute","promiseThunks","concurrency","delay","options","promise","Promise","delayFn","sleep","Array","isArray","length","Error","all","map","_promise","apply","slice","current","rest"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;SAC8BA,iB;;;;;+EAAf,iBACbC,aADa,EAEbC,WAFa,EAGbC,KAHa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIbC,YAAAA,OAJa,2DAOT,EAPS;AAAA,+BASkCA,OATlC,CASLC,OATK,EASLA,OATK,iCASKC,OATL,wCASkCF,OATlC,CAScG,OATd,EAScA,OATd,iCASwBC,YATxB;;AAAA,kBAUT,CAACC,KAAK,CAACC,OAAN,CAAcT,aAAd,CAAD,IAAiCA,aAAa,CAACU,MAAd,IAAwB,CAVhD;AAAA;AAAA;AAAA;;AAAA,6CAWJ,EAXI;;AAAA;AAAA,kBAaT,OAAOV,aAAa,CAAC,CAAD,CAApB,KAA4B,UAbnB;AAAA;AAAA;AAAA;;AAAA,kBAcL,IAAIW,KAAJ,CAAU,uCAAV,CAdK;;AAAA;AAAA,kBAgBTX,aAAa,CAACU,MAAd,IAAwBT,WAhBf;AAAA;AAAA;AAAA;;AAAA,6CAiBJG,OAAO,CAACQ,GAAR,CAAYZ,aAAa,CAACa,GAAd,CAAkB,UAACC,QAAD;AAAA,qBAAcA,QAAQ,CAACC,KAAT,CAAe,IAAf,CAAd;AAAA,aAAlB,CAAZ,CAjBI;;AAAA;AAAA;AAAA,mBAmBchB,iBAAiB,CAC1CC,aAAa,CAACgB,KAAd,CAAoB,CAApB,EAAuBf,WAAvB,CAD0C,EAE1CA,WAF0C,EAG1CC,KAH0C,EAI1CC,OAJ0C,CAnB/B;;AAAA;AAmBPc,YAAAA,OAnBO;;AAAA,iBAyBTf,KAzBS;AAAA;AAAA;AAAA;;AAAA;AAAA,mBA0BLI,OAAO,CAACJ,KAAD,CA1BF;;AAAA;AAAA;AAAA,mBA4BWH,iBAAiB,CACvCC,aAAa,CAACgB,KAAd,CAAoBf,WAApB,CADuC,EAEvCA,WAFuC,EAGvCC,KAHuC,EAIvCC,OAJuC,CA5B5B;;AAAA;AA4BPe,YAAAA,IA5BO;AAAA,0EAkCFD,OAlCE,sBAkCUC,IAlCV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import { sleep } from '../sleep';\n\ntype PromiseThunks<T> = (() => Promise<T>)[];\n\n/**\n * With concurrentExecute helper function, you could control\n * the concurrency and delay of your Promise.all execution.\n * @param {Array<Function>} promiseThunks A set of thunk functions of Promise\n * @param {Number} concurrency Concurrent granularity\n * @param {Number} delay Batch execution delay\n * @param {Function} delayFn Specify your own delay function\n */\nexport default async function concurrentExecute<T>(\n  promiseThunks: PromiseThunks<T>,\n  concurrency: number,\n  delay: number,\n  options: {\n    promise?: PromiseConstructor;\n    delayFn?: (...args: any) => Promise<void>;\n  } = {},\n) {\n  const { promise = Promise, delayFn = sleep } = options;\n  if (!Array.isArray(promiseThunks) || promiseThunks.length <= 0) {\n    return [];\n  }\n  if (typeof promiseThunks[0] !== 'function') {\n    throw new Error('concurrentExecute needs promise thunk');\n  }\n  if (promiseThunks.length <= concurrency) {\n    return promise.all(promiseThunks.map((_promise) => _promise.apply(null)));\n  }\n  const current: T[] = await concurrentExecute(\n    promiseThunks.slice(0, concurrency),\n    concurrency,\n    delay,\n    options,\n  );\n  if (delay) {\n    await delayFn(delay);\n  }\n  const rest: T[] = await concurrentExecute(\n    promiseThunks.slice(concurrency),\n    concurrency,\n    delay,\n    options,\n  );\n  return [...current, ...rest];\n}\n"],"file":"index.js"}