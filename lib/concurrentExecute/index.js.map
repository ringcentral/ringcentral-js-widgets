{"version":3,"sources":["lib/concurrentExecute/index.js"],"names":["sleep","resolve","setTimeout","t","promiseThunks","concurrency","delay","options","promise","delayFn","Array","isArray","length","Error","all","map","_promise","apply","concurrentExecute","slice","current","rest"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,QAAQ,SAARA,KAAQ;AAAA,SAAK,sBAAY,UAACC,OAAD,EAAa;AAC1CC,eAAW;AAAA,aAAMD,SAAN;AAAA,KAAX,EAA4BE,CAA5B;AACD,GAFkB,CAAL;AAAA,CAAd;;AAIA;;;;;;;;;;wEAQe,iBACbC,aADa,EAEbC,WAFa,EAGbC,KAHa;AAAA;;AAAA,QAIbC,OAJa,uEAIH,EAJG;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,+BAMkCA,OANlC,CAMLC,OANK,EAMLA,OANK,6FAMkCD,OANlC,CAMcE,OANd,EAMcA,OANd,oCAMwBT,KANxB;;AAAA,kBAOT,CAACU,MAAMC,OAAN,CAAcP,aAAd,CAAD,IAAiCA,cAAcQ,MAAd,IAAwB,CAPhD;AAAA;AAAA;AAAA;;AAAA,6CAQJ,EARI;;AAAA;AAAA,kBAUT,OAAOR,cAAc,CAAd,CAAP,KAA4B,UAVnB;AAAA;AAAA;AAAA;;AAAA,kBAWL,IAAIS,KAAJ,CAAU,uCAAV,CAXK;;AAAA;AAAA,kBAaTT,cAAcQ,MAAd,IAAwBP,WAbf;AAAA;AAAA;AAAA;;AAAA,6CAcJG,QAAQM,GAAR,CAAYV,cAAcW,GAAd,CAAkB;AAAA,qBAAYC,SAASC,KAAT,OAAZ;AAAA,aAAlB,CAAZ,CAdI;;AAAA;AAAA;AAAA,mBAgBSC,kBACpBd,cAAce,KAAd,CAAoB,CAApB,EAAuBd,WAAvB,CADoB,EAEpBA,WAFoB,EAGpBC,KAHoB,EAIpBC,OAJoB,CAhBT;;AAAA;AAgBPa,mBAhBO;;AAAA,iBAsBTd,KAtBS;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAuBLG,QAAQH,KAAR,CAvBK;;AAAA;AAAA;AAAA,mBAyBMY,kBACjBd,cAAce,KAAd,CAAoBd,WAApB,CADiB,EAEjBA,WAFiB,EAGjBC,KAHiB,EAIjBC,OAJiB,CAzBN;;AAAA;AAyBPc,gBAzBO;AAAA,wFA+BFD,OA/BE,oCA+BUC,IA/BV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;WAAeH,iB;;;;SAAAA,iB","file":"index.js","sourcesContent":["const sleep = t => new Promise((resolve) => {\n  setTimeout(() => resolve(), t);\n});\n\n/**\n * With concurrentExecute helper function, you could control\n * the concurrency and delay of your Promise.all execution.\n * @param {Array<Function>} promiseThunks A set of thunk functions of Promise\n * @param {Number} concurrency Concurrent granularity\n * @param {Number} delay Batch execution delay\n * @param {Function} delayFn Specify your own delay function\n */\nexport default async function concurrentExecute(\n  promiseThunks,\n  concurrency,\n  delay,\n  options = {}\n) {\n  const { promise = Promise, delayFn = sleep } = options;\n  if (!Array.isArray(promiseThunks) || promiseThunks.length <= 0) {\n    return [];\n  }\n  if (typeof promiseThunks[0] !== 'function') {\n    throw new Error('concurrentExecute needs promise thunk');\n  }\n  if (promiseThunks.length <= concurrency) {\n    return promise.all(promiseThunks.map(_promise => _promise.apply(this)));\n  }\n  const current = await concurrentExecute(\n    promiseThunks.slice(0, concurrency),\n    concurrency,\n    delay,\n    options\n  );\n  if (delay) {\n    await delayFn(delay);\n  }\n  const rest = await concurrentExecute(\n    promiseThunks.slice(concurrency),\n    concurrency,\n    delay,\n    options\n  );\n  return [...current, ...rest];\n}\n"]}