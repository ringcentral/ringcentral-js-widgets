{"version":3,"sources":["lib/di/registry/registry.ts"],"names":["Registry","klass","metadata","deps","name","JSON","stringify","Object","keys","length","moduleRegistry","set","providers","providerRegistry","currentClass","parentClass","has","resolved","get","moduleProviderMetadata","hasProviders","providerMetadata","mergeProviders","resolveInheritedModuleFactory","resolve","assign","moduleMetadata","hasDeps","mergeDependencies","resolveInheritedDependencies","formatted","provide","useClass","baseProvider","parentProvider","merged","Map","pp","_formatClassProvider","p","useValue","merge","Array","from","values","baseDeps","parentDeps","parent","dep","optional","base","ModuleRegistry","ProviderRegistry"],"mappings":"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","sourcesContent":["import { isArray, isFunction, isObject } from '../utils/is_type';\nimport { assert, getParentClass } from '../utils/utils';\nimport ModuleRegistry from './module_registry';\nimport ProviderRegistry from './provider_registry';\n\nexport default class Registry {\n  static moduleRegistry = new ModuleRegistry();\n  static providerRegistry = new ProviderRegistry();\n\n  static registerModule(klass, metadata) {\n    assert(isFunction(klass), 'Expected module to be a Class');\n    if (metadata) {\n      assert(\n        isObject(metadata),\n        'Expected parameter of @Module() to be an Object',\n      );\n      if (metadata.deps) {\n        assert(\n          isArray(metadata.deps),\n          `Expected deps to be an Array: [${klass.name}]\n          ${JSON.stringify(metadata)}`,\n        );\n      }\n    }\n    if (!metadata || Object.keys(metadata).length <= 0) {\n      metadata = null;\n    }\n    this.moduleRegistry.set(klass, metadata);\n  }\n\n  static registerModuleFactory(klass, metadata) {\n    assert(klass && isFunction(klass), 'Expected moduleFactory to be a Class');\n\n    if (metadata) {\n      assert(\n        isObject(metadata),\n        'Expected parameter of @ModuleFactory() to be an Object',\n      );\n      if (metadata.providers && !isArray(metadata.providers)) {\n        assert(\n          isArray(metadata.providers),\n          'Expected providers in @ModuleFactory() to be an Array',\n        );\n      }\n    } else {\n      metadata = null;\n    }\n    // TODO: validate module providers\n    // useValue should be object or number or string, etc.\n    // spread can only be used if useValue is an object.\n    // Not to check it for now, maybe cause performance issue\n    this.providerRegistry.set(klass, metadata);\n  }\n\n  /**\n   * Process the inheritance relationship of ModuleFactory.\n   * Support some inheritance options such as overwrite, merge, etc.\n   * ModuleFactory can only inherit from ModuleFactory.\n   * @param {Class} currentClass\n   */\n  static resolveInheritedModuleFactory(currentClass) {\n    const parentClass = getParentClass(currentClass);\n    if (!this.providerRegistry.has(currentClass)) return [];\n    if (this.providerRegistry.resolved(currentClass)) {\n      return this.providerRegistry.get(currentClass).providers;\n    }\n    const moduleProviderMetadata = this.providerRegistry.get(currentClass);\n    const hasProviders =\n      moduleProviderMetadata && isArray(moduleProviderMetadata.providers);\n    const providerMetadata = this.mergeProviders(\n      hasProviders ? moduleProviderMetadata.providers : [],\n      this.resolveInheritedModuleFactory(parentClass),\n    );\n    this.providerRegistry.resolve(\n      currentClass,\n      Object.assign({}, moduleProviderMetadata, {\n        providers: providerMetadata,\n      }),\n    );\n    return providerMetadata;\n  }\n\n  /**\n   * Process the inheritance relationship of Module and Library.\n   * Module can inherit from Module and Library.\n   * @param {Class} currentClass\n   * @return {Array} deps - resolved deps\n   */\n  static resolveInheritedDependencies(currentClass) {\n    const parentClass = getParentClass(currentClass);\n    if (!this.moduleRegistry.has(currentClass)) return [];\n    if (this.moduleRegistry.resolved(currentClass)) {\n      return this.moduleRegistry.get(currentClass).deps;\n    }\n    const moduleMetadata = this.moduleRegistry.get(currentClass);\n    const hasDeps = moduleMetadata && isArray(moduleMetadata.deps);\n    const deps = this.mergeDependencies(\n      hasDeps ? moduleMetadata.deps : [],\n      this.resolveInheritedDependencies(parentClass),\n    );\n    // Update parent class metadata\n    this.moduleRegistry.resolve(\n      currentClass,\n      Object.assign({}, moduleMetadata, {\n        deps,\n      }),\n    );\n    return deps;\n  }\n\n  /**\n   * A helper function for formating class provider metadata.\n   * @param {Object|Function} providerMetadata\n   */\n  static _formatClassProvider(providerMetadata) {\n    let formatted = {};\n    if (isFunction(providerMetadata)) {\n      formatted = {\n        provide: providerMetadata.name,\n        useClass: providerMetadata,\n      };\n    } else if (isFunction(providerMetadata.provide)) {\n      formatted = {\n        provide: providerMetadata.provide.name,\n        useClass: providerMetadata.provide,\n      };\n    }\n    return Object.assign({}, providerMetadata, formatted);\n  }\n\n  /**\n   * A helper function for merging child and parent providers.\n   * @param {Object|Function} baseProvider\n   * @param {Object|Function} parentProvider\n   */\n  static mergeProviders(baseProvider, parentProvider) {\n    const merged = new Map();\n    for (let pp of parentProvider) {\n      pp = this._formatClassProvider(pp);\n      merged.set(pp.provide, pp);\n    }\n\n    // Merge child providers into parent providers\n    // Only support object shallow merge\n    for (let p of baseProvider) {\n      // useValue and don't overwrite parent values\n      const pp = merged.get(p.provide);\n      if (pp && p.useValue && p.merge) {\n        assert(\n          pp.useValue,\n          `Expected parent provider of [${p.provide}] to be a value provider`,\n        );\n        assert(\n          isObject(pp.useValue),\n          `Expected parent provider of [${p.provide}] to be an Object`,\n        );\n        p.useValue = Object.assign({}, pp.useValue, p.useValue);\n        merged.set(p.provide, Object.assign({}, pp, p));\n      } else {\n        // useClass, useExisting, useFactory will always overwrite parent provider\n        p = this._formatClassProvider(p);\n        merged.set(p.provide, Object.assign({}, pp, p));\n      }\n    }\n    return Array.from(merged.values());\n  }\n\n  /**\n   * A helper function for merging child and parent module dependencies.\n   * @param {Array} baseDeps\n   * @param {Array} parentDeps\n   */\n  static mergeDependencies(baseDeps, parentDeps) {\n    const merged = new Map();\n    // Deps preprocess\n    for (const parent of parentDeps) {\n      if (!isObject(parent)) {\n        merged.set(parent, { dep: parent, optional: false });\n      } else {\n        merged.set(parent.dep, parent);\n      }\n    }\n\n    for (let base of baseDeps) {\n      if (!isObject(base)) {\n        base = { dep: base, optional: false };\n      }\n      if (merged.has(base.dep)) {\n        merged.set(base.dep, {\n          dep: base.dep,\n          optional: base.optional && merged.get(base.dep).optional,\n        });\n      } else {\n        merged.set(base.dep, base);\n      }\n    }\n\n    return Array.from(merged.values());\n  }\n}\n"],"file":"registry.js"}