{"version":3,"sources":["lib/di/registry/registry.js"],"names":["Registry","klass","metadata","deps","name","length","moduleRegistry","set","providers","providerRegistry","currentClass","parentClass","has","resolved","get","moduleProviderMetadata","hasProviders","providerMetadata","mergeProviders","resolveInheritedModuleFactory","resolve","moduleMetadata","hasDeps","mergeDependencies","resolveInheritedDependencies","formatted","provide","useClass","baseProvider","parentProvider","merged","pp","_formatClassProvider","p","useValue","merge","values","baseDeps","parentDeps","parent","dep","optional","base"],"mappings":"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","file":"registry.js","sourcesContent":["import ModuleRegistry from './module_registry';\nimport ProviderRegistry from './provider_registry';\nimport { getParentClass, assert } from '../utils/utils';\nimport { isFunction, isArray, isObject } from '../utils/is_type';\n\nexport default class Registry {\n  static moduleRegistry = new ModuleRegistry();\n  static providerRegistry = new ProviderRegistry();\n\n  static registerModule(klass, metadata) {\n    assert(\n      isFunction(klass),\n      'Expected module to be a Class'\n    );\n    if (metadata) {\n      assert(\n        isObject(metadata),\n        'Expected parameter of @Module() to be an Object'\n      );\n      if (metadata.deps) {\n        assert(\n          isArray(metadata.deps),\n          `Expected deps to be an Array: [${klass.name}]\n          ${JSON.stringify(metadata)}`\n        );\n      }\n    }\n    if (!metadata || Object.keys(metadata).length <= 0) {\n      metadata = null;\n    }\n    this.moduleRegistry.set(klass, metadata);\n  }\n\n  static registerModuleFactory(klass, metadata) {\n    assert(\n      klass && isFunction(klass),\n      'Expected moduleFactory to be a Class'\n    );\n\n    if (metadata) {\n      assert(\n        isObject(metadata),\n        'Expected parameter of @ModuleFactory() to be an Object'\n      );\n      if (metadata.providers && !isArray(metadata.providers)) {\n        assert(\n          isArray(metadata.providers),\n          'Expected providers in @ModuleFactory() to be an Array'\n        );\n      }\n    } else {\n      metadata = null;\n    }\n    // TODO: validate module providers\n    // useValue should be object or number or string, etc.\n    // spread can only be used if useValue is an object.\n    // Not to check it for now, maybe cause performance issue\n    this.providerRegistry.set(klass, metadata);\n  }\n\n  /**\n   * Process the inheritance relationship of ModuleFactory.\n   * Support some inheritance options such as overwrite, merge, etc.\n   * ModuleFactory can only inherit from ModuleFactory.\n   * @param {Class} currentClass\n   */\n  static resolveInheritedModuleFactory(currentClass) {\n    const parentClass = getParentClass(currentClass);\n    if (!this.providerRegistry.has(currentClass)) return [];\n    else if (this.providerRegistry.resolved(currentClass)) {\n      return this.providerRegistry.get(currentClass).providers;\n    }\n    const moduleProviderMetadata = this.providerRegistry.get(currentClass);\n    const hasProviders = moduleProviderMetadata && isArray(moduleProviderMetadata.providers);\n    const providerMetadata = this.mergeProviders(\n      hasProviders ? moduleProviderMetadata.providers : [],\n      this.resolveInheritedModuleFactory(parentClass)\n    );\n    this.providerRegistry.resolve(\n      currentClass,\n      Object.assign({}, moduleProviderMetadata, {\n        providers: providerMetadata\n      })\n    );\n    return providerMetadata;\n  }\n\n  /**\n   * Process the inheritance relationship of Module and Library.\n   * Module can inherit from Module and Library.\n   * @param {Class} currentClass\n   * @return {Array} deps - resolved deps\n   */\n  static resolveInheritedDependencies(currentClass) {\n    const parentClass = getParentClass(currentClass);\n    if (!this.moduleRegistry.has(currentClass)) return [];\n    else if (this.moduleRegistry.resolved(currentClass)) {\n      return this.moduleRegistry.get(currentClass).deps;\n    }\n    const moduleMetadata = this.moduleRegistry.get(currentClass);\n    const hasDeps = moduleMetadata && isArray(moduleMetadata.deps);\n    const deps = this.mergeDependencies(\n      hasDeps ? moduleMetadata.deps : [],\n      this.resolveInheritedDependencies(parentClass)\n    );\n    // Update parent class metadata\n    this.moduleRegistry.resolve(\n      currentClass,\n      Object.assign({}, moduleMetadata, {\n        deps\n      })\n    );\n    return deps;\n  }\n\n  /**\n   * A helper function for formating class provider metadata.\n   * @param {Object|Function} providerMetadata\n   */\n  static _formatClassProvider(providerMetadata) {\n    let formatted = {};\n    if (isFunction(providerMetadata)) {\n      formatted = { provide: providerMetadata.name, useClass: providerMetadata };\n    } else if (isFunction(providerMetadata.provide)) {\n      formatted = { provide: providerMetadata.provide.name, useClass: providerMetadata.provide };\n    }\n    return Object.assign({}, providerMetadata, formatted);\n  }\n\n  /**\n   * A helper function for merging child and parent providers.\n   * @param {Object|Function} baseProvider\n   * @param {Object|Function} parentProvider\n   */\n  static mergeProviders(baseProvider, parentProvider) {\n    const merged = new Map();\n    for (let pp of parentProvider) {\n      pp = this._formatClassProvider(pp);\n      merged.set(pp.provide, pp);\n    }\n\n    // Merge child providers into parent providers\n    // Only support object shallow merge\n    for (let p of baseProvider) {\n      // useValue and don't overwrite parent values\n      const pp = merged.get(p.provide);\n      if (pp && p.useValue && p.merge) {\n        assert(pp.useValue, `Expected parent provider of [${p.provide}] to be a value provider`);\n        assert(isObject(pp.useValue), `Expected parent provider of [${p.provide}] to be an Object`);\n        p.useValue = Object.assign({}, pp.useValue, p.useValue);\n        merged.set(p.provide, Object.assign({}, pp, p));\n      } else {\n        // useClass, useExisting, useFactory will always overwrite parent provider\n        p = this._formatClassProvider(p);\n        merged.set(p.provide, Object.assign({}, pp, p));\n      }\n    }\n    return Array.from(merged.values());\n  }\n\n  /**\n   * A helper function for merging child and parent module dependencies.\n   * @param {Array} baseDeps\n   * @param {Array} parentDeps\n   */\n  static mergeDependencies(baseDeps, parentDeps) {\n    const merged = new Map();\n    // Deps preprocess\n    for (const parent of parentDeps) {\n      if (!isObject(parent)) {\n        merged.set(parent, { dep: parent, optional: false });\n      } else {\n        merged.set(parent.dep, parent);\n      }\n    }\n\n    for (let base of baseDeps) {\n      if (!isObject(base)) {\n        base = { dep: base, optional: false };\n      }\n      if (merged.has(base.dep)) {\n        merged.set(base.dep, {\n          dep: base.dep,\n          optional: base.optional && merged.get(base.dep).optional\n        });\n      } else {\n        merged.set(base.dep, base);\n      }\n    }\n\n    return Array.from(merged.values());\n  }\n}\n"]}