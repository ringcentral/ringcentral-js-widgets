{"version":3,"file":"ObjectMap.js","names":["sDefinition","Symbol","RUNTIME","usingFactory","prefixCache","Map","factory","prototype","property","descriptor","baseFunction","value","args","result","call","prefixString","str","prefix","ObjectMap","definition","TypeError","key","Object","hasOwnProperty","set","defineProperty","get","enumerable","keys","instance","find","v","entries","size","has","getKey","values","fn","forEach","k","obj","fromObject","prefixedInstance"],"sources":["lib/ObjectMap/ObjectMap.ts"],"sourcesContent":["import { find } from 'ramda';\n\nconst sDefinition = Symbol('definition');\nconst RUNTIME = {\n  usingFactory: false,\n  prefixCache: new Map(),\n};\n\nfunction factory<T>(\n  prototype: T,\n  property: string,\n  descriptor: PropertyDescriptor,\n) {\n  const baseFunction = descriptor.value;\n  return {\n    ...descriptor,\n    value(this: ThisType<T>, ...args: any) {\n      RUNTIME.usingFactory = true;\n      const result = baseFunction.call(this, ...args);\n      RUNTIME.usingFactory = false;\n      return result;\n    },\n  };\n}\n\nexport type ObjectMapKey<D> = D extends ObjectMap<infer D, infer K, infer V> &\n  infer D\n  ? K\n  : never;\n\nexport type ObjectMapValue<D> = D extends ObjectMap<infer D, infer K, infer V> &\n  infer D\n  ? V\n  : never;\n\nexport function prefixString(str: string, prefix: string = ''): string {\n  return prefix === '' ? str : `${prefix}-${str}`;\n}\n\nexport class ObjectMap<\n  D extends Record<string | number, any>,\n  K extends keyof D,\n  V extends D[K],\n> {\n  private readonly [sDefinition] = new Map();\n\n  constructor(definition: D) {\n    if (!RUNTIME.usingFactory) {\n      throw TypeError(\n        'Instantiating ObjectMap with `new ObjectMap(definition)` is not recommended. ' +\n          'Please use one of the ObjectMap factory functions.',\n      );\n    }\n    if (definition) {\n      for (const key in definition) {\n        if (Object.prototype.hasOwnProperty.call(definition, key)) {\n          this[sDefinition].set(key, definition[key]);\n          Object.defineProperty(this, key, {\n            get() {\n              return this[sDefinition].get(key);\n            },\n            enumerable: true,\n          });\n        }\n      }\n    }\n  }\n\n  @factory\n  static fromObject<\n    D extends Record<string | number, any>,\n    K extends keyof D,\n    V extends D[K],\n  >(definition: D) {\n    return new ObjectMap(definition) as ObjectMap<D, K, V> & D;\n  }\n\n  @factory\n  static fromKeys<K extends string>(keys: K[]) {\n    const definition = {} as Record<K, K>;\n    for (const key of keys) {\n      definition[key] = key;\n    }\n    return new ObjectMap(definition) as ObjectMap<{ [V in K]: V }, K, K> & {\n      [V in K]: V;\n    };\n  }\n\n  @factory\n  static prefixKeys<K extends string>(keys: K[], prefix: string = '') {\n    const definition = {} as Record<K, string>;\n    for (const key of keys) {\n      definition[key] = prefixString(key, prefix);\n    }\n    return new ObjectMap(definition) as ObjectMap<\n      { [V in K]: string },\n      K,\n      string\n    > & { [V in K]: string };\n  }\n\n  static getKey<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n    value: V,\n  ): K | null {\n    const [key = null] =\n      find<[K, V]>(([, v]) => v === value, [...ObjectMap.entries(instance)]) ||\n      [];\n    return key;\n  }\n\n  static entries<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n  ): IterableIterator<[K, V]> {\n    return instance[sDefinition].entries();\n  }\n\n  static size<K extends keyof D, V extends D[K], D>(\n    instance: ObjectMap<D, K, V> & D,\n  ): number {\n    return instance[sDefinition].size;\n  }\n\n  static has<K extends keyof D, V extends D[K], D>(\n    instance: ObjectMap<D, K, V> & D,\n    key: K,\n  ): boolean {\n    return instance[sDefinition].has(key);\n  }\n\n  static hasValue<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n    value: V,\n  ): boolean {\n    return !!ObjectMap.getKey(instance, value);\n  }\n\n  static keys<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n  ): IterableIterator<K> {\n    return instance[sDefinition].keys();\n  }\n\n  static values<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n  ): IterableIterator<V> {\n    return instance[sDefinition].values();\n  }\n\n  static forEach<D, K extends keyof D, V extends D[K]>(\n    fn: (value: V, key: K, map: ObjectMap<D, K, V> & D) => void,\n    instance: ObjectMap<D, K, V> & D,\n  ): void {\n    return instance[sDefinition].forEach((v, k) => fn(v, k, instance));\n  }\n\n  static filter<D extends Record<K, V>, K extends keyof D, V extends D[K]>(\n    fn: (value: V, key: K) => boolean,\n    instance: ObjectMap<D, K, V> & D,\n  ) {\n    const obj = {} as Record<K, V>;\n    ObjectMap.forEach((v, k) => {\n      if (fn(v, k)) {\n        obj[k] = v;\n      }\n    }, instance);\n    return ObjectMap.fromObject(obj);\n  }\n\n  static prefixValues<\n    D extends Record<K, string>,\n    K extends keyof D,\n    V extends D[K],\n  >(instance: ObjectMap<D, K, V> & D, prefix = '') {\n    if (prefix === '') {\n      return instance;\n    }\n    if (!RUNTIME.prefixCache.has(prefix)) {\n      RUNTIME.prefixCache.set(prefix, new Map());\n    }\n    if (!RUNTIME.prefixCache.get(prefix).has(instance)) {\n      const definition = {} as Record<K, string>;\n      ObjectMap.forEach((value, key) => {\n        definition[key] = prefixString(value, prefix);\n      }, instance);\n      const prefixedInstance = ObjectMap.fromObject(definition);\n      RUNTIME.prefixCache.get(prefix).set(instance, prefixedInstance);\n    }\n    return RUNTIME.prefixCache.get(prefix).get(instance) as ObjectMap<\n      { [V in K]: string },\n      K,\n      string\n    > & { [V in K]: string };\n  }\n}\n"],"mappings":"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"}